:PROPERTIES:
:ID:       1ad8c3d5-97ba-4905-be11-e6f2626127ad
:header-args+: :wrap :results raw
:END:
#+title: Emacs
* 概要
Emacsは非常に優れた拡張性を特徴とするテキストエディタ。
エディタに内蔵された言語[[id:c7e81fac-9f8b-4538-9851-21d4ff3c2b08][Emacs Lisp]]で柔軟に設定を変更できる。

できること。
- 情報集積([[id:7e85e3f3-a6b9-447e-9826-307a3618dac8][org-mode]], [[id:815a2c31-7ddb-40ad-bae0-f84e1cfd8de1][Org-roam]])
- タスク管理([[id:7e85e3f3-a6b9-447e-9826-307a3618dac8][org-mode]])
- [[id:90c6b715-9324-46ce-a354-63d09403b066][Git]]([[id:5ba43a42-93cb-48fa-8578-0558c757493f][magit]]) + [[id:6b889822-21f1-4a3e-9755-e3ca52fa0bc4][GitHub]]([[id:4a80d381-2620-40dc-8588-cda910c3d785][magit-forge]])
- コマンド実行と結果出力([[id:7e85e3f3-a6b9-447e-9826-307a3618dac8][org-mode]])
- ウィンドウマネージャ([[id:eb196529-bdbd-48c5-9d5b-a156fe5c2f41][EXWM]])
- 静的サイトジェネレータ([[id:7e85e3f3-a6b9-447e-9826-307a3618dac8][org-mode]])
- ブラウザ(eww)
- インターネットラジオプレーヤ(eradio)
- フィードリーダー(elfeed.el)
- ファイラ
- 表計算
- テスト実行(rspec-mode)
- ターミナル実行(vterm)
- [[id:1658782a-d331-464b-9fd7-1f8233b8b7f8][Docker]]管理(docker-mode)
- リマインダー(org-alert)
- PDF閲覧(pdf-tools)

の機能を、共通の効率的なキーボード操作、プレーンテキストベースで行える。
* Memo
** TODO 覚えるコマンド
:LOGBOOK:
CLOCK: [2022-09-26 Mon 10:39]--[2022-09-26 Mon 11:04] =>  0:25
CLOCK: [2022-09-26 Mon 10:04]--[2022-09-26 Mon 10:29] =>  0:25
:END:
移動に便利なコマンド。

- M-- マイナスの前置引数
  - 例えばC-M-- C-f は1文字戻る
  - M-- M-d 前の単語を削除
  - M-- C-k kill-lineの逆、行の左側を削除
- C-M-d, C-M-u S式の中、外に移動する
- C-M-n, C-M-p 次のリスト、前のリストに移動する(dumb-jump-mode に奪われている)
- C-M-k S式を削除する
- M-}, M-{ パラグラフの最後、最初に移動する
- M-a, M-e センテンスの先頭、最後に移動する
- C-M-a, C-M-e defunの先頭、最後に移動する
- C-M-v 別ウィンドウを下方にスクロール
- M-r ポイントを左上、左、左下に移動

削除。

- M-k センテンスを削除
- C-M-k S式を削除
- C-S-<backspace> 現在の行を削除

ブックマーク。

- C-x r m ブックマークをセット

レジスター。

- C-x r s レジスターにリージョンを保存
- C-x r SPC レジスターにポイントを保存
- C-x r j レジスターにジャンプ
- C-x r i レジスターの内容を挿入

マーク。

- M-h 次のパラグラフをマーク
- C-M-h 次のdefunをマーク
- C-x h バッファー全体をマーク
- C-x C-p 次のページをマーク
- M-@ 次の単語をマーク
- C-M-@ 次のS式をマーク

検索。

- C-M-s regexpインクリメンタル検索を開始する

キルリング。

- C-M-w 次のコマンドがkillコマンドなら、killリングに追加する

入れ替え。

- C-x C-t 行の入れ替え

コメント。

- C-x C-; 行をコメント化あるいは非コメント化
- M-x comment-box リージョンを囲み枠でコメント化する

大文字化。

- M-c 次の単語をcapitalize(Word)
- M-u 次の単語を大文字に(WORD)
- M-l 次の単語を小文字に(word)

** 現在実行しているコマンドが入る変数
- ~this-command~
** リンクを開くときにブラウザにフォーカスさせない
firefox側で設定する。about:config をURLバーに打ち込み、設定項目 browser.tabs.loadDivertedInBackground を true にする。
https://stackoverflow.com/questions/10506496/run-browse-url-in-emacs-without-giving-focus-to-the-browser
** バッファ管理
rails開発で処理が多くのファイルに分散していて、同じような名前のファイルが多い場合、集中のスイッチングコストが大きくなる。今まではあまりファイル分散してなかったので ~counsel-switch-buffer~ ひとつで問題なかったが、タスクやコードの構造によって問題になりうる。ファイル移動しようとするたびに思考が中断される。

- 方法1: projectile-railsのキーバインドを覚える https://qiita.com/yoshinarl/items/8e3c4b075a181f224591
  - projectile-rails-find-current-spec(C-c r P) 対応するテストファイルを開く
  - MVC系の移動 C-c r M、C-c r C、C-c r V
- 方法2: バッファをリセットする
  - 無関係な似たような名前のバッファが溜まるのが問題であって、そもそもこまめにリセットすれば見やすくなる説
- 方法3: ブックマーク
  - 必要なものはブックマークしておく。メンドイ。
- 方法4: タブ表示
  - ブラウザのように、タブに表示する。結局ファイル名が長かったり、ファイル名が多くなるとやりにくくなるのだが、直近3つくらいのファイルが見られるだけでも改善する

良いページを発見した。[[https://wikemacs.org/wiki/Buffer_management][Buffer management - WikEmacs]]
** リストの重複を削除する

#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/lisp/subr.el#L731-L751
#+end_src

#+RESULTS:
#+begin_results emacs-lisp
(defun delete-dups (list)
  "Destructively remove `equal' duplicates from LIST.
Store the result in LIST and return it.  LIST must be a proper list.
Of several `equal' occurrences of an element in LIST, the first
one is kept.  See `seq-uniq' for non-destructive operation."
  (let ((l (length list)))
    (if (> l 100)
        (let ((hash (make-hash-table :test #'equal :size l))
              (tail list) retail)
          (puthash (car list) t hash)
          (while (setq retail (cdr tail))
            (let ((elt (car retail)))
              (if (gethash elt hash)
                  (setcdr tail (cdr retail))
                (puthash elt t hash)
                (setq tail retail)))))
      (let ((tail list))
        (while tail
          (setcdr tail (delete (car tail) (cdr tail)))
          (setq tail (cdr tail))))))
  list)
#+end_results

*** 100以下の処理

リストの長さによって処理が分岐していることがわかる。まず100行以下での処理を見る。

#+caption: 100行以下の処理
#+begin_src emacs-lisp
(let ((tail list))
        (while tail
          (setcdr tail (delete (car tail) (cdr tail)))
          (setq tail (cdr tail))))
#+end_src

これで重複削除になるのか、と不思議な感じがする。不明な関数を調べる。

*** setcdr
[[https://ayatakesi.github.io/emacs/24.5/elisp_html/Setcdr.html][Setcdr (GNU Emacs Lisp Reference Manual)]]

setcdrが非常に重要な処理をしているように見えるので調べる。

#+begin_src emacs-lisp
  (setq x '(1 2 3))
  (setcdr x '(4))
  x
#+end_src

#+RESULTS:
#+begin_results
(1 4)
#+end_results

コンスセルのcdrを変更することで、他のリストに置き換える働きをする。

*** delete

#+begin_src emacs-lisp
  (setq x '(1 2 3 4))
  (delete x '(3))
  x
#+end_src

#+RESULTS:
#+begin_results
(1 2 3 4)
#+end_results

*** 処理に戻る

本筋に戻る。

#+caption: 抜粋。削除
#+begin_src emacs-lisp
  (delete (car tail) (cdr tail))
#+end_src

は、値を決めて(car tail)、それをリストから取り除く。
例) '(1 1 2 3) -> '(2 3) になる。carの1を取り上げて、cdrに含まれる1を削除する。

#+caption: 抜粋。連結
#+begin_src emacs-lisp
(setcdr tail (delete (car tail) (cdr tail)))
#+end_src

そしてsetcdrによって、1つになった値と残りの値を連結する。
'(1) + '(2 3) -> '(1 2 3)

#+caption: 次ループに向けて
#+begin_src emacs-lisp
(setq tail (cdr tail))
#+end_src

次の値を計算するために、単独になった値を除いたリストにする。
'(1 2 3) -> '(2 3)

ここでは、tailだけが次の計算に向けて再代入されたのであって、値の元になったlistは再代入されずに'(1 2 3)が入ったままになっている。すべての計算が終わったあとlistを評価すれば、望みの値が得られる。tailはループ用で、最終的にnilになる。

*** ハッシュテーブルを使うバージョン

リストの要素が100より大きいとき、ハッシュテーブルを使う実装になっている。100は何基準だろうか。

#+caption: ハッシュテーブルを使う
#+begin_src emacs-lisp
  (let ((hash (make-hash-table :test #'equal :size l))
        (tail list) retail)
    (puthash (car list) t hash)
    (while (setq retail (cdr tail))
      (let ((elt (car retail)))
        (if (gethash elt hash)
            (setcdr tail (cdr retail))
          (puthash elt t hash)
          (setq tail retail)))))
#+end_src

- ハッシュに既に入っている値であれば、その要素を取り除いて次の探索へ
- ハッシュに入っていなければ登録して次の探索

この方法だとループは多いけど、メモリ消費がとても少ないということか。一度のループで比較するのは最初の要素とハッシュの要素だけだ。

** defsubst
[[https://www.mew.org/~kazu/doc/elisp/defsubst.html][Emacs Lisp]]
defsubstで定義した関数はbyte compileのときにインライン展開される。つまり、コンパイルして関数実行時の関数呼び出しのコストがなくなり高速になる。頻繁に用いられる小さな関数で有効。

#+caption: defunで定義した場合は、lst plus2と、関数名がそのまま表示され、インライン展開されない
#+begin_src emacs-lisp
  (defun plus2 (x)
    (+ x 2))
  (byte-compile 'plus2)

  (defun foo (lst)
    (plus2 lst))
  (byte-compile 'foo)
#+end_src
p
#+RESULTS:
#+begin_results
#[(lst) "\301!\207" [lst plus2] 2]
#+end_results

#+caption: plus2をdefsubstに変更する。関数の中身lst x 2とインライン展開されていることがわかる
#+begin_src emacs-lisp
  (defsubst plus2 (x)
    (+ x 2))
  (byte-compile 'plus2)

  (defun foo (lst)
    (plus2 lst))
  (byte-compile 'foo)
#+end_src

#+RESULTS:
#+begin_results
#[(lst) "\211\302\\)\207" [lst x 2] 3]
#+end_results

#+caption: optimizerをつけていることがわかる
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/lisp/emacs-lisp/byte-run.el#L480-L495
#+end_src

#+RESULTS:
#+begin_results emacs-lisp
(defmacro defsubst (name arglist &rest body)
  "Define an inline function.  The syntax is just like that of `defun'.

\(fn NAME ARGLIST &optional DOCSTRING DECL &rest BODY)"
  (declare (debug defun) (doc-string 3) (indent 2))
  (or (memq (get name 'byte-optimizer)
	    '(nil byte-compile-inline-expand))
      (error "`%s' is a primitive" name))
  `(prog1
       (defun ,name ,arglist ,@body)
     (eval-and-compile
       ;; Never native-compile defsubsts as we need the byte
       ;; definition in `byte-compile-unfold-bcf' to perform the
       ;; inlining (Bug#42664, Bug#43280, Bug#44209).
       ,(byte-run--set-speed name nil -1)
       (put ',name 'byte-optimizer 'byte-compile-inline-expand))))
#+end_results

** simple.el
/lisp/simple.elには基本的な編集関数がある。

#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/lisp/simple.el#L1
#+end_src

#+RESULTS:
#+begin_results
;;; simple.el --- basic editing commands for Emacs  -*- lexical-binding: t -*-
#+end_results

** 正規表現置換
入れ替えとかしたい。
** 検索結果に対する置換 counsel-git-grep-query-replace
counsel-git-grep したあとに counsel-git-grep-query-replace(M-q)することで、git grepした結果に対して置換をかけられる。
** message関数はどう動いているか
CLOSED: [2022-07-17 Sun 23:43]
:LOGBOOK:
CLOCK: [2022-07-17 Sun 23:19]--[2022-07-17 Sun 23:43] =>  0:24
CLOCK: [2022-07-17 Sun 22:50]--[2022-07-17 Sun 23:15] =>  0:25
CLOCK: [2022-07-15 Fri 00:01]--[2022-07-15 Fri 00:26] =>  0:25
CLOCK: [2022-07-12 Tue 23:44]--[2022-07-13 Wed 00:09] =>  0:25
:END:

message関数はメッセージをmessageバッファ、モードラインに表示する関数である。フォーマットを指定できる機能もある。これはどうやって動いているのだろうか。Lispの形をしたC言語で定義されている。

#+caption: コード。読みやすくするためにコメントを削除・追加している
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/d983e080e027bd7b680b1e40ccfa0c71d6a3cd94/src/editfns.c#L2849-L2884
#+end_src

#+RESULTS:
#+begin_results C
DEFUN ("message", Fmessage, Smessage, 1, MANY, 0,
       doc: /* Display a message at the bottom of the screen.
  (ptrdiff_t nargs, Lisp_Object *args)
{
  if (NILP (args[0])
      || (STRINGP (args[0])
	  && SBYTES (args[0]) == 0))
    {
      ;; 最初の引数(表示文字列)がないときはクリア
      message1 (0);
      return args[0];
    }
  else
    ;; 引数があるとき、オプションをLisp Objectにして関数に渡す
    {
      Lisp_Object val = Fformat_message (nargs, args); ;; フォーマット
      message3 (val); ;; 表示
      return val;;
    }
}
#+end_results

文字列のときはそのまま表示し、フォーマットが必要なときはフォーマットする、ということか。message3とmessage1の違いは何。この関数名の意味。

#+caption: messageの定義
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/d983e080e027bd7b680b1e40ccfa0c71d6a3cd94/src/xdisp.c#L11588-L11608
#+end_src

#+RESULTS:
#+begin_results C
void
message3 (Lisp_Object m)
{
  clear_message (true, true); // メッセージ削除
  cancel_echoing (); // エコーエリアをリセット

  /* First flush out any partial line written with print.  */
  message_log_maybe_newline ();
  if (STRINGP (m))
    {
      ptrdiff_t nbytes = SBYTES (m);
      bool multibyte = STRING_MULTIBYTE (m);
      char *buffer;
      USE_SAFE_ALLOCA;
      SAFE_ALLOCA_STRING (buffer, m);
      message_dolog (buffer, nbytes, true, multibyte); // 本筋の処理
      SAFE_FREE ();
    }
  if (! inhibit_message)
    message3_nolog (m);
}
#+end_results

本筋はmessage_dologを呼ぶこと。ほかはそのための準備とか、オプションに対応してる部分。

#+caption: message1はmessage3によって定義される
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/d983e080e027bd7b680b1e40ccfa0c71d6a3cd94/src/xdisp.c#L11693-L11697
#+end_src

#+RESULTS:
#+begin_results C
void
message1 (const char *m)
{
  message3 (m ? build_unibyte_string (m) : Qnil);
}
#+end_results

#+caption: 改行を入れる処理。message_dologに空文字と改行オプションを指定して、改行する
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/src/xdisp.c#L11430-L11435
#+end_src

#+RESULTS:
#+begin_results C
void
message_log_maybe_newline (void)
{
  if (message_log_need_newline)
    message_dolog ("", 0, true, false);
}
#+end_results

#+caption: message_dologする前に呼び出してる関数
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/src/lisp.h#L5292-L5294
#+end_src

#+RESULTS:
#+begin_results C
#define USE_SAFE_ALLOCA			\
  ptrdiff_t sa_avail = MAX_ALLOCA;	\
  specpdl_ref sa_count = SPECPDL_INDEX ()
#+end_results

#+caption: message_dologする前に呼び出してる関数2。memcpyでメモリをコピーする
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/src/lisp.h#L5319-L5325
#+end_src

#+RESULTS:
#+begin_results C
/* SAFE_ALLOCA_STRING allocates a C copy of a Lisp string.  */

#define SAFE_ALLOCA_STRING(ptr, string)			\
  do {							\
    (ptr) = SAFE_ALLOCA (SBYTES (string) + 1);		\
    memcpy (ptr, SDATA (string), SBYTES (string) + 1);	\
  } while (false)
#+end_results

#+caption: メッセージログに追加する関数。長い
#+begin_src git-permalink
https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/src/xdisp.c#L11438-L11633
#+end_src

#+RESULTS:
#+begin_results C
/* Add a string M of length NBYTES to the message log, optionally
   terminated with a newline when NLFLAG is true.  MULTIBYTE, if
   true, means interpret the contents of M as multibyte.  This
   function calls low-level routines in order to bypass text property
   hooks, etc. which might not be safe to run.

   This may GC (insert may run before/after change hooks),
   so the buffer M must NOT point to a Lisp string.  */

void
message_dolog (const char *m, ptrdiff_t nbytes, bool nlflag, bool multibyte)
{
  const unsigned char *msg = (const unsigned char *) m;

  if (!NILP (Vmemory_full))
    return;

  if (!NILP (Vmessage_log_max))
    {
      struct buffer *oldbuf;
      Lisp_Object oldpoint, oldbegv, oldzv;
      int old_windows_or_buffers_changed = windows_or_buffers_changed;
      ptrdiff_t point_at_end = 0;
      ptrdiff_t zv_at_end = 0;
      Lisp_Object old_deactivate_mark;

      old_deactivate_mark = Vdeactivate_mark;
      oldbuf = current_buffer;

      /* Sanity check, in case the variable has been set to something
	 invalid.  */
      if (! STRINGP (Vmessages_buffer_name))
	Vmessages_buffer_name = build_string ("*Messages*");
      /* Ensure the Messages buffer exists, and switch to it.
         If we created it, set the major-mode.  */
      bool newbuffer = NILP (Fget_buffer (Vmessages_buffer_name));
      Fset_buffer (Fget_buffer_create (Vmessages_buffer_name, Qnil));
      if (newbuffer
	  && !NILP (Ffboundp (intern ("messages-buffer-mode"))))
	call0 (intern ("messages-buffer-mode"));

      bset_undo_list (current_buffer, Qt);
      bset_cache_long_scans (current_buffer, Qnil);

      oldpoint = message_dolog_marker1;
      set_marker_restricted_both (oldpoint, Qnil, PT, PT_BYTE);
      oldbegv = message_dolog_marker2;
      set_marker_restricted_both (oldbegv, Qnil, BEGV, BEGV_BYTE);
      oldzv = message_dolog_marker3;
      set_marker_restricted_both (oldzv, Qnil, ZV, ZV_BYTE);

      if (PT == Z)
	point_at_end = 1;
      if (ZV == Z)
	zv_at_end = 1;

      BEGV = BEG;
      BEGV_BYTE = BEG_BYTE;
      ZV = Z;
      ZV_BYTE = Z_BYTE;
      TEMP_SET_PT_BOTH (Z, Z_BYTE);

      /* Insert the string--maybe converting multibyte to single byte
	 or vice versa, so that all the text fits the buffer.  */
      if (multibyte
	  && NILP (BVAR (current_buffer, enable_multibyte_characters)))
	{
	  /* Convert a multibyte string to single-byte
	     for the *Message* buffer.  */
	  for (ptrdiff_t i = 0; i < nbytes; )
	    {
	      int char_bytes, c = check_char_and_length (msg + i, &char_bytes);
	      char work = CHAR_TO_BYTE8 (c);
	      insert_1_both (&work, 1, 1, true, false, false);
	      i += char_bytes;
	    }
	}
      else if (! multibyte
	       && ! NILP (BVAR (current_buffer, enable_multibyte_characters)))
	{
	  /* Convert a single-byte string to multibyte
	     for the *Message* buffer.  */
	  for (ptrdiff_t i = 0; i < nbytes; i++)
	    {
	      int c = make_char_multibyte (msg[i]);
	      unsigned char str[MAX_MULTIBYTE_LENGTH];
	      int char_bytes = CHAR_STRING (c, str);
	      insert_1_both ((char *) str, 1, char_bytes, true, false, false);
	    }
	}
      else if (nbytes)
	insert_1_both (m, chars_in_text (msg, nbytes), nbytes,
		       true, false, false);

      if (nlflag)
	{
	  ptrdiff_t this_bol, this_bol_byte, prev_bol, prev_bol_byte;
	  intmax_t dups;

          /* Since we call del_range_both passing false for PREPARE,
             we aren't prepared to run modification hooks (we could
             end up calling modification hooks from another buffer and
             only with AFTER=t, Bug#21824).  */
          specpdl_ref count = SPECPDL_INDEX ();
          specbind (Qinhibit_modification_hooks, Qt);

	  insert_1_both ("\n", 1, 1, true, false, false);

	  scan_newline (Z, Z_BYTE, BEG, BEG_BYTE, -2, false);
	  this_bol = PT;
	  this_bol_byte = PT_BYTE;

	  /* See if this line duplicates the previous one.
	     If so, combine duplicates.  */
	  if (this_bol > BEG)
	    {
	      scan_newline (PT, PT_BYTE, BEG, BEG_BYTE, -2, false);
	      prev_bol = PT;
	      prev_bol_byte = PT_BYTE;

	      dups = message_log_check_duplicate (prev_bol_byte,
                                                  this_bol_byte);
	      if (dups)
		{
		  del_range_both (prev_bol, prev_bol_byte,
				  this_bol, this_bol_byte, false);
		  if (dups > 1)
		    {
		      char dupstr[sizeof " [ times]"
				  + INT_STRLEN_BOUND (dups)];

		      /* If you change this format, don't forget to also
			 change message_log_check_duplicate.  */
		      int duplen = sprintf (dupstr, " [%"PRIdMAX" times]",
					    dups);
		      TEMP_SET_PT_BOTH (Z - 1, Z_BYTE - 1);
		      insert_1_both (dupstr, duplen, duplen,
				     true, false, true);
		    }
		}
	    }

	  /* If we have more than the desired maximum number of lines
	     in the *Messages* buffer now, delete the oldest ones.
	     This is safe because we don't have undo in this buffer.  */

	  if (FIXNATP (Vmessage_log_max))
	    {
	      scan_newline (Z, Z_BYTE, BEG, BEG_BYTE,
			    -XFIXNAT (Vmessage_log_max) - 1, false);
	      del_range_both (BEG, BEG_BYTE, PT, PT_BYTE, false);
	    }

          unbind_to (count, Qnil);
	}
      BEGV = marker_position (oldbegv);
      BEGV_BYTE = marker_byte_position (oldbegv);

      if (zv_at_end)
	{
	  ZV = Z;
	  ZV_BYTE = Z_BYTE;
	}
      else
	{
	  ZV = marker_position (oldzv);
	  ZV_BYTE = marker_byte_position (oldzv);
	}

      if (point_at_end)
	TEMP_SET_PT_BOTH (Z, Z_BYTE);
      else
	/* We can't do Fgoto_char (oldpoint) because it will run some
           Lisp code.  */
	TEMP_SET_PT_BOTH (marker_position (oldpoint),
			  marker_byte_position (oldpoint));

      unchain_marker (XMARKER (oldpoint));
      unchain_marker (XMARKER (oldbegv));
      unchain_marker (XMARKER (oldzv));

      /* We called insert_1_both above with its 5th argument (PREPARE)
	 false, which prevents insert_1_both from calling
	 prepare_to_modify_buffer, which in turns prevents us from
	 incrementing windows_or_buffers_changed even if *Messages* is
	 shown in some window.  So we must manually set
	 windows_or_buffers_changed here to make up for that.  */
      windows_or_buffers_changed = old_windows_or_buffers_changed;
      bset_redisplay (current_buffer);

      set_buffer_internal (oldbuf);

      message_log_need_newline = !nlflag;
      Vdeactivate_mark = old_deactivate_mark;
    }
}
#+end_results

** TODO 起動時何をやっているのか                                     :DontKnow:
いろいろ走るけど、何をしているのだろう。
** TODO C部分の定義方法の違い                                    :DontKnow:
同じC言語部分のソースコードでも、DEFUNを使ってlisp風に書かれたコードと、生のCっぽく書かれたものがある。違いはなにか。

#+caption: message3関数の定義
#+begin_src c
void
message3 (Lisp_Object m)
{
  clear_message (true, true);
#+end_src

#+caption: message関数の定義
#+begin_src C
DEFUN ("message", Fmessage, Smessage, 1, MANY, 0,
       doc: /* Display a message at the bottom of the screen.
#+end_src
** 本体コードを読む
:LOGBOOK:
CLOCK: [2022-07-10 Sun 23:19]--[2022-07-10 Sun 23:44] =>  0:25
CLOCK: [2022-07-10 Sun 21:41]--[2022-07-10 Sun 22:06] =>  0:25
CLOCK: [2022-07-10 Sun 16:57]--[2022-07-10 Sun 17:22] =>  0:25
CLOCK: [2022-07-10 Sun 16:28]--[2022-07-10 Sun 16:53] =>  0:25
CLOCK: [2022-07-10 Sun 15:39]--[2022-07-10 Sun 15:55] =>  0:16
CLOCK: [2022-07-10 Sun 12:13]--[2022-07-10 Sun 12:30] =>  0:17
CLOCK: [2022-07-10 Sun 11:48]--[2022-07-10 Sun 12:13] =>  0:25
CLOCK: [2022-07-09 Sat 23:36]--[2022-07-10 Sun 00:01] =>  0:25
CLOCK: [2022-07-09 Sat 23:00]--[2022-07-09 Sat 23:25] =>  0:25
CLOCK: [2022-07-09 Sat 22:23]--[2022-07-09 Sat 22:48] =>  0:25
:END:

https://systemcrafters.net/live-streams/august-20-2021/
まずビルドする。

#+caption: Guix環境の場合
#+begin_src shell
  guix environment --pure emacs-next --ad-hoc git
#+end_src

ほとんどは[[id:c7e81fac-9f8b-4538-9851-21d4ff3c2b08][Emacs Lisp]]で書かれている。コアな部分は[[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C language]]。
~src/*~ にはCのコードがある。
~src/lisp.h~ は[[id:c7e81fac-9f8b-4538-9851-21d4ff3c2b08][Emacs Lisp]]そのもののコードで重要。

[[https://www.reddit.com/r/emacs/comments/7i2alo/how_to_read_and_understand_gnu_emacs_source_code/][How to read (and understand) GNU Emacs source code? : emacs]]

コードの読み方の参考。
[[https://solist.work/blog/posts/git-history-tool/][ソースコードの読み方 - Solist Work Blog]]
** プロセス管理
最初から入っている ~proced~ が便利。一覧に加えてkillもできる。
** デフォルトの動的補完 dabbrev
dabbrevはEmacsデフォルトの補完機能。大雑把で高速。
dabbrev-expand (M-/)
** デフォルトの定義探す系 xref
- xref-find-definitions (M-.) :: 定義ジャンプ
- xref-find-references (M-?) :: 参照箇所(使われてるところ)にジャンプ

lspと接続しているとそっちを使って辿るようだ。
** LSP設定
:LOGBOOK:
CLOCK: [2022-03-05 Sat 17:14]--[2022-03-05 Sat 17:39] =>  0:25
:END:
[[id:eb807577-cd69-478c-8f82-264243c67354][LSP]]を設定する。

- lsp-modeは[[id:eb807577-cd69-478c-8f82-264243c67354][LSP]]全般を扱うパッケージである。lsp-install-serverで各プログラミング言語の[[id:eb807577-cd69-478c-8f82-264243c67354][LSP]] serverをダウンロード・起動することで有効化できる。
- lsp-ui-modeはlsp-modeのグラフィック面を強化するパッケージである(optional)。ドキュメント表示、エラー表示などができるようになる

[[id:b2f63c13-4b30-481c-9c95-8abe388254fd][Scala]]の[[id:eb807577-cd69-478c-8f82-264243c67354][LSP]]サーバーであるmetalsはGPGエラーでインストールできない状態だった。
~(setq lsp-verify-signature nil)~ するとインストールできる。

https://github.com/coursier/coursier/issues/2346
** corfu設定
:LOGBOOK:
CLOCK: [2022-03-05 Sat 18:23]--[2022-03-05 Sat 18:48] =>  0:25
CLOCK: [2022-03-05 Sat 11:28]--[2022-03-05 Sat 11:53] =>  0:25
CLOCK: [2022-03-05 Sat 10:53]--[2022-03-05 Sat 11:18] =>  0:25
CLOCK: [2022-03-05 Sat 10:30]--[2022-03-05 Sat 10:53] =>  0:23
CLOCK: [2022-03-05 Sat 09:54]--[2022-03-05 Sat 10:19] =>  0:25
:END:
- ミニマルなパッケージを組み合わせる方法が主流である。
- 各パッケージの概要: https://tam5917.hatenablog.com/entry/2022/02/05/141115
** git-timemachineで歴史を見る
[[https://github.com/emacsmirror/git-timemachine][emacsmirror/git-timemachine: Walk through git revisions of a file]]
~git-timemachine~ を使うと、ファイルごとで軽々とコミットを辿れて楽しい。すごいのにあまり有名ではないよう。

- n で次のコミット、p で前のコミットに移る。
- c でコミット内容を見る。ファイルビューではコミット時点のファイルだけなので、差分をみたいときにはこっちを使う。

** faceを調べる
M-x list-faces-display
** diredでzip展開
dired-modeで Z ... ~dired-do-compress~ で展開か圧縮できる。
** 矩形選択する
~rectangle-mark-mode~ -- C-x SPC
で矩形選択できる。

back-button-modeのキーバインドが衝突してたのでback-button-modeの方を無効化。

#+caption: 無効化
#+begin_src emacs-lisp
(define-key back-button-mode-map (kbd "C-x SPC") nil)
#+end_src
** pdf-tools
pdf-toolsはEmacs内でPDFを閲覧できるパッケージ。
インストールしても、しばらくすると利用不可になってることがあるのでinstallしなおす。
インストールするとdiredから選択するとpdf-toolsが使われる。

#+caption: インストールする
#+begin_src emacs-lisp
(pdf-tools-install)
#+end_src
** ivy-occurで一括置換する
occurの特徴はeでedit-modeに入れる点。一覧にして複数ファイルをそのまま置換できる。

プロジェクトのファイルにすべてに対してoccurしたいとき。
~counsel-git-grep~ して絞り込んだものに対して ~(ivy-occur)~ = ~C-c C-o~ でoccurできる。

edit-modeに入るには。
~(ivy-wgrep-change-to-wgrep-mode)~ = ~C-x C-q~
occurでの変更をコミットするには。
~C-x C-s~ 。覚えにくい。
** 絵文字挿入
~C-x 8 return~
** elisp-refs
[[https://github.com/Wilfred/elisp-refs][Wilfred/elisp-refs: semantic code search for emacs lisp]]
関数や変数の参照を見つけるパッケージ。
じっさいに使われている例を探し出すことができる。

#+caption: popで検索してみた例
#+begin_src emacs-lisp
File: /gnu/store/lnwgc4ww47vkq2wv2ay3rdm0ppnmgyfy-emacs-27.2/share/emacs/27.2/lisp/format.el.gz
(setq prop (pop props))

File: /gnu/store/lnwgc4ww47vkq2wv2ay3rdm0ppnmgyfy-emacs-27.2/share/emacs/27.2/lisp/window.el.gz
(let ((window (pop window-state-put-stale-windows)))
#+end_src
** キーバインドの一覧を出力するコマンド
キーバインドの一覧を出力するコマンド。
~make-command-summary~ 。
** 複数行に空白挿入
複数行一気に空白を挿入してインデントを整えるとき。
~C-x C-i~ で挿入モードにあるのであとは方向キーで微調整できる。
** 文字コード変更
改行コードなどで問題が生じたとき。^Mが表示されるとか。
~C-x RET f utf-8-unix~
で文字コードを変更して保存する。
** カウントダウンタイマー
カップ麺の3分を測りたい、みたいなとき。
~(org-timer-set-timer)~
** company-documentation
Company is input complement package.
Read document on complementation list.
~Ctrl + Shift + h~
** vtermのbash_profileを設定する
#+caption: .bash_profile
#+begin_src shell
if [[ "$INSIDE_EMACS" = 'vterm' ]] \
    && [[ -n ${EMACS_VTERM_PATH} ]] \
    && [[ -f ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh ]]; then
    source ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh
fi
#+end_src
[[https://naokton.hatenablog.com/entry/2020/12/08/150130][vterm-modeを使う - technokton]]
** パッケージのソースコードメモ
- org-lint
  - https://github.com/kijimaD/emacs/blob/master/lisp/org/org-lint.el#L124
- interactive
  - https://github.com/kijimaD/emacs/blob/master/src/callint.c#L37
- defun
  - https://github.com/kijimaD/emacs/blob/master/lisp/emacs-lisp/byte-run.el#L280
  - https://github.com/kijimaD/emacs/blob/master/lisp/emacs-lisp/cl-macs.el#L339
** projectile-toggle-between-implementation-and-test (~C-c p t~)
テストとプロダクトコードを切り替える。
** (magit-topic)
一覧でPRとIssueにアクセスできると行き来がしやすそう。
Forgeのトピック間移動がhelmでできたらいいのにな。
** [[id:7dab097c-60ba-43b9-949f-c58bf3151aa8][MySQL]]と接続して[[id:8b69b8d4-1612-4dc5-8412-96b431fdd101][SQL]]を直に実行する
#+begin_src
M-x customize-variable RET sql-connection-alist RET ...
M-x sql-connect
open buffer...
M-x sql-mode
M-x sql-set-sqli-buffer RET
sql-send-buffer (C-c C-b)
sqlup-capitalize-keywords-in-region (C-c u)
#+end_src
** Macでの置換
- Macでは ~query-replace~ (~M-%~)が奪われて押せないので、 ~query-replace-regexp~ (~C-M-%~)する。
** spring [[id:afccf86d-70b8-44c0-86a8-cdac25f7dfd3][RSpec]]
[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]でspringを走らせておくと[[id:afccf86d-70b8-44c0-86a8-cdac25f7dfd3][RSpec]]が高速に動作する。

いつのまにかEmacsでspringが動かなくなっていた。コマンドでは ~spring rspec~ などで動かせるが、Emacsではふつうの ~bundle exec ...~ になっていた。前は早くできていたはず。ネットの記事を参考に修正した。

#+begin_quote
emacsのrspec-modeで、上記のようにしてspringを使うと、自動ではspringがONにならない。 これはtmpにpidファイルが作られないため。 強制的にspringを使うには、次のように設定する。
#+end_quote

  #+begin_src emacs-lisp
  (require 'rspec-mode)
  (defun rspec-spring-p ()
    (and rspec-use-spring-when-possible
         (stringp (executable-find "spring"))))
  #+end_src

springを自動で検出してくれるらしい(何より今までできてた)。
~spring status~ でspringが動いてるかチェックする。動いてなかったら ~spring rspec~ する。
** デバッグ起動する
#+begin_src shell
$ emacs -q
# init読み込まない
$ emacs --debug-init
# デバッグモードで起動する
#+end_src
** [[id:fa497359-ae3f-494a-b24a-9822eefe67ad][System Crafters]] IRC
#+begin_quote
erc-tls
irc.libera.chat
6697
/join #systemcrafters
#+end_quote
** mermaid jsをEmacsで使う
mermaidはプレーンテキストで図を作れるツール。[[id:a6980e15-ecee-466e-9ea7-2c0210243c0d][JavaScript]]で書かれている。
これをEmacsで扱えるようにするのがmermaid-mode。

- https://github.com/abrochard/mermaid-mode

#+begin_src shell
npm install -g @mermaid-js/mermaid-cli
#+end_src
して、C-cで画像にコンパイルできる。
** 各Window managerでEmacs風キーバインドにする
- https://linuxfan.info/linux-emacs-keybindings-matome

#+begin_src shell
  # gnome
  gsettings set org.gnome.desktop.interface gtk-key-theme Emacs
  # MATE
  gsettings set org.mate.interface gtk-key-theme Emacs
  # Cinnamon
  gsettings set org.cinnamon.desktop.interface gtk-key-theme Emacs
#+end_src
** counsel-find-fileで新しいファイルを作る
補完選択になってしまって新しくファイルが作れないときは、C-M-jで新規作成できる。

counselのリポジトリのREADMEの最後に書かれてた。
#+begin_src emacs-lisp
(setq ivy-use-selectable-prompt t)
#+end_src
をすると上下選択できるようになる。
選択一覧にはでないのでわかりにくい。
** blame系関数
- ~vc-annotate~
- ~magit-blame~
- ~blamer~
** keybinding一覧
~(make-command-summary)~ や ~(describe-bindings)~ で生成できる。
* Tasks
** TODO hydraはどうやって登録キーをマップに登録しているか        :DontKnow:
:LOGBOOK:
CLOCK: [2022-08-10 Wed 11:08]--[2022-08-10 Wed 11:33] =>  0:25
:END:
アルファベットで指定して初期化するだけでメニュー表示に追加し、キーバインドを作成する。これはどうやっているか。hydra起動中はキーバインドが一切衝突しないのも気になる。

#+caption: hydraメニュー定義の例
#+begin_src emacs-lisp
  (defhydra hydra-zoom (global-map "<f2>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out"))
#+end_src

#+caption: ポップ中のキーバインドを限定してそうな部分
#+begin_src git-permalink
https://github.com/kd-collective/hydra/blob/2d553787aca1aceb3e6927e426200e9bb9f056f1/hydra.el#L160-L161
#+end_src

#+RESULTS:
#+begin_results
      (when overriding-terminal-local-map
        (internal-pop-keymap hydra-curr-map 'overriding-terminal-local-map))))
#+end_results

** リンクを開くときにブラウザにフォーカスさせない
firefox側で設定する。about:config をURLバーに打ち込み、設定項目 browser.tabs.loadDivertedInBackground を true にする。
https://stackoverflow.com/questions/10506496/run-browse-url-in-emacs-without-giving-focus-to-the-browser
** バッファ管理
rails開発で処理が多くのファイルに分散していて、同じような名前のファイルが多い場合、集中のスイッチングコストが大きくなる。今まではあまりファイル分散してなかったので ~counsel-switch-buffer~ ひとつで問題なかったが、タスクやコードの構造によって問題になりうる。ファイル移動しようとするたびに思考が中断される。

- 方法1: projectile-railsのキーバインドを覚える https://qiita.com/yoshinarl/items/8e3c4b075a181f224591
  - projectile-rails-find-current-spec(C-c r P) 対応するテストファイルを開く
  - MVC系の移動 C-c r M、C-c r C、C-c r V
- 方法2: バッファをリセットする
  - 無関係な似たような名前のバッファが溜まるのが問題であって、そもそもこまめにリセットすれば見やすくなる説
- 方法3: ブックマーク
  - 必要なものはブックマークしておく。メンドイ。
- 方法4: タブ表示
  - ブラウザのように、タブに表示する。結局ファイル名が長かったり、ファイル名が多くなるとやりにくくなるのだが、直近3つくらいのファイルが見られるだけでも改善する

良いページを発見した。[[https://wikemacs.org/wiki/Buffer_management][Buffer management - WikEmacs]]

** TODO [[https://daregada.sakuraweb.com/paredit_tutorial_ja.html][ParEdit チュートリアル]]
すごい便利らしいのでやってみる。
** TODO 設定をエクスポートして文芸的にする
自分だけでなく、他人も理解できるようにする。
** TODO use-packageでパッケージ設定を書き直す
パッケージごとの設定がわかりづらい状態なので、書き直す。とくにhook、keybindあたりはあちこちに散らかっている。
** TODO 今日の残り時間をゲージで表示する
時計より視覚的にわかりやすそうなので、polybarで出すようにしよう。
** TODO recompileが別ウィンドウで立ち上がるようにする
recompileは直前のcompilationの再実行関数。
実行して別ウィンドウのバッファが残るはずなのだが、何かウィンドウに関するパッケージを入れたせいで挙動が変わっている。
消えてしまう。
** TODO 正規表現置換が2度目以降失敗する
プログラム関係のmodeで起こることを確認(orgでは起こらない)。
#+begin_quote
  vr--perform-query-replace: Match data clobbered by buffer modification hooks
#+end_quote
** TODO Slackを見られるようにする
** TODO mailを読めるようにする
** TODO Vtermのログ件数を増やす
** TODO [[https://solist.work/blog/posts/git-history-tool/][ソースコードの読み方 - Solist Work Blog]]
Emacs, Magitで解説している。
** TODO [[https://dev.classmethod.jp/articles/emacs-multiple-cursors/][複数カーソルを操作するパッケージ multiple-cursors.el のご紹介 | DevelopersIO]]
** TODO .emacs.d整理
package管理もちゃんと使って設定したい。

- leaf https://qiita.com/conao3/items/dc88bdadb0523ef95878
** TODO wikipediaを直に検索できるようにする
** TODO popper(emacs package)
ウィンドウの出る方法を設定できるパッケージ。
** TODO shackle.el設定
** TODO EmacsとレプリカDB接続
ローカルではできるが、SSHを使う方法がわかっていない。
SQLを打つ時に不便なので。
** TODO lsp-mode が何かと競合する
消したときに近くの矩形が消されてしまう謎の挙動。
** TODO プロジェクトファイル限定のswitch-buffer。
projectile-switch-to-buffer (C-c p b)
** TODO キーバインドの一覧を表示
<F1> b
** TODO プロジェクトをag検索
projectile-ag (~C-c p s s~)
** TODO vtermでカッコが入力できない
vtermは互換性が高い[[id:585d3b5e-989d-4363-bcc3-894402fcfcf9][Shell]]のターミナルパッケージ。

カッコを自動入力するモードにしていると入力できなる。
なのでカッコ関係はコピペする羽目になる。
** TODO HIGでコピペしたときにおかしい
~highlight-indent-guides-mode~ がコピペしたときに表示がおかしい。
faceまでコピーするから仕方ないのかな。
** TODO vtermでコピーしたときにキルリングに入らない
一度読み取り専用バッファにして、コピーしないといけない。
** TODO GTAGSを使えるようにする
読むときにたどれないと不便。
** TODO 使ってないコマンドを開拓するパッケージ
最初にコマンド一覧をどこからか出力する。
それから、何かコマンドを打つごとに数を保存する。
そうしてしばらく使っていくと、使ったことのないコマンドが明らかになる。
カバレッジ率的にやっても面白そうだろう。
** TODO [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Tips.html][Appendix D Tips and Conventions]]
Emacs Lisp Manual。いくつか面白そうな章がある。
** TODO [[https://qiita.com/takaxp/items/a5a3383d7358c58240d0][org-mode のキーバインド、その先 - Qiita]]
キーバインドの記事。
* Emacsconf 2021
** Emacs News Highlights Sacha Chua
1年のニュース。
Emacs本体, magit, roamのメジャーバージョンアップ。
** The True Frownies are the Friends We Made Along the Way: An Anecdote of Emacs's Malleability Case Duckworth
frown-modeの開発。
** Emacs manuals translation and OmegaT Jean-Christophe Helary
翻訳をツールを使って早く進める。
** GNU's Not UNIX: Why Emacs Demonstrates The UNIX Philosophy Isn't Always The Only Answer Daniel Rose
UNIX哲学の概要、異なる点。
** Emacs and Montessori Philosophy Grant Shangreaux
Emacsとモンテッソーリ教育。
ドキュメント化されたコード。
** Emacs as Design Pattern Learning Greta Goetz
Emacsのデザインパターン。

- エコシステム
- 拡張性
- ユーザ
- 学ぶ方法
- コミュニティ
** How Emacs made me appreciate software freedom Protesilaos Stavrou
プログラマーでなかったがパッケージ開発をするようになった人。
Emacsのドキュメント文化。
たとえばinfoはREADMEというより本。
そういった文書は非常に参考になる。
初心者でもドキュメントにコミットの余地がある。

org, magitなどのキラーアプリを使いたくても、まずEmacsを使えるようになる必要がある。

Emacsはユーザと開発者の境界が曖昧である。
ほかのソフトウェアは、分かれている。
** NonGNU ELPA Update Philip Kaludercic
よいパッケージは本体に組み込む。
NonGNU ELPAはFSFのサインをする必要がない。
** Manual Package Management in The Era of Repositories - Why and How Dhavan (codingquark)
最初のインストールから説明。
git-submoduleでのパッケージ管理。
パッケージをクローンして、ビルドする。
** Introducing N-Angulator Kevin Haddock
UNIXファイルシステムはN次元の配列の集合体である。
だからそれをうまく扱えればファイラになる。

プレゼンの画面がとてつもなく古い。
SXEmacsだ。
** telega.el and the Emacs community on Telegram Gabriele Bozzola
メッセージサービスTelegramのラッパー。
拡張性が高い。
** Typesetting Gregorian Chant with Emacs Spencer King
楽譜を書くソフトのラッパー。
Emacsで書いて、PDFに変換できる。
** A day in the life of a janitor Stefan Monnier
Emacsのメンテナーのコンパイル。
レキシカルバインディングとか、依存関係とか。
なんだかよくわからない。
** Emacs Research Group, Season Zero: What we did together with Emacs in 2 hours a week for a year Noorah Alhasan, Joe Corneli, Raymond Puzio, Leo Vivier
** One effective CS grad student workflow Greg Coladonato
** Using Org-Mode For Recording Continuous Professional Development Philip Beadling
** Creating technical API documentation and presentations using org-babel, restclient, and org-treeslide Jan Ypma
** Org as an executable format Tom Gillespie
** The use of Org mode syntax outside of GNU/Emacs Karl Voit
org-modeの特徴をいくつかの段階に分ける。
最も基礎的な部分をOrgdown1とする。
** Using Org-mode to teach programming Daniel German
** Managing a research workflow (bibliographies, note-taking, and arXiv) Ahmed Khaled
** Babel for academics Asilata Bapat
** Reproducible molecular graphics with Org-mode Blaine Mooers
** Budgeting, Project Monitoring and Invoicing with Org Mode Adolfo Villafiorita
** Finding Your (In)voice: Emacs for Invoicing Bala Ramadurai
** Productivity Dashboards with Emacs and Kindle Mehmet Tekman
** Emacs with Nyxt: extend your editor with the power of a Lisp browser Andrea
** Emacs development updates John Wiegley
** On the design of text editors Nicolas P. Rougier
** Closing remarks day 1
** Opening remarks day 2
** Optimizing Emacs Lisp Code Dmitry Gutov
[[id:c7e81fac-9f8b-4538-9851-21d4ff3c2b08][Emacs Lisp]]の高速化。
オーバーレイがたくさんあるので、foldしまくってると表示が重い。

最初に計測して、原因を探ることから。
autocompleteの作者でもあるTomohiro Matsuyamaの作ったプロファイルライブラリがある。
ほかにもいろんなベンチマークがある。
** Tree-edit: Structural editing for Java, Python, C, and beyond Ethan Leba
DSLで展開して編集するパッケージの開発者。
大学生。すごいなあ。
** Yak-shaving to a UI framework Erik Anderson
React API。
Emacs上でコンポーネントの操作をできるようにするパッケージ。
すごすぎ。
テーマとかフォントはクソ古い感じで、ギャップに笑う。
** Moldable Emacs, a step towards sustainable software Andrea
[[id:c7e81fac-9f8b-4538-9851-21d4ff3c2b08][Emacs Lisp]]のクエリで図を生成する。
** Extending the "model" of Emacs to other applications Laszlo Krajnikovszkij
** Emacs Lisp native compiler, current status and future developments Andrea Corallo
** Old McCarthy Had a Form
** Turbo Bindat
** Test blocks
** Perso-Arabic Input Methods And Making More Emacs Apps BIDI Aware
** Emacs Application Framework: A 2021 Update
** Imaginary Programming
** CLEDE: the Common Lisp Emacs Development Environment
** How to help Emacs maintainers
** How to build an Emacs
** M-x Forever: Why Emacs will outlast text editor trends
** Closing remarks day 2
* References
** [[https://zenn.dev/nasum/articles/2020-12-06-emacs-init-el-dev][emacs.d でないところで init.el を育てる方法]]
ユーザディレクトリ以外に配置した.emacs.dを使う方法。
** [[http://pragmaticemacs.com/][Pragmatic Emacs | practical tips for everyday emacs]]
役立つtipsが紹介されているサイト。
** [[http://www.modernemacs.com/post/pretty-magit/][Pretty Magit - Integrating commit leaders | Modern Emacs]]
:LOGBOOK:
CLOCK: [2022-02-19 Sat 20:57]--[2022-02-19 Sat 21:22] =>  0:25
CLOCK: [2022-02-19 Sat 20:31]--[2022-02-19 Sat 20:56] =>  0:25
:END:
[[id:36da3e35-29c9-480f-99b3-4a297345bd5d][Conventional Commits]]を絵文字表示にする。
** [[https://www.slideshare.net/yukihiro_matz/how-emacs-changed-my-life][How Emacs changed my life]]
Matzのスライド。
Emacsを単に道具として使うだけでなく、[[id:cfd092c4-1bb2-43d3-88b1-9f647809e546][Ruby]]を書く上での参考にもなったという。
** [[https://zenn.dev/lambdagonbei/articles/1b2bce27673078][【Emacs入門】②バージョン28で新たにビルトインされるModus Themesを使おう]]
新しく追加されたthemeとその設定方法。
** [[https://karthinks.com/software/avy-can-do-anything/][Avy can do anything | Karthinks]]
avyの解説。
** [[https://www.emacswiki.org/emacs/HackerGuide][EmacsWiki: Hacker Guide]]
Emacsの簡単な概要。
** [[https://leanpub.com/hacking-your-way-emacs/][Hacking your way around in… by Marcin Borkowski]]
Emacsの本。買うか迷ってる。
** [[https://www.slideshare.net/nanasess/emacs-5282932][Emacs アイコンがコミットされるまで]]
こんな流れなんだ。
**  [[https://www.macs.hw.ac.uk/~rs46/posts/2018-12-29-textlint-flycheck.html][A textlint flycheck checker in Emacs]]
EmacsでのTextlint設定方法。
**  [[https://rubikitch.hatenadiary.org/entry/20101109/mouse][Emacsでマウスを有効活用する方法 - http://rubikitch.com/に移転しました]]
マウス活用の方法。
**  [[https://stackoverflow.com/questions/15272841/how-to-remove-a-function-from-run-with-idle-timer][emacs - How to remove a function from run-with-idle-timer? - Stack Overflow]]
timerのキャンセル方法。
**  [[https://spin.atomicobject.com/2016/05/27/write-emacs-package/][A Simple Guide to Writing & Publishing Emacs Packages]]
パッケージを作ってみる記事。
**  [[https://github.com/alphapapa/emacs-package-dev-handbook][alphapapa/emacs-package-dev-handbook]]
Emacsパッケージのハンドブック。
**  [[https://zeekat.nl/articles/making-emacs-work-for-me.html][Making Emacs Work For Me]]
設定解説。
** [[http://www.takuichi.net/hobby/symbolic/lisp/build-in.html][Emacs Lisp 組込み関数]]
基本的な関数をまとめたリスト。
** [[https://batsov.com/][(think)]]
Emacsのブログ。
** [[https://irreal.org/blog/][Irreal | The minds had long ago come up with a proper name for it; they called it the Irreal, but they thought of it as Infinite Fun. That was what they really knew it as. The Land of Infinite Fun. –Iain M. Banks, Excession]]
Emacsのブログ。
** [[https://kitchingroup.cheme.cmu.edu/blog/][The Kitchin Research Group]]
Emacsのブログ。
** [[https://planet.emacsen.org/][Theresa O’Connor]]
Emacsの情報集約サイト。
* Archives
** DONE git-linkでコミットハッシュからリンクを取る
CLOSED: [2021-09-24 Fri 10:44]
デフォルトだと現在のブランチから名前を取るため、remoteに存在しないブランチのとき無効なリンクになる。
ブランチ名を固定もできるが、汎用性がなくなる。
コミットハッシュから取ればいい。
#+begin_src emacs-lisp
(setq git-link-use-commit t)
#+end_src
** DONE ivy化
CLOSED: [2021-09-12 Sun 13:02]
[[https://qiita.com/takaxp/items/2fde2c119e419713342b][helm を背に ivy の門を叩く - Qiita]]
** DONE esh-autosuggestを導入する
CLOSED: [2021-09-12 Sun 12:47]
履歴を自動入力。
#+begin_src emacs-lisp
  (use-package esh-autosuggest
    :hook (eshell-mode . esh-autosuggest-mode)
    :config
    (setq esh-autosuggest-delay 0.5)
    (set-face-foreground 'company-preview-common "#4b5668")
    (set-face-background 'company-preview nil))
#+end_src
** DONE undo履歴を保持しないときがある
CLOSED: [2021-08-17 Tue 09:41]
3つくらいしか戻れないときがあり、原因は不明。
undo-treeで戻れる。
** DONE ~vterm-toggle~ をもっと良い感じに出てくるようにしたい。toggleでオフになったとき分割ウィンドウが消える。
CLOSED: [2021-05-30 Sun 00:25]
設定を追加した。
** DONE ~markdown-mode~ でHelm-M-xが作動しない。...emacs-mozcを使っていて日本語入力モードのときhelmがうまく作動しない。
CLOSED: [2021-05-30 Sun 00:25]
よくわからないのでclose。
** DONE 列名を表示する
CLOSED: [2021-07-26 Mon 09:41]
(global-display-line-numbers-mode)
linum-modeよりこっちのほうがいいらしい。
linum-modeは重かった。
外観も綺麗。
** DONE diredで直に編集する
CLOSED: [2021-06-23 Wed 01:34]
(wdired-change-to-wdired-mode)
編集モードにして ~C-c C-c~ で実行する。
** DONE 見出しレベル替え
CLOSED: [2021-09-10 Fri 17:58]
(org-cycle-level)
何も書いてない見出しでtab。
** DONE 見出し挿入
CLOSED: [2021-06-23 Wed 01:33]
C-enter
前の項目がリストでも見出しが挿入できる。
** DONE ~C-c n~
CLOSED: [2021-06-03 Thu 21:45]
roam のプレフィクスキー。
** DONE wdired-change-to-wdired-mode dired
CLOSED: [2021-06-03 Thu 21:45]
便利な置換。
** DONE org-mode の各種挿入 ~C-c C-,~
CLOSED: [2021-06-03 Thu 21:44]
** DONE ~projectile-find-file~ (~C-c p f~)
CLOSED: [2021-06-03 Thu 21:42]
プロジェクト全体のファイル名検索。
** DONE ~projectile-switch-project~ (~C-c p p~)
プロジェクトを切り替える。
CLOSED: [2021-06-03 Thu 21:42]
** DONE ~robe-doc~ (~C-c C-d~)
CLOSED: [2021-06-03 Thu 21:42]
Rubyメソッドを調べられる。gemがあるプロジェクトのGemfileで ~pry~, ~pry-doc~ をインストールして実行するとpryが起動して、以後使えるようになる。これは補完の ~company.el~ と連携させているため、pryを起動しないことにはgemの補完は表示されない。
** DONE ~vterm-copy-mode~ → ~C-c C-t~
CLOSED: [2021-06-03 Thu 21:42]
vterm上で、eshellなどのように自由に動き回るモード。
** DONE C-c C-w (org-refile)
CLOSED: [2021-07-26 Mon 09:41]
https://orgmode.org/manual/Refile-and-Copy.html#Refile-and-Copy
見出しの移動。
** DONE 使用パッケージで分岐するとき、どうやってbyte-compileエラーを回避するのか
CLOSED: [2021-08-21 Sat 23:47]
たとえばhelmを使ってるときはこれ、ivyのときはこれとかでrequireするものは変わるものだが。既存パッケージはどうしているのだろう。

↓とかやった。外部のコマンドは最初に定義しておいた。
#+begin_src emacs-lisp
(defvar w3m-current-url)
(declare-function w3m-current-title "ext:w3m-util")
#+end_src
** CLOSE Emacsをビルドしてみる
CLOSED: [2021-08-25 Wed 22:31]
https://systemcrafters.net/live-streams/august-20-2021/

この通りにやって簡単にできた。
** DONE roamリポジトリをサイト公開する
CLOSED: [2021-08-29 Sun 17:53]
どうにかして静的ページとして公開できるはず。
かっこいいのがなければ作る。

いい感じにやっているサイトはいくつもある。

- http://juanjose.garciaripoll.com/blog/org-mode-html-templates/index.html
- https://diego.codes/post/blogging-with-org/
- https://hugocisneros.com/org-config/#configuration
- https://hugocisneros.com/blog/my-org-roam-notes-workflow/
- https://doubleloop.net/2020/08/21/how-publish-org-roam-wiki-org-publish/
- https://notes.alexkehayias.com/org-roam/
- https://www.mtsolitary.com/20210318221148-emacs-configuration/#hugo-support
** DONE org-publishのスタイルを設定する
CLOSED: [2021-08-29 Sun 17:55]
https://ogbe.net/blog/blogging_with_org.html

contentのhtmlをいじることができなかったが、とりあえずcssで指定してOK。
** DONE autosaveが出てきてうざい
CLOSED: [2021-08-29 Sun 17:55]
Guixでは編集すると毎回プロンプトが出てくる。
#+begin_src emacs-lisp
  (defun ask-user-about-supersession-threat (fn)
    "blatantly ignore files that changed on disk"
  )
  (defun ask-user-about-lock (file opponent)
    "always grab lock"
  t)

  ;; or

  (setq revert-without-query '(".*"))
#+end_src
を実行したが、変わらなかった。

↓できた。
#+begin_src emacs-lisp
(setq auto-save-timeout 2)
(setq auto-save-visited-interval 2)
(setq auto-save-no-message t)
(auto-save-visited-mode)
#+end_src
** CLOSE Projectileの幅がせまくて見づらい
ほかのcompletionは幅いっぱいにハイライトされるが、projectileは文字のあるところしかハイライトされないので短い検索のときに見えにくい。たとえば ~counsel-find-file~ とか ~counsel-find-file~ と比べるとわかる。

counsel-projectileを使えば問題ない。でもデフォルトの動作がおかしいので修正したいところ。
いや、ivyの問題ぽい。ivy yasnippetをすると同じような状態になる。テーマを変えてもそうなる。

org-refileでも同じような感じ。要調査。
共通点は、右側にアノテーションが出ないときか。そのときはfaceが設定されないので右側まで伸びない。
** DONE org-mode のキーバインド
CLOSED: [2021-08-29 Sun 23:52]
見出し移動とか。
** DONE lsp setup([[id:ad1527ee-63b3-4a9b-a553-10899f57c234][TypeScript]])
CLOSED: [2021-09-04 Sat 14:39]
1. install language-server
https://deno.land/#installation
#+begin_src shell
  curl -fsSL https://deno.land/x/install/install.sh | sh
#+end_src
2. Install lsp-mode package
3. Add lsp settings to init.el

- reference :: [[https://takeokunn.xyz/blog/post/emacs-lsp-mode][emacsにlsp-mode入れた - takeokunn's blog]]
** DONE Vterm settings
CLOSED: [2021-09-12 Sun 13:05]
- prompt settings
** DONE lispxmpを設定する
CLOSED: [2021-09-19 Sun 19:42]
xmp-filterのelisp版。
#+begin_src emacs-lisp
  (require 'lispxmp)
  (define-key emacs-lisp-mode-map (kbd "C-c C-d") 'lispxmp)
#+end_src
** DONE pareditを設定する
CLOSED: [2021-09-19 Sun 19:42]
#+begin_src emacs-lisp
;;;括弧の対応を保持して編集する設定
(require 'paredit)
(add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
(add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
(add-hook 'lisp-mode-hook 'enable-paredit-mode)
(add-hook 'ielm-mode-hook 'enable-paredit-mode)
#+end_src
** DONE リンクを保存する方法をどうにかする
CLOSED: [2021-09-26 Sun 14:33]
ブラウザからコピペするのがメンドイのでどうにかする。
org-protocolを設定して簡単に保存できるようにした。
** DONE 踏み台SSH接続を簡単にできるように
CLOSED: [2022-01-15 Sat 10:11]
Emacsはあまり関係ない。
pecoを設定して簡単に接続できるようにした。
[[https://qiita.com/jagio/items/7b020df50c4b1bdc6ad0][Ubuntuにpecoを導入する(for bash) (for fish) - Qiita]]

#+caption: ~/.bashrc
#+begin_src shell
alias sshp='ssh $(grep Host ~/.ssh/config | grep -v HostName | cut -d" " -f2 | peco)'
#+end_src
** DONE EXWMとの連携を行う
CLOSED: [2022-01-19 Wed 10:16]
:LOGBOOK:
CLOCK: [2022-01-18 Tue 22:08]--[2022-01-18 Tue 22:33] =>  0:25
CLOCK: [2022-01-18 Tue 21:39]--[2022-01-18 Tue 22:04] =>  0:25
:END:
[[https://www.youtube.com/watch?v=usCfMstCZ7E][The Perfect Panel: Integrating Polybar with Emacs - Emacs Desktop Environment #5 - YouTube]]
** DONE vterm-toggleで初回崩れるのを直す
CLOSED: [2022-04-24 Sun 10:35]
:LOGBOOK:
CLOCK: [2022-04-23 Sat 22:22]--[2022-04-23 Sat 22:47] =>  0:25
:END:
READMEに書かれている設定を書いたら直った。前もコピペしてたはずなので、修正されたのだろう。
** DONE hydra設定
CLOSED: [2022-07-23 Sat 17:25]
:LOGBOOK:
CLOCK: [2022-07-23 Sat 16:59]--[2022-07-23 Sat 17:24] =>  0:25
CLOCK: [2022-07-23 Sat 12:27]--[2022-07-23 Sat 12:52] =>  0:25
CLOCK: [2022-07-23 Sat 11:57]--[2022-07-23 Sat 12:08] =>  0:11
CLOCK: [2022-07-23 Sat 11:43]--[2022-07-23 Sat 11:57] =>  0:14
CLOCK: [2022-07-23 Sat 10:44]--[2022-07-23 Sat 11:09] =>  0:25
:END:

すぐ自分で設定したキーバインドを忘れる対策で、hydraを設定した。
** DONE leaf.elはどうやって動いているか                          :DontKnow:
CLOSED: [2022-08-10 Wed 01:05]
:LOGBOOK:
CLOCK: [2022-08-10 Wed 00:49]--[2022-08-10 Wed 01:14] =>  0:25
CLOCK: [2022-08-07 Sun 18:01]--[2022-08-07 Sun 18:26] =>  0:25
:END:
- [[https://github.com/conao3/leaf.el][conao3/leaf.el: Flexible, declarative, and modern init.el package configuration]]

基本の動きは把握した。

キーワードを指定することで、インストール、フック、キーボードバインドまで、パッケージ周りの設定をうまくやってくれる。これはどうやっているのだろうか。

- キーワードをマクロで変換して、処理を実行してるぽい。たとえばpackageキーワードの場合、最終的にpackage.elのpackage-installが呼ばれてインストールする、というように。leaf自体が処理を持っているわけではない
- leaf関数がメイン。各キーワードをapplyして、対応する関数を実行している
- leaf keywordで定義されているキーワードの処理の中身はhandler系
- defmacroが大量に使われている。マクロを理解していないと読めない
  - [[https://www.tohoho-web.com/ex/lisp.html#defmacro][とほほのLISP入門 - とほほのWWW入門]] でdefmacroをおさらいする

#+caption: (* 2 3) というマクロが生成され、実行される
#+begin_src emacs-lisp
  (defmacro double (x) (list '* 2 x))
  (double 3)
#+end_src

#+RESULTS:
#+begin_results
6
#+end_results

#+caption: 式が生成されたあと、a1が2回インクリメントされる
#+begin_src emacs-lisp
  (defmacro double (x) (list '+ x x))
  (defvar a1 2)
  (double (incf a1))
  ;; (+ (incf a1) (incf a1))
  ;; (+ 3 4)
#+end_src

#+RESULTS:
#+begin_results
7
#+end_results

#+caption: マクロの展開形を確認する
#+begin_src emacs-lisp
  (defmacro double (x) (list '+ x x))
  (defvar a1 2)
  (macroexpand '(double (incf a1)))
#+end_src

#+RESULTS:
#+begin_results
(+ (incf a1) (incf a1))
#+end_results

バッククォートでマクロを表現。コンマで部分評価する。

#+caption: ↓同じ意味のふたつの書き方
#+begin_src emacs-lisp
  (defmacro add(x y) (list '+ x y)) ; `を使わないと、若干面倒
  (defmacro add(x y) `(+ ,x ,y)) ;; x, yを評価
  (add 1 2)
#+end_src

#+RESULTS:
#+begin_results
3
#+end_results

リスト展開。
#+caption: シングルクォートの中で@,で、リスト展開する
#+begin_src emacs-lisp
  (defmacro if-do (test &body do-list)
    `(if ,test (progn ,@do-list)))
  (if-do (> 5 3) (print "AAA") (print "BBB"))
#+end_src

** DONE [[https://masteringemacs.org/][Mastering Emacs]]
CLOSED: [2022-09-25 Sun 01:12]
:LOGBOOK:
CLOCK: [2022-09-24 Sat 23:28]--[2022-09-24 Sat 23:53] =>  0:25
CLOCK: [2022-09-24 Sat 20:52]--[2022-09-24 Sat 21:17] =>  0:25
CLOCK: [2022-09-24 Sat 20:26]--[2022-09-24 Sat 20:51] =>  0:25
CLOCK: [2022-09-24 Sat 17:40]--[2022-09-24 Sat 18:05] =>  0:25
CLOCK: [2022-09-24 Sat 17:15]--[2022-09-24 Sat 17:40] =>  0:25
CLOCK: [2022-09-24 Sat 16:50]--[2022-09-24 Sat 17:15] =>  0:25
CLOCK: [2022-09-24 Sat 15:08]--[2022-09-24 Sat 15:33] =>  0:25
CLOCK: [2022-09-24 Sat 12:21]--[2022-09-24 Sat 12:46] =>  0:25
CLOCK: [2022-09-24 Sat 11:34]--[2022-09-24 Sat 11:59] =>  0:25
CLOCK: [2022-09-24 Sat 11:06]--[2022-09-24 Sat 11:31] =>  0:25
CLOCK: [2022-09-24 Sat 09:46]--[2022-09-24 Sat 10:11] =>  0:25
CLOCK: [2022-09-24 Sat 09:21]--[2022-09-24 Sat 09:46] =>  0:25
CLOCK: [2022-09-24 Sat 08:55]--[2022-09-24 Sat 09:20] =>  0:25
CLOCK: [2022-09-24 Sat 08:26]--[2022-09-24 Sat 08:51] =>  0:25
:END:
Emacsの本。

メモ。

- paragraph-start 巨大な正規表現...
- リージョンの選択領域が出るのはtransient markモードを使用しているから。これがデフォルトになる前は記憶していた...
