:PROPERTIES:
:ID:       e9a608aa-8545-42be-90bb-303097800a85
:END:
#+title: assembly language
* 概要
アセンブリ言語はビット列命令に対応した文字列命令を利用するプログラミング言語の種類。ビット列に対応する文字列命令(ニーモニック)を利用する。アセンブリ言語を用いることで、機械語相当の低水準なコードをより直感的に記述できる。
* Memo
** objdumpでオブジェクトファイルの中身を確認する

abc.cがあるとする。このデータがオブジェクトファイルではどう表現されているかを見る。

#+begin_src c
char str[] = "ABC";
#+end_src

#+caption: 確認する
#+begin_src shell
$ gcc -fno-pic -fomit-frame-pointer -c -o abc.o abc.c
$ objdump -s -j .data abc.o
#+end_src

#+caption: 実行結果
#+begin_src
abc.o:     file format elf64-x86-64

Contents of section .data:
 0000 41424300                             ABC.
#+end_src

文字列ABCが、4バイト(0x41, 0x42, 0x43, 0x00)に変換されたことがわかる。

** 各種コマンド

#+caption: コンパイル
#+begin_src shell
  $ gcc -c add.c
#+end_src

#+caption: アセンブリ言語のプログラムadd.sにコンパイルする。
#+begin_src shell
$ gcc -S -fno-pic -fomit-frame-pointer add.c
#+end_src

#+caption: アセンブリ言語で書かれたプログラムadd.sを機械語に変換する。
#+begin_src shell
$ as -o add.o add.s
#+end_src

#+caption: アセンブラに-aオプションを指定すると、アセンブル結果を標準出力に表示する。
#+begin_src shell
$ as -a -o add.o add.s
#+end_src

#+caption: 実行結果
#+begin_src
GAS LISTING add.s                       page 1


   1                            .file   "add.c"
   2                            .text
   3                            .globl  i
   4                            .data
   5                            .align 4
   6                            .type   i, @object
   7                            .size   i, 4
   8                    i:
   9 0000 7B000000              .long   123
  10                            .text
  11                            .globl  main
  12                            .type   main, @function
  13                    main:
  14                    .LFB0:
  15                            .cfi_startproc
  16 0000 F30F1EFA              endbr64
  17 0004 8B050000              movl    i(%rip), %eax
  17      0000
  18 000a 05C80100              addl    $456, %eax
  18      00
  19 000f 89050000              movl    %eax, i(%rip)
  19      0000
  20 0015 B8000000              movl    $0, %eax
  20      00
  21 001a C3                    ret
  22                            .cfi_endproc
  23                    .LFE0:
  24                            .size   main, .-main
  25                            .ident  "GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0"
  26                            .section        .note.GNU-stack,"",@progbits
  27                            .section        .note.gnu.property,"a"
  28                            .align 8
  29 0000 04000000              .long   1f - 0f
  30 0004 10000000              .long   4f - 1f
  31 0008 05000000              .long   5
  32                    0:
  33 000c 474E5500              .string "GNU"
  34                    1:
  35                            .align 8
  36 0010 020000C0              .long   0xc0000002
  37 0014 04000000              .long   3f - 2f
  38                    2:
  39 0018 03000000              .long   0x3
  40                    3:
  41 001c 00000000              .align 8
  42                    4:

GAS LISTING add.s                       page 2


DEFINED SYMBOLS
                            *ABS*:0000000000000000 add.c
               add.s:8      .data:0000000000000000 i
               add.s:13     .text:0000000000000000 main

NO UNDEFINED SYMBOLS
#+end_src

** ニーモニック
- ニーモニックは処理内容に応じて各機械語命令に与えられた文字列・命令語。機械語のオペコードに相当する
- オペランドは命令の対象・引数
** 機械語との対応
アセンブリ言語と機械語の表現は一対一で対応している。これに対して、高級言語とアセンブリ言語は一対一対応していない。コンパイラの実装によって結果は異なる。

アセンブリ言語と機械語を比較する読み方。gccの-aオプションでコンパイルすると、機械語を見られる。

#+caption: 出力の一部
#+begin_src
  18 000a 05C80100              addl    $456, %eax
  18      00
#+end_src

これは、メモリ0018番地に、16進数で0x05, 0xc8, 0x01, 0x00という5バイトの機械語を生成したことを意味する。

- 1つのアセンブリ言語の命令につき1バイト(ret)から5バイト(movl, addl)の機械語が生成されている
- ~.~ から始まる命令に対しては機械語が生成されていない

* Tasks
** TODO [[https://www.amazon.co.jp/%E7%8B%AC%E7%BF%92%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9-%E6%96%B0%E7%89%88-%E5%A4%A7%E5%B4%8E-%E5%8D%9A%E4%B9%8B/dp/4798170291][独習アセンブラ 新版 | 大崎 博之 |本 | 通販 | Amazon]]
:LOGBOOK:
CLOCK: [2023-08-06 Sun 19:24]--[2023-08-06 Sun 19:49] =>  0:25
CLOCK: [2023-08-06 Sun 16:22]--[2023-08-06 Sun 16:47] =>  0:25
CLOCK: [2023-08-06 Sun 15:52]--[2023-08-06 Sun 16:17] =>  0:25
CLOCK: [2023-08-06 Sun 15:09]--[2023-08-06 Sun 15:34] =>  0:25
CLOCK: [2023-08-06 Sun 14:42]--[2023-08-06 Sun 15:07] =>  0:25
CLOCK: [2023-08-06 Sun 14:10]--[2023-08-06 Sun 14:35] =>  0:25
CLOCK: [2023-08-06 Sun 11:23]--[2023-08-06 Sun 11:48] =>  0:25
CLOCK: [2023-08-06 Sun 10:44]--[2023-08-06 Sun 11:09] =>  0:25
CLOCK: [2023-08-06 Sun 10:19]--[2023-08-06 Sun 10:44] =>  0:25
CLOCK: [2023-08-06 Sun 09:49]--[2023-08-06 Sun 10:14] =>  0:25
CLOCK: [2023-08-06 Sun 09:14]--[2023-08-06 Sun 09:39] =>  0:25
CLOCK: [2023-08-06 Sun 03:04]--[2023-08-06 Sun 03:29] =>  0:25
CLOCK: [2023-08-05 Sat 22:42]--[2023-08-05 Sat 23:07] =>  0:25
CLOCK: [2023-08-05 Sat 22:16]--[2023-08-05 Sat 22:41] =>  0:25
CLOCK: [2023-08-05 Sat 21:44]--[2023-08-05 Sat 22:09] =>  0:25
CLOCK: [2023-08-05 Sat 21:18]--[2023-08-05 Sat 21:43] =>  0:25
CLOCK: [2023-08-05 Sat 20:40]--[2023-08-05 Sat 21:05] =>  0:25
CLOCK: [2023-08-05 Sat 20:15]--[2023-08-05 Sat 20:40] =>  0:25
CLOCK: [2023-08-05 Sat 18:53]--[2023-08-05 Sat 19:18] =>  0:25
CLOCK: [2023-08-05 Sat 16:22]--[2023-08-05 Sat 16:47] =>  0:25
CLOCK: [2023-08-05 Sat 15:36]--[2023-08-05 Sat 16:02] =>  0:26
CLOCK: [2023-08-05 Sat 15:08]--[2023-08-05 Sat 15:33] =>  0:25
CLOCK: [2023-08-05 Sat 14:22]--[2023-08-05 Sat 14:47] =>  0:25
:END:

- 107, 130
- 「アセンブリ言語のプログラムを、アセンブラを使ってアセンブルする」というのが正しい用法になる
  - アセンブリ: 組み立てるという「行為」
  - アセンブル: 組み立ての「動作」
  - アセンブラ: 組み立てる「人や物」
- gccコマンドそのものはCコンパイラの本体ではなく、Cコンパイラのフロントエンドになっている
- gcc実行の流れ。コンパイル・アセンブル・リンク
  1. C言語(ソースコード)
  2. アセンブリ言語(ソースコード)
  3. 機械語(オブジェクトファイル)
  4. 機械語(実行ファイル)
- ビットという名前は Binary digIT から来ている
- フランス、ドイツ、イタリアでは小数の区切りにはカンマを用いる
- 文字情報を含んだバイナリファイルやバイナリデータを扱うプログラムを書いたり読んだりする場合には、文字の表現に対する理解が不可欠
- コンピュータにおける文字の用語
  - 文字(character) :: 書き言葉における最小の構成要素であり、何らかの意味を持ったものを指す。コンピュータにおける文字は制御文字も含む。文字そのものは抽象的な概念で、具体的にコンピュータでその文字をどのように格納したり、表示するのかとは直接関係ない
  - 文字列(string) :: 1つまたは複数の文字の並び
  - 文字集合(character set) :: 文字(character)の集合(set)。英語大文字26個を集めれば、それは英語大文字の文字集合。通常、文字集合には何らかの書き言葉を構成するすべての文字を含める
  - エンコーディング :: 何らかのデータを一定の規則に従って変換することを指し、符号化ともいう。ファイルの圧縮や暗号化、画像やビデオの符号化もエンコーディング。文字の表現におけるエンコーディングは文字エンコーディングを意味する。つまり文字の情報をある一定の規則に従って何らかのビット列に変換すること。ASCII, ISO-8859-1, UTF-8, EUC-JP, ISO-2022-JP, Shift_JISなどがある。エンコーディングは文字を一定の規則に従ってビット列に変換すること
  - 文字コード :: 本来、ある特定の文字に定められた符号(code)のこと。例えばASCIIにおいて、英大文字の「A」の文字コードは0x41。より正確には、ASCIIは7ビットのエンコーディングなので、英大文字「A」の文字コードは1000001となる。つまりASCIIにおいて、ある特定の文字「A」に定められた符号は1000001となる。日本では、文字エンコーディングと文字コードという言葉が混同して使用されることが多い…。文字コードとは、エンコーディングごとにそれぞれの文字に対して定められた符号を指す
  - CCS(Coded Character Set) :: 符号化文字の集合。抽象的な文字の集合から整数の集合への1対1対応のマッピング
  - CES(Character Encoding Scheme) ::文字エンコーディング体系。単一もしくは複数の符号化文字の集合CCSから、オクテット列の集合へのマッピング。文字、コード、バイト列との対応関係を定める。CCSの各文字のコードから、それに対応するバイト列への変換方法を定める。例えば1. 文字のコードの上位8バイトに0x80を足したものを1バイト目とする。2.文字のコードの下位8バイトに0x80を足したものを2バイト目とする。という規則で文字のコードからバイト列へと対応させている
- 制御文字は図形を表示するためのものではない。端末エミュレータ上で出力しても画面には何も表示されない。反対に、図形を表示するための文字をグラフィック文字という
- ASCII
  - JISキーボードの数字キーの記号配列は、ASCIIの範囲に対応している
    1. ~&~ の文字コードが知りたい
    2. JISキーボードを見ると ~&~ は ~6~ キーにある
    3. したがって ~&~ の文字コードは0x20 + 6 = 0x26
  - 0x30 ~ 0x39 には数字の0~9が配置されている。なので数字の文字コードは 0x30 + 数 とわかる
  - 0x41 ~ 0x5a には英大文字A~Zが配置されている。Aは1文字目のアルファベットなので、Aの文字コードは0x40 + 1 = 0x41。Cは3文字目のアルファベットなので、Cの文字コードは0x40 + 3 = 0x43
  - 0x61 ~ 0x7a には英小文字a~zが配置されている。Aとaの文字コードを2進数で表記すると1ビットだけが異なるように意図して配置されている
  - つまり配置として、多くの記号の文字コード < 英大文字の文字コード < 小文字の文字コードとなる。なので、文字コードでソートしたときに記号、大文字、小文字という順番になる
  - タブは制御文字とグラフィック文字の両方の側面を持っている
- 制御文字LFはラインフィードの意味。タイプライタ時代に用紙を読み込む指示をしていたから。当時のテレタイプには行を送るだけのものと、行を送ったあとキャリッジリターン(行頭に移動)するものがあった。Unixではラインフィードを「改行(行送り+行頭に移動」の意味で解釈している、といえる
- 一方で[[id:a15d346a-f82e-4796-a78b-85a8d227f0ef][Windows]]での改行は制御文字CRとLFの2文字である。これはラインフィードを「単なる行送り」の意味で解釈しているといえる。キャリッジリターンCRで行頭に戻して、その後ラインフィードLFで1行進めている、といえる
- キャリッジリターンという言葉は昔のタイプライタから来ている。キャリッジはタイプライタの用紙を動かす部分の名称。タイプライタは活字が刻印されたハンマーを打ち付けることによって印字する。ハンマーではなく用紙のほうを移動させる。キャリッジリターンはキャリッジを戻すという操作を意味している。キャリッジを戻すことにより、用紙のほうを移動させるという仕組みになっている
- DELが 0x7f(0b1111111)に配置されているのは、紙テープがすべて穿孔されていれば間違いがあり意味のないデータとして取り扱っていたため
- [[id:c76de2cf-e70d-4bc6-aa3a-f14d05debb6e][Unicode]]
  - 世界中の言語で使用されている文字を統一的に扱う規格であるUnicodeと、Unicodeの文字エンコーディング体系であるUTF-8やUTF-16
  - Unicodeではそれぞれの文字に割り当てられている整数をコードポイントと呼ぶ。例えば「あ」のコードポイントは0x3042
  - 文字とUnicodeのコードポイントが必ずしも1対1で対応しない。アクセントや濁音、半濁音がついた文字は複数の表現がある
  - Unicodeを使って文字をバイト列として表現するためには、符号化文字の集合に加えて、文字エンコーディング体系が必要になる
  - UTF-32, UTF-16, UTF-8のいずれかでエンコードされたバイト列を見ても、それがどの文字エンコード体系でエンコードされたのかはわからない。区別のために、BOM(Byte Order Mark)を使用できる
  - [[id:c76de2cf-e70d-4bc6-aa3a-f14d05debb6e][Unicode]]の特殊文字BOM(コードポイントU+FEFF)をUnicodeテキストの先頭にうめこんでおくと、エンコードしたバイト列から、このバイト列はどの文字エンコーディング体系でエンコードされたものかわかるようになる
  - [[id:c76de2cf-e70d-4bc6-aa3a-f14d05debb6e][Unicode]]テキストの先頭にU+FEFFがあればそれはBOMを意味するが、Unicodeテキストの2文字目以降にU+FEFFがあれば、それは「幅がゼロの改行できない空白」を意味する。
  - なのでBOMを表示・印刷しても何も見えない
- ドットから始まる命令はアセンブラの疑似命令であり、ディレクティブとも呼ばれる
  - アセンブラの疑似命令は、CPUが実行する命令ではなく、プログラマからアセンブラへの指示
- .gdbinitでプリント対象の変数を指定できる
- ~$ gcc -q add~ オプションは起動時のメッセージを抑制する

** TODO [[https://qiita.com/edo_m18/items/83c63cd69f119d0b9831][アセンブラに手を出してみる - Qiita]]
アセンブラの説明集。
** TODO [[https://tatsu-zine.com/books/my-emulator-x86-architecture][自作エミュレータで学ぶx86アーキテクチャ コンピュータが動く仕組みを徹底理解！【委託】 - 達人出版会]]
エミュレータで再現しながらの解説。
* Reference
** [[https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E8%A8%80%E8%AA%9E][アセンブリ言語 - Wikipedia]]
解説。
* Archives
