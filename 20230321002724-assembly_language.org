:PROPERTIES:
:ID:       e9a608aa-8545-42be-90bb-303097800a85
:header-args+: :wrap :results raw
:END:
#+title: assembly language
* 概要
アセンブリ言語はビット列命令に対応した文字列命令を利用するプログラミング言語の種類。ビット列に対応する文字列命令(ニーモニック)を利用する。アセンブリ言語を用いることで、機械語相当の低水準なコードをより直感的に記述できる。
* Memo
** objdumpでlsコマンドを逆アセンブルする
#+begin_src shell
  objdump -d -M intel /bin/ls | head -n 30
#+end_src

#+RESULTS:
#+begin_results

/bin/ls:     file format elf64-x86-64


Disassembly of section .init:

0000000000004000 <.init>:
    4000:	f3 0f 1e fa          	endbr64
    4004:	48 83 ec 08          	sub    rsp,0x8
    4008:	48 8b 05 b1 df 01 00 	mov    rax,QWORD PTR [rip+0x1dfb1]        # 21fc0 <__gmon_start__@Base>
    400f:	48 85 c0             	test   rax,rax
    4012:	74 02                	je     4016 <free@plt-0x66a>
    4014:	ff d0                	call   rax
    4016:	e8 c5 2b 00 00       	call   6be0 <__sprintf_chk@plt+0x1f00>
    401b:	e8 d0 30 01 00       	call   170f0 <_obstack_memory_used@@Base+0x6940>
    4020:	48 83 c4 08          	add    rsp,0x8
    4024:	c3                   	ret

Disassembly of section .plt:

0000000000004030 <.plt>:
    4030:	ff 35 2a dc 01 00    	push   QWORD PTR [rip+0x1dc2a]        # 21c60 <_obstack_memory_used@@Base+0x114b0>
    4036:	f2 ff 25 2b dc 01 00 	bnd jmp QWORD PTR [rip+0x1dc2b]        # 21c68 <_obstack_memory_used@@Base+0x114b8>
    403d:	0f 1f 00             	nop    DWORD PTR [rax]
    4040:	f3 0f 1e fa          	endbr64
    4044:	68 00 00 00 00       	push   0x0
    4049:	f2 e9 e1 ff ff ff    	bnd jmp 4030 <free@plt-0x650>
    404f:	90                   	nop
    4050:	f3 0f 1e fa          	endbr64
    4054:	68 01 00 00 00       	push   0x1
#+end_results

** objdumpでオブジェクトファイルの中身を確認する

abc.cがあるとする。このデータがオブジェクトファイルではどう表現されているかを見る。

#+begin_src c
char str[] = "ABC";
#+end_src

#+caption: 確認する
#+begin_src shell
$ gcc -fno-pic -fomit-frame-pointer -c -o abc.o abc.c
$ objdump -s -j .data abc.o
#+end_src

#+caption: 実行結果
#+begin_src
abc.o:     file format elf64-x86-64

Contents of section .data:
 0000 41424300                             ABC.
#+end_src

文字列ABCが、4バイト(0x41, 0x42, 0x43, 0x00)に変換されたことがわかる。

** 各種コマンド

#+caption: コンパイル
#+begin_src shell
  $ gcc -c add.c
#+end_src

#+caption: アセンブリ言語のプログラムadd.sにコンパイルする。
#+begin_src shell
$ gcc -S -fno-pic -fomit-frame-pointer add.c
#+end_src

#+caption: アセンブリ言語で書かれたプログラムadd.sを機械語に変換する。
#+begin_src shell
$ as -o add.o add.s
#+end_src

#+caption: アセンブラに-aオプションを指定すると、アセンブル結果を標準出力に表示する。
#+begin_src shell
$ as -a -o add.o add.s
#+end_src

#+caption: 実行結果
#+begin_src
GAS LISTING add.s                       page 1


   1                            .file   "add.c"
   2                            .text
   3                            .globl  i
   4                            .data
   5                            .align 4
   6                            .type   i, @object
   7                            .size   i, 4
   8                    i:
   9 0000 7B000000              .long   123
  10                            .text
  11                            .globl  main
  12                            .type   main, @function
  13                    main:
  14                    .LFB0:
  15                            .cfi_startproc
  16 0000 F30F1EFA              endbr64
  17 0004 8B050000              movl    i(%rip), %eax
  17      0000
  18 000a 05C80100              addl    $456, %eax
  18      00
  19 000f 89050000              movl    %eax, i(%rip)
  19      0000
  20 0015 B8000000              movl    $0, %eax
  20      00
  21 001a C3                    ret
  22                            .cfi_endproc
  23                    .LFE0:
  24                            .size   main, .-main
  25                            .ident  "GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0"
  26                            .section        .note.GNU-stack,"",@progbits
  27                            .section        .note.gnu.property,"a"
  28                            .align 8
  29 0000 04000000              .long   1f - 0f
  30 0004 10000000              .long   4f - 1f
  31 0008 05000000              .long   5
  32                    0:
  33 000c 474E5500              .string "GNU"
  34                    1:
  35                            .align 8
  36 0010 020000C0              .long   0xc0000002
  37 0014 04000000              .long   3f - 2f
  38                    2:
  39 0018 03000000              .long   0x3
  40                    3:
  41 001c 00000000              .align 8
  42                    4:

GAS LISTING add.s                       page 2


DEFINED SYMBOLS
                            *ABS*:0000000000000000 add.c
               add.s:8      .data:0000000000000000 i
               add.s:13     .text:0000000000000000 main

NO UNDEFINED SYMBOLS
#+end_src

** ニーモニック
- ニーモニックは処理内容に応じて各機械語命令に与えられた文字列・命令語。機械語のオペコードに相当する
- オペランドは命令の対象・引数
** 機械語との対応
アセンブリ言語と機械語の表現は一対一で対応している。これに対して、高級言語とアセンブリ言語は一対一対応していない。コンパイラの実装によって結果は異なる。

アセンブリ言語と機械語を比較する読み方。gccの-aオプションでコンパイルすると、機械語を見られる。

#+caption: 出力の一部
#+begin_src
  18 000a 05C80100              addl    $456, %eax
  18      00
#+end_src

これは、メモリ0018番地に、16進数で0x05, 0xc8, 0x01, 0x00という5バイトの機械語を生成したことを意味する。

- 1つのアセンブリ言語の命令につき1バイト(ret)から5バイト(movl, addl)の機械語が生成されている
- ~.~ から始まる命令に対しては機械語が生成されていない

* Tasks
** TODO [[https://qiita.com/kaito_tateyama/items/89272098f4b286b64115][アセンブリに触れてみよう - Qiita]]
:LOGBOOK:
CLOCK: [2023-08-26 Sat 17:22]--[2023-08-26 Sat 17:47] =>  0:25
CLOCK: [2023-08-26 Sat 11:49]--[2023-08-26 Sat 12:14] =>  0:25
:END:
アセンブリの解説。

- raxのA = Accumulator
- rbxのB = Base address
- rcxのC = Count register
- rdxのD = Data register

その他のレジスタ。

+ ripのipはInstruction Pointer。次に実行する命令のアドレスを記録する
+ rbpのbpはBase Pointer。現在の処理のスタックフレームの底部分のアドレスを記録する
+ rspのspはStack Pointer。スタック領域に積まれているデータのうち、一番小さいアドレスを記録する

** TODO [[https://www.sigbus.info/compilerbook][低レイヤを知りたい人のためのCコンパイラ作成入門]]
:LOGBOOK:
CLOCK: [2023-10-09 Mon 23:34]--[2023-10-09 Mon 23:59] =>  0:25
CLOCK: [2023-10-09 Mon 22:06]--[2023-10-09 Mon 22:31] =>  0:25
CLOCK: [2023-10-09 Mon 21:41]--[2023-10-09 Mon 22:06] =>  0:25
CLOCK: [2023-08-16 Wed 16:47]--[2023-08-16 Wed 18:44] =>  1:57
CLOCK: [2023-08-16 Wed 15:39]--[2023-08-16 Wed 16:24] =>  0:45
CLOCK: [2023-08-16 Wed 12:48]--[2023-08-16 Wed 13:13] =>  0:25
CLOCK: [2023-08-16 Wed 11:14]--[2023-08-16 Wed 11:39] =>  0:25
CLOCK: [2023-08-16 Wed 10:18]--[2023-08-16 Wed 10:43] =>  0:25
CLOCK: [2023-08-12 Sat 19:30]--[2023-08-12 Sat 19:55] =>  0:25
CLOCK: [2023-08-12 Sat 13:07]--[2023-08-12 Sat 13:32] =>  0:25
CLOCK: [2023-08-12 Sat 12:18]--[2023-08-12 Sat 12:43] =>  0:25
:END:
コンパイラの作り方の本。作り方だけでなく、インクリメンタルに大きなソフトウェアを作っていくことを体験できるのが良い。

- コンパイラが動作するマシンのことを「ホスト」、コンパイラが出力したコードが動作するマシンのことを「ターゲット」という
- 仮に関数呼び出しが1段しかなければ、リターンアドレスはCPUの適当なレジスタに保存しておけばいいが、関数呼び出しはいくらでも深くできるのでリターンアドレスはメモリ(上にあるスタック)に保存する必要がある
- ~再帰下降構文解析法~ でパーサを書くときの基本的な戦略は、非終端記号1つ1つをそのまま関数1つ1つにマップするということ

スタックマシンの解説。2+3*4 をする場合。


[[file:images/20230816-tree.drawio.svg]]

1. 左の部分木をコンパイル。数値の2をコンパイルすることになり、結果はそのままPUSH 2 [2]
2. 右の部分木をコンパイル。再帰的に部分木の左側をコンパイルしてPUSH 3。部分木の右側をコンパイルしてPUSH 4 [2 3 4]
3. コード生成関数は再帰呼び出しを元に戻りながら、部分木の演算子の型に合わせたコードを出力していく。
   1. 最初に出力されるのはスタックトップの2つの要素をそれらを掛けたもので置き換えるコード [2 12]
   3. 次にスタックトップの2つの要素をそれらを足したもので置き換えるコード [14]

結果として、以下のようなアセンブリが出力される。
#+begin_src asm
  PUSH 2
  PUSH 3
  PUSH 4
  MUL
  ADD
#+end_src

- レジスタマシンでスタックマシンをエミュレートする
- x86-64のRSPレジスタはスタックポインタとして使うことを念頭に置いて設計されている。x86-64のpushやpopといった命令は、暗黙のうちにRSPをスタックポインタとして使ってその値を変更しつつ、RSPが指しているメモリにアクセスする

#+begin_src asm
  push 1
  push 2

  pop rdi
  pop rax
  add rax, rdi

  push rax
#+end_src

86_64には「RSPが指している2つの要素を足す」という命令はないので、いったんレジスタにロードして加算し、その結果をスタックにプッシュしなおす必要がある。

2*3+4*5をx86-64で実装する。

#+begin_src asm
  // 2*3を計算して結果をスタックにプッシュ
  push 2
  push 3

  pop rdi
  pop rax
  mul rax, rdi
  push rax

  // 4*5を計算して結果をスタックにプッシュ
  push 4
  push 5

  pop rdi
  pop rax
  mul rax, rdi
  push rax

  // スタックトップの2つの値を足す
  pop rdi
  pop rax
  add rax, rdi
  push rax
  #+end_src

#+caption: コラムのいい話
#+begin_quote
技巧を凝らした簡潔なコードを書くことを常に目指す必要はありません。そういうことを目指していると、それ以上難しくできないところまでコードを難しくしてしまいがちです。

コードを書いている本人はそのコードのエキスパートになるので、エキスパート目線から見た簡潔で無駄のないコードを良いコードだと感じがちですが、大半のコードの読者は筆者と同じ感覚は共有しておらず、そもそもそこまで習熟する必要性もないので、コードの筆者としての自分の感覚はある程度疑ってかかる必要があります。「もっといい書き方がありそうな単純なコード」を必要に応じてあえて書くというのは、理解しやすくメンテナンスしやすいプログラムを作るための一つの重要なテクニックです。
#+end_quote

cmp命令。

#+begin_src asm
  pop rdi
  pop rax
  cmp rax, rdi
  sete al
  movzb rax, al
#+end_src

- 比較結果は比較命令の結果は特別なフラグレジスタにセットされる
  - フラグレジスタは整数演算や比較命令が実行されるたびに更新されるレジスタで、結果が0未満かどうかといったビットを持っている
  - フラグレジスタは通常の整数レジスタではないので、RAXに比較結果をセットしたい場合、フラグレジスタの特定のビットをRAXにコピーする必要がある。それをするのがsete命令
  - sete命令は直前のcmp命令で調べた2つのレジスタが同じだった場合に指定したレジスタに1をセットする。それ以外の場合には0をセットする
  - ALはRAXの下位8ビットを指す別名レジスタにすぎない。seteがALに値をセットすると、自動的にRAXも更新されることになる
  - RAXをALで更新するとき上位56ビットは変わらないので、RAX全体を0か1にしたい場合、上位56ビットはゼロクリアする必要がある。movzb命令でそれを行っている
- 分割コンパイルは1つのプログラムに複数のソースファイルに分割して書いて、別々にコンパイルすること
- 分割コンパイルでは、コンパイラはプログラム全体ではなく、プログラムの断片を読んで、それに対応した断片を出力することになる。単体では実行不可能なプログラムの断片の入ったファイルのことを「オブジェクトファイル」という。オブジェクトファイルをまとめて1つの実行ファイルにするプログラムをリンカという
- 標準ライブラリは普通はコンパイル済みのオブジェクトファイル形式で配布されている
- 分割コンパイルを行わないと、1行変更しただけでもコード全体をコンパイルし直すことになる
- callで飛ぶ先のアドレスは分割コンパイル時にわからないが、アセンブラはとりあえずアドレス0にジャンプするようなcall命令を出力しておいて、オブジェクトファイル内に「オブジェクトファイルのXバイト目をYという名前の関数のアドレスで修正する」という情報を残しておくことができる
- リンカはその情報を見て、実行ファイルのレイアウトを決めた後、プログラム断片をバイナリパッチングして、ジャンプ先のアドレスを修正する(リロケートという)。したがって分割コンパイルするためには関数の名前は必要だが関数のアドレスは不要
- 宣言に対して関数のコードを含むものを「定義」という。宣言を示すキーワードexternがある
- Cで他のCファイルをコンパイルするときに必要になる宣言をまとめてヘッダファイルを書く。宣言を書いておいて、それを必要とする別のCファイルに ~#include "foo.h"~ のように書いておくと、#includeの行がfoo.hファイルの内容に置き換えられる
- コンパイラは宣言を読み込んだときに特に何のアセンブリも出力しない。宣言は別のファイルに含まれている関数や変数を使うために必要な情報であって、それ自体は関数や変数を定義するものではないから
- C標準ライブラリについてくるヘッダファイルをインクルードすることで、printfの存在とその型をコンパイラは知ることができ、printfの関数呼び出しをコンパイルできるようになる
- Cの言語仕様では、コンパイラがファイル全体を読み込むことをせずに、関数1つ1つを先頭から順にコンパイルしていけるようになっている。ファイルの後ろで定義されている関数を使いたい場合、事前にその関数の定義を書いておく必要がある。そういった宣言を前方宣言という
- 関数も変数もアセンブラにおいてはただのラベルになっていて、同じ名前空間に属している
- 宣言は変数の型だけをコンパイラに教えるためのものなので、具体的な初期化式は必要ない
- 宣言と定義は異なる
- CPUを完全にハングさせるF00Fバグ
- Cのstaticキーワードには2つの用途がある
  - ローカル変数にstaticをつけて、関数を抜けた後でも値が保存されるようにする
  - グローバル変数や関数にstaticをつけて、その変数や関数のスコープをファイルスコープにする
- 共通性はとくにないにも関わらず同じキーワードになってしまっている
- ローカル変数を関数呼び出しごとに別々にもたせるために、Cではローカル変数はスタックに置くことになっている
- fが呼ばれた時点のスタックトップは、そのリターンアドレスが入っている
- ~{ ... }~ ブロックは、複数のステートメントをまとめて1つのステートメントにする効果がある ~if~ や ~while~ は条件式が成立したときに実行されるステートメントを1つしか許していない。が、ブロックを実装することで ~C~ と同じように ~{}~ でくくった複数の文を書ける
  - 関数本体もブロックで、 ~if~ や ~while~ の後に書く ~{...}~ と文法的には同じ

** TODO [[https://blog.foresta.me/posts/view_assembly_code/][アセンブリコードを眺めてみる]]
簡潔な解説。
** TODO [[https://qiita.com/edo_m18/items/83c63cd69f119d0b9831][アセンブラに手を出してみる - Qiita]]
アセンブラの説明集。
** TODO [[https://tatsu-zine.com/books/my-emulator-x86-architecture][自作エミュレータで学ぶx86アーキテクチャ コンピュータが動く仕組みを徹底理解！【委託】 - 達人出版会]]
エミュレータで再現しながらの解説。
* Reference
** [[https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E8%A8%80%E8%AA%9E][アセンブリ言語 - Wikipedia]]
解説。
** [[https://github.com/h-ohsaki/asm][h-ohsaki/asm: 「独習アセンブラ 新版」(翔泳社) サポートページ]]
サンプルコード。
* Archives
** DONE [[https://www.amazon.co.jp/%E7%8B%AC%E7%BF%92%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9-%E6%96%B0%E7%89%88-%E5%A4%A7%E5%B4%8E-%E5%8D%9A%E4%B9%8B/dp/4798170291][独習アセンブラ 新版 | 大崎 博之 |本 | 通販 | Amazon]]
CLOSED: [2023-09-10 Sun 11:24]
:PROPERTIES:
:Effort:   50:00
:END:
:LOGBOOK:
CLOCK: [2023-09-10 Sun 11:16]--[2023-09-10 Sun 11:41] =>  0:25
CLOCK: [2023-09-10 Sun 10:47]--[2023-09-10 Sun 11:12] =>  0:25
CLOCK: [2023-09-10 Sun 00:40]--[2023-09-10 Sun 01:05] =>  0:25
CLOCK: [2023-09-09 Sat 22:56]--[2023-09-09 Sat 23:21] =>  0:25
CLOCK: [2023-09-09 Sat 22:03]--[2023-09-09 Sat 22:28] =>  0:25
CLOCK: [2023-09-09 Sat 17:12]--[2023-09-09 Sat 17:37] =>  0:25
CLOCK: [2023-09-09 Sat 16:42]--[2023-09-09 Sat 17:07] =>  0:25
CLOCK: [2023-09-09 Sat 13:58]--[2023-09-09 Sat 14:23] =>  0:25
CLOCK: [2023-09-09 Sat 13:00]--[2023-09-09 Sat 13:25] =>  0:25
CLOCK: [2023-09-09 Sat 12:09]--[2023-09-09 Sat 12:34] =>  0:25
CLOCK: [2023-09-07 Thu 22:51]--[2023-09-07 Thu 23:16] =>  0:25
CLOCK: [2023-09-07 Thu 20:39]--[2023-09-07 Thu 21:04] =>  0:25
CLOCK: [2023-09-02 Sat 23:29]--[2023-09-02 Sat 23:54] =>  0:25
CLOCK: [2023-09-02 Sat 23:02]--[2023-09-02 Sat 23:27] =>  0:25
CLOCK: [2023-09-02 Sat 21:44]--[2023-09-02 Sat 22:09] =>  0:25
CLOCK: [2023-08-30 Wed 23:37]--[2023-08-31 Thu 00:02] =>  0:25
CLOCK: [2023-08-30 Wed 22:45]--[2023-08-30 Wed 23:10] =>  0:25
CLOCK: [2023-08-30 Wed 22:09]--[2023-08-30 Wed 22:34] =>  0:25
CLOCK: [2023-08-26 Sat 21:40]--[2023-08-26 Sat 22:05] =>  0:25
CLOCK: [2023-08-26 Sat 21:10]--[2023-08-26 Sat 21:35] =>  0:25
CLOCK: [2023-08-26 Sat 20:45]--[2023-08-26 Sat 21:10] =>  0:25
CLOCK: [2023-08-26 Sat 20:14]--[2023-08-26 Sat 20:39] =>  0:25
CLOCK: [2023-08-23 Wed 23:34]--[2023-08-23 Wed 23:59] =>  0:25
CLOCK: [2023-08-23 Wed 22:53]--[2023-08-23 Wed 23:18] =>  0:25
CLOCK: [2023-08-23 Wed 22:17]--[2023-08-23 Wed 22:42] =>  0:25
CLOCK: [2023-08-16 Wed 22:55]--[2023-08-16 Wed 23:20] =>  0:25
CLOCK: [2023-08-16 Wed 22:26]--[2023-08-16 Wed 22:51] =>  0:25
CLOCK: [2023-08-16 Wed 09:40]--[2023-08-16 Wed 10:05] =>  0:25
CLOCK: [2023-08-12 Sat 11:33]--[2023-08-12 Sat 11:58] =>  0:25
CLOCK: [2023-08-12 Sat 10:50]--[2023-08-12 Sat 11:15] =>  0:25
CLOCK: [2023-08-12 Sat 10:25]--[2023-08-12 Sat 10:50] =>  0:25
CLOCK: [2023-08-11 Fri 21:59]--[2023-08-11 Fri 22:24] =>  0:25
CLOCK: [2023-08-11 Fri 21:29]--[2023-08-11 Fri 21:54] =>  0:25
CLOCK: [2023-08-11 Fri 20:56]--[2023-08-11 Fri 21:21] =>  0:25
CLOCK: [2023-08-11 Fri 20:31]--[2023-08-11 Fri 20:56] =>  0:25
CLOCK: [2023-08-11 Fri 18:48]--[2023-08-11 Fri 19:13] =>  0:25
CLOCK: [2023-08-11 Fri 18:19]--[2023-08-11 Fri 18:44] =>  0:25
CLOCK: [2023-08-08 Tue 23:25]--[2023-08-08 Tue 23:50] =>  0:25
CLOCK: [2023-08-08 Tue 22:59]--[2023-08-08 Tue 23:24] =>  0:25
CLOCK: [2023-08-08 Tue 22:01]--[2023-08-08 Tue 22:26] =>  0:25
CLOCK: [2023-08-08 Tue 21:36]--[2023-08-08 Tue 22:01] =>  0:25
CLOCK: [2023-08-07 Mon 23:33]--[2023-08-07 Mon 23:58] =>  0:25
CLOCK: [2023-08-07 Mon 22:56]--[2023-08-07 Mon 23:21] =>  0:25
CLOCK: [2023-08-07 Mon 21:42]--[2023-08-07 Mon 22:07] =>  0:25
CLOCK: [2023-08-07 Mon 21:16]--[2023-08-07 Mon 21:41] =>  0:25
CLOCK: [2023-08-07 Mon 20:29]--[2023-08-07 Mon 20:54] =>  0:25
CLOCK: [2023-08-06 Sun 19:24]--[2023-08-06 Sun 19:49] =>  0:25
CLOCK: [2023-08-06 Sun 16:22]--[2023-08-06 Sun 16:47] =>  0:25
CLOCK: [2023-08-06 Sun 15:52]--[2023-08-06 Sun 16:17] =>  0:25
CLOCK: [2023-08-06 Sun 15:09]--[2023-08-06 Sun 15:34] =>  0:25
CLOCK: [2023-08-06 Sun 14:42]--[2023-08-06 Sun 15:07] =>  0:25
CLOCK: [2023-08-06 Sun 14:10]--[2023-08-06 Sun 14:35] =>  0:25
CLOCK: [2023-08-06 Sun 11:23]--[2023-08-06 Sun 11:48] =>  0:25
CLOCK: [2023-08-06 Sun 10:44]--[2023-08-06 Sun 11:09] =>  0:25
CLOCK: [2023-08-06 Sun 10:19]--[2023-08-06 Sun 10:44] =>  0:25
CLOCK: [2023-08-06 Sun 09:49]--[2023-08-06 Sun 10:14] =>  0:25
CLOCK: [2023-08-06 Sun 09:14]--[2023-08-06 Sun 09:39] =>  0:25
CLOCK: [2023-08-06 Sun 03:04]--[2023-08-06 Sun 03:29] =>  0:25
CLOCK: [2023-08-05 Sat 22:42]--[2023-08-05 Sat 23:07] =>  0:25
CLOCK: [2023-08-05 Sat 22:16]--[2023-08-05 Sat 22:41] =>  0:25
CLOCK: [2023-08-05 Sat 21:44]--[2023-08-05 Sat 22:09] =>  0:25
CLOCK: [2023-08-05 Sat 21:18]--[2023-08-05 Sat 21:43] =>  0:25
CLOCK: [2023-08-05 Sat 20:40]--[2023-08-05 Sat 21:05] =>  0:25
CLOCK: [2023-08-05 Sat 20:15]--[2023-08-05 Sat 20:40] =>  0:25
CLOCK: [2023-08-05 Sat 18:53]--[2023-08-05 Sat 19:18] =>  0:25
CLOCK: [2023-08-05 Sat 16:22]--[2023-08-05 Sat 16:47] =>  0:25
CLOCK: [2023-08-05 Sat 15:36]--[2023-08-05 Sat 16:02] =>  0:26
CLOCK: [2023-08-05 Sat 15:08]--[2023-08-05 Sat 15:33] =>  0:25
CLOCK: [2023-08-05 Sat 14:22]--[2023-08-05 Sat 14:47] =>  0:25
:END:

IA-32アーキテクチャの章までちゃんと読んだ。あとはいろんなアーキテクチャの解説があったが、そこはざっくりとしか読んでいない。

メモ。

- 「アセンブリ言語のプログラムを、アセンブラを使ってアセンブルする」というのが正しい用法になる
  - アセンブリ: 組み立てるという「行為」
  - アセンブル: 組み立ての「動作」
  - アセンブラ: 組み立てる「人や物」
- gccコマンドそのものはCコンパイラの本体ではなく、Cコンパイラのフロントエンドになっている
- gcc実行の流れ。コンパイル・アセンブル・リンク
  1. C言語(ソースコード)
  2. アセンブリ言語(ソースコード)
  3. 機械語(オブジェクトファイル)
  4. 機械語(実行ファイル)
- ビットという名前は Binary digIT から来ている
- フランス、ドイツ、イタリアでは小数の区切りにはカンマを用いる
- 文字情報を含んだバイナリファイルやバイナリデータを扱うプログラムを書いたり読んだりする場合には、文字の表現に対する理解が不可欠
- 制御文字は図形を表示するためのものではない。端末エミュレータ上で出力しても画面には何も表示されない。反対に、図形を表示するための文字をグラフィック文字という
- ASCII
  - JISキーボードの数字キーの記号配列は、ASCIIの範囲に対応している
    1. ~&~ の文字コードが知りたい
    2. JISキーボードを見ると ~&~ は ~6~ キーにある
    3. したがって ~&~ の文字コードは0x20 + 6 = 0x26
  - 0x30 ~ 0x39 には数字の0~9が配置されている。なので数字の文字コードは 0x30 + 数 とわかる
  - 0x41 ~ 0x5a には英大文字A~Zが配置されている。Aは1文字目のアルファベットなので、Aの文字コードは0x40 + 1 = 0x41。Cは3文字目のアルファベットなので、Cの文字コードは0x40 + 3 = 0x43
  - 0x61 ~ 0x7a には英小文字a~zが配置されている。Aとaの文字コードを2進数で表記すると1ビットだけが異なるように意図して配置されている
  - つまり配置として、多くの記号の文字コード < 英大文字の文字コード < 小文字の文字コードとなる。なので、文字コードでソートしたときに記号、大文字、小文字という順番になる
  - タブは制御文字とグラフィック文字の両方の側面を持っている
- 制御文字LFはラインフィードの意味。タイプライタ時代に用紙を読み込む指示をしていたから。当時のテレタイプには行を送るだけのものと、行を送ったあとキャリッジリターン(行頭に移動)するものがあった。Unixではラインフィードを「改行(行送り+行頭に移動」の意味で解釈している、といえる
- 一方で[[id:a15d346a-f82e-4796-a78b-85a8d227f0ef][Windows]]での改行は制御文字CRとLFの2文字である。これはラインフィードを「単なる行送り」の意味で解釈しているといえる。キャリッジリターンCRで行頭に戻して、その後ラインフィードLFで1行進めている、といえる
- キャリッジリターンという言葉は昔のタイプライタから来ている。キャリッジはタイプライタの用紙を動かす部分の名称。タイプライタは活字が刻印されたハンマーを打ち付けることによって印字する。ハンマーではなく用紙のほうを移動させる。キャリッジリターンはキャリッジを戻すという操作を意味している。キャリッジを戻すことにより、用紙のほうを移動させるという仕組みになっている
- DELが 0x7f(0b1111111)に配置されているのは、紙テープがすべて穿孔されていれば間違いがあり意味のないデータとして取り扱っていたため
- [[id:c76de2cf-e70d-4bc6-aa3a-f14d05debb6e][Unicode]]
  - 世界中の言語で使用されている文字を統一的に扱う規格であるUnicodeと、Unicodeの文字エンコーディング体系であるUTF-8やUTF-16
  - Unicodeではそれぞれの文字に割り当てられている整数をコードポイントと呼ぶ。例えば「あ」のコードポイントは0x3042
  - 文字とUnicodeのコードポイントが必ずしも1対1で対応しない。アクセントや濁音、半濁音がついた文字は複数の表現がある
  - Unicodeを使って文字をバイト列として表現するためには、符号化文字の集合に加えて、文字エンコーディング体系が必要になる
  - UTF-32, UTF-16, UTF-8のいずれかでエンコードされたバイト列を見ても、それがどの文字エンコード体系でエンコードされたのかはわからない。区別のために、BOM(Byte Order Mark)を使用できる
  - [[id:c76de2cf-e70d-4bc6-aa3a-f14d05debb6e][Unicode]]の特殊文字BOM(コードポイントU+FEFF)をUnicodeテキストの先頭にうめこんでおくと、エンコードしたバイト列から、このバイト列はどの文字エンコーディング体系でエンコードされたものかわかるようになる
  - [[id:c76de2cf-e70d-4bc6-aa3a-f14d05debb6e][Unicode]]テキストの先頭にU+FEFFがあればそれはBOMを意味するが、Unicodeテキストの2文字目以降にU+FEFFがあれば、それは「幅がゼロの改行できない空白」を意味する。
  - なのでBOMを表示・印刷しても何も見えない
- ドットから始まる命令はアセンブラの疑似命令であり、ディレクティブとも呼ばれる
  - アセンブラの疑似命令は、CPUが実行する命令ではなく、プログラマからアセンブラへの指示
- .gdbinitでプリント対象の変数を指定できる
- ~$ gcc -q add~ オプションは起動時のメッセージを抑制する
- C言語の規格では、各型の最小のビット数と、それぞれの型のビット数の大小関係のみが規定されていて、実際のビット数はそれぞれの処理系によって異なる
- ドットから始まる命令はアセンブラの疑似命令。 ~.L~ から始まるラベルは局所ラベル
- アセンブリ言語によるプログラミングにおけるスタックの利用法
  - 計算結果をスタックに一時保存する。複雑な計算をするとレジスタの数が不足するため。スタックはメモリ上に確保されるので、広大なメモリ空間を活用できる
  - 関数やサブルーチンと呼ばれる小さなまとまりのプログラムを実現するためにスタックを利用する
- 関数呼び出しを実現するために必要なこと
  - 呼び出しにどのように戻るか、リターンアドレスの管理
  - 呼び出し元から関数に引数をどのように渡すか
  - 関数から呼び出し元に返り値をどのように返すか
- コンピュータ内部で情報を保存できるのはレジスタとメモリしかない。したがって情報の受け渡しには、レジスタを使うかメモリを使うかの二択になる
- ~call アドレス~ で、リターンアドレスをスタックにプッシュし、指定されたアドレスにジャンプできる
- ~ret~ で、スタックからリターンアドレスを取り出して、そのアドレスにジャンプできる
- スタックの一番上のアドレス = レジスタESP
- ~cmpl	$0x1, 0x10(%esp)~
  - $0x1 → 整数1
  - 0x10(%esp) → ESPレジスタの値+0x10
  - を比較する、ということ
- サブルーチンの呼び出しアドレスは、最終的に隣家によって結合された時点で確定する。オブジェクトファイルがまだリンクされていないと、アドレスが未確定のままになっている
- writeシステムコールでは、レジスタEBXでファイルディスクリプタを、レジスタECXで文字列が格納されているアドレスを、レジスタEDXで出力する文字列長を指定する
- GNUアセンブラ(GAS)は、Cコンパイラの裏方で動作するアセンブラとして設計された
  - CコンパイラはC言語で書かれたプログラムをコンパイルし、アセンブリ言語のプログラムを生成する
  - GASは、Cコンパイラが生成したアセンブリ言語のプログラムを機械語に変換する

#+caption: 例示
#+begin_export asm
    .globl main
    .type main, @function
main:
.LFB0:
    .cfi_startproc
    movl i, %eax
#+end_export

- ~main~, ~.LFB0~, ~i~ はシンボル。
- ~L~ や ~.L~ から始まるシンボルは局所シンボル
- ~main:~ はラベル。ラベルは末尾にコロンを付与する
- 局所ラベルは「数字b」「数字f」によって参照できる
- ピリオドから始まる命令はGASの疑似命令(アセンブラに対する指示)
- アセンブラにおけるセクションとは、ある連続したアドレスの範囲
- GASはそれぞれのセクションを0番地から開始する。機械語のプログラムを格納するセクションも、プログラムが使用するデータを格納するセクションも、すべて0番地から開始する。機械語のプログラムも、プログラムが使用するデータも、最終的にはメモリ上のどこかのアドレスに配置されて実行される
- アセンブラが生成したオブジェクトファイルを、実際の適切なメモリ上の番地に配置するのはリンカの役割。リンカが、各セクションを配置するアドレスを決定することを再配置とよぶ。GASはそれぞれのセクションが実際のメモリのどこに配置されるかには関与しない
- GASは機械語のプログラムを.textセクションに格納する
- .dataセクションはプログラムが使用するデータを格納する
- .bssセクションは初期化されていないデータ領域のためのセクション。初期化されていないデータの中身は保持しなくてよく、大きさだけ持っていればよいのでデータ削減になる
- C言語における関数呼び出しは、C言語で書かれたプログラムを呼び出しているのではなく、もともとはC言語で書かれたプログラムだったが、現在はコンパイルが済んで機械語になっているプログラムを呼び出している
- ~movl $123, %eax~ とあるときの$123を即値という。アドレスの123番地ではなく、123という「値そのもの」を意味するから。値が指す先にあるものではなく、値が即時に表すものなので即値(immediate value)
- ビットシフト命令はハードウェアで実行しなければならない処理がはるかに簡単。乗数や除数が2のべき乗であれば、MUL命令やDIV命令を使用せずに、ビットシフト命令を用いることで高速な計算が可能になる
- NOP命令は何もしない命令。CPUはNOP命令を単に読み飛ばす。NOP命令は、バイナリファイルを書き換えて、特定の命令を無効化するのに使う
- CALL命令はリターンアドレスをスタックにプッシュしたあとでEIPレジスタの値を変更する
- IA-32アーキテクチャでアドレスは32ビット(4バイト)なので、スタックポインタの値を4だけ減らす
