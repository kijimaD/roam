<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-06-30 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Common Lisp</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel='shortcut icon' type='image/x-icon' href='/roam/favicon.ico' /><link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css' /><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css' /><link rel='stylesheet' href='../css/site.css' /><link rel='stylesheet' href='../roam/css/code.css' /><link rel='stylesheet' href='css/site.css' /><link rel='stylesheet' href='css/code.css' />
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content">
<h1 class="title">Common Lisp</h1>
<div id="outline-container-orgd0806e5" class="outline-2">
<h2 id="orgd0806e5"><a href="#orgd0806e5">概要</a></h2>
<div class="outline-text-2" id="text-orgd0806e5">
<p>
Common Lispは<a href="20210509101246-programming_language.html#ID-868ac56a-2d42-48d7-ab7f-7047c85a8f39">Programming Language</a>、<a href="20210911183844-lisp.html#ID-18fbe00f-4ec8-4ca0-adfa-2d1381669642">LISP</a>の方言の1つ。
Lispファミリーではもっともメジャー。
</p>
</div>
</div>
<div id="outline-container-org0e86b28" class="outline-2">
<h2 id="org0e86b28"><a href="#org0e86b28">Memo</a></h2>
</div>
<div id="outline-container-org2eba117" class="outline-2">
<h2 id="org2eba117"><a href="#org2eba117"><span class="todo TODO">TODO</span> <a href="https://www.oreilly.co.jp/books/9784873115870/">O&rsquo;Reilly Japan - Land of Lisp</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Read">Read</span></span></a></h2>
<div class="outline-text-2" id="text-org2eba117">
</div>
<div id="outline-container-org9d979fe" class="outline-3">
<h3 id="org9d979fe"><a href="#org9d979fe">_</a></h3>
<div class="outline-text-3" id="text-org9d979fe">
<ul class="org-ul">
<li>46, 48, 96, 103, 106, 132</li>
</ul>
</div>
</div>
<div id="outline-container-orgd72bceb" class="outline-3">
<h3 id="orgd72bceb"><a href="#orgd72bceb">数あてゲーム</a></h3>
<div class="outline-text-3" id="text-orgd72bceb">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>defparameterはグローバル変数</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*small*</span> 1)
*small*
</pre>
</div>

<div class="results" id="orgc97eb83">
<p>
1
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>元の値は上書きされる</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*foo*</span> 5)
*foo*
(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*foo*</span> 6)
*foo*
</pre>
</div>

<div class="results" id="org38e1564">
<p>
6
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>ashはバイナリサーチを書くのに使う</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">guess-my-number</span> ()
  (ash (+ *small* *big*) -1))
</pre>
</div>

<div class="results" id="org7cbd3ff">
<p>
GUESS-MY-NUMBER
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>実行してみる</label><pre class="src src-lisp">(guess-my-number)
</pre>
</div>

<div class="results" id="org8f5fa46">
<p>
50
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>smallerとbigger関数の定義</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">smaller</span> ()
  (setf *big* (1- (guess-my-number)))
  (guess-my-number))
(<span class="org-keyword">defun</span> <span class="org-function-name">bigger</span> ()
  (setf *small* (1+ (guess-my-number)))
  (guess-my-number))
</pre>
</div>

<div class="results" id="org8732aac">
<p>
BIGGER
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>使ってみる</label><pre class="src src-lisp">(bigger)
</pre>
</div>

<div class="results" id="org043678b">
<p>
75
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>初期化関数の定義</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">start-over</span> ()
  (<span class="org-keyword">defparameter</span> <span class="org-variable-name">*small*</span> 1)
  (<span class="org-keyword">defparameter</span> <span class="org-variable-name">*big*</span> 100)
  (guess-my-number))
(start-over)
</pre>
</div>

<div class="results" id="orgcff4991">
<p>
50
</p>

</div>
</div>
</div>
<div id="outline-container-org18438c2" class="outline-3">
<h3 id="org18438c2"><a href="#org18438c2">基本関数</a></h3>
<div class="outline-text-3" id="text-org18438c2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>53の53乗</label><pre class="src src-lisp">(expt 53 53)
</pre>
</div>

<div class="results" id="org21afaeb">
<p>
24356848165022712132477606520104725518533453128685640844505130879576720609150223301256150373
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>除算関数は有理数を返す</label><pre class="src src-lisp">(/ 4 6)
</pre>
</div>

<div class="results" id="org057901f">
<p>
2/3
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>文字を表示するprinc</label><pre class="src src-lisp">(princ <span class="org-string">"aaaa"</span>)
</pre>
</div>

<div class="results" id="org2ddaa94">
<p>
aaaa
</p>

</div>

<p>
Lispには、コードモードとデータモードがある。
通常はコードモード、シングルクォートがつくとデータモード。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>cadrで短くかける</label><pre class="src src-lisp">(car (cdr '(pork beef chicken)))
(cadr '(pork beef chicken))
</pre>
</div>
<p>
名前はリストにしたときの順番になっている。
つまり評価するときの意味としては逆になる。
cadrはcdr+carである。
</p>

<p>
andやorは真偽値演算だけでなく、条件判断としても使える。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>条件を満たさないときは、以降は評価されない</label><pre class="src src-lisp">(and *file-modified* (ask-user-about-saving) (save-file))
</pre>
</div>

<p>
member関数の返り値は部分リストになっている。もしマッチしたものを返すだったらnilを探すとき偽になってしまうから。
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">if</span> (member nil '(3 4 nil 5))
    'nil-is-in-the-list
    'nil-is-not-in-the-list)
</pre>
</div>

<ul class="org-ul">
<li>シンボル同士は常に <code>eq</code> で比較する</li>
<li>シンボル同士の比較でなければ <code>equal</code> で比較する</li>
</ul>
</div>
</div>
<div id="outline-container-org9a5fa98" class="outline-3">
<h3 id="org9a5fa98"><a href="#org9a5fa98">描写する</a></h3>
<div class="outline-text-3" id="text-org9a5fa98">
<ul class="org-ul">
<li>ゲームに限らずほとんどの実用プログラムでは、出力される情報は単なるテキストよりもはるかに複雑な構造をとる。HTML, PDF, グラフィック</li>
<li>元となるデータ構造を出力形式に縛られない形で最初から持っておけば、プログラミング言語の得意な点を活かしたコーディングができる。<a href="20210911183844-lisp.html#ID-18fbe00f-4ec8-4ca0-adfa-2d1381669642">LISP</a>の場合操作がしやすいのはシンボルとリストだから、可能な限り、プログラムを設計する際にこれらのデータ型で処理できないかを考える</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>連想リストを使って景色を描写する</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*nodes*</span> '((living-room (you are in the living-room.
                                      a wizard is snoring loudly on the couch.))
                        (garden (your are in a beautiful garden.
                                 there is a well in front of you.))
                        (attic (you are in the attic.
                                there is a giant welding torch in the corner.))))
</pre>
</div>

<div class="results" id="org9048d1c">
<p>
<b>NODES</b>
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>alistからキーを取り出す</label><pre class="src src-lisp">(assoc 'garden *nodes*)
</pre>
</div>

<div class="results" id="orgd3b0c23">
<p>
(GARDEN (YOUR ARE IN A BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU.))
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>場所を描写する関数</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">describe-location</span> (location nodes)
  (cadr (assoc location nodes)))
(describe-location 'living-room *nodes*)
</pre>
</div>

<div class="results" id="org0a90dbd">
<p>
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH.)
</p>

</div>

<p>
通り道を描写する。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>ゲームのマップ上でプレーヤーが場所間を移動可能な通り道を格納する</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*edges*</span> '((living-room (garden west door)
                                     (attic upstairs ladder))
                        (garden (living-room east door))
                        (attic (living-room downstairs ladder))))
</pre>
</div>

<div class="results" id="org3fd9dbd">
<p>
<b>EDGES</b>
</p>

</div>

<p>
テキストをシンボルのリストとして表現しておいたおかげで、準クォートを使って文を構築するコードを簡潔に書ける。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>必要なエッジの名前からテキストによる説明を得る関数</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">describe-path</span> (edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))
(describe-path '(garden west door))
</pre>
</div>

<div class="results" id="orgf84c85b">
<p>
(THERE IS A DOOR GOING WEST FROM HERE.)
</p>

</div>

<p>
1つの場所からはいくつもの通り道が出ている可能性がある。
与えられた場所から出ているすべての*edges*データから探して描写する関数が必要。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>描写する</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">describe-paths</span> (location edges)
  (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))
(describe-paths 'living-room *edges*)
</pre>
</div>

<div class="results" id="org7c08579">
<p>
(THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
 HERE.)
</p>

</div>

<p>
mapcarはよく使われる。引数に他の関数とリストを受け取って、リストの要素それぞれを引数として受け取った関数を呼び出す。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>sqrtは平方根を求める関数</label><pre class="src src-lisp">(mapcar #'sqrt '(1 2 3 4))
</pre>
</div>

<div class="results" id="org6d509eb">
<p>
(1 1.4142135 1.7320508 2)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>2つのリストの最初を返す</label><pre class="src src-lisp">(mapcar #'car '((foo bar) (baz qux)))
</pre>
</div>

<div class="results" id="orge138b1c">
<p>
(FOO BAZ)
</p>

</div>

<p>
#&rsquo;はfunctionオペレータの略記。この記号を含む式は、内部的に変換される。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>↑の関数の内部的な形</label><pre class="src src-lisp">(mapcar (function car) '((foo bar) (baz qux)))
</pre>
</div>

<div class="results" id="orgd522777">
<p>
(FOO BAZ)
</p>

</div>

<p>
Common Lispでは関数を値として扱うときにfunctionオペレータを使ってそのことを明示しなければならない。
関数と変数で名前が衝突した場合にエラーを起こす可能性があるから。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>別々の名前空間。組み込みの関数carとローカル変数carは区別できる。mapcarはそれぞれのapply結果のリストを返す</label><pre class="src src-lisp">(<span class="org-keyword">let</span> ((car <span class="org-string">"Honda Civic"</span>))
  (mapcar #'car '((foo bar) (baz qux))))
</pre>
</div>

<div class="results" id="orgabdeec9">
<p>
(FOO BAZ)
</p>

</div>

<p>
<a href="20210926144913-scheme.html#ID-53a7a781-8398-4069-8735-6ac5b8c3bc05">Scheme</a>では、変数と関数と名前空間が共通なので関数を値として渡す場合にfunctionオペレータで明示する必要はない。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>applyとappendでリストを合体する</label><pre class="src src-lisp">(apply #'append '((mary had) (a) (little lamb)))
</pre>
</div>

<div class="results" id="org539ed92">
<p>
(MARY HAD A LITTLE LAMB)
</p>

</div>

<div class="org-src-container">
<pre class="src src-lisp">(apply #'append '((THERE IS A DOOR GOING WEST FROM HERE.)
                  (THERE IS A LADDER GOING UPSTAIRS FROM HERE.)))
</pre>
</div>

<div class="results" id="orgb682afb">
<p>
(THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
 HERE.)
</p>

</div>
</div>
</div>

<div id="outline-container-org7882eb5" class="outline-3">
<h3 id="org7882eb5"><a href="#org7882eb5">目に見えるオブジェクトをリストする</a></h3>
<div class="outline-text-3" id="text-org7882eb5">
<p>
ゲーム世界に存在するオブジェクトのリストを作る。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*objects*</span> '(whiskey bucket frog chain))
</pre>
</div>

<div class="results" id="orgb71b387">
<p>
<b>OBJECTS</b>
</p>

</div>

<p>
オブジェクトとその場所をalistで表現する。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>alist</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*object-locations*</span> '((whiskey living-room)
                                   (bucket living-room)
                                   (chain garden)
                                   (frog garden)))
*object-locations*
</pre>
</div>

<div class="results" id="org76e8f6f">
<p>
((WHISKEY LIVING-ROOM) (BUCKET LIVING-ROOM) (CHAIN GARDEN) (FROG GARDEN))
</p>

</div>

<p>
与えられた場所から見るオブジェクトのリスト。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>labelsでローカル関数が定義できる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">objects-at</span> (loc objs obj-locs)
  (<span class="org-keyword">labels</span> ((at-loc-p (obj)
             (eq (cadr (assoc obj obj-locs)) loc)))
    (remove-if-not #'at-loc-p objs)))
</pre>
</div>

<div class="results" id="org053c884">
<p>
OBJECTS-AT
</p>

</div>

<p>
objects-atを使ってみる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span>living-roomにあるobjectを描写する</label><pre class="src src-lisp">(objects-at 'living-room *objects* *object-locations*)
</pre>
</div>

<div class="results" id="org8c7392a">
<p>
(WHISKEY BUCKET)
</p>

</div>

<p>
ある場所で見えるオブジェクトの一覧。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 30: </span>オブジェクト一覧</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">describe-objects</span> (loc objs obj-loc)
  (<span class="org-keyword">labels</span> ((describe-obj (obj)
             `(you see a ,obj on the floor.)))
    (apply #'append (mapcar #'describe-obj (objects-at loc objs obj-loc)))))
</pre>
</div>

<div class="results" id="orgec3ec40">
<p>
DESCRIBE-OBJECTS
</p>

</div>

<p>
使ってみる。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(describe-objects 'living-room *objects* *object-locations*)
</pre>
</div>

<div class="results" id="orgee45f39">
<p>
(YOU SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
</p>

</div>
</div>
</div>

<div id="outline-container-org0fc7e7b" class="outline-3">
<h3 id="org0fc7e7b"><a href="#org0fc7e7b">現在地を保持する</a></h3>
<div class="outline-text-3" id="text-org0fc7e7b">
<p>
現在値を保持する変数を作る。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span>現在地を保持する</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*location*</span> 'living-room)
*location*
</pre>
</div>

<div class="results" id="orgaea1c69">
<p>
LIVING-ROOM
</p>

</div>

<p>
プレイヤーがタイプするlook関数を作る。見えるものすべてを描写する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 33: </span>見えるものすべてを描写する</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">look</span> ()
(append (describe-location *location* *nodes*)
      (describe-paths *location* *edges*)
      (describe-objects *location* *objects* *object-locations*)))
(look)
</pre>
</div>

<div class="results" id="org1f66bf9">
<p>
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
 A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
 SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
</p>

</div>

<p>
look関数はグローバル変数を読むから、関数的ではない。
</p>
</div>
</div>
<div id="outline-container-org150db22" class="outline-3">
<h3 id="org150db22"><a href="#org150db22">動き回る</a></h3>
<div class="outline-text-3" id="text-org150db22">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span>歩き回るwalk関数。find関数はリストから与えた要素を探す関数</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">walk</span> (direction)
  (<span class="org-keyword">let</span> ((next (find direction
                    (cdr (assoc *location* *edges*))
                    <span class="org-builtin">:key</span> #'cadr)))
    (<span class="org-keyword">if</span> next
        (<span class="org-keyword">progn</span> (setf *location* (car next))
               (look))
        '(you cannot go that way.))))
</pre>
</div>

<div class="results" id="orgf115cf3">
<p>
WALK
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 35: </span>findの例: シンボルyをcadrに持つような最初の要素をリストから探し出す</label><pre class="src src-lisp">(find 'y '((5 x) (3 y) (7 z)) <span class="org-builtin">:key</span> #'cadr)
</pre>
</div>

<div class="results" id="org5bbfae8">
<p>
(3 Y)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 36: </span>findの例2: シンボルyをcarに持つような最初の要素をリストから探し出す</label><pre class="src src-lisp">(find '3 '((5 x) (3 y) (7 z)) <span class="org-builtin">:key</span> #'car)
</pre>
</div>

<div class="results" id="orgd3a652b">
<p>
(3 Y)
</p>

</div>

<p>
:key #&rsquo;carはキーワード引数。
コロンで始まる名前、続く値で構成されている。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 37: </span>walkを使ってみる</label><pre class="src src-lisp">(walk 'west)
</pre>
</div>

<div class="results" id="org1d877cb">
<p>
(YOUR ARE IN A BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU. THERE IS A
 DOOR GOING EAST FROM HERE. YOU SEE A FROG ON THE FLOOR. YOU SEE A CHAIN ON THE
 FLOOR.)
</p>

</div>
</div>
</div>

<div id="outline-container-org251bdc0" class="outline-3">
<h3 id="org251bdc0"><a href="#org251bdc0">オブジェクトを手に取る</a></h3>
<div class="outline-text-3" id="text-org251bdc0">
<p>
pushとassocを使うことで、alistの値が変更されたかのように見せることができる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 38: </span>オブジェクトの場所を管理している変数 *object-locations*を変更する</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">pickup</span> (object)
  (<span class="org-keyword">cond</span> ((member object
                 (objects-at *location* *objects* *object-locations*))
         (push (list object 'body) *object-locations*)
         `(you are now carrying the ,object))
        (t '(you cannot get that.))))
</pre>
</div>

<div class="results" id="orga0cfee6">
<p>
PICKUP
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 39: </span>リビングに戻る</label><pre class="src src-lisp">(walk 'east)
</pre>
</div>

<div class="results" id="org3cae7a2">
<p>
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
 A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
 SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 40: </span>ウィスキーを取る</label><pre class="src src-lisp">(pickup 'whiskey)
</pre>
</div>

<div class="results" id="org39b4661">
<p>
(YOU CANNOT GET THAT.)
</p>

</div>

<p>
alist中の値を置き換えたければ、新しい要素をリストにpushするだけでいい。
assocはもっとも新しい値だけを返すから。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 41: </span>持っているものを調べる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">inventory</span> ()
    (cons 'items- (objects-at 'body *objects* *object-locations*)))
(inventory)
</pre>
</div>

<div class="results" id="orgf4e1080">
<p>
(ITEMS-)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 42: </span>pushは先頭に新しいリストを追加する</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*foo*</span> '(1 2 3))
(push 7 *foo*)
</pre>
</div>

<div class="results" id="orgaf19a5c">
<p>
(7 1 2 3)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 43: </span>↑と同じことをsetfで表現する</label><pre class="src src-lisp">(setf *foo* (cons 7 '(1 2 3)))
</pre>
</div>

<div class="results" id="org4e639f3">
<p>
(7 1 2 3)
</p>

</div>

<p>
動作を試す。
居間に戻ってウィスキーを取る。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 44: </span>歩く</label><pre class="src src-lisp">(walk 'east)
</pre>
</div>

<div class="results" id="orga8545be">
<p>
(YOU CANNOT GO THAT WAY.)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 45: </span>ウィスキーを取る</label><pre class="src src-lisp">(pickup 'whiskey)
</pre>
</div>

<div class="results" id="org8744c7d">
<p>
(YOU ARE NOW CARRYING THE WHISKEY)
</p>

</div>
</div>
</div>

<div id="outline-container-org5355a0b" class="outline-3">
<h3 id="org5355a0b"><a href="#org5355a0b">テキストの表示と読み込み</a></h3>
<div class="outline-text-3" id="text-org5355a0b">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 46: </span>表示する</label><pre class="src src-lisp">(print <span class="org-string">"foo"</span>)
</pre>
</div>

<div class="results" id="org81a12ff">
<p>
foo
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 47: </span>printは改行する</label><pre class="src src-lisp">(<span class="org-keyword">progn</span> (print <span class="org-string">"this"</span>)
       (print <span class="org-string">"is"</span>)
       (print <span class="org-string">"a"</span>)
       (print <span class="org-string">"test"</span>))
</pre>
</div>

<div class="results" id="orgf70a72e">
<p>

</p>

<p>
&ldquo;this&rdquo;
&ldquo;is&rdquo;
&ldquo;a&rdquo;
&ldquo;test&rdquo;
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 48: </span>prin1は改行しない</label><pre class="src src-lisp">(<span class="org-keyword">progn</span> (prin1 <span class="org-string">"this"</span>)
       (prin1 <span class="org-string">"is"</span>)
       (prin1 <span class="org-string">"a"</span>)
       (prin1 <span class="org-string">"test"</span>))
</pre>
</div>

<div class="results" id="orgac87065">
<p>
this&ldquo;&rdquo;is&ldquo;&rdquo;a&ldquo;&rdquo;test
</p>

</div>

<p>
prin1の方がやってることは少ないので、より基本的な関数であると言える。組み合わせの自由度も高く、したがって大規模なコードの中でよく見られる。
</p>

<p>
入力させて挨拶を返す関数。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 49: </span>プロンプトから呼び出して、入力を待つ。入力はダブルクォートで囲む必要がある</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">say-hello</span> ()
  (print <span class="org-string">"Please type your name:"</span>)
  (<span class="org-keyword">let</span> ((name (read)))
    (print <span class="org-string">"Nice to meet you, "</span>)
    (print name)))
</pre>
</div>

<p>
printはコンピュータ向け、princは人間向け。
printは元のデータを表示する。printcは文字列にして表示する。
</p>

<p>
ダブルクォートをつけなくていい改良版。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 50: </span>princ, read-lineを使う</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">say-hello</span>()
  (princ <span class="org-string">"Please type your name:"</span>)
  (<span class="org-keyword">let</span> ((name (read-line)))
    (princ <span class="org-string">"Nice to meet you, "</span>)
    (princ name)))
</pre>
</div>

<div class="results" id="orgceab521">
<p>
SAY-HELLO
</p>

</div>
</div>
</div>

<div id="outline-container-org6951186" class="outline-3">
<h3 id="org6951186"><a href="#org6951186">データの対称性</a></h3>
<div class="outline-text-3" id="text-org6951186">
<p>
プログラムコードとデータを同じデータ構造を使って扱うプログラミング言語は、同図象性を持つ、と呼ばれる。
</p>

<ul class="org-ul">
<li>&rsquo;(+ 1 2) → データモード</li>
<li>(+ 1 2) → コードモード</li>
</ul>

<p>
evalは強力で、自己書き換えのプログラムを書くには役立つ。が、普段はほとんど使わない。
</p>
</div>
</div>

<div id="outline-container-org45e9b37" class="outline-3">
<h3 id="org45e9b37"><a href="#org45e9b37">専用のインターフェースを追加する</a></h3>
<div class="outline-text-3" id="text-org45e9b37">
<p>
専用のREPLを作るのは簡単にできる。
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">game-repl</span> ()
  (<span class="org-keyword">loop</span> (print (eval (read)))))
(game-repl)
</pre>
</div>

<p>
REPLでの実行。
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (look)
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
 A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
 SEE A BUCKET ON THE FLOOR.)
</pre>
</div>

<p>
quit呼び出しを検知して、replを抜けられるようにする。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 52: </span>ローカル変数cmdにコマンドを保存しておいて、判断する</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">game-repl</span> ()
  (<span class="org-keyword">let</span> ((cmd (game-read)))
    (<span class="org-keyword">unless</span> (eq (car cmd) 'quit)
      (game-print (game-eval cmd))
      (game-repl))))
</pre>
</div>

<div class="results" id="org30a5f56">
<p>
GAME-REPL
</p>

</div>

<p>
カッコをつけなくてもコマンド入力できるようにする。
walk east とタイプしたなら、(walk east) になる。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 53: </span>カッコを付け足して評価する</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">game-read</span> ()
  (<span class="org-keyword">let</span> ((cmd (read-from-string
              (concatenate 'string <span class="org-string">"("</span> (read-line) <span class="org-string">")"</span>))))
    (<span class="org-keyword">flet</span> ((quote-it (x)
             (list 'quote x)))
      (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))
</pre>
</div>

<div class="results" id="orgea1ded8">
<p>
GAME-READ
</p>

</div>

<p>
game-evalではあらかじめ決めたコマンドだけを呼べるようにする。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 54: </span>変数に入れておいたコマンドだけ実行できる</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*allowed-commands*</span> '(look walk pickup inventory))

(<span class="org-keyword">defun</span> <span class="org-function-name">game-eval</span> (sexp)
  (<span class="org-keyword">if</span> (member (car sexp) *allowed-commands*)
      (eval sexp)
      '(i do not know that command.)))
</pre>
</div>

<div class="results" id="org4aba674">
<p>
GAME-EVAL
</p>

</div>

<p>
テキストをいい感じに変換する関数が必要。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 55: </span>内部表現にすぎないシンボルのリストを文字列に変換する。coerce関数を使って文字列を文字のリストに変換することで、解くべき問題をリスト処理へと落とし込んでいる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">tweak-text</span> (lst caps lit)
  (<span class="org-keyword">when</span> lst
    (<span class="org-keyword">let</span> ((item (car lst))
          (rest (cdr lst)))
      (<span class="org-keyword">cond</span> ((eql item #\space) (cons item (tweak-text rest caps lit)))
            ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit))) <span class="org-comment-delimiter">;; </span><span class="org-comment">&#25991;&#31456;&#12398;&#20808;&#38957;&#12399;&#12289;!,?,.,&#12398;&#12354;&#12392;&#12395;&#29694;&#12428;&#12427;</span>
            ((eql item #\") (tweak-text rest caps (not lit)))
            (lit (cons  item (tweak-text rest nil lit)))
            (caps (cons (char-upcase item) (tweak-text rest nil lit)))
            (t (cons (char-downcase item) (tweak-text rest nil nil))))))) <span class="org-comment-delimiter">;; </span><span class="org-comment">&#12393;&#12398;&#26465;&#20214;&#12418;&#28288;&#12383;&#12373;&#12394;&#12369;&#12428;&#12400;&#12289;&#23567;&#25991;&#23383;&#12395;&#12394;&#12427;</span>

(<span class="org-keyword">defun</span> <span class="org-function-name">game-print</span> (lst)
  (princ (coerce (tweak-text (coerce (string-trim <span class="org-string">"() "</span>
                                                  (prin1-to-string lst))
                                     'list)
                             t
                             nil)
                 'string)
         (fresh-line)))
</pre>
</div>

<div class="results" id="org141b797">
<p>
GAME-PRINT
</p>

</div>

<p>
途中で大文字が出てくる場合に対応している。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 56: </span>&ldquo;がでてきた場合は無視して、残りの処理を続行する</label><pre class="src src-lisp">(game-print '(not only does this sentence have a <span class="org-string">"comma,"</span> it also mentions the <span class="org-string">"iPad."</span>))
</pre>
</div>

<div class="results" id="orgb53b4ed">
<p>
Not only does this sentence have a comma, it also mentions the iPad.
</p>

</div>
</div>
</div>

<div id="outline-container-org3be0dc8" class="outline-3">
<h3 id="org3be0dc8"><a href="#org3be0dc8">Lambda</a></h3>
<div class="outline-text-3" id="text-org3be0dc8">
<p>
そもそもLispが産まれたのは、lambdaコマンドのためだった。
</p>

<p>
lambdaを使えば、名前を与えずに関数を作れる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 57: </span>関数引数に渡すことができる</label><pre class="src src-lisp">(mapcar (<span class="org-keyword">lambda</span> (n) (/ n 2)) '(2 4 6))
</pre>
</div>

<div class="results" id="org1c561c0">
<p>
(1 2 3)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 58: </span>関数引数に渡すことができる</label><pre class="src src-lisp">(funcall (<span class="org-keyword">lambda</span> (n) (/ n 2)) 2)
</pre>
</div>

<div class="results" id="orga2999be">
<p>
1
</p>

</div>

<p>
lambdaの引数は評価されずlambdaに渡される。つまり、lambdaは本物の関数ではない。これはマクロとよばれる。<a href="20210911183844-lisp.html#ID-18fbe00f-4ec8-4ca0-adfa-2d1381669642">LISP</a>の関数の引数は、関数自体が評価される前にすべて評価される。
lambdaが返す値は通常のLisp関数である。
多くの言語では、関数と値の世界を分けようとしている。Lispでは、この2つの世界をつなぐことができる。
</p>

<p>
関数を普通のデータのように受け渡しできるという機能は、とても便利である。純粋に数学的な意味では、lambdaが唯一のLispコマンドといえる。(ラムダ算法…lambdaを唯一のコマンドする理論的なプログラミング言語のようなもの。)
</p>

<ul class="org-ul">
<li>lambda形式はLispシステムの中でもっとも根源的なコマンドである</li>
<li>Lispの他の関数はlambdaの概念を元に導かれている</li>
<li>lambdaはLispのアイディアそのものが産まれた中心にある概念</li>
</ul>
</div>
</div>
<div id="outline-container-org2fb44bd" class="outline-3">
<h3 id="org2fb44bd"><a href="#org2fb44bd">奇妙なリスト</a></h3>
<div class="outline-text-3" id="text-org2fb44bd">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 59: </span>通常のリスト</label><pre class="src src-lisp">(cons 1 (cons 2 (cons 3 nil)))
</pre>
</div>

<div class="results" id="org003aee1">
<p>
(1 2 3)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 60: </span>リストの最後のnilが見つからなかったとき、3の前に . をつけて表示する</label><pre class="src src-lisp">(cons 1 (cons 2 3))
</pre>
</div>

<div class="results" id="org5d05944">
<p>
(1 2 . 3)
</p>

</div>

<p>
最後がnilではないことを明示するために.をつけている。
ドットリストは、対を表現するのによく使う。
</p>

<p>
リストの最後がリストの最初を指すような、循環しているリストもある。
遊ぶ前に準備する。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 61: </span>ループで止まるのを防ぐ設定</label><pre class="src src-lisp">(setf *print-circle* t)
</pre>
</div>

<div class="results" id="orgb9b24d1">
<p>
T
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 62: </span>循環リストを作る</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">foo</span> (list 1 2 3))
(setf (cdddr foo) foo)
</pre>
</div>

<div class="results" id="orge769a4f">
<p>
#1=(1 2 3 . #1#)
</p>

</div>
</div>
</div>
<div id="outline-container-org0a2018b" class="outline-3">
<h3 id="org0a2018b"><a href="#org0a2018b">連想リスト</a></h3>
<div class="outline-text-3" id="text-org0a2018b">
<p>
コンスセルから作られるデータ構造の中でも特に便利なのは、連想リスト。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 63: </span>連想リストと、assocによるアクセス</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*drink-order*</span> '((bill . double-espresso)
                              (lisa . small-drip-coffee)
                              (john . medium-latter)))
(assoc 'lisa *drink-order*)
</pre>
</div>

<div class="results" id="org7f054d5">
<p>
(LISA . SMALL-DRIP-COFFEE)
</p>

</div>

<p>
追加。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 64: </span>追加。lisaが2つあることがわかる</label><pre class="src src-lisp">(push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
</pre>
</div>

<div class="results" id="org1ac82da">
<p>
((LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM) (BILL . DOUBLE-ESPRESSO)
 (LISA . SMALL-DRIP-COFFEE) (JOHN . MEDIUM-LATTER))
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 65: </span>assocで優先されるのは先にあるほうだから、新しい値に入れ替わったことになる</label><pre class="src src-lisp">(assoc 'lisa *drink-order*)
</pre>
</div>

<div class="results" id="org6bdc384">
<p>
(LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
</p>

</div>

<p>
そのため、データの変更履歴をたどることも可能。
</p>
</div>
</div>
<div id="outline-container-orgae955da" class="outline-3">
<h3 id="orgae955da"><a href="#orgae955da">ノードの変換</a></h3>
<div class="outline-text-3" id="text-orgae955da">
<p>
グラフ構造を視覚的に表現するために、graphvizを使う。
フォーマットを出力するための関数を書く。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 66: </span>DOTフォーマットが受け付けない文字(アルファベットでも数字でもない)をすべてアンダースコアに変更する</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">dot-name</span> (exp)
    (substitute-if #\_ (complement #'alphanumericp) (prin1-to-string exp)))
(dot-name 'foo!)
</pre>
</div>

<div class="results" id="org2dbd93c">
<p>
FOO_
</p>

</div>

<p>
substitute-ifは、与えられたテスト関数の結果によって値を置き換える関数。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 67: </span>数字をeに変換する</label><pre class="src src-lisp">(substitute-if #\e #'digit-char-p <span class="org-string">"I'm a l33t hack3r!"</span>)
</pre>
</div>

<div class="results" id="orge14f335">
<p>
I&rsquo;m a leet hacker!
</p>

</div>

<p>
substitute-ifは、リストも処理できる。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 68: </span>奇数を0に置き換える</label><pre class="src src-lisp">(substitute-if 0 #'oddp '(1 2 3 4 5 6 7 8 9))
</pre>
</div>

<div class="results" id="org82c5199">
<p>
(0 2 0 4 0 6 0 8 0)
</p>

</div>

<p>
グラフのノードにラベルをつける。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 69: </span>write-to-string のキーワード引数prettyは、人間用に改行などを整形してくれるのをオフにするため</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*max-label-length*</span> 30)

(<span class="org-keyword">defun</span> <span class="org-function-name">dot-label</span> (exp)
  (<span class="org-keyword">if</span> exp
      (<span class="org-keyword">let</span> ((s (write-to-string exp <span class="org-builtin">:pretty</span> nil)))
        (<span class="org-keyword">if</span> (&gt; (length s) *max-label-length*)
            (concatenate 'string (subseq s 0 (- *max-label-length* 3)) <span class="org-string">"..."</span>)
            s))
      <span class="org-string">""</span>))
</pre>
</div>

<div class="results" id="org94bfcd9">
<p>
DOT-LABEL
</p>

</div>

<p>
ノードのalistを取ってその情報をDOTの形で生成する関数を書く。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 70: </span>mapcはmapcarの変種で、結果のリストを返さない。ここではREPLで出力される情報だけが重要(副作用だけを使う)なため</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">nodes-&gt;dot</span> (nodes)
  (mapc (<span class="org-keyword">lambda</span> (node)
          (fresh-line)
          (princ (dot-name (car node)))
          (princ <span class="org-string">"[label=\""</span>)
          (princ (dot-label node))
          (princ <span class="org-string">"\"];"</span>))
        nodes))
</pre>
</div>

<div class="results" id="orgf271d85">
<p>
NODES-&gt;DOT
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 71: </span>変換したいalistを再定義しておく</label><pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*wizard-edges*</span> '((living-room (garden west door)
                         (attic upstairs ladder))
                        (garden (living-room east door))
                        (attic (living-room downstairs ladder))))

(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*wizard-nodes*</span> '((living-room (you are in the living-room.
                                      a wizard is snoring loudly on the couch.))
                        (garden (your are in a beautiful garden.
                                 there is a well in front of you.))
                        (attic (you are in the attic.
                                there is a giant welding torch in the corner.))))
</pre>
</div>

<div class="results" id="org18ab8fd">
<p>
<b>WIZARD-NODES</b>
</p>

</div>

<div class="org-src-container">
<pre class="src src-lisp">(nodes-&gt;dot *wizard-nodes*)
</pre>
</div>

<div class="results" id="org7daf94c">
<p>
LIVING_ROOM[label=&ldquo;(LIVING-ROOM (YOU ARE IN TH&#x2026;&rdquo;];
GARDEN[label=&ldquo;(GARDEN (YOUR ARE IN A BEAU&#x2026;&rdquo;];
ATTIC[label=&ldquo;(ATTIC (YOU ARE IN THE ATTI&#x2026;&rdquo;];
</p>

</div>

<p>
次は、エッジをDOTの情報として書き出す。
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">edges-&gt;dot</span> (edges)
  (mapc (<span class="org-keyword">lambda</span> (node)
          (mapc (<span class="org-keyword">lambda</span> (edge)
                  (fresh-line)
                  (princ (dot-name (car node)))
                  (princ <span class="org-string">"-&gt;"</span>)
                  (princ (dot-name (car edge)))
                  (princ <span class="org-string">"[label=\""</span>)
                  (princ (dot-label (cdr edge)))
                  (princ <span class="org-string">"\"];"</span>))
                (cdr node)))
        edges))
</pre>
</div>

<div class="results" id="orgcb100ea">
<p>
EDGES-&gt;DOT
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org1322efa" class="outline-2">
<h2 id="org1322efa"><a href="#org1322efa"><a href="https://www.amazon.co.jp/%E5%88%9D%E3%82%81%E3%81%A6%E3%81%AE%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AELISP-%E5%A2%97%E8%A3%9C%E6%94%B9%E8%A8%82%E7%89%88-%E7%AB%B9%E5%86%85-%E9%83%81%E9%9B%84/dp/4798119415/ref=pd_vtp_3/356-6212978-4622712">初めての人のためのLISP</a></a></h2>
<div class="outline-text-2" id="text-org1322efa">
</div>
<div id="outline-container-org8d5eaea" class="outline-3">
<h3 id="org8d5eaea"><a href="#org8d5eaea">_</a></h3>
<div class="outline-text-3" id="text-org8d5eaea">
<p>
Lispの考え方に焦点を当てた入門本。
解説で使われているのは<a href="20210926152425-common_lisp.html#ID-2337587f-0d95-484f-922a-f4cca1ace49e">Common Lisp</a>。
</p>
</div>
</div>

<div id="outline-container-orgf2dd636" class="outline-3">
<h3 id="orgf2dd636"><a href="#orgf2dd636">cond</a></h3>
<div class="outline-text-3" id="text-orgf2dd636">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 74: </span>condは条件式の処理に使う。</label><pre class="src src-lisp">(<span class="org-keyword">cond</span> ((&gt;= 1 1) (print 0))
      ((= 0 0) (print 1)))
</pre>
</div>

<pre class="example">
0
</pre>
</div>
</div>
<div id="outline-container-orgdd69e92" class="outline-3">
<h3 id="orgdd69e92"><a href="#orgdd69e92">member</a></h3>
<div class="outline-text-3" id="text-orgdd69e92">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 75: </span>member関数は、リストのトップレベルに望むものがあるか調べる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-member</span> (x y)
  (<span class="org-keyword">cond</span> ((null y) nil)
        ((eq x (car y)) t)
        (t (member x (cdr y)))))
(my-member 'a '(a b))
</pre>
</div>

<div class="results" id="org929b305">
<p>
T
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 76: </span>無い場合はnilを返す</label><pre class="src src-lisp">(my-member 'c '(a b))
</pre>
</div>

<div class="results" id="orgb3f1d47">
<p>
NIL
</p>

</div>
</div>
</div>
<div id="outline-container-org512cc51" class="outline-3">
<h3 id="org512cc51"><a href="#org512cc51">assoc</a></h3>
<div class="outline-text-3" id="text-org512cc51">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 77: </span>assoc関数は辞書を検索する</label><pre class="src src-lisp">(setq dict '((unum . 1) (duo . 2) (tria . 3)))
(assoc 'unum dict)
</pre>
</div>

<div class="results" id="orgefdd0e0">
<p>
(UNUM . 1)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 78: </span>assocの定義</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-assoc</span> (x y)
  (<span class="org-keyword">cond</span> ((null y) nil)
        ((eq x (caar y)) (car y))
        (t (assoc x (cdr y)))))
(my-assoc 'unum dict)
</pre>
</div>

<div class="results" id="org462aaa1">
<p>
(UNUM . 1)
</p>

</div>
</div>
</div>

<div id="outline-container-org44f9b92" class="outline-3">
<h3 id="org44f9b92"><a href="#org44f9b92">rassoc</a></h3>
<div class="outline-text-3" id="text-org44f9b92">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 79: </span>rassocは逆引き関数。辞書からcdrを検索する</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-rassoc</span> (x y)
  (<span class="org-keyword">cond</span> ((null y) nil)
        ((eq x (cdar y)) (car y))
        (t (rassoc x (cdr y)))))
(my-rassoc 1 dict)
</pre>
</div>

<div class="results" id="org6b6add1">
<p>
(UNUM . 1)
</p>

</div>

<p>
ドット記法で <code>(reiko . (3 712 5648))</code> は、
<code>(reiko 3 712 5678)</code> と同じ。後ろの方がリストになっているとドットは書かない慣習。
</p>

<p>
Lispにおける式は、題付きリストといえる。
(関数 引数1 引数2 &#x2026;)
は、関数と引数のリストとのドット対、
(関数 . 引数のリスト)
と考えることができる。
</p>
</div>
</div>
<div id="outline-container-org3ca7afe" class="outline-3">
<h3 id="org3ca7afe"><a href="#org3ca7afe">replaca</a></h3>
<div class="outline-text-3" id="text-org3ca7afe">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 80: </span>rplacaはxが指しているセルのcarをyに置き換える</label><pre class="src src-lisp">(rplaca '(1 1) 2)
</pre>
</div>

<div class="results" id="org9ce2c3b">
<p>
(2 1)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 81: </span>rplacdはcdrバージョン</label><pre class="src src-lisp">(rplacd '(1 1) 2)
</pre>
</div>

<div class="results" id="orgd8abcf0">
<p>
(1 . 2)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 82: </span>alistを書き換える関数</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">update-phone</span> (p x y)
    (rplacd (assoc x p) y)
    p  )

(setq dict '((unum . 1) (duo . 2) (tria . 3)))
(update-phone dict 'unum 111)
</pre>
</div>

<div class="results" id="orgd5a2e9d">
<p>
((UNUM . 111) (DUO . 2) (TRIA . 3))
</p>

</div>
</div>
</div>

<div id="outline-container-org2aed2f4" class="outline-3">
<h3 id="org2aed2f4"><a href="#org2aed2f4">remove</a></h3>
<div class="outline-text-3" id="text-org2aed2f4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 83: </span>xと等しいトップレベルの要素をすべて削除してみる</label><pre class="src src-lisp">  (<span class="org-keyword">defun</span> <span class="org-function-name">my-remove</span> (x y)
    (<span class="org-keyword">cond</span> ((null y) nil)
          ((eq (car y) x) (remove x (cdr y)))
          (t (cons (car y) (remove x (cdr y))))))
(my-remove 'mo '(to mo do mo mo to mo to mo))
</pre>
</div>

<div class="results" id="orgcf559f5">
<p>
(TO DO TO TO)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 84: </span>マッチした最初のリストを取り除く。書き換えるべきセルは、1つ前のセル。</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-delete-1</span> (x y)
  (setq y (cons 'dummy y))
  (my-del2 x (cdr y) y)
  (cdr y))

(<span class="org-keyword">defun</span> <span class="org-function-name">my-del2</span> (x y z)
  (<span class="org-keyword">cond</span> ((null y) nil)
        ((eq (car y) x) (rplacd z (cdr y)))
        (t (my-del2 x (cdr y) y))))
(my-delete-1 'mo '(mo mo mo to to to))
</pre>
</div>

<div class="results" id="org7be407d">
<p>
(MO MO TO TO TO)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 85: </span>再帰関数が取る変数を少なくしたバージョン</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-delete</span> (x y)
  (setq y (cons 'dummy y))
  (my-dela x y)
  (cdr y))

(<span class="org-keyword">defun</span> <span class="org-function-name">my-dela</span> (x y)
  (<span class="org-keyword">cond</span> ((null (cdr y)) nil)
        ((eq (cadr y) x)
         (rplacd y (cddr y))
         (my-dela x (cdr y)))
  (t (my-dela x (cdr y)))))

(my-delete 'mo '(mo to mo to))
</pre>
</div>

<div class="results" id="org15f5fc7">
<p>
(TO TO TO)
</p>

</div>
</div>
</div>
<div id="outline-container-org79a4e0a" class="outline-3">
<h3 id="org79a4e0a"><a href="#org79a4e0a">nreverse</a></h3>
<div class="outline-text-3" id="text-org79a4e0a">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 86: </span>nreverseはリストを逆にする関数</label><pre class="src src-lisp">(nreverse '(A B C))
</pre>
</div>

<div class="results" id="orgc6ceeca">
<p>
(C B A)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 87: </span>nreverseを定義する(バグ)</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-nreverse</span> (x)
  (nrev2 x nil))

(<span class="org-keyword">defun</span> <span class="org-function-name">nrev2</span> (x r)
  (<span class="org-keyword">cond</span> ((null x) r)
        (t (rplacd x r)
           (nrev2 (cdr x) x))))
(my-nreverse '(A B C))
</pre>
</div>

<div class="results" id="orgb71fbf0">
<p>
(A)
</p>

</div>

<p>
特殊形式prog1。
(prog1 式1 式2 式3 &#x2026;)
は返す値が式1の値。これを使って修正する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 88: </span>nrev2の修正版。prog1を使う</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">nrev2</span> (x r)
  (<span class="org-keyword">cond</span> ((null x) r)
        (t (<span class="org-keyword">prog1</span> (nrev2 (cdr x) x)
             (rplacd x r)))))
(my-nreverse '(A B C))
</pre>
</div>

<div class="results" id="orgd9b59a3">
<p>
(C B A)
</p>

</div>
</div>
</div>
<div id="outline-container-org9cfbfe8" class="outline-3">
<h3 id="org9cfbfe8"><a href="#org9cfbfe8">破壊的関数</a></h3>
<div class="outline-text-3" id="text-org9cfbfe8">
<p>
nreverseは破壊的。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 89: </span>返される値は逆になる</label><pre class="src src-lisp">(setq numl '(1 2 3))
(nreverse numl)
</pre>
</div>

<div class="results" id="org874bace">
<p>
(3 2 1)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 90: </span>元のリストは破壊される</label><pre class="src src-lisp">numl
</pre>
</div>

<div class="results" id="orgdd85d59">
<p>
(1)
</p>

</div>

<p>
破壊的関数にはsetqを使うとよい。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 91: </span>numlにnreverseした後の値が入っている</label><pre class="src src-lisp">(setq numl '(1 2 3))
(setq numl (nreverse numl))
numl
</pre>
</div>

<div class="results" id="org3123337">
<p>
(3 2 1)
</p>

</div>
</div>
</div>

<div id="outline-container-orge6ee9f6" class="outline-3">
<h3 id="orge6ee9f6"><a href="#orge6ee9f6">append, nconc</a></h3>
<div class="outline-text-3" id="text-orge6ee9f6">
<p>
appendの破壊版がnconc。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 92: </span>appendは非破壊</label><pre class="src src-lisp">(setq numl '(1 2 3))
(append numl 1)
numl
</pre>
</div>

<div class="results" id="orgec9d223">
<p>
(1 2 3)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 93: </span>nconcは破壊的</label><pre class="src src-lisp">(setq numl '(1 2 3))
(nconc numl 1)
numl
</pre>
</div>

<div class="results" id="org00892fb">
<p>
(1 2 3 . 1)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 94: </span>nconcを定義する。xに破壊的変更して、xを最後に返す</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-nconc</span> (x y)
  (<span class="org-keyword">cond</span> ((null x) y)
        (t (rplacd (last x) y) x)))
(my-nconc '(1 2 3) 1)
</pre>
</div>

<div class="results" id="org46370df">
<p>
(1 2 3 . 1)
</p>

</div>
</div>
</div>
<div id="outline-container-org5acd834" class="outline-3">
<h3 id="org5acd834"><a href="#org5acd834">last</a></h3>
<div class="outline-text-3" id="text-org5acd834">
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-last</span> (x)
  (<span class="org-keyword">cond</span> ((null x) nil)
        (t (my-last2 x))))

(<span class="org-keyword">defun</span> <span class="org-function-name">my-last2</span> (x)
  (<span class="org-keyword">cond</span> ((null (cdr x)) x)
        (t (my-last2 (cdr x)))))

(my-last '(1 2 3))
</pre>
</div>

<div class="results" id="orgcd51807">
<p>
(3)
</p>

</div>
</div>
</div>

<div id="outline-container-org58e8f2c" class="outline-3">
<h3 id="org58e8f2c"><a href="#org58e8f2c">subst</a></h3>
<div class="outline-text-3" id="text-org58e8f2c">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 96: </span>substはaをbに置き換える関数</label><pre class="src src-lisp">(subst 'a 'b '(a b (a b (b ba) nil a)))
</pre>
</div>

<div class="results" id="orgfdf9753">
<p>
(A A (A A (A BA) NIL A))
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 97: </span>substの定義</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-subst</span> (new old tree)
  (<span class="org-keyword">cond</span> ((eq old Tree) new)
        ((atom tree) tree)
        (t (cons (subst new old (car tree))
                 (subst new old (cdr tree))))))
(my-subst 'a 'b '(a b a b))
</pre>
</div>

<div class="results" id="org9322bf2">
<p>
(A A A A)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 98: </span>substではcarもcdrも平等に扱われているので、ドット記法が見える。</label><pre class="src src-lisp">(subst 'kk nil '(a b (b ba) nil a))
</pre>
</div>

<div class="results" id="orgd0e4fc1">
<p>
(A B (B BA . KK) KK A . KK)
</p>

</div>

<p>
consを使っているので、新しいリストを作っていることになる。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 99: </span>置き換える対象がなければ単にリストコピーになる</label><pre class="src src-lisp">(subst 'a 'b '(a a a))
</pre>
</div>

<div class="results" id="org318d3d4">
<p>
(A A A)
</p>

</div>

<p>
何もやらないときはcopy関数の定義と同じ。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 100: </span>cons部分に注目すると同じことがわかる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-copy</span> (tree)
  (<span class="org-keyword">cond</span> ((atom tree) tree)
        (t (cons (my-copy (car tree))
                 (my-copy (cdr tree))))))
(my-copy '(a a a))
</pre>
</div>

<div class="results" id="orgc4b08d2">
<p>
(A A A)
</p>

</div>

<p>
今風スタイルなsubst。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 101: </span>letと、同じであればコピーせずtreeをそのまま返すのが違い</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-subst</span> (new old tree)
  (<span class="org-keyword">cond</span> ((eq old tree) new)
        ((atom tree) tree)
        (t (<span class="org-keyword">let</span> ((a (my-subst new old (car tree)))
                 (d (my-subst new old (cdr tree))))
             (<span class="org-keyword">cond</span> ((and (eq a (car tree))
                         (eq d (cdr tree)))
                    tree)
                   (t (cons a d)))))))
(my-subst 'a 'b '(a b))
</pre>
</div>

<div class="results" id="org1da6eef">
<p>
(A A)
</p>

</div>

<p>
複数種類の置き換えをしたい。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 102: </span>sublistは置き換えのための辞書をalistでもらう</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-sublis</span> (alist tree)
  (<span class="org-keyword">let</span> ((pair (assoc tree alist)))
    (<span class="org-keyword">cond</span> (pair (cdr pair))
          ((atom tree) tree)
          (t (<span class="org-keyword">let</span> ((a (my-sublis alist (car tree)))
                   (d (my-sublis alist (cdr tree))))
               (<span class="org-keyword">cond</span> ((and (eq a (car tree))
                           (eq d (cdr Tree)))
                      tree)
                     (t (cons a d))))))))
(my-sublis '((unum . 1) (duo . 2) (tria . 3)) '(unum duo tria unum (unum tria)))
</pre>
</div>

<div class="results" id="orgfcc288f">
<p>
(1 2 3 1 (1 3))
</p>

</div>
</div>
</div>
<div id="outline-container-org7988be2" class="outline-3">
<h3 id="org7988be2"><a href="#org7988be2">defsubst</a></h3>
<div class="outline-text-3" id="text-org7988be2">
<p>
defsubstが使われるとき。
</p>

<p>
まずifを定義してみる(これはうまくいかない)。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 103: </span>返る値とxの値の違いに注目する。ifを呼ぶ時に引数を評価してしまう。なので副作用が実行されてxの値は7になる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-if</span> (p x y)
  (<span class="org-keyword">cond</span> (p x)
        (t y)))

(setq x 4)
(setq flag t)
(my-if flag (setq x (+ x 1)) (setq x (+ x 2))) <span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; 5</span>
x <span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; 7</span>
</pre>
</div>

<div class="results" id="org95911a7">
<p>
7
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 104: </span>defsubst。setqのように副作用のある式が引数に来ても、評価しない</label><pre class="src src-lisp">(<span class="org-keyword">defsubst</span> <span class="org-function-name">my-if</span> (p x y)
  (<span class="org-keyword">cond</span> (p x)
        (t y)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">(setq x 4)</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">(setq flag t)</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">(my-if flag (setq x (+ x 1)) (setq x (+ x 2)))</span>
</pre>
</div>

<p>
余剰変数: 変数が不定個の引数をリストに束ねて受け取ること。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 105: </span>&amp;restでlistが簡単に定義できる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-list</span> (<span class="org-type">&amp;rest</span> x) x)
(my-list 1 1)
</pre>
</div>

<div class="results" id="org95a7e5d">
<p>
(1 1)
</p>

</div>
</div>
</div>
<div id="outline-container-orgcfc81ec" class="outline-3">
<h3 id="orgcfc81ec"><a href="#orgcfc81ec">defmacro</a></h3>
<div class="outline-text-3" id="text-orgcfc81ec">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 106: </span>マクロは引数を評価しない</label><pre class="src src-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">my-first</span> (x)
  (list 'car x))
(my-first (list 1 2 3))
</pre>
</div>

<div class="results" id="org5707efc">
<p>
1
</p>

</div>

<p>
<code>(my-first (list 1 2 3))</code> は、
<code>(car (list 1 2 3))</code> に置き換わるように見える。
</p>

<p>
試しにdefunでやってみると、できない。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 107: </span>carが単なるシンボルになり(関数として評価されない)、リストになる</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-first</span> (x)
  (list 'car x))
(my-first '(1 2 3)) <span class="org-comment-delimiter">;; </span><span class="org-comment">'(car (1 2 3)) &#12392;&#21516;&#12376;</span>
</pre>
</div>

<div class="results" id="org9a2c150">
<p>
(CAR (1 2 3))
</p>

</div>

<p>
condをマクロ定義してみる。
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">my-cond</span> (<span class="org-type">&amp;rest</span> clauses)
  (expand-cond clauses))

(<span class="org-keyword">defun</span> <span class="org-function-name">expand-cond</span> (clauses)
  (my-cond ((null clauses) nil)
        ((eq (caar clauses) 't)
         (cons 'progn (cdar clauses)))
        (t (list 'if
                 (caar clauses)
                 (cons 'progn (cdar clauses))
                 (expand-cond (cdr clauses))))))
(my-cond (1 '(1))
         (t '(t)))
</pre>
</div>

<div class="results" id="org7b56398">
<p>
(1)
</p>

</div>

<p>
backquoteをつけると、quoteと違ってS式がコピーされる。
コピーの途中で、コンマのついた部分S式があるとそれを評価する。
これを用いてfirstの定義を書き直す。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 109: </span>バッククォートを使ったバージョンのfirst</label><pre class="src src-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">my-first</span> (x)
  `(car ,x))
(my-first '(1 2 3))
</pre>
</div>

<div class="results" id="orge2fbd6f">
<p>
1
</p>

</div>

<p>
よく見るパターンをマクロ化する。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 110: </span>よく見るやつ</label><pre class="src src-lisp">(<span class="org-keyword">cond</span> ((null &#12394;&#12435;&#12392;&#12363;) &#12393;&#12358;&#12377;&#12427;1)
      (t &#12393;&#12358;&#12377;&#12427;2))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">if-null</span> (nan dos1 dos2)
  `(<span class="org-keyword">cond</span> ((null ,nan) ,dos1)
         (t ,dos2)))
(<span class="org-keyword">defun</span> <span class="org-function-name">my-even</span> (x)
  (if-null (= (mod x 2) 1) t nil))
(my-even 2)
</pre>
</div>

<div class="results" id="org0016d82">
<p>
T
</p>

</div>
</div>
</div>
<div id="outline-container-org2bb7b32" class="outline-3">
<h3 id="org2bb7b32"><a href="#org2bb7b32">pop</a></h3>
<div class="outline-text-3" id="text-org2bb7b32">
<p>
よく使うマクロ2つ。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 112: </span>定義する</label><pre class="src src-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">my-pop</span> (x)
  `(<span class="org-keyword">prog1</span> (car ,x) (setq ,x (cdr ,x))))
(<span class="org-keyword">defmacro</span> <span class="org-function-name">my-push</span> (y x)
  `(setq ,x (cons ,y ,x)))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 113: </span>popを使ってみる</label><pre class="src src-lisp">(setq pop-test '(1 2 3))
(my-pop pop-test)
</pre>
</div>

<div class="results" id="org2d21fd3">
<p>
1
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 114: </span>破壊的</label><pre class="src src-lisp">pop-test
</pre>
</div>

<div class="results" id="org554b996">
<p>
(2 3)
</p>

</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">image</span> (var list <span class="org-type">&amp;rest</span> forms)
  `(<span class="org-keyword">let</span> (($list$ ,list)
         ($r$ nil)
         (,var nil))
    (<span class="org-keyword">while</span> ($list$ (nreverse $r$))
     (setq ,var (pop $list$))
     (push (<span class="org-keyword">progn</span> ,@forms) $r$))))
(image i (list 1 2 3 4) (* i i)) <span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; (1 4 9 16)&#12395;&#12394;&#12427;&#12399;&#12378;&#12384;&#12364;&#21205;&#12363;&#12394;&#12356;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">i &#12434;ruby&#12391;&#12356;&#12358;&#12502;&#12525;&#12483;&#12463;&#24341;&#25968;&#12392;&#12377;&#12427;&#12424;&#12358;&#12395;&#23450;&#32681;&#12377;&#12427;&#12510;&#12463;&#12525;</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">&#12371;&#12398;&#12424;&#12358;&#12395;&#12418;&#12392;&#12418;&#12392;&#12398;&#29305;&#27530;&#24418;&#24335;&#12392;&#21516;&#12376;&#12424;&#12358;&#12395;&#33258;&#30001;&#12395;&#23450;&#32681;&#12391;&#12365;&#12427;&#12398;&#12364;Lisp&#12425;&#12375;&#12373;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4d688bc" class="outline-3">
<h3 id="org4d688bc"><a href="#org4d688bc">文字列</a></h3>
<div class="outline-text-3" id="text-org4d688bc">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 115: </span>実体が異なるのでnilになる</label><pre class="src src-lisp">(eq <span class="org-string">"tide"</span> <span class="org-string">"tide"</span>)
</pre>
</div>

<div class="results" id="org30ed477">
<p>
NIL
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 116: </span>equalを使うと文字列で比較する</label><pre class="src src-lisp">(equal <span class="org-string">"tide"</span> <span class="org-string">"tide"</span>)
</pre>
</div>

<div class="results" id="orgeb612b5">
<p>
T
</p>

</div>
</div>
</div>

<div id="outline-container-org2c66d3b" class="outline-3">
<h3 id="org2c66d3b"><a href="#org2c66d3b">alist</a></h3>
<div class="outline-text-3" id="text-org2c66d3b">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 117: </span>alistにアクセスするgetの実装</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-get</span> (symbol property)
  (<span class="org-keyword">let</span> ((plist (symbol-plist symbol)))
    (<span class="org-keyword">loop</span> (until (null plist) nil)
       (until (eq (car plist) property) (cadr plist))
       (setq plist (cddr plist)))))
</pre>
</div>

<div class="results" id="orgebdf211">
<p>
MY-GET
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 118: </span>putpropの実装</label><pre class="src src-lisp">(putprop 'foo
         (cons (symbol-function 'foo)
               (get 'foo 'old-definition))
         'old-definition)
</pre>
</div>

<p>
lambdaはdefunのように関数を定義する特殊形式ではない。
lambdaはcarにあるリストが関数実体を示す単なる標識。
defunとは、関数実体に名前をつける関数といえる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 119: </span>applyは関数(ラムダ式でも名前付きでもよい)に引数を与えて評価する</label><pre class="src src-lisp">(apply (<span class="org-keyword">lambda</span> (x y) (+ (* x x) (* y y))) (list 3 4))
</pre>
</div>

<div class="results" id="org99a4b7d">
<p>
25
</p>

</div>

<p>
簡単な例。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 120: </span>リストの合計を求める。第2引数はリスト</label><pre class="src src-lisp">(apply '+ '(1 2 3 4))
</pre>
</div>

<div class="results" id="org027b31f">
<p>
10
</p>

</div>

<p>
funcallで書く。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 121: </span>リストの合計を求める。第2引数は任意の数</label><pre class="src src-lisp">(funcall '+ 1 2 3 4)
</pre>
</div>

<div class="results" id="orgc6854d1">
<p>
10
</p>

</div>
</div>
</div>
<div id="outline-container-org288c400" class="outline-3">
<h3 id="org288c400"><a href="#org288c400">mapcar</a></h3>
<div class="outline-text-3" id="text-org288c400">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 122: </span>mapcarの定義</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-mapcar</span> (fn mlist)
  (<span class="org-keyword">cond</span> ((null mlist) nil)
        (t (cons (funcall fn (car mlist))
                 (mapcar fn (cdr mlist))))))
(my-mapcar #'sqrt '(1 2 3))
</pre>
</div>

<div class="results" id="orgca7ac99">
<p>
(1 1.4142135 1.7320508)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 123: </span>maplistの定義</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-maplist</span> (fn mlist)
  (<span class="org-keyword">cond</span> ((null mlist) nil)
        (t (cons (funcall fn mlist) <span class="org-comment-delimiter">;; </span><span class="org-comment">mapcar &#12392;&#12398;&#36949;&#12356;&#12399;&#12371;&#12371;&#12384;&#12369;&#12290;car&#12391;&#12399;&#12394;&#12367;&#12522;&#12473;&#12488;&#12395;&#23550;&#12375;&#12390;fn&#12434;apply&#12377;&#12427;</span>
                 (maplist fn (cdr mlist))))))
(my-maplist #'append '(1 2 3))
</pre>
</div>

<div class="results" id="org3d6fe1b">
<p>
((1 2 3) (2 3) (3))
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 124: </span>maplistの例。各要素の累計を得るとき</label><pre class="src src-lisp">(reverse
 (my-maplist (<span class="org-keyword">lambda</span> (x) (apply #'+ x))
             (reverse '(10 5 6 12 3 5 9 7 0 4 2 15))))
</pre>
</div>

<div class="results" id="org2e94c09">
<p>
(10 15 21 33 36 41 50 57 57 61 63 78)
</p>

</div>
</div>
</div>
<div id="outline-container-orgd9e3da2" class="outline-3">
<h3 id="orgd9e3da2"><a href="#orgd9e3da2">sort</a></h3>
<div class="outline-text-3" id="text-orgd9e3da2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 125: </span>無名関数で順序を指定してソートする</label><pre class="src src-lisp">(setq monthly-sales
      '((Jan . 10) (Feb . 5) (Mar . 6) (Apr . 12) (May . 3)(Jun . 5) (Jul . 9) (Aug . 7) (Sep . 0) (Oct . 4)(Nov . 2) (Dec . 15)))
(sort monthly-sales #'(<span class="org-keyword">lambda</span> (x y) (&gt; (cdr x) (cdr y))))
</pre>
</div>

<div class="results" id="org7a5ceed">
<p>
((DEC . 15) (APR . 12) (JAN . 10) (JUL . 9) (AUG . 7) (MAR . 6) (FEB . 5)
 (JUN . 5) (OCT . 4) (MAY . 3) (NOV . 2) (SEP . 0))
</p>

</div>
</div>
</div>
<div id="outline-container-org1c6922a" class="outline-3">
<h3 id="org1c6922a"><a href="#org1c6922a">eval</a></h3>
<div class="outline-text-3" id="text-org1c6922a">
<p>
evalを実装することで理解する。
スコープあたりの核となる部分を実装しているのだが、よくわからない。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 126: </span>eval</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">eval</span> (form)
  (<span class="org-keyword">cond</span>
    ((or (null form) (numberp form) (stringp form)) form) <span class="org-comment">; nil, &#25968;, &#25991;&#23383;&#21015;&#12398;&#20516;&#12399;&#12381;&#12428;&#33258;&#36523;</span>
    ((symbolp form) (variable-value form)) <span class="org-comment">; &#12471;&#12531;&#12508;&#12523;&#12399;&#22793;&#25968;&#12392;&#35299;&#37320;&#12373;&#12428;&#12427;</span>
    ((member (car form)
             '(quote cond setq prog progn prog1 prog2 go let let* if do do* defun defmacro function ...))
     (eval-special-form form)) <span class="org-comment">; &#29305;&#27530;&#24418;&#24335;&#12398;&#20966;&#29702;(&#12371;&#12371;&#12363;&#12425;&#20808;&#12399;&#12475;&#12523;&#12392;&#12431;&#12363;&#12387;&#12390;&#12356;&#12427;)</span>
    ((and (consp (car Form)) <span class="org-comment">; &#12521;&#12512;&#12480;&#24335;</span>
          (eq (caar form) 'lambda))
     (apply (car form) (evlis (cdr form))))
    ((function-symbol-p (car form)  <span class="org-comment">; &#38306;&#25968;&#12471;&#12531;&#12508;&#12523;</span>
                        (evlis (cdr form))))
    ((macro-symbol-p (car form)) <span class="org-comment">; &#12510;&#12463;&#12525;&#21628;&#12403;&#20986;&#12375;&#12290;&#12383;&#12384;&#12375;backquote&#12395;&#12399;&#26410;&#23550;&#24540;</span>
     (eval (apply (macro-function (car form)) (cdr form))))
    (t (<span class="org-warning">error</span> 'concat-evaluate form))))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 127: </span>evlis</label><pre class="src src-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">&#24341;&#25968;&#12434;&#38918;&#27425;&#35413;&#20385;&#12375;&#12390;&#12522;&#12473;&#12488;&#12395;&#12377;&#12427;(&#23455;&#38555;&#12399;&#12522;&#12473;&#12488;&#12434;&#20316;&#12425;&#12378;&#12473;&#12479;&#12483;&#12463;&#12395;&#31309;&#12416; ??)</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">evlis</span> (args)
  (<span class="org-keyword">cond</span> ((null args) nil)
        (t (cons (eval (car args)) (evlis (cdr args))))))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 128: </span>特殊形式の評価</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">eval-special-form</span> (form)
  (<span class="org-keyword">cond</span> ((eq (car form) 'quote) (cadr form))
        ((eq (car form 'cond) (evcon (cdr form))))
        ((eq (car form) 'setq') ...)
        ((eq (car form) 'progn) (evprogn (cdr form)))))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 129: </span>cond式の評価</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">evcon</span> (clauses)
  (<span class="org-keyword">cond</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">&#12418;&#12358;cond&#31680;&#12364;&#27531;&#12387;&#12390;&#12394;&#12369;&#12428;&#12400;nil&#12434;&#36820;&#12377;</span>
    ((null clauses) nil)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">&#36848;&#35486;&#12364;&#30495;&#12391;&#12354;&#12428;&#12400;&#12289;&#24112;&#32080;&#12398;&#26263;&#40665;&#12398;progn&#12434;&#38918;&#27425;&#35413;&#20385;&#12377;&#12427;</span>
    ((eval (caar clauses))
     (evprogn (cdr clauses)))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">&#27425;&#12398;cond&#31680;&#12434;&#35519;&#12409;&#12427;</span>
    (t (evcon (cdr clauses)))))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 130: </span>prognの評価</label><pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">evprogn</span> (forms)
  (<span class="org-keyword">cond</span>
    ((null forms) nil)
    ((null (cdr forms)) (eval (car forms)))
    (t (eval (car forms)) (evprogn (cdr forms)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb53e53d" class="outline-3">
<h3 id="orgb53e53d"><a href="#orgb53e53d">キーワード</a></h3>
<div class="outline-text-3" id="text-orgb53e53d">
<p>
Common Lispでは名前空間のことをシンボル・パッケージあるいは単にパッケージと呼ぶ。シンボルはどれかのパッケージに属する。
Common Lispで標準的に用意されているのはlisp, user, keyword, systemの4つ。
</p>

<p>
carと使うときは、実際にはlisp:carとしている。文脈によって自動で決定されるので毎回lisp:を打つ必要はない。
</p>

<p>
キーワード引数は名前空間のうち、keywordを使う。特別扱いされ、keyword: が :だけに省略できる。
なので keyword:direction と:direction は同じ意味である。キーワードを評価すると、つねにそれ自身を値として返すので、quoteする必要がない。
</p>
</div>
</div>
</div>
<div id="outline-container-org63d6fdf" class="outline-2">
<h2 id="org63d6fdf"><a href="#org63d6fdf">Tasks</a></h2>
<div class="outline-text-2" id="text-org63d6fdf">
</div>
<div id="outline-container-org183c6ef" class="outline-3">
<h3 id="org183c6ef"><a href="#org183c6ef"><a href="https://www.cs.cmu.edu/~dst/LispBook/book.pdf">COMMONLISP: A Gentle Introduction to Symbolic Computation</a></a></h3>
<div class="outline-text-3" id="text-org183c6ef">
<p>
わかりやすい入門。
</p>
</div>
</div>
<div id="outline-container-org7b5674b" class="outline-3">
<h3 id="org7b5674b"><a href="#org7b5674b"><span class="todo TODO">TODO</span> <a href="http://lyrical.bugyo.tk/">魔法言語 リリカル☆Lisp</a></a></h3>
<div class="outline-text-3" id="text-org7b5674b">
<p>
nscripterと萌えキャラでLispが学べる…。
</p>
</div>
</div>
<div id="outline-container-orgf2583a1" class="outline-3">
<h3 id="orgf2583a1"><a href="#orgf2583a1"><a href="https://lispcookbook.github.io/cl-cookbook/">Common Lisp Cookbook Home</a></a></h3>
</div>
<div id="outline-container-org75ca51b" class="outline-3">
<h3 id="org75ca51b"><a href="#org75ca51b"><a href="https://gigamonkeys.com/book/">Practical Common Lisp</a></a></h3>
</div>
<div id="outline-container-orgcb22149" class="outline-3">
<h3 id="orgcb22149"><a href="#orgcb22149"><span class="todo TODO">TODO</span> 実用 Common Lisp</a></h3>
<div class="outline-text-3" id="text-orgcb22149">
<ul class="org-ul">
<li><a href="https://www.amazon.co.jp/Common-Lisp-Architects%E2%80%99Archive-CLASSIC-MODER/dp/4798118907/">実用 Common Lisp (IT Architects’Archive CLASSIC MODER)</a></li>
<li><a href="https://github.com/norvig/paip-lisp">norvig/paip-lisp</a> - サンプルスクリプト</li>
</ul>
</div>
</div>
<div id="outline-container-org2da9748" class="outline-3">
<h3 id="org2da9748"><a href="#org2da9748"><span class="todo TODO">TODO</span> Common Lisp Quick Reference</a></h3>
</div>
</div>
<div id="outline-container-org337077b" class="outline-2">
<h2 id="org337077b"><a href="#org337077b">Reference</a></h2>
<div class="outline-text-2" id="text-org337077b">
</div>
<div id="outline-container-org7c04967" class="outline-3">
<h3 id="org7c04967"><a href="#org7c04967"><a href="https://lisphub.jp/common-lisp/cookbook/index.cgi">逆引き Common Lisp クックブック:逆引きCommon Lisp</a></a></h3>
<div class="outline-text-3" id="text-org7c04967">
<p>
リファレンス。
</p>
</div>
</div>
</div>
<div id="outline-container-orgaec331d" class="outline-2">
<h2 id="orgaec331d"><a href="#orgaec331d">Archives</a></h2>
<div class="outline-text-2" id="text-orgaec331d">
</div>
<div id="outline-container-org8dc6b8d" class="outline-3">
<h3 id="org8dc6b8d"><a href="#org8dc6b8d"><span class="done DONE">DONE</span> Road to Common Lisp</a></h3>
<div class="outline-text-3" id="text-org8dc6b8d">
<p>
Lispの学び方、おすすめ本の紹介。
</p>
<ul class="org-ul">
<li><a href="https://gist.github.com/y2q-actionman/49d7587912b2786eb68643afde6ca192">A Road to Common Lisp 翻訳</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"/>
</div>
</body>
</html>
