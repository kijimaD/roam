#+title: Emacs Lisp

* arielコードメモ

http://dev.ariel-networks.com/articles/workshop/emacs-lisp-basic/
の元の内容に、たまにコメントをつけて読んでいったものです。
- 実装を見ている
- わかりやすい例
** ring

データ型定義のやり方。型述語の実装。
https://github.com/kijimaD/emacs/blob/master/lisp/emacs-lisp/ring.el#L47

** eww

https://github.com/kijimaD/emacs/blob/master/lisp/net/eww.el#L1

** lisp.h

lispシンボルの実装。
https://github.com/kijimaD/emacs/blob/master/src/lisp.h#L798

#+begin_src emacs-lisp
(type-of 42)
=>integer
(type-of 3.14)
=> float
(type-of "foo")
=> string
(type-of '(1 2))
=> cons
(type-of '[1 2])
=> vector
(type-of 'foo)
=> symbol
(type-of ?a)  ; Cの'a'相当。内部的には数値
=> integer
#+end_src

** 中で起こってること

~(setq foo "FOO")~ したとき、symbolオブジェクトは以下のようにセットされます。
#+begin_src c
// lisp.h
struct Lisp_Symbol
  {
    struct Lisp_String *name;  => "foo"
    Lisp_Object value;  => "FOO"の値を持つ文字列オブジェクトを指す
    Lisp_Object function;  => 空
    略
  };
#+end_src

↑のように作られているオブジェクトを関数で調べてみます。

#+begin_src emacs-lisp
(symbolp 'foo)    ; シンボルか否かの判定。tが真。nilが偽。(後述)
=> t
(symbol-name 'foo)
=> "foo"
(symbol-value 'foo)
=> "FOO"
(boundp 'foo)   ; 値セルに値があればt、なければnil
=> t
(fboundp 'foo)  ; 関数セルに関数があればt、なければnil
=> nil
(symbol-function 'foo)
; まだ設定していないので、今はエラー
#+end_src

** クォートの意味

#+begin_quote
クォートは「評価しない」ことを指示します。クォートしないと、基本的に評価されてしまいます。
#+end_quote

#+begin_src emacs-lisp
(type-of 'foo)
=> symbol
(type-of foo)
=> string   ; 評価後、つまり値セルの指すオブジェクトの型が出力されます
#+end_src

~'~ は ~quote~ 関数の略記です。

** シンボルのまとめ

#+begin_quote
ここまでで分かったこと

シンボルは名前を持つ (symbol-name関数で確認可能)
シンボルの値セルは任意のオブジェクトを指す (symbol-value関数で確認可能)
シンボルの指すオブジェクトの型はtype-ofで確認可能
#+end_quote

** コンスセルの表記

#+begin_quote
コンスセルとはふたつのポインタ(*)を持ったオブジェクトです。
#+end_quote
実装
https://github.com/kijimaD/emacs/blob/master/src/lisp.h#L1350

#+begin_src c
struct Lisp_Cons
{
  union
  {
    struct
    {
      /* Car of this cons cell.  */
      Lisp_Object car;

      union
      {
    /* Cdr of this cons cell.  */
    Lisp_Object cdr;

    /* Used to chain conses on a free list.  */
    struct Lisp_Cons *chain;
      } u;
    } s;
    GCALIGNED_UNION_MEMBER
  } u;
};
#+end_src
サイトのときとはコードが変わっているようです。
- ~union~ って何だろう。
- 2つのポインタ…elispではcarとcdr

#+begin_quote
後述するように、コンスセルのcdrが別のコンスセルを指すことで、リスト構造を作ります。コンスセルで作るリスト処理こそがLisp(LISt Processing)の名前の由来でもあります。
#+end_quote

** コンスセルの表記

~("foo" . "bar")~
これは内部的に↓
#+begin_src c
struct Lisp_Cons
  {
    Lisp_Object car;  => "foo"文字列オブジェクトを指す
    Lisp_Object cdr;  => "bar"文字列オブジェクトを指す
  };
#+end_src

オブジェクトが2つ組み合わされたもの。

** コンスセルの生成

#+begin_src emacs-lisp
(cons "foo" "bar")
=> ("foo" . "bar")
#+end_src

- consはconstructの略。

** コンスセルの値

コンスセルの値にアクセスするには ~car~ と ~cdr~ だけ使える。getterメソッドみたいなもの。

#+begin_quote
car、cdr以外にコンスセルの中を参照する手段はありません。
#+end_quote

なるほど。

#+begin_src emacs-lisp
(car '("foo" . "bar"))
=> "foo"
(cdr '("foo" . "bar"))
=> "bar"
#+end_src

#+begin_quote
Java風に言えば、コンスセルはふたつのprivateフィールドとふたつのアクセサを持つだけの軽いオブジェクトです。
#+end_quote

** プログラム自体がオブジェクト

#+begin_quote
厳密に言えば、("foo" . "bar") という文字列は、コンスセルの(Java風に言えば)シリアライズ化した表現です。
後述するように、elispのプログラム自体はリスト表現で書きます。
これの意味することは、プログラム自体がオブジェクトであり、ソースコードはオブジェクトをシリアライズ化しただけの文字列と言えます。
#+end_quote

- シリアライズ化?
- データとプログラムの区別がない…真髄的なところだということはわかる。

** なんでもオブジェクト

#+begin_src emacs-lisp
(setq foo '("foo" . 42))  ; carに文字列、cdrに数値のコンスセルを指すシンボルfoo
=> ("foo" . 42)
(setq bar '(foo . foo))   ; quoteは全体に効いているので、carとcdrの両方がシンボルfoo
=> (foo . foo)
(symbol-value (car bar))
=> ("foo" . 42)
(symbol-value (cdr bar))
=> ("foo" . 42)
(setq bar `(,foo . foo))  ; backquoteの例
=> (("foo" . 42) . foo)   ; ,のついたオブジェクトは評価。そうでないオブジェクトは未評価
#+end_src

bar -> foo -> "foo" -> 42

シンボルを評価すると、値セルを返します。
** cdrが別のコンスセル

#+begin_src emacs-lisp
(cons "foo" '("bar" . "baz"))
=> ("foo" "bar" . "baz")
#+end_src

~("foo" . "bar" "baz")~ とはならない

#+begin_src emacs-lisp
'("foo" . ("bar" . "baz"))
;; => ("foo" "bar" . "baz")
#+end_src

** リスト化

最期のcdrをnilにするとリストに。
#+begin_src emacs-lisp
(cons "foo" '("bar" . nil))
;; => ("foo" "bar")
#+end_src

nilじゃないとコンスセルになる(前の節の通り)。
#+begin_src emacs-lisp
(cons "foo" '("bar" . "aaa"))
("foo" "bar" . "aaa")
#+end_src

** リスト操作

#+begin_src emacs-lisp
(car '("foo" "bar" "baz"))
=> "foo"
(cdr '("foo" "bar" "baz"))
=> ("bar" "baz")
(cdr (cdr '("foo" "bar" "baz")))
=> ("baz")    ; dotted pair notationで書けば ("baz" . nil)
(cdr (cdr (cdr '("foo" "bar" "baz"))))
=> nil
#+end_src

面倒だけど、リストの操作が行えることがわかります。

#+begin_src emacs-lisp
(setq foo "a")
(setq foo (cons "value" foo))   ; リストfooに要素をprepend
;; => ("value" . "a")
(setq foo (cons "value" foo))   ; さらにprepend
;; => ("value" "value" . "a")
(setq load-path (cons (expand-file-name "~/elisp") load-path))

(list "foo" "bar" "baz")  ; 引数を要素に持つリストを生成
=> ("foo" "bar" "baz")

(append '("foo" "bar") '("baz"))  ; 連接したリストを生成
=> ("foo" "bar" "baz")
(setq load-path (append load-path (list (expand-file-name "~/elisp"))))

(car (nthcdr 1 '("foo" "bar" "baz")))   ; N番目の要素の取得
=> "bar"
#+end_src

** 評価
#+begin_quote
コンスセルの評価は次のように行います。

リストの先頭要素(先頭のコンスセルのcar)のシンボルの関数セルの指す関数呼び出し
リストの後続要素(先頭以外のコンスセルのcar)を関数の引数として渡す。引数はquoteがなければ、評価してから引数に渡ります
リストの後続要素は、リストであるかもしれません。この場合、内側のリストを評価、つまり関数呼び出しをしてから、外側のリストの関数呼び出しをします(前ページで既にやっていますが)。
#+end_quote

- コンスセルとリストの違い。コンスセルは ~( . )~ で、最後のcdrがnilでないもの。
- リストは最後のcdrがnilのもの。
- ~(append '("foo" "bar") '("baz"))~ の例.
  1. リストの先頭要素 ~append~ の関数セルの指す関数を呼び出す。
  2. リストの後続要素 ~'("foo" "bar") '("baz")~ が引数として呼び出される。quoteがあるので評価されない。リストのときは評価=関数呼び出しを1.と同様に内側→外側の順に行う。

#+begin_src emacs-lisp
(defun plus1 (n)
  (+ n 1))
=> plus1
(plus1 10)
=> 11
(defun my-plus (m n)
  (+ m n))
=> my-plus
(my-plus 2 5)
=> 7
#+end_src

#+begin_quote
関数の戻り値(=関数の評価結果)は、関数本体の最後の評価結果です
#+end_quote

なるほど。
** 関数に名前はない

#+begin_quote
defunを見て、関数に名前があると思うのは間違いです。

defunは、シンボルを作って、その関数セルが関数定義を指すようにしています。
#+end_quote

シンボルの定義を思い返してみます。

#+begin_src c
// lisp.h
struct Lisp_Symbol
  {
    struct Lisp_String *name;  => "foo"
    Lisp_Object value;  => "FOO"の値を持つ文字列オブジェクトを指す
    Lisp_Object function;  => 空
    略
  };
#+end_src

確かに関数定義を指しています。

#+begin_src emacs-lisp
(defun foo () (message "a"))
(symbolp 'foo)
=> t
(symbol-name 'foo)
=> "foo"
(symbol-value 'foo)
=> error: (void-variable foo)
(symbol-function 'foo)
=> (lambda nil (message "a"))
(boundp 'foo)
=> nil
(fboundp 'foo) ; 関数定義
=> t
#+end_src

** 既存関数も同じ
どれもシンボルで、関数定義を指しています
#+begin_src emacs-lisp
(symbol-function 'car)
=> #<subr car>
(symbol-function 'defun)
=> #<subr defun>
(symbol-function '+)
=> #<subr +>
#+end_src

#+begin_quote
subr(subroutineの略)は、Cで書かれた関数を意味しています。

構造(シンボルcarやシンボルdefunがあり、それらの関数セルが関数定義を指す)は同じです。
#+end_quote

subrそうだったのか。 ~#<>~ はどういう意味なのだろう。

** fset
#+begin_quote
値セルにsetqやsetがあったように、関数セルにはfsetがあります(fsetqはありません)。
#+end_quote

#+begin_src emacs-lisp
(fset 'my-plus2
  '(lambda (n) (+ n 2)))   ; defunと同じ
=> (lambda (n) (+ n 2))
(my-plus2 10)
=> 12
#+end_src

関数セルと値セルを確認します。

#+begin_src emacs-lisp
(setq foo "foo")
=> "foo"
(fset 'foo '(lambda (s) (concat s "bar"))) ; 名前とリストの組み合わせ。どちらも未評価で渡す。
=> (lambda (s) (concat s "bar"))
(foo foo)
=> "foobar"
#+end_src

** lambda

https://github.com/kijimaD/emacs/blob/master/lisp/subr.el#L106

#+begin_src emacs-lisp
(lambda (引数 ...) (関数本体))
#+end_src

処理の中身。名前と組み合わせると関数になります。

#+begin_src emacs-lisp
((lambda (m n) (+ m n)) 2 5)
=> 7
#+end_src

関数定義。declare(...関数やマクロに関する情報、infoで出てくる文章)の箇所を除くとこれだけです。
引数cdr(処理したい内容)でコンスセルを作って、関数セルと組み合わせてリストを作ります。なので名前はありません。
#+begin_src emacs-lisp
(defmacro lambda (&rest cdr)
  (list 'function (cons 'lambda cdr)))
#+end_src

** 関数とは何か

述語関数から見てます。この方法いいですね。

#+begin_src emacs-lisp
; subr.el
(defun functionp (object)
  "Non-nil if OBJECT is a type of object that can be called as a function."
  (or (subrp object) (byte-code-function-p object)
      (eq (car-safe object) 'lambda)
      (and (symbolp object) (fboundp object))))
#+end_src

#+begin_quote
elispにとって、「関数」とは次の4つのいずれかであることが分かります。

- subroutine (Cで書かれた関数)
- バイトコンパイルされた関数 (今はあまり気にしないように)
- シンボルlambdaで始まるリスト
- 関数セルが空ではないシンボル
#+end_quote

** 関数呼び出し

#+begin_quote
リストの先頭要素に「関数」があれば、関数呼び出しになります。
#+end_quote

リストがすべてに優先して存在します。

#+begin_src emacs-lisp
(my-plus 1 3)   ; シンボルであれば関数セルの指す関数を呼び出す
=> 4
((lambda (m n) (+ m n)) 1 3)   ; シンボルlambdaで始まるリストも「関数」
=> 4
#+end_src

** funcall
#+begin_quote
funcall関数は引数の1番目を関数として呼びます。
#+end_quote

#+begin_src emacs-lisp
(funcall 'my-plus 1 3)
=> 4
(funcall '(lambda (m n) (+ m n)) 1 3)
=> 4
#+end_src

- ~'(lambda (m n) (+ m n))~ は関数として呼ばれる。
~- (lambda (m n) (+ m n))~ でもいいみたい。

違いは何だっけ。... 評価して渡されるかどうか。この場合は関数なので、評価されるのがいつでも結果は変わらない。

#+begin_src emacs-lisp
(funcall '(lambda () (+ 1 2)))
(if (eq 1 (+ 1)) 1) ; 1
(if (eq 1 '(+ 1)) 1) ; nil

(+ (+ 1) 1) ; 2
(+ '(+ 1) 1) ; (wrong-type-argument number-or-marker-p (+ 1))
#+end_src

** 値セルにlambda

つまり、値を関数でも呼び出せます。

#+begin_src emacs-lisp
(setq foo '(lambda (m n) (+ m n)))
=> (lambda (m n) (+ m n))
(funcall foo 2 5)
=> 7
#+end_src

なるほど…。

** 明示的に空にする

#+begin_quote
(makunbound 'foo)   ;値セルを空にする
=> foo
(fmakunbound 'foo)  ;関数セルを空にする
=> foo
#+end_quote

** 連想リスト(association list)

#+begin_src emacs-lisp
'(("foo" . "FOO") ("bar" . "BAR") ("baz" . "BAZ"))
#+end_src

リストの要素がコンスセル。

** 配列

#+begin_quote
配列は次の4つに分類できます。

- ベクタ
- 文字列
- 文字テーブル
- ブールベクタ
#+end_quote

#+begin_quote
言語仕様として「配列」があると言うより、次のarrayp述語で「配列」型(基本型では無い)が定義されているようなものです。
#+end_quote

#+begin_src c
// data.c
DEFUN ("arrayp", Farrayp, Sarrayp, 1, 1, 0, "Return t if OBJECT is an array (string or vector).")
  (object)
     Lisp_Object object;
{
  if (VECTORP (object) || STRINGP (object)
      || CHAR_TABLE_P (object) || BOOL_VECTOR_P (object))
    return Qt;
  return Qnil;
}
#+end_src

ベクタ/文字/文字テーブル/ブールベクタであればarray。なんだそりゃ？

#+begin_src emacs-lisp
(arrayp '(1 2)) ; nil
(arrayp "aaa")  ; t
#+end_src

** ベクタ

#+begin_src emacs-lisp
[1 3 5]
=> [1 3 5]
(vectorp [1 3 5])
=> t
(setq foo [1 3 5])    ; quoteしてもしなくても同じ
=> [1 3 5]
(vectorp foo)
=> t
#+end_src

** ベクタの操作

#+begin_src emacs-lisp

#+end_src
** 元ページ再掲
http://dev.ariel-networks.com/articles/workshop/emacs-lisp-basic/
* リスト遊び
** リスト
- リストを構成するセルのCDRはm，セルかnilを指している。
しかしポイントはなんでも指せるので、CDRはアトム(整数とか)も参照できる。
CARが1, CDRが2のセルは、表記方法では表現できない。
これを表現するために、ドット対表記が用意されている。
#+begin_src emacs-lisp
(cons 1 (cons 2 nil))
=> (1 2)

(cons 1 2)
=> (1 . 2)
#+end_src

nilで終端しないセルはドット対で表記する。
この方法で表現すると、
(1) => (1. nil)
(1 2 3) => (1 . (2 . (3. nil)))
みたいになる。ドット対は連想リストで用いられる。
** Lispのデータ
- セル(1対のポインタ。consで作られる。CARとCDRが指しているポインタが指すデータを見るには、carとcdrを用いる)
- アトム(セル以外。整数とか)
** Lispの評価
- 式がセルなら関数を呼び出す。第1要素のシンボルの指す関数を実行する。引数は評価する。
- 式がアトムならその値を返す。
** quote
クオートをつけると評価せずそのまま返す。

#+begin_src emacs-lisp
(quote (1 2))
=> (1 2)

同じ意味:
'(1 2)

(setq dog 5)
dog
=> 5   ; 評価結果
'dog
=> dog ; シンボル自身を表現する
#+end_src

(setq dog "dog")
はシンボルdog(評価しない)に、"dog"を入れるということ。
** ポインタ
変数から変数への代入は、ポインタを複製するということ。

#+begin_src emacs-lisp
(setq x 'dog)
(setq y 'dog)
(eq x y)
=> t
(setq z y)
(eq y z)
=> t
#+end_src

#+begin_src emacs-lisp
(setq x "dog")
(setq y "dog")
(eq x y)
=> nil ; 同じ中身の文字列だが、指しているポインタが異なるため。
(setq z y)
(eq y z)
=> t   ; 指しているポインタが同じため
#+end_src

変数はポインタを格納する箱。
* On Lisp
** もう一つの関数定義

#+begin_src emacs-lisp
(defun double (x) (* x 2))
#'double ; 関数オブジェクトを得る

#'(lambda (x) (* x 2))
#+end_src

#+begin_quote
名前が関数呼び出しの先頭かシャープクォートの次に来ると関数への参照と見
なされ， それ以外では変数名と見なされる．
#+end_quote
なので(double double)とかも可能。変数と関数の名前空間が異なっている。

- 関数は普通のデータオブジェクト。なので変数が値として関数を持てる。

#+begin_src emacs-lisp
(setq x #'append)
#+end_src

2つの式は大体同じことをしている:
#+begin_src emacs-lisp
(defun double (x) (* x 2))

(setf (symbol-function 'double)
      #'(lambda (x) (* x 2)))
#+end_src

手続き定義…名前をコードと関連付ける。

#+begin_quote
関数を作るのにdefunは必要ではなく， 関数は何かのシンボルの値と
して保存されなくてもいい．
defunの背後には， もっと一般的な仕組みが隠れている： 関数を作ることと，
それをある名前に関連づけることは別々の働きだ． Lispの関数の概念の一般性
全体までは必要ないとき， defunはもっと制限の強いプログラミング言語と同
じ位単純に関数定義を行う．
#+end_quote

applyは、オブジェクトを関数として実行する。

#+begin_src emacs-lisp
(+ 1 2)
(apply #'+ '(1 2))
(apply (symbol-function '+) '(1 2))
(apply #'(lambda (x y) (+ x y)) '(1 2))
#+end_src
** クロージャ
#+begin_src emacs-lisp
(defun make-adder (n)
  #'(lambda (x) (+ x n)))
#+end_src

は数を取り，「呼ばれると引数にその数を加えるクロージャ」を返す． その足
し算関数のインスタンスは幾らでも作ることができる：

#+begin_src emacs-lisp
> (setq add2 (make-adder 2)
        add10 (make-adder 10))
#<Interpreted-Function BF162E>
> (funcall add2 5)
7
> (funcall add10 3)
13
#+end_src

変数に引数をとった関数を入れる。すごいな。
** 末尾再帰
再帰関数とは自分自身を呼び出す関数だ． そして関数呼び出しの後に行うべき
作業が残っていなければ， その呼び出しは\emph{末尾再帰}だ． 次の関数は末
尾再帰でない．

#+begin_src emacs-lisp :tangle yes
(defun our-length (lst)
  (if (null lst)
      0
      (1+ (our-length (cdr lst)))))

#+end_src

再帰呼び出しから戻った後，結果を1+ に渡さなければいけないからだ． しか
し次の関数は末尾再帰だ．

#+begin_src emacs-lisp :tangle yes
(defun our-find-if (fn lst)
  (if (funcall fn (car lst))
      (car lst)
      (our-find-if fn (cdr lst))))
#+end_src
** 抽象化
#+begin_src emacs-lisp :tangle yes
(defun 1st (exp) (car exp))
(defun 2nd (exp) (car (cdr exp)))
(defun 3rd (exp) (car (cdr (cdr exp))))

(setq order-func1 '((OP . 2nd) (ARG1 . 1st) (ARG2 . 3rd)))
(setq order-func2 '((OP . 1st) (ARG1 . 2nd) (ARG2 . 3rd)))

(defun order-func (sym odr-db)
  (cdr (assq sym odr-db)))

(defun op (exp order-db)
  (funcall (order-func 'OP order-db) exp))
(defun arg1 (exp order-db)
  (funcall (order-func 'ARG1 order-db) exp))
(defun arg2 (exp order-db)
  (funcall (order-func 'ARG2 order-db) exp))

(setq op-func1 '((+ . +) (- . -) (* . *)))
(setq op-func2 '((add . +) (sub . -) (mul . *)))

(defun op-func (sym op-db)
  (cdr (assq sym op-db)))

(defun calc (exp op-db odr-db)
  (cond
    ((atom exp) exp)
    (t (funcall
        (op-func (op exp odr-db) op-db)
        (calc (arg1 exp odr-db) op-db odr-db)
        (calc (arg2 exp odr-db) op-db odr-db)))))

(calc '(1 + (2 * 3)) op-func1 order-func1)
(calc '(add 1 (mul 2 3)) op-func2 order-func2)
#+end_src
* memo
