#+title:      make emulator
#+date:       [2023-03-19 Sun 13:00]
#+filetags:   :code:
#+identifier: 20230319T130040

* ゲームボーイエミュレータを作る
:LOGBOOK:
CLOCK: [2023-03-21 Tue 11:32]--[2023-03-21 Tue 11:57] =>  0:25
CLOCK: [2023-03-21 Tue 11:05]--[2023-03-21 Tue 11:30] =>  0:25
CLOCK: [2023-03-21 Tue 10:39]--[2023-03-21 Tue 11:04] =>  0:25
CLOCK: [2023-03-21 Tue 10:14]--[2023-03-21 Tue 10:39] =>  0:25
CLOCK: [2023-03-21 Tue 00:58]--[2023-03-21 Tue 01:23] =>  0:25
CLOCK: [2023-03-21 Tue 00:32]--[2023-03-21 Tue 00:57] =>  0:25
CLOCK: [2023-03-21 Tue 00:07]--[2023-03-21 Tue 00:32] =>  0:25
CLOCK: [2023-03-20 Mon 22:55]--[2023-03-20 Mon 23:20] =>  0:25
CLOCK: [2023-03-20 Mon 21:55]--[2023-03-20 Mon 22:20] =>  0:25
CLOCK: [2023-03-20 Mon 21:28]--[2023-03-20 Mon 21:53] =>  0:25
CLOCK: [2023-03-20 Mon 20:46]--[2023-03-20 Mon 21:11] =>  0:25
CLOCK: [2023-03-20 Mon 20:16]--[2023-03-20 Mon 20:41] =>  0:25
CLOCK: [2023-03-20 Mon 00:46]--[2023-03-20 Mon 01:11] =>  0:25
CLOCK: [2023-03-19 Sun 23:09]--[2023-03-19 Sun 23:34] =>  0:25
CLOCK: [2023-03-19 Sun 22:43]--[2023-03-19 Sun 23:08] =>  0:25
CLOCK: [2023-03-19 Sun 22:05]--[2023-03-19 Sun 22:30] =>  0:25
CLOCK: [2023-03-19 Sun 21:21]--[2023-03-19 Sun 21:46] =>  0:25
CLOCK: [2023-03-19 Sun 20:35]--[2023-03-19 Sun 21:00] =>  0:25
CLOCK: [2023-03-19 Sun 20:10]--[2023-03-19 Sun 20:35] =>  0:25
CLOCK: [2023-03-19 Sun 19:45]--[2023-03-19 Sun 20:10] =>  0:25
CLOCK: [2023-03-19 Sun 17:59]--[2023-03-19 Sun 18:24] =>  0:25
CLOCK: [2023-03-19 Sun 15:27]--[2023-03-19 Sun 15:52] =>  0:25
CLOCK: [2023-03-19 Sun 14:57]--[2023-03-19 Sun 15:22] =>  0:25
CLOCK: [2023-03-19 Sun 14:23]--[2023-03-19 Sun 14:48] =>  0:25
CLOCK: [2023-03-19 Sun 13:58]--[2023-03-19 Sun 14:23] =>  0:25
:END:

- [[https://github.com/bokuweb/gopher-boy][bokuweb/gopher-boy: A Game Boy emulator written in Go]]の最初のコミットをたどる。
- pkgconfigの問題で実行できず
  - ググった方法で実行できた
  - 機能ごとにさまざまなミニマルROMがある
  - 各ROMの画像回帰テストで動作チェックしているよう。うまい
  - go run cmd/go-boy/main.go roms/helloworld/hello.gb
- 比較的コードが少なく、ファイルが分かれているので読みやすそう
- 命令には引数(オペランド)が存在することがある
  - 引数を指定する方法は13種類ある。アドレッシングモードという
  - プログラムに埋め込んだ定数を引数にするモードやメモリアドレスを渡してそのアドレスに格納されている値を引数にするモードがある
- memory mapped IO
  - IOレジスタがCPUのメモリ空間上にマップされている。該当するアドレスを読み書きすることで、CPUはコントローラの入力を読み取ったり、PPUに出力する画像の情報を送ったり、APUから出力する音の波形を設定したりできる
  - アドレスに対応するモジュールにアクセス
  - CPUからはメモリアクセスに見える
  - このアドレスを読み書きすれば各モジュールを使える、くらいの感じ
- カセットのMemory Bank Controller
  - カセットにはメモリが積まれていて、メモリの拡張として用いる
  - セーブデータとか保存している領域っぽい
  - 確かにカセットごとに保存されてたよな
  - コントローラには種類がある
  - RAMのサイズはカセットによって異なる
  - コントローラは複数のbankで構成されていて、スイッチできる
  - コントローラにはモードがある
    - RAM優先/ROM優先
- ビット演算を復習しないといけないな。こういうとき使うんだ
  - 命令を眺める。意味はわかるが、どうしてそうなのかはよくわからない

* [[https://gihyo.jp/dp/ebook/2019/978-4-297-10822-9][動かしてわかる CPUの作り方10講 | Gihyo Digital Publishing]]
:LOGBOOK:
CLOCK: [2023-03-21 Tue 23:26]--[2023-03-21 Tue 23:51] =>  0:25
CLOCK: [2023-03-21 Tue 21:43]--[2023-03-21 Tue 22:08] =>  0:25
CLOCK: [2023-03-21 Tue 21:18]--[2023-03-21 Tue 21:43] =>  0:25
CLOCK: [2023-03-21 Tue 20:43]--[2023-03-21 Tue 21:08] =>  0:25
CLOCK: [2023-03-21 Tue 20:18]--[2023-03-21 Tue 20:43] =>  0:25
CLOCK: [2023-03-21 Tue 19:52]--[2023-03-21 Tue 20:17] =>  0:25
CLOCK: [2023-03-21 Tue 18:33]--[2023-03-21 Tue 18:58] =>  0:25
CLOCK: [2023-03-21 Tue 17:55]--[2023-03-21 Tue 18:20] =>  0:25
CLOCK: [2023-03-21 Tue 17:30]--[2023-03-21 Tue 17:55] =>  0:25
CLOCK: [2023-03-21 Tue 16:54]--[2023-03-21 Tue 17:19] =>  0:25
CLOCK: [2023-03-21 Tue 16:11]--[2023-03-21 Tue 16:36] =>  0:25
CLOCK: [2023-03-21 Tue 13:19]--[2023-03-21 Tue 13:44] =>  0:25
CLOCK: [2023-03-21 Tue 12:50]--[2023-03-21 Tue 13:15] =>  0:25
CLOCK: [2023-03-21 Tue 12:19]--[2023-03-21 Tue 12:44] =>  0:25
:END:

CPUの知識が足りないので読む。

- この本で設計するシンプルなRISC型CPUの仕様
  - すべての命令は固定長で15bit
  - 機械語を格納するインストラクション・レジスタやメインメモリのプログラムにおけるデータ長も、命令と同じ長さになる
  - 2バイト(16bit)のデータ表現
    - CPUが扱うデータは2バイト(16bit)
    - 汎用レジスタやメインメモリのデータ領域のデータ長も16bitになる
    - 算術論理演算を行うALUも16bitが基本サイズ
  - 8個の汎用レジスタ
    - 命令長が15bitの制約の中で、命令の種類を表すオペレーションと、最大2つのオペランドを指定する必要がある
    - オペレーションを表す命令コードに4bit、汎用レジスタを指定するオペランドに3bitを割り当てることにする
    - なので命令の数は16個、汎用レジスタの数は8個になる
  - プログラム領域とデータ領域を分離するハーバードアーキテクチャ
    - メインメモリとレジスタ間のデータ転送は、
      - A. プログラム領域とインストラクション・レジスタ間
      - B. データ領域と汎用レジスタ間
    - プログラム領域におけるデータ長が15bit、データ領域におけるデータ長は16bitとなり、1bitのずれがある。そのため独立したデータバスとして扱うハーバードアーキテクチャを採用する
    - メモリマップドI/O
      - 回路構成をシンプルにするため、メインメモリのデータ領域に独立したアドレスを与えてI/Oを配置するメモリマップドI/Oを採用する
  - シンプルさに徹している。命令長を増やせば命令数を増やしたり、オペランド等に割り当てるビット数に余裕が生まれ、汎用レジスタの数やメモリサイズを大きくできるがやらない
- mov
  - 汎用レジスタのデータを移動(コピー)する
  - [命令コード][第1オペランド...to][第2オペランド...from]
  - toの汎用レジスタの内容を、fromの汎用レジスタにコピーする
- add
  - 汎用レジスタのデータを加算
  - [命令コード][第1オペランド...target][第2オペランド...from]
  - target + fromして、計算結果をtargetの汎用レジスタに上書きする

* Reference
** [[http://gikofami.fc2web.com/][ｷﾞｺ猫でもわかるファミコンプログラミング]]
定番のエミュレータ解説サイト。一般的な仕組みはこっちで学んでおくのがよさそう。
** [[https://gbdev.io/pandocs/About.html][Foreword - Pan Docs]]
ゲームボーイの仕様。
** [[http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf][GameBoy CPU Manual]]
ゲームボーイのCPUマニュアル。
