:properties:
:ID: 20240608T113006
:end:
#+title:      KDOC 188: 『Visual Guide to Slices in Go』
#+date:       [2024-06-08 Sat 11:30]
#+filetags:   :draft:book:
#+identifier: 20240608T113006

# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。

* この文書のステータス
:LOGBOOK:
CLOCK: [2024-06-08 Sat 14:05]--[2024-06-08 Sat 14:30] =>  0:25
CLOCK: [2024-06-08 Sat 12:51]--[2024-06-08 Sat 13:16] =>  0:25
:END:
- 作成
  - [X] 2024-06-08 貴島
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
[[https://sazak.io/articles/visual-guide-to-slices-in-go-2024-03-25][Visual Guide to Slices in Go — Ozan Sazak]]は、[[id:7cacbaa3-3995-41cf-8b72-58d6e07468b1][Go]]のスライスを解説した記事。

* メモ

- スライスは配列を抽象化したもの。扱うときに実際に割り当てられているメモリについて考えなくてよくするため。たとえばCでは、当初のメモリ割当よりも配列が大きくなった場合、手動でメモリの再割り当てとコピーが必要であった

#+caption: スライスの定義
#+begin_src git-permalink
https://github.com/kd-collective/go/blob/b8ac61e6e64c92f23d8cf868a92a70d13e20a124/src/runtime/slice.go#L15-L19
#+end_src

#+RESULTS:
#+begin_src
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
#+end_src

- capは基底配列の長さ。再メモリ確保せずに保存できる領域の長さ
- arrayフィールドは、基底配列への(最初の要素の)ポインタ。
- forによるイテレーションは、要素の長さ(len)で決まり、capの長さではない
- len == cap の状態で要素を加えた(append)とき、メモリを再割り当て(reallocate)する。capacityを増やして新しくsliceを作り、中身をコピーする
- ~sl = append(sl, "hello")~ のようになるのは、コピーによって異なるポインタを指すことがあるから
- printfフォーマットの ~%p~ によって、ポインタを表示できる
- スライス記法を使うと、コピーされずに同じ基底配列を指す。スライスの最初の要素ポインタがずれる
  - ↓の例では中の要素がbyteなので、1バイト文だけずれる

#+caption: コピーされている
#+begin_src go :imports "fmt"
  s1 := []byte{16, 32, 48, 64, 80}
  s2 := s1[1:3]

  fmt.Printf("s1: %p %v len: %d cap: %d\n", s1, s1, len(s1), cap(s1))
  fmt.Printf("s2: %p %v len: %d cap: %d\n", s2, s2, len(s2), cap(s2))
#+end_src

#+RESULTS:
#+begin_src
s1: 0xc0000120e0 [16 32 48 64 80] len: 5 cap: 5
s2: 0xc0000120e1 [32 48] len: 2 cap: 4
#+end_src

同じ基底配列を使っているのを確認する。

#+caption: s2に追加するとs1も増えている
#+begin_src go :imports "fmt"
  s1 := []byte{16, 32, 48, 64, 80}
  s2 := s1[1:3]

  s2 = append(s2, 100, 101)
  fmt.Printf("s1: %p %v len: %d cap: %d\n", s1, s1, len(s1), cap(s1))
  fmt.Printf("s2: %p %v len: %d cap: %d\n", s2, s2, len(s2), cap(s2))
#+end_src

#+RESULTS:
#+begin_src
s1: 0xc0000120e0 [16 32 48 100 101] len: 5 cap: 5
s2: 0xc0000120e1 [32 48 100 101] len: 4 cap: 4
#+end_src

capを超えた場合、再割り当てされるので、s1, s2は同じ基底配列ではなくなる。

- s2の先頭要素のポインタが変わっている
- s2への変更がs1に反映されない

#+caption: s2のcapを超える
#+begin_src go :imports "fmt"
  s1 := []byte{16, 32, 48, 64, 80}
  s2 := s1[1:3]

  s2 = append(s2, 100, 101, 102)
  fmt.Printf("s1: %p %v len: %d cap: %d\n", s1, s1, len(s1), cap(s1))
  fmt.Printf("s2: %p %v len: %d cap: %d\n", s2, s2, len(s2), cap(s2))
#+end_src

#+RESULTS:
#+begin_src
s1: 0xc0000120e0 [16 32 48 64 80] len: 5 cap: 5
s2: 0xc0000120e8 [32 48 100 101 102] len: 5 cap: 8
#+end_src

スライス記法の3番目の引数で、新しいスライスの容量を制限できる。これによって、同じ基底配列に意図せず変更を加えるのを防げる。

#+begin_src go :imports "fmt"
  s1 := []byte{16, 32, 48, 64, 80}
  s3 := s1[1:3:3]

  s3 = append(s3, 200, 201)

  fmt.Printf("s1: %v, len: %d, cap: %d\n", s1, len(s1), cap(s1))
  fmt.Printf("s3: %v, len: %d, cap: %d\n", s3, len(s3), cap(s3))
#+end_src

#+RESULTS:
#+begin_src
s1: [16 32 48 64 80], len: 5, cap: 5
s3: [32 48 200 201], len: 4, cap: 8
#+end_src

* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# この事実は自分のこのアイデアとどう整合するか。
# この現象はあの理論でどう説明できるか。
# ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# いま聞いた内容は以前に聞いたことがなかったか。
# メモ y についてメモ x はどういう意味か。
