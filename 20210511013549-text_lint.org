#+title: text-lint

text-lintをorg-modeに対応させたい。
単にテキストからのAST変換…構文解析してオブジェクトに変換する…の部分ができればすべてうまくいくはずだ。

* text-lint
** 勉強
https://azu.github.io/JavaScript-Plugin-Architecture/JavaScript-Plugin-Architecture.pdf
- lintは直に文字列を比較しているわけではない。ASTを比較してる。確かに文字列比較している箇所はなかった。

#+begin_src emacs-lisp
const ast = parse(code);
#+end_src
の部分だ。ルールではなく、ASTのparseをorgに対応させる。それくらいすでにありそうだけどな。

#+begin_quote
ルールの実装の方を見てみると、直接オブジェクトをexportしないで、
contextとしてRuleContextのインスタンスを受け取っていることが分かると思
います。
#+end_quote

#+begin_src js
module.exports = {
    meta: { /* ルールのメタ情報 */ },
    create: function (context) {
        return {
            "MemberExpression": function (node) {
                if (node.object.name === "console") {
                    context.report({
                        node,
                        message: "Unexpected console statement."
                    });
                }
            }
        };
    }
};
#+end_src

#+begin_quote
このようにして、ルールは context という与えられたものだけを使うので、ルー
ルがMyLinter本体の実装の詳細を知らなくても良くなります。
#+end_quote

#+begin_quote
このプラグインアーキテクチャはPub/Subパターンを上手く使い、 ESLintのよ
うに与えられたコードを読み取ってチェックするような使い方に向いています。
#+end_quote

- read向け。writeは競合変更などに対応しにくい。
- 走査が1回なので性能がよい
*** 誤字
- 実際に利⽤するため際は
- 制御することのは難しい
- Getting Started with Redux - Course by @dan_abramov @eggheadio (リンク切れ)
- test/prh-rule.yaml (リンク切れ)
- staltz.com/unidirectional-user-interface-architectures.htmlo(右端にoがついてる)
- middleware が直接的に結果(State)を直接書き換えることはできません。(直接が2回)
- test/prh-rule.yaml(リンク切れ)
- conventional-changelog/angular.md at master · ajoslin/conventional-changelog(リンク切れ)
** plugin-org

ああ、すでにある、思ってcloneして動かしてみる…動かない…4年前のWIPだった。
1コミットだけのをフォークしてしまった。
実行・テスト何もできない状態。importすらできず、地獄。
それでも1からやるよりはマシだった可能性はある…ほぼサンプルのコピペはされてたので。

type: "module"にすればよいとの意見多数だったが、依存パッケージが壊れるのでできなかった。
コンパイルすることに。babel。バージョンの違いで苦しみ、なんとかすべて最新の状態に(自分のグローバルインストールのnodeなんかも超古かった)。

そして…とりあえず単体で動くように。本体のtext-lintの中では動かないが、とりあえずプラグイン認識はしてくれてる。
どこが悪いのか判別つかないのでとりあえず単体テストをやる。
テストもめちゃくちゃで、とりあえず全部消してコンパイル設定とかやって一応動きはするように。

無テストでCIだけ立ち上げる。今までの困難とは裏腹に成功。
パッケージ管理メンドいけど、こういうところがメリットだとわかる。
** htmlのASTとの比較
html-to-astとorgaの出力の比較。
けっこう違うな。

#+begin_src json
  {
      type: 'Document',
      children: [
          {
              type: 'Html',
              tagName: 'h2',
              properties: {},
              children: [Array],
              loc: [Object],
              range: [Array],
              raw: '<h2>hello</h2>'
          },
          type: 'UNKNOWN'
      ],
      loc: { start: { line: 1, column: 0 }, end: { line: 1, column: 14 } },
      range: [ 0, 14 ],
      raw: '<h2>hello</h2>'
  }
#+end_src

#+begin_src json
  s<ref *1> {
    type: 'document',
    properties: {},
    children: [
      {
        type: 'paragraph',
        children: [Array],
        attributes: {},
        position: [Object],
        parent: [Circular *1]
      }
    ],
    position: { start: { line: 1, column: 1 }, end: { line: 1, column: 13 } }
  }
#+end_src
** Converting circular structure to JSON
循環参照が含まれているのがだめらしい。
↑でいうとparent: [Circular *1]のところか。

Note how [Circular ~] shows the path to the referenced object.
なるほど。

** 出力がかっこいい
テストの出力がかっこいい。わかりやすいし。
power-assert
https://github.com/power-assert-js/power-assert

#+begin_src
  1) Array #indexOf() should return index when the value is present:
     AssertionError: # path/to/test/mocha_node.js:10

  assert(ary.indexOf(zero) === two)
         |   |       |     |   |
         |   |       |     |   2
         |   -1      0     false
         [1,2,3]

  [number] two
  => 2
  [number] ary.indexOf(zero)
  => -1
#+end_src

#+begin_src
  OrgProcessor-test
    #parse
      ✓ should return AST
      ✓ begin_src should CodeBlock
      ✓ text should Paragraph
      ✓ begin_comment should block
      ✓ ~~ should text.code
    OrgPlugin
      when target file is a Org
        ✓ should report lint error
        ✓ should not comma check inside the code block.
#+end_src

** マッピング
~* header~
はorgaだと(section) => (star) + (headline) みたいになる。
だから1階層下ってheadlineにマッピングしてやる必要がある。
