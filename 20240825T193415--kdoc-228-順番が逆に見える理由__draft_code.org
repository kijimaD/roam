:properties:
:ID: 20240825T193415
:end:
#+title:      KDOC 228: 実行時のアドレスの使い方が逆に見える
#+date:       [2024-08-25 Sun 19:34]
#+filetags:   :draft:code:
#+identifier: 20240825T193415

# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。

* この文書のステータス
- 作成
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
# 本文(タイトルをつける)。

C言語で実行時のアドレス位置と、アセンブリの位置で違いがあるように見えたので確かめる。

#+caption: 変数の番地を表示する
#+begin_src C
  int main() {
    char base = 0;
    char a = 'a';
    char b = 'b';
    char c = 'c';

    printf("%p: base\n", &base);
    printf("%p: a\n", &a);
    printf("%p: b\n", &b);
    printf("%p: c\n", &c);
  }
#+end_src

#+RESULTS:
#+begin_src
0x7fffa55f0a84: base
0x7fffa55f0a85: a
0x7fffa55f0a86: b
0x7fffa55f0a87: c
#+end_src

つまり、↓このようになっているように見える。コードで変数を初期化した順番とアドレスの順番が一致している。

#+caption: 先に書いた変数(base)が低位アドレスとなる
#+begin_src shell
  ^番地小(低)

  | ...84: base |
  | ...85: a |
  | ...86: b |
  | ...87: c |

  v番地大(高)
#+end_src

いっぽう、アセンブリで見る。

#+begin_export html
<iframe width="800px" height="200px" src="https://godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:2,endLineNumber:6,positionColumn:2,positionLineNumber:6,selectionStartColumn:2,selectionStartLineNumber:6,startColumn:2,startLineNumber:6),source:'int+main()+%7B%0A++++char+base+%3D+1%3B%0A++++char+a+%3D+!'a!'%3B%0A++++char+b+%3D+!'b!'%3B%0A++++char+c+%3D+!'c!'%3B%0A%7D'),l:'5',n:'1',o:'C+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cclang1701,filters:(b:'0',binary:'1',binaryObject:'1',commentOnly:'0',debugCalls:'1',demangle:'0',directives:'0',execute:'1',intel:'1',libraryCode:'0',trim:'0',verboseDemangling:'0'),flagsViewOpen:'1',fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'',overrides:!(),selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'+x86-64+clang+17.0.1+(Editor+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>
#+end_export

つまり、アセンブリでは↓こう格納されそうに見える。コードで変数を初期化した順番とアドレスの順番は逆順になる。スタックの成長する方向であり、納得できる。

#+caption: 先に書いた変数(base)が高位アドレスとなる
#+begin_src shell
  ^番地小(低)

  | rbp-4: c |
  | rbp-3: b |
  | rbp-2: a |
  | rbp-1: base  |

  v番地大(高)
#+end_src

実行して確認したアドレスと、アセンブリのアドレスの順番が、逆になっているように見える。これはなぜなのだろう。

いくつか調べるなかで、箇所は不明だが環境依存であると考えた。

- [[https://brain.cc.kogakuin.ac.jp/~kanamaru/lecture/prog1/08-03.html][第八回-03 メインメモリとアドレス]]の例では、同じようなコードだが、アドレスの順番が高位アドレス→低位アドレスとなっている
- [[https://paiza.io/projects/P_5GA1AKodgUoRjfhdY3_A?language=c][ブラウザでプログラミング・実行ができる「オンライン実行環境」| paiza.IO]]で実行するとアドレスの順番が高位アドレス→低位アドレスとなっている。paizaではclangを使っているようだ
- 手元で ~clang~ でコンパイルすると高位アドレス→低位アドレスになる。gccでコンパイルすると低位アドレス→高位アドレスになる
- Compiler Explorerでgcc, clangを入れ替えてみたが順序は変わらず

#+caption: clangでコンパイルして実行した結果。先に書いた変数が高位アドレスとなる
#+begin_src shell
  0x7ffe71de7317: base
  0x7ffe71de7316: a
  0x7ffe71de7315: b
  0x7ffe71de7314: c

  --------------------
  ^番地小(低)

  | ...14: c |
  | ...15: b |
  | ...16: a |
  | ...17: base |

  v番地大(高)
#+end_src

手元のgccでアセンブラを見てみると、(低)base, a, b, c(高)順のアドレスになっているのを確認できた。

#+caption: 手元のgccで-Sオプションを使って出力した
#+begin_src asm
          .file	"main.c"
          .text
          .section	.rodata
  .LC0:
          .string	"%p: base\n"
  .LC1:
          .string	"%p: a\n"
  .LC2:
          .string	"%p: b\n"
  .LC3:
          .string	"%p: c\n"
          .text
          .globl	main
          .type	main, @function
  main:
  .LFB0:
          .cfi_startproc
          endbr64
          pushq	%rbp
          .cfi_def_cfa_offset 16
          .cfi_offset 6, -16
          movq	%rsp, %rbp
          .cfi_def_cfa_register 6
          subq	$16, %rsp
          movq	%fs:40, %rax
          movq	%rax, -8(%rbp)
          xorl	%eax, %eax
          movb	$0, -12(%rbp)  ; 👈
          movb	$97, -11(%rbp) ; 👈
          movb	$98, -10(%rbp) ; 👈
          movb	$99, -9(%rbp)  ; 👈
          leaq	-12(%rbp), %rax
          movq	%rax, %rsi
          leaq	.LC0(%rip), %rax
          movq	%rax, %rdi
          movl	$0, %eax
          call	printf@PLT
          leaq	-11(%rbp), %rax
          movq	%rax, %rsi
          leaq	.LC1(%rip), %rax
          movq	%rax, %rdi
          movl	$0, %eax
          call	printf@PLT
          leaq	-10(%rbp), %rax
          movq	%rax, %rsi
          leaq	.LC2(%rip), %rax
          movq	%rax, %rdi
          movl	$0, %eax
          call	printf@PLT
          leaq	-9(%rbp), %rax
          movq	%rax, %rsi
          leaq	.LC3(%rip), %rax
          movq	%rax, %rdi
          movl	$0, %eax
          call	printf@PLT
          movl	$0, %eax
          movq	-8(%rbp), %rdx
          subq	%fs:40, %rdx
          je	.L3
          call	__stack_chk_fail@PLT
  .L3:
          leave
          .cfi_def_cfa 7, 8
          ret
          .cfi_endproc
  .LFE0:
          .size	main, .-main
          .ident	"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0"
          .section	.note.GNU-stack,"",@progbits
          .section	.note.gnu.property,"a"
          .align 8
          .long	1f - 0f
          .long	4f - 1f
          .long	5
  0:
          .string	"GNU"
  1:
          .align 8
          .long	0xc0000002
          .long	3f - 2f
  2:
          .long	0x3
  3:
          .align 8
  4:

    --------------------------------
    |-12(%rbp): base |
    |-11(%rbp): a |
    |-10(%rbp): b |
    | -9(%rbp): c |
#+end_src

つまり、コードで変数を初期化した順番と、アドレスの順番は必ずしも逆にはならないことがある。なぜそうなるのかは、いつか調べる。

* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# この事実は自分のこのアイデアとどう整合するか。
# この現象はあの理論でどう説明できるか。
# ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# いま聞いた内容は以前に聞いたことがなかったか。
# メモ y についてメモ x はどういう意味か。
なし。
