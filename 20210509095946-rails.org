:PROPERTIES:
:ID:       e04aa1a3-509c-45b2-ac64-53d69c961214
:END:
#+title: Rails
* 概要
Railsは[[id:cfd092c4-1bb2-43d3-88b1-9f647809e546][Ruby]]でWEBサイトを作るためのフレームワーク。
* Memo
TODO: 数が多くなってきたので分類する。
** [[id:cfd092c4-1bb2-43d3-88b1-9f647809e546][Ruby]]バージョンアップデート
超強い人が言っていたメモ。
コマンドを組み合わせて一気に置換して検討していく。
#+caption: 全体を一気に置換する
#+begin_src shell
git grep -l '2\.6\.5' | xargs sed -i 's/2\.6\.5/2.7.1/g'
#+end_src
vendor/bundle を削除して、bundle install。
マイナーバージョンを変更した場合は .rubocop.yml の RUBY_VERSION を修正(parser gemの指定)。
** 新規作成時はform表示しない
formを共通化しているようなとき。
このカラムはedit時のみ出したい、というようなことがある。
#+caption: new時persistされてないので表示されない
#+begin_src ruby
  form_for do |f|
    f.number_field :position if @content_category.persisted?
  end
#+end_src
** 一部アクションだけvalidation
#+caption: onでアクションを指定できる。
#+begin_src ruby
validates :user_id, presence: true, :on => :create
#+end_src
** 便利な日付操作
#+caption: Time.zone
#+begin_src ruby
Time.zone.yesterday
Time.zone.today.ago(7.days)
#+end_src

[[https://qiita.com/mmmm/items/efda48f1ac0267c95c29][Railsでの日付操作でよく使うものまとめ - Qiita]]
** 安全に関連カラムを追加する
Blogにuser_idを後から追加したい、みたいなとき。User -< Blog。
最初にnullableで外部キーを作成する。

次に、新規作成時にmodelでvalidationをかける。
すると既存レコードの外部キーはnull、新しくできるレコードは外部キーありという状態になる。
外部キーなしが増えることはない。移行をする。
nullのレコードがゼロになってから外部キー制約をつけて関連カラム追加完了。
** 関連カラムを安全に変更する
レコードがすでに入っているテーブルの関連を変更する場合。
たとえば、blogs >- somethings >- users を blogs >- users というような。somethingsテーブルは何もしてないので削除したい、とする。
何も考えずにやると、一気にすべてを切り替えることになりがち。

悪い例を示す。
1. 最初に関連カラムを変更する。
  #+caption: modelファイルで関連変更
  #+begin_src ruby
   belongs_to :user # 旧 belongs_to :something
  #+end_src
2. 旧関連を使ってたアプリケーション側をすべて変更する。MVCすべて。
3. 新しい関連カラムは空で、旧データを移行しないといけない。移行は↑のデプロイと同時にしないと不整合になる。デプロイと移行スクリプトの間の変更は無視されるから。
4. 1~3をまとめて一気にリリースする

ということで、大量な複数層の変更をぶっつけ本番でしないといけなくなる。途中で嫌になるだろうし、運が悪ければミスって大変なことになる。

ではどうするか。根本的なアイデアは、2つの関連を同時に保持しておくことだ。
同時に持っておけば、大丈夫なことを確認してから関連を変更するだけでいい。そうやって遅延させることで、一気にいろいろな変更をしなくてよくなる。

具体的にどうやるか。良い例。
#+caption: modelのbefore_saveでオンデマンドコピー
#+begin_src ruby
  class Blog < ApplicationRecord
    before_save do
      self.user_id ||= something.user_id
    end
  end
#+end_src

としておくと、保存時にblog.user_idとblog.something.user_idの両方に関連がコピーされる。somethingsを経由しないでよくなる。

既存データについても処理を追加しておく。
#+caption: modelにメソッドを作っておく
#+begin_src ruby
  class User < ApplicationRecord
    def migrate
      self.user_id ||= something.user_id
      save!
    end
  end
#+end_src
そして、全Userでmigrateを実行すれば既存データにも新しいカラムが入る。

既存データと新しく作成されるレコードをおさえたので、新旧2つの関連カラムは完全に同等になる。
ここまででマージ、リリースする。
問題ないことを確認したあとで、新旧カラムが使える状態を活かしてアプリケーション側の変更…実際の関連の変更をやる(一番の目的の箇所)。
ここまででマージ、リリースする。

その後、移行処理とカラムを削除して片付ければ完了。(あるいは移行処理は前の時点で消す)
関連カラムだけでなく、何かカラムを移すときにはすべて同様にできる。

実際のタスクでは、migration処理をする箇所は複数になるので前もって調査が必要。
** カラム名を安全に変更する
カラム名変更とアプリケーション側の変更を分け、変更範囲を狭める。
alias_attributeを追加する。すると、新しいカラム名でもアクセスできるようになる。
依存しているほかのアプリケーションの変更をする(new_user_idに書き換える)。
#+caption: modelファイルにて、追加
#+begin_src ruby
alias_attribute :new_user_id, :typo_user_id
#+end_src

それらを書き換えたらマージ、リリースする。
その後、カラム名を書き換えるマイグレーションを作成する。使っている箇所はないので安全に変更できる。
マイグレーション後、alias_attributeを削除する。
** テーブル名を安全に変更する
最初にmodel クラス名を変更し、テーブルの参照先に変更前のものを設定する。
#+begin_src ruby
  class Blog_After < ApplicationRecord
    self.table_name = :blog_before
  end
#+end_src
すると、アプリケーション側だけの変更で、DBの変更はない状態で動作上の変更はなくなる。
次にアプリケーションの、ほかの依存している箇所を修正する。
ここまで1つのPRにする。

テストが通ったりリリースできたら、テーブル名変更のマイグレーションを作成し、modelでのtable_name設定を削除するPRをつくる。
安全に変更が完了する。
テーブルの変更と、アプリケーションの変更を同時にやらないと安全だし分割できてすっきりする。
** modelのログを保持する
[[https://github.com/paper-trail-gem/paper_trail][paper-trail-gem/paper_trail: Track changes to your rails models]]
変更や差分、変更時の何らかの情報(つまり、作業者とか)を保存、閲覧できる。

[[https://github.com/ankit1910/paper_trail-globalid][ankit1910/paper_trail-globalid: An extension to paper_trail, using this you can fetch actual object who was responsible for this change]]
paper_trailの拡張。変更したか取得できるようになる。
** サロゲートキー
Railsでいうところの ~id~ のこと。Rails5 からはbigintで設定されている。
主キーとして使う人工的な値、というのがポイント。

[[https://e-words.jp/w/%E3%82%B5%E3%83%AD%E3%82%B2%E3%83%BC%E3%83%88%E3%82%AD%E3%83%BC.html][サロゲートキー（surrogate key）とは - IT用語辞典 e-Words]]
#+begin_quote
サロゲートキーとは、データベースのテーブルの主キーとして、自動割り当ての連続した通し番号のように、利用者や記録する対象とは直接関係のない人工的な値を用いること。また、そのために設けられたカラムのこと。
#+end_quote
** ロールバックできないマイグレーションであることを明示する
たいていの場合はコメントでロールバックできないなどと書けばよいが、rollbackが破壊的な動作になる場合があるのでdownに書く。
#+caption: ActiveRecord::IrreversibleMigration
#+begin_src ruby
  def down
    raise ActiveRecord::IrreversibleMigration
  end
#+end_src
** null制約を追加しつつdefault設定
[[https://qiita.com/akinov/items/852fe789fe98a44350a9][Railsのmigrationで後からNULL制約を設定する - Qiita]]

null制約追加には、 ~change_column_null~ を使う。
null制約だけ追加すると変更前にnullだったレコードでエラーになってしまうので、同時にdefaultを設定するとよい。

#+caption: null制約 + default設定
#+begin_src ruby
class ChangePointColumnOnPost < ActiveRecord::Migration[5.2]
  def change
    change_column_null :posts, :point, false, 0
    change_column_default :posts, :point, from: nil, to: 0
  end
end
#+end_src

#+caption: ↑falseはnullオプション
#+begin_src ruby
  change_column_null(table_name, column_name, null, default = nil)
#+end_src
** migrationファイルによる不整合解消タスク
migrationファイルは一部DSLが扱われるだけで普通のrubyファイルと変わらない。
データベースの不整合を解消することにも使える。

#+caption:
#+begin_src ruby
  def up
    Blog.unscoped.where(user_id: nil).delete_all
  end
#+end_src
というように。
環境別にconsoleでコマンドを実行する必要がないので便利。
** unscopedでdefault_scopeを無効化
~unscoped~ はdefault_scopeを無効化する。
[[https://apidock.com/rails/ActiveRecord/Base/unscoped/class][unscoped (ActiveRecord::Base) - APIdock]]

#+caption: 自動でpublishedの条件が発行されていることがわかる
#+begin_src ruby
  class Post < ActiveRecord::Base
    def self.default_scope
      where :published => true
    end
  end

  Post.all          # Fires "SELECT * FROM posts WHERE published = true"
  Post.unscoped.all # Fires "SELECT * FROM posts"
#+end_src

#+caption: default_scopeの条件がなくなる
#+begin_src ruby
  Post.unscoped {
    Post.limit(10) # Fires "SELECT * FROM posts LIMIT 10"
  }
#+end_src
** inverse_ofで双方向の不整合を防ぐ
[[https://qiita.com/itp926/items/9cac175d3b35945b8f7e][inverse_of について - Qiita]]

双方向の関連付けの不整合を防ぐ関連オプション。belongs_to, has_many等ではデフォルトでオンになっているよう。

#+caption:
#+begin_src ruby
  class Category
    has_many :blog
  end

  class Order
    belongs_to :category
  end
#+end_src

#+caption: 不整合
#+begin_src ruby
  c = Category.first
  b = c.orders.first

  c.title = "change"
  c.title == b.category.title #=> false 値は異なる
  c.equal? b.category #=> false 同じオブジェクトでない
#+end_src
inverse_ofを使うと同じオブジェクトを使うようになる。
** リレーションの不整合検知
よくわからない。

#+caption: 不整合検知タスク
#+begin_src ruby
desc '外部キーの整合性を検証する'
task extract_mismatch_records: :environment do
  Rails.application.eager_load!

  ApplicationRecord.subclasses.each do |model|
    model.reflections.select { |_, reflection| reflection.is_a?(ActiveRecord::Reflection::BelongsToReflection) }.each do |name, reflection|
      model_name = model.model_name.human
      foreign_key = reflection.options[:foreign_key] || "#{name}_id"

      unless model.columns.any? { |column| column.name == foreign_key.to_s }
        puts "💢 #{model_name} には #{foreign_key} フィールドがありません"
        next
      end

      parent_model_class_name = reflection.options[:class_name] || reflection.name.to_s.classify
      parent_model = parent_model_class_name.safe_constantize

      unless parent_model
        puts "💢 #{model_name} が依存している #{parent_model_class_name} は参照できません"
        next
      end

      parent_model_name = parent_model.model_name.human

      begin
        # NOTE: 親テーブルのIDとして存在しない外部キーの数を照会
        relation = model.unscoped.where.not(foreign_key => parent_model.unscoped.select(:id)).where.not(foreign_key => nil)
        sql = relation.to_sql
        count = relation.count

        if count.zero?
          puts "💡 #{model_name} の #{parent_model_name} の外部キーは整合性が保証されています" unless ENV['ONLY_FAILURE']
        else
          puts "💣 #{model_name} の #{parent_model_name} の外部キーで不正なキーが #{count} 件 設定されています"
        end

        if ENV['DEBUG']
          puts "=> #{sql}\n"
          puts
        end
      rescue StandardError
        # NOTE: マスタデータの場合はスキップ
        puts "🈳 #{model_name} の #{parent_model_name} の整合性の検証をスキップしました" unless ENV['ONLY_FAILURE']
      end
    end
  end
end
#+end_src

Reflectionクラスはアソシエーション関係のmoduleのよう。
https://github.com/kd-collective/rails/blob/f132be462b957ea4cd8b72bf9e7be77a184a887b/activerecord/lib/active_record/reflection.rb#L49

#+begin_quote
Reflection enables the ability to examine the associations and aggregations of Active Record classes and objects. This information, for example, can be used in a form builder that takes an Active Record object and creates input fields for all of the attributes depending on their type and displays the associations to other objects.

Reflectionを使用すると、Active Recordのクラスやオブジェクトの関連付けや集計を調べることができます。この情報は、例えば、Active Recordオブジェクトを受け取り、その型に応じてすべての属性の入力フィールドを作成します。他のオブジェクトとの関連を表示するフォームビルダーで使用できます。
#+end_quote

Reflectionに関する記事。
[[https://qiita.com/kkyouhei/items/067d5bb8d79c71f1646b][Railsのコードを読む アソシエーションについて - Qiita]]
** クエリ高速化
ネストしてクエリを発行してるときは何かがおかしい。

- parent_category -> category -> blog のような構造

#+caption: ひどいクエリメソッド
#+begin_src ruby
  parent_categories.each do |parent_category|
    parent_category.categories.each do |category|
      category.blogs.each do |blog|
        @content << blog.content
      end
    end
  end
#+end_src

- parent_category -> category -> blog

#+caption: joins
#+begin_src ruby
  Blog.joins(categories: category)
    .merge(Category.where(parent_category: parent_large_categories))
#+end_src
** Migrationファイルをまとめて高速化する
Migrationファイルは変更しないのが基本だが、数が多い場合、 ~rails migrate:reset~ に時間がかかる。

db/schema.rbの内容を、最新のタイムスタンプのマイグレーションにコピーする。

- つまり現在のDB状況が、そのまま1つのmigrationとなる。DSLが同じなので問題ない。
- migrationのタイムスタンプは既に実行済みのため、動作に影響しない。
** Gemfileで環境指定する
Gemfileのgroupキーワードは、指定環境でしかインストールしないことを示す。

#+caption: developmentでしかインストールされない
#+begin_src ruby
  group :development do
    gem 'annotate', require: false
  end
#+end_src

なので環境を指定せずにテストを実行したとき、gem not foundが出る。実行されたのがdevelopment環境で、テストのgemが読み込まれてないから。 ~RAILS_ENV=test~ がついているか確認する。
** 論理削除と物理削除
論理削除は削除したときレコードを削除するのではなく、フラグをトグルするもの。
逆に物理削除はレコードから削除すること。

論理削除のメリットは、データが戻せること。

が、データベースの運用的に、後から問題となることの方が多い。

- 削除フラグを付け忘れると事故になる。削除したはずなのに表示したり、計算に入れたりしてしまう
- データが多くなるためパフォーマンスが悪くなる

Railsではgem act_as_paranoidを使って簡単に論理削除処理を追加できる。deleted_atカラムを論理削除を管理するフラグとして用いる。
** find、find_by、whereの違い
[[https://qiita.com/tsuchinoko_run/items/f3926caaec461cfa1ca3][find、find_by、whereの違い - Qiita]]

- find :: 各モデルのidを検索キーとしてデータを取得するメソッド。モデルインスタンスが返る
- find_by :: id以外をキーとして検索。複数あった場合は最初だけ取る。モデルインスタンスが返る。
- where :: id以外をキーとして検索。モデルインスタンスの入った配列が返る。
** acts_as_list
acts_as_listは順番を管理するgem。
[[https://github.com/brendon/acts_as_list][brendon/acts_as_list: An ActiveRecord plugin for managing lists.]]

順番の生成と、操作を可能にする。
modelに順番カラムを指定すると、create時に自動で番号が格納される。
逆にフォームで番号格納しているとそれが優先して入るため自動採番されない。
new時には番号フォームを表示しないなどが必要。
** テーブル名と名前空間
** pluck
~pluck~ は、各レコードを丸ごとオブジェクトとしてとってくるのではなく、引数で指定したカラムのみの *配列* で返すメソッド。
[[https://railsdoc.com/page/model_pluck][pluck | Railsドキュメント]]

~select~ はカラム指定というところは同じだがオブジェクトを返す。
** まとめて処理して高速化
1つ1つ処理するのではなくて、同時に複数のレコードを処理することで高速化する。
** 該当レコード数が莫大な場合
メモリに全体を展開するのでなく、ある数ずつ展開してメモリ消費を抑える。

[[https://railsdoc.com/page/find_each][find_each | Railsドキュメント]] ... 1件ずつ処理。
[[https://railsdoc.com/page/find_in_batches][find_in_batches | Railsドキュメント]] ... 配列で処理。

** 並列処理の例
parallel gemによって。
#+caption: 例
#+begin_src ruby
  require 'parallel'
  result = Parallel.each(1..10) do |item|
      item ** 2
  end
#+end_src
** 開発に便利なページ
- /rails/info/routes
  routes一覧。
- /letter_opener(自分で設定する)
  送信したメール一覧を見られる。
  gemが入ってる場合。
  [[https://github.com/ryanb/letter_opener][ryanb/letter_opener: Preview mail in the browser instead of sending.]]
- rails/mailers/
  Action Mailerのプレビューを見られる。
  previewを準備しておくといちいち送信せずとも、ローカルでダミーが入った文面を確認できる。
** 開発環境でしか使えないメソッドが存在する
~class_name~ は開発環境でしか使えない。
gemによってはそういうパターンで使えないことがあることに注意しておく。

- https://stackoverflow.com/questions/38776080/method-class-name-undefined-for-class-object-in-rails
#+begin_quote
class_name method is defined by yard gem. it works only development env.
#+end_quote
** rails console -s
~rails console -s~ としてconsole起動すると、sandbox-modeになりコンソール内のDB操作が終了時にリセットされる。
便利。
** rails cできないとき
springはキャッシュを保存して次のコマンド実行を早くするgem。
テストも高速化できるので便利だが、たまに壊れて反映しなくなったりする。

まずspringを止めて確認する。
#+begin_src shell
  bundle exec spring stop
#+end_src
** system specでTCP error がでるとき
テストがある程度の長さを超えると、メモリの量が足りなくなってエラーを出す。
特にMacだと起こるよう。
#+begin_src shell
  ulimit -n 1024
#+end_src
** どのメソッドか調べる
どのgemのメソッドかわからないときに ~source_location~ が便利。
https://docs.ruby-lang.org/ja/latest/method/Method/i/source_location.html
#+begin_src ruby
  character.method(:draw).source_location
#+end_src
** DBリセット
環境を指定して、リセットを行う。
データの初期化にseed_fu gemを使っている。

#+begin_src shell
  bundle exec rails db:migrate:reset && rails db:seed_fu
#+end_src
** デイリーでやること
gemのupdateやマイグレーションが起きたときにやる。
どこかで定型化して一気に実行するようにする。
#+begin_src shell
  git checkout develop && bundle install && bundle exec rails db:migrate
#+end_src
** scope
scopeはクラスメソッド的なやつ。
インスタンスには使えない。 ~User.scope...~
[[https://railsguides.jp/active_record_querying.html#%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97][Active Record クエリインターフェイス - Railsガイド]]

#+begin_quote
スコープを設定することで、関連オブジェクトやモデルへのメソッド呼び出しとして参照される、よく使用されるクエリを指定することができます。
#+end_quote
** validation
~valid?~ はAction Modelのバリデーションメソッド。
[[https://devdocs.io/rails~6.1/activemodel/validations#method-i-valid-3F][Ruby on Rails 6.1 / ActiveModel::Validations#valid? — DevDocs]]
引っかかってたらfalseになる。
オーバーライドしてしまいそうになるメソッド名なのに注意。
** ネストしたvalidateは反応しない
 特定の条件だけで発動するvalidation + 条件。`with_options: if`内で`if`を使うと、中のif条件が優先して実行されるため、こう書く必要がある。
#+begin_src ruby
  validates :term_date, date: { after: proc { Time.zone.now } }, if: proc { |p| p.term_date? && p.sellable?  }
#+end_src
** N+1問題
[[id:8b69b8d4-1612-4dc5-8412-96b431fdd101][SQL]]がたくさん実行されて遅くなること。ループしているとレコードの数だけSQLが発行され、一気に遅くなる。
includesを使うと少ないSQLにまとめられる。
https://qiita.com/hirotakasasaki/items/e0be0b3fd7b0eb350327

#+caption: includesで関連テーブルをまとめて取得する
#+begin_src ruby
  Page.includes(:category)
#+end_src
** 子のデータが存在するとき関連削除しないようにする
~dependent: destroy~ だと子のデータもすべて破壊して整合性を保つ。
それでは具合が悪いときもあるので、消さないようにする。
#+begin_src ruby
  has_many :contents, dependent: :restrict_with_error
#+end_src

あるいは、外部キーをnull更新する方法もある(nullableであれば)。
#+begin_src ruby
  has_many :contents, dependent: :nullify
#+end_src
** 文字列で返ってくる真偽値をbooleanオブジェクトに変換する
文字列で返ってくる真偽値を、booleanオブジェクトとして扱いとき。ActiveModelのmoduleを使用する。
言われてみるとDBでは文字列かをあまり意識せずに使える。
#+begin_src ruby
  ActiveModel::Type::Boolean.new.cast(value) == true
#+end_src
** slimで条件分岐
[[https://qiita.com/mishiwata1015/items/407e924263d698ddeaae][【Rails】Slimで入れ子になっている要素の親タグのみを分岐させる - Qiita]]
閉じタグがないため階層の上だけ条件分岐するためには特殊な書き方が必要になる。
#+begin_export html
- unless request.variant.present? && request.variant.include?(:phone)
  / PCでのみサイドバーに
  - args = [:section, class: 'sidebar']
- else
  / スマホではメインコンテンツに入れる
  - args = [:section]
= content_tag(*args)
#+end_export
* Tasks
** TODO Advanced Rails Recipe
** TODO [[https://dxd2021.cto-a.org/program/time-table/b-3][クソコード動画「Userクラス」で考える技術的負債解消の観点/DXD2021]]
クソコードから学ぶ。
** TODO loggerを自動オン
Rails console。ENVで分岐すれば本番コンソールでログレベルを上げる、ということができるはず。
** TODO [[https://railsguides.jp/][Ruby on Rails ガイド：体系的に Rails を学ぼう]]
:LOGBOOK:
CLOCK: [2021-10-10 Sun 14:09]--[2021-10-10 Sun 14:43] =>  0:34
:END:
Rails のドキュメント。
** TODO [[https://www.codewithjason.com/understanding-factory-bot-syntax-coding-factory-bot/][Understanding Factory Bot syntax by coding your own Factory Bot - Code with Jason]]
Factory Botの作り方。
** TODO Tips文書化
DEADLINE: <2021-12-26 Sun>
:LOGBOOK:
CLOCK: [2021-12-23 Thu 10:01]--[2021-12-23 Thu 10:56] =>  0:55
:END:
- 5730
* Archive
** DONE 誤字
CLOSED: [2021-09-09 木 09:18]
https://github.com/carrierwaveuploader/carrierwave/blob/a3ffc5381e70a4014b61b27b35540aa3b945910d/README.md#retry-option-for-douwload-from-remote-location

PR送信完了。一字だけ。
* References
** [[https://github.com/ankane/strong_migrations][ankane/strong_migrations: Catch unsafe migrations in development]]
READMEに安全なマイグレーションの説明がある。
** [[https://tech.speee.jp/entry/2020/06/30/110000][reg-suit によるビジュアルリグレッションテストで Rails アプリの CSS 改善サイクルが回り始めた話 - Speee DEVELOPER BLOG]]
ビジュアルリグレッションテストの運用方法。
** [[https://zenn.dev/yukito0616/articles/d3b7032e9f1e90][Only My Rails Way]]
Rails Wayの定義について。
** [[https://discuss.rubyonrails.org/][Ruby on Rails Discussions - Ruby on Rails Discussions]]
Rails開発のディスカッション。
** [[https://www.slideshare.net/ockeghem/ruby-on-rails-security-142250872][Railsエンジニアのためのウェブセキュリティ入門]]
わかりやすいスライド。
** [[https://techracho.bpsinc.jp/hachi8833/2020_05_13/91211][Rails開発者が採用面接で聞かれる想定Q&A 53問（翻訳）｜TechRacho by BPS株式会社]]
ちゃんとRailsガイドを読まないときついな。
