:properties:
:ID: 20241103T121759
:mtime:    20241110095656
:ctime:    20241103121812
:end:
#+title:      KDOC 264: 『YARV Maniacs』
#+date:       [2024-11-03 Sun 12:17]
#+filetags:   :draft:book:
#+identifier: 20241103T121759

# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか。それで本を書けと言われて書けるか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。
# 個人の感想・意思表明ではない。事実や書籍情報に基づいている

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====水準を満たす価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。
# 公表できるレベルの洞察を得られるか

# ====フロー。
# 1. 「走り書きメモ」「文献メモ」を書く
# 2. 1日1回既存のメモを見て、自分自身の研究、思考、興味にどのように関係してくるかを見る
# 3. 追加すべきものだけ追加する

* この文書のステータス
:LOGBOOK:
CLOCK: [2024-11-10 Sun 09:31]--[2024-11-10 Sun 09:56] =>  0:25
CLOCK: [2024-11-04 Mon 23:54]--[2024-11-05 Tue 00:19] =>  0:25
CLOCK: [2024-11-04 Mon 22:48]--[2024-11-04 Mon 23:13] =>  0:25
CLOCK: [2024-11-04 Mon 21:56]--[2024-11-04 Mon 22:21] =>  0:25
CLOCK: [2024-11-04 Mon 21:31]--[2024-11-04 Mon 21:56] =>  0:25
:END:
- 作成
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# チェックリスト ================
# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概略
# 内容を端的に説明する短い文
[[https://magazine.rubyist.net/articles/0006/0006-YarvManiacs.html][『YARV Maniacs』]]はRubyのVM、YARVの作者であるささだこういちが書いた記事。
* メモ

- もっとも単純なディスパッチ処理はswitch/caseで分岐させること。つぎに関数ポインタを使った例がある。命令配列に関数ポインタを入れておいて命令を取り出す

#+caption: 関数ポインタの例。そのままコピペしてきた
#+begin_src c
  #define Ia 0
  //...

  static const InsnFuncType InsnInstruction_bodies[] = {
    Ia_body, Ib_body, ..., Iz_body,
  };

  while(1){
    Instruction_bodies[iseq[pc]]();
   }
#+end_src

- switch/caseによる分岐は実際の機械語としてはif文の並びのようになる。たくさん分岐することになる。そこで、飛び先をテーブルにして、関数ポインタによる命令ディスパッチの例のように飛び先をテーブルに格納してジャンプできるようにする

#+caption: 最終的にこうなる。ダイレクトスレッデッドコードという。コピペしてきた
#+begin_src c
  loop_start:
    goto *iseq_ptr[PC];
  Ia:
    Ia_body();
    goto *iseq_ptr[PC];
  Ib:
    Ib_body();
    goto *iseq_ptr[PC];
  ...
  Iz:
    Iz_body();
    goto *iseq_ptr[PC];
#+end_src

- こういう命令ディスパッチをするプログラムをスレッデッドコードという
- ~&&ラベル名~ でラベルを値として扱う。その値としてのラベルにジャンプするには ~goto *value~ と記述する
- スレッデッドコードの利点はgotoが1個減っただけ。1命令減っただけに見えるが、さらにうれしいことがある。プロセッサの分岐予測の成功率が高くなる。switch/caseの場合は分岐予測が毎回外れるため遅い
- JITコンパイルは、VM命令の命令ディスパッチを必要としなくなる。でも実装が大変である、という
- YARVでは Rubyプログラム -> YARV命令列 -> C と変換するコンパイラを用意している。そのため命令ディスパッチ自体のオーバーヘッドは無い
- switch/case を利用した命令ディスパッチとスレッデッドコードを利用したプログラムはあまり見かけは変わらないのでマクロで書いておけば切り替えは簡単にできる。そうしているVMや処理系は多い、という

#+caption: YARV命令列
#+begin_src ruby
0003 send            :puts, 1, false, 0, <ic>
#+end_src

- puts: putsメソッドの起動を表す
- 1: 引数を1つで起動
- send命令は、引数の数分だけの値と、レシーバをスタックから取ってメソッドを起動する、という意味になる

#+caption: 何もしないプログラムは変換されない
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('true;false;123;:sym;/abc/;nil').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,29)> (catch: FALSE)
0000 putnil                                                           (   1)[Li]
0001 leave
#+end_src

#+caption: stringはputstring命令を使う
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('a = "abc"').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,9)> (catch: FALSE)
local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
[ 1] a@0
0000 putstring                              "abc"                     (   1)[Li]
0002 dup
0003 setlocal_WC_0                          a@0
0005 leave
#+end_src

- 文字列オブジェクトは破壊的な変更が可能なのでmuutableといえる。たとえばプログラム上同じ位置にあっても文字列リテラルが返すオブジェクトは毎回異なる
- putobjectは毎回同じオブジェクトをスタックトップに置く。なので文字列ではputobject命令は使えない。代わりにputstringを使う

#+caption: 要素が文字列の場合はputstring
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('["a", "b", "c"]').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,15)> (catch: FALSE)
0000 putstring                              "a"                       (   1)[Li]
0002 putstring                              "b"
0004 putstring                              "c"
0006 newarray                               3
0008 leave
#+end_src

#+caption: 要素がFixnumの場合
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('[1, 2, 3]').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,9)> (catch: FALSE)
0000 duparray                               [1, 2, 3]                 (   1)[Li]
0002 leave
#+end_src

- 要素がすべてリテラル(putobject命令で済むもの)だった場合、毎回各要素をスタックに積まなくても作るものが決まっている。duparray命令1つ、配列オブジェクトをdupしてスタックトップに積む、でよくなる

#+caption: インスタンス変数。専用の命令がある
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('@a = 1; a = @a').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,14)> (catch: FALSE)
local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
[ 1] a@0
0000 putobject_INT2FIX_1_                                             (   1)[Li]
0001 setinstancevariable                    :@a, <is:0>
0004 getinstancevariable                    :@a, <is:0>
0007 dup
0008 setlocal_WC_0                          a@0
0010 leave
#+end_src

#+caption: グローバル変数。専用の命令がある
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('$global = 1; a = $global').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,24)> (catch: FALSE)
local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
[ 1] a@0
0000 putobject_INT2FIX_1_                                             (   1)[Li]
0001 setglobal                              :$global
0003 getglobal                              :$global
0005 dup
0006 setlocal_WC_0                          a@0
0008 leave
#+end_src

#+caption: 現在のクラスを起点に探る
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('C').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,1)> (catch: FALSE)
0000 opt_getinlinecache                     9, <is:0>                 (   1)[Li]
0003 putobject                              true
0005 getconstant                            :C
0007 opt_setinlinecache                     <is:0>
0009 leave
#+end_src

#+caption: Object(トップレベル)のCを探る
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('::C').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,3)> (catch: FALSE)
0000 opt_getinlinecache                     12, <is:0>                (   1)[Li]
0003 pop
0004 putobject                              Object
0006 putobject                              true
0008 getconstant                            :C
0010 opt_setinlinecache                     <is:0>
0012 leave
#+end_src

#+caption: Cを探り、Cの中のDを探る
#+begin_src ruby :results output
puts RubyVM::InstructionSequence.compile('C::D').disasm
#+end_src

#+RESULTS:
#+begin_src
== disasm: #<ISeq:<compiled>@<compiled>:1 (1,0)-(1,4)> (catch: FALSE)
0000 opt_getinlinecache                     13, <is:0>                (   1)[Li]
0003 putobject                              true
0005 getconstant                            :C
0007 putobject                              false
0009 getconstant                            :D
0011 opt_setinlinecache                     <is:0>
0013 leave
#+end_src

- 定数の検索は、処理系実装者から見るとかなり作るのが面倒な部分になっている。コンパイル時に定数検索パスが定まらないため
- メソッド定義の探索が計算負荷が大きい。そのためキャッシュを使う。グローバルメソッドキャッシュやインラインメソッドキャッシュ

* 用語

- メソッドディスパッチ :: オブジェクト指向でいうメソッドを実際に起動する機能。Rubyだとレシーバオブジェクトがあって、メソッド名があったとき、実際にメソッドを起動するときに処理をさせること
- 命令ディスパッチ :: 命令によってそれに応じて処理をさせること

* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# この事実は自分のこのアイデアとどう整合するか。
# この現象はあの理論でどう説明できるか。
# ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# いま聞いた内容は以前に聞いたことがなかったか。
# メモ y についてメモ x はどういう意味か。
