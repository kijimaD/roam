:PROPERTIES:
:ID:       59d0554c-f2fa-4ca1-8c7a-774c68bdb036
:END:
#+title: Web Server
* 概要
Webサーバはソフトウェアの種類の1つ。HTTPに則りブラウザに対して表示を提供する。
* Memo
** MIME(マイムタイプ)
media type。ファイルの種類。

#+begin_quote
メールやホームページのファイルにくっつけて送られる「このファイルは、こんな種類のファイルですよ」な情報
#+end_quote

[[https://wa3.i-3-i.info/word15786.html][MIMEタイプ (マイムタイプ)とは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典]]
** session, cookieとは
- [[https://ips.nekotype.com/2441/][「Cookie」と「セッション」と「セッションCookie」の違い | 猫型iPS細胞研究所]]
  - cookieはWEBサーバが発行し、ブラウザが保持するキーと値。ブラウザのWEBコンソールで確認できる
  - sessionはWEBサーバで保持するキーと値
  - IDやパスワードを毎回ブラウザから送信しない。セキュリティ的に問題だから。
  - ログイン成功時にセッションとして値を保持し、ブラウザにはcookieを送信する。以降リクエストされるたびにサーバは保持されたセッションに含まれるIDと、送信されたcookieに含まれるIDを比較して認証状況を判断する。

ログインの流れ。
1. ブラウザ: ログイン成功
2. サーバ: クッキーにセッションID書き込み
3. サーバ: セッションIDを[[id:48b99bce-05ce-49af-921d-1e321e5a4f8b][Redis]]等に保存
   - key: sessionID, value: {token, userID...}
4. ブラウザ: リクエスト時にクッキーを送信
5. サーバ: 送信されたクッキーに含まれるセッションIDと、[[id:48b99bce-05ce-49af-921d-1e321e5a4f8b][Redis]]に保存されたセッションIDを比較。一致していればログイン成功

ログアウトの流れ。
1. ブラウザ: ログアウト実行
2. サーバ: [[id:48b99bce-05ce-49af-921d-1e321e5a4f8b][Redis]]からセッションID
** JWT認証
JWT(JSON Web Token)はトークンの1つ。

- [[https://blog.cloud-acct.com/posts/u-rails-jwt-userauth/][【Rails×JWT】ログイン認証解説とJWT初期設定ファイルの作成 - 独学プログラマ]]
  1. ブラウザ: ログインする
  2. サーバ: ログイン情報と一致するユーザを検索。存在すればJWTを発行し、Cookieに保存する
  3. サーバ: ブラウザにJSONを返す。有効期限とユーザオブジェクトを返す。JWTはそのものは返さない
  4. ブラウザ: JSONを保存する。保存したユーザオブジェクトをログイン中のユーザとして扱う。保持されている有効期限を、ログイン状態を維持するかの判定に使う。
* Tasks
** [[https://www.oreilly.co.jp/books/9784873118642/][O'Reilly Japan - 入門 監視]]
システム監視の解説。
** [[https://zenn.dev/rita0222/articles/13953a5dfb9698][スレッドプールの作り方]]
コードによる詳しい解説。
* Reference
** [[https://scrapbox.io/kawasima/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E5%A4%A7%E5%85%A8][アーキテクチャ大全 - kawasima]]
WEBでありがちな部品がまとめられたページ。
** [[https://qiita.com/nanasess/items/350e59b29cceb2f122b3][ログ設計指針 - Qiita]]
ログの設計指針。
** [[https://dev.classmethod.jp/articles/recommend-operation-for-bigoted-developers/][開発者が運用を経験すべき一つの理由 | DevelopersIO]]
ログはその重要性にかかわらず認識されていない。
** [[https://ja.wikipedia.org/wiki/Web%E3%82%B5%E3%83%BC%E3%83%90][Webサーバ - Wikipedia]]
* Archives
** DONE webサーバは何をしているか                                :DontKnow:
CLOSED: [2022-08-21 Sun 22:01]
:LOGBOOK:
CLOCK: [2022-08-21 Sun 21:29]--[2022-08-21 Sun 21:54] =>  0:25
CLOCK: [2022-08-21 Sun 20:48]--[2022-08-21 Sun 21:13] =>  0:25
CLOCK: [2022-08-21 Sun 20:02]--[2022-08-21 Sun 20:27] =>  0:25
CLOCK: [2022-08-21 Sun 19:29]--[2022-08-21 Sun 19:54] =>  0:25
CLOCK: [2022-08-21 Sun 17:58]--[2022-08-21 Sun 18:23] =>  0:25
CLOCK: [2022-08-21 Sun 17:26]--[2022-08-21 Sun 17:51] =>  0:25
CLOCK: [2022-08-16 Tue 19:42]--[2022-08-16 Tue 20:07] =>  0:25
CLOCK: [2022-08-14 Sun 20:32]--[2022-08-14 Sun 20:57] =>  0:25
CLOCK: [2022-08-14 Sun 20:06]--[2022-08-14 Sun 20:31] =>  0:25
:END:

[[https://doc.rust-jp.rs/book-ja/ch20-00-final-project-a-web-server.html][最後のプロジェクト：マルチスレッドのWebサーバを構築する - The Rust Programming Language 日本語版]]

シンプルなWebサーバを実装し、基本的な仕組みを理解する。

- 接続は、クライアントがサーバに接続し、サーバがレスポンスを生成し、サーバが接続を閉じるというリクエストとレスポンス全体の過程の名前
- let response = "HTTP/1.1 200 OK\r\n\r\n";にするとブラウザwebツールで200 OKが出る。適当な文字列を入れると出ない。入れた文字がそのままページとして表示された
- HTTPステータスはレスポンスの先頭行の文字列をパースして得る。文字列はプロトコルとして定義されている
- レスポンスのヘッダ以降は表示される。だから[[id:9f5b7514-d5e5-4997-81b0-bd453775415c][HTML]]を入れてレスポンスを返すと、ブラウザで表示できる
  - pumaが200を返す部分。https://github.com/kd-collective/puma/blob/e9f09ba1fe6b168bed7fff59d0bdbfd65351cf9d/lib/puma/app/status.rb#L70 当然だが実際の大きなアプリケーションでも、レスポンスを返す部分がある。本質的な部分はシンプルなことがわかる
- パスによる分岐の実態は、アプリケーションを書くうえで直感的に感じる構造とは異なる。サーバ側でパスによる分岐処理があるから表示を分けられる。パス指定されていても、リクエストパスが異なるだけで他は同じ形式のリクエストに過ぎない

*** スレッドプール

何も工夫がない場合、遅いリクエストを受けた場合ほかのリクエストも同様に待たされることになる。そうならないための仕組みがある。

- スレッドプールは、待機し、タスクを処理する準備のできた大量に生成されたスレッド。プログラムが新しいタスクを受け取ったら、プールのスレッドのどれかをタスクにあてがい、そのスレッドがタスクを処理する
- 最初のスレッドがタスクの処理を完了したら、アイドル状態のスレッドプールに戻り、新しいタスクを処理する準備ができる
- スレッドプールにより平行で接続を処理でき、サーバのスループットを向上させる
- プールのスレッド数は小さい数字に制限し、DOS攻撃から保護する
- スレッドを大量生産するのではなく、プールに固定された数のスレッドを待機させる

***  ワーカー

標準ライブラリはスレッドを生成する手段として ~thread::spawn~ を提供する。生成されるとすぐにスレッドが実行すべき何らかのコードを得る。スレッドを生成して、後ほど送信するコードを待機してほしい。

- この振る舞いを管理するスレッドと ~ThreadPool~ に新しいデータ構造を導入する。このデータ構造を Worker とよび、プール実装では一般的な用語
- ログを取ったり、デバッグする際にプールの異なるワーカーを区別できるように、各ワーカーにidも付与する
- workerは作業者という意味。ワーカースレッドが仕事を1つずつ取り、処理する。仕事がなかったらワーカスレッドは新しい仕事が届くまで待つ。
- ワーカースレッドが繰り返し仕事を実行するので、新しいスレッドを実行する必要がない。つまりリソースの消費が少ない
- ワーカースレッドが持っているフィールドは仕事のリクエストを得るためのインスタンスだけで、具体的な仕事内容は知らない
- [[https://qiita.com/yoshi-yoshi/items/06294f81756a1c07f414][『Java言語で学ぶデザインパターン(マルチスレッド編)』まとめ(その１０) - Qiita]] が参考になった
- ThreadPool > workers > thread
