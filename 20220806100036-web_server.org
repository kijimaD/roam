:PROPERTIES:
:ID:       59d0554c-f2fa-4ca1-8c7a-774c68bdb036
:END:
#+title: Web Server
* 概要
Webサーバはソフトウェアの種類の1つ。HTTPに則りブラウザに対して表示を提供する。
* Memo
* Tasks
** [[https://zenn.dev/rita0222/articles/13953a5dfb9698][スレッドプールの作り方]]
コードによる詳しい解説。
* Reference
** [[https://ja.wikipedia.org/wiki/Web%E3%82%B5%E3%83%BC%E3%83%90][Webサーバ - Wikipedia]]
* Archives
** DONE webサーバは何をしているか                                :DontKnow:
CLOSED: [2022-08-21 Sun 22:01]
:LOGBOOK:
CLOCK: [2022-08-21 Sun 21:29]--[2022-08-21 Sun 21:54] =>  0:25
CLOCK: [2022-08-21 Sun 20:48]--[2022-08-21 Sun 21:13] =>  0:25
CLOCK: [2022-08-21 Sun 20:02]--[2022-08-21 Sun 20:27] =>  0:25
CLOCK: [2022-08-21 Sun 19:29]--[2022-08-21 Sun 19:54] =>  0:25
CLOCK: [2022-08-21 Sun 17:58]--[2022-08-21 Sun 18:23] =>  0:25
CLOCK: [2022-08-21 Sun 17:26]--[2022-08-21 Sun 17:51] =>  0:25
CLOCK: [2022-08-16 Tue 19:42]--[2022-08-16 Tue 20:07] =>  0:25
CLOCK: [2022-08-14 Sun 20:32]--[2022-08-14 Sun 20:57] =>  0:25
CLOCK: [2022-08-14 Sun 20:06]--[2022-08-14 Sun 20:31] =>  0:25
:END:

[[https://doc.rust-jp.rs/book-ja/ch20-00-final-project-a-web-server.html][最後のプロジェクト：マルチスレッドのWebサーバを構築する - The Rust Programming Language 日本語版]]

シンプルなWebサーバを実装し、基本的な仕組みを理解する。

- 接続は、クライアントがサーバに接続し、サーバがレスポンスを生成し、サーバが接続を閉じるというリクエストとレスポンス全体の過程の名前
- let response = "HTTP/1.1 200 OK\r\n\r\n";にするとブラウザwebツールで200 OKが出る。適当な文字列を入れると出ない。入れた文字がそのままページとして表示された
- HTTPステータスはレスポンスの先頭行の文字列をパースして得る。文字列はプロトコルとして定義されている
- レスポンスのヘッダ以降は表示される。だから[[id:9f5b7514-d5e5-4997-81b0-bd453775415c][HTML]]を入れてレスポンスを返すと、ブラウザで表示できる
  - pumaが200を返す部分。https://github.com/kd-collective/puma/blob/e9f09ba1fe6b168bed7fff59d0bdbfd65351cf9d/lib/puma/app/status.rb#L70 当然だが実際の大きなアプリケーションでも、レスポンスを返す部分がある。本質的な部分はシンプルなことがわかる
- パスによる分岐の実態は、アプリケーションを書くうえで直感的に感じる構造とは異なる。サーバ側でパスによる分岐処理があるから表示を分けられる。パス指定されていても、リクエストパスが異なるだけで他は同じ形式のリクエストに過ぎない

*** スレッドプール

何も工夫がない場合、遅いリクエストを受けた場合ほかのリクエストも同様に待たされることになる。そうならないための仕組みがある。

- スレッドプールは、待機し、タスクを処理する準備のできた大量に生成されたスレッド。プログラムが新しいタスクを受け取ったら、プールのスレッドのどれかをタスクにあてがい、そのスレッドがタスクを処理する
- 最初のスレッドがタスクの処理を完了したら、アイドル状態のスレッドプールに戻り、新しいタスクを処理する準備ができる
- スレッドプールにより平行で接続を処理でき、サーバのスループットを向上させる
- プールのスレッド数は小さい数字に制限し、DOS攻撃から保護する
- スレッドを大量生産するのではなく、プールに固定された数のスレッドを待機させる

***  ワーカー

標準ライブラリはスレッドを生成する手段として ~thread::spawn~ を提供する。生成されるとすぐにスレッドが実行すべき何らかのコードを得る。スレッドを生成して、後ほど送信するコードを待機してほしい。

- この振る舞いを管理するスレッドと ~ThreadPool~ に新しいデータ構造を導入する。このデータ構造を Worker とよび、プール実装では一般的な用語
- ログを取ったり、デバッグする際にプールの異なるワーカーを区別できるように、各ワーカーにidも付与する
- workerは作業者という意味。ワーカースレッドが仕事を1つずつ取り、処理する。仕事がなかったらワーカスレッドは新しい仕事が届くまで待つ。
- ワーカースレッドが繰り返し仕事を実行するので、新しいスレッドを実行する必要がない。つまりリソースの消費が少ない
- ワーカースレッドが持っているフィールドは仕事のリクエストを得るためのインスタンスだけで、具体的な仕事内容は知らない
- [[https://qiita.com/yoshi-yoshi/items/06294f81756a1c07f414][『Java言語で学ぶデザインパターン(マルチスレッド編)』まとめ(その１０) - Qiita]] が参考になった
- ThreadPool > workers > thread
