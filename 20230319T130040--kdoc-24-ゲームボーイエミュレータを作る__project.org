:properties:
:ID: 20230319T130040
:mtime:    20241102180225
:ctime:    20241028101410
:end:
#+title:      KDOC 24: ゲームボーイエミュレータを作る
#+date:       [2023-03-19 Sun 13:00]
#+filetags:   :project:
#+identifier: 20230319T130040

ゲームボーイエミュレータの実装は数多くある。参考にして作る。

* memo
:LOGBOOK:
CLOCK: [2023-03-25 Sat 23:32]--[2023-03-25 Sat 23:57] =>  0:25
CLOCK: [2023-03-25 Sat 23:04]--[2023-03-25 Sat 23:29] =>  0:25
CLOCK: [2023-03-21 Tue 11:32]--[2023-03-21 Tue 11:57] =>  0:25
CLOCK: [2023-03-21 Tue 11:05]--[2023-03-21 Tue 11:30] =>  0:25
CLOCK: [2023-03-21 Tue 10:39]--[2023-03-21 Tue 11:04] =>  0:25
CLOCK: [2023-03-21 Tue 10:14]--[2023-03-21 Tue 10:39] =>  0:25
CLOCK: [2023-03-21 Tue 00:58]--[2023-03-21 Tue 01:23] =>  0:25
CLOCK: [2023-03-21 Tue 00:32]--[2023-03-21 Tue 00:57] =>  0:25
CLOCK: [2023-03-21 Tue 00:07]--[2023-03-21 Tue 00:32] =>  0:25
CLOCK: [2023-03-20 Mon 22:55]--[2023-03-20 Mon 23:20] =>  0:25
CLOCK: [2023-03-20 Mon 21:55]--[2023-03-20 Mon 22:20] =>  0:25
CLOCK: [2023-03-20 Mon 21:28]--[2023-03-20 Mon 21:53] =>  0:25
CLOCK: [2023-03-20 Mon 20:46]--[2023-03-20 Mon 21:11] =>  0:25
CLOCK: [2023-03-20 Mon 20:16]--[2023-03-20 Mon 20:41] =>  0:25
CLOCK: [2023-03-20 Mon 00:46]--[2023-03-20 Mon 01:11] =>  0:25
CLOCK: [2023-03-19 Sun 23:09]--[2023-03-19 Sun 23:34] =>  0:25
CLOCK: [2023-03-19 Sun 22:43]--[2023-03-19 Sun 23:08] =>  0:25
CLOCK: [2023-03-19 Sun 22:05]--[2023-03-19 Sun 22:30] =>  0:25
CLOCK: [2023-03-19 Sun 21:21]--[2023-03-19 Sun 21:46] =>  0:25
CLOCK: [2023-03-19 Sun 20:35]--[2023-03-19 Sun 21:00] =>  0:25
CLOCK: [2023-03-19 Sun 20:10]--[2023-03-19 Sun 20:35] =>  0:25
CLOCK: [2023-03-19 Sun 19:45]--[2023-03-19 Sun 20:10] =>  0:25
CLOCK: [2023-03-19 Sun 17:59]--[2023-03-19 Sun 18:24] =>  0:25
CLOCK: [2023-03-19 Sun 15:27]--[2023-03-19 Sun 15:52] =>  0:25
CLOCK: [2023-03-19 Sun 14:57]--[2023-03-19 Sun 15:22] =>  0:25
CLOCK: [2023-03-19 Sun 14:23]--[2023-03-19 Sun 14:48] =>  0:25
CLOCK: [2023-03-19 Sun 13:58]--[2023-03-19 Sun 14:23] =>  0:25
:END:
- [[https://github.com/bokuweb/gopher-boy][bokuweb/gopher-boy]]は[[id:7cacbaa3-3995-41cf-8b72-58d6e07468b1][Go]]で読める。最初のコミットをたどる。
- pkgconfigの問題で実行できず
  - ググった方法で実行できた
  - 機能ごとにさまざまなミニマルROMがある
  - 各ROMの画像回帰テストで動作チェックしているよう。うまい
  - go run cmd/go-boy/main.go roms/helloworld/hello.gb
- 比較的コードが少なく、ファイルが分かれているので読みやすそう
- 命令には引数(オペランド)が存在することがある
  - 引数を指定する方法は13種類ある。アドレッシングモードという
  - プログラムに埋め込んだ定数を引数にするモードやメモリアドレスを渡してそのアドレスに格納されている値を引数にするモードがある
- memory mapped IO
  - IOレジスタがCPUのメモリ空間上にマップされている。該当するアドレスを読み書きすることで、CPUはコントローラの入力を読み取ったり、PPUに出力する画像の情報を送ったり、APUから出力する音の波形を設定したりできる
  - アドレスに対応するモジュールにアクセス
  - CPUからはメモリアクセスに見える
  - このアドレスを読み書きすれば各モジュールを使える、くらいの感じ
- カセットのMemory Bank Controller
  - カセットにはメモリが積まれていて、メモリの拡張として用いる
  - セーブデータとか保存している領域っぽい
  - 確かにカセットごとに保存されてたよな
  - コントローラには種類がある
  - RAMのサイズはカセットによって異なる
  - コントローラは複数のbankで構成されていて、スイッチできる
  - コントローラにはモードがある
    - RAM優先/ROM優先
- ビット演算を復習しないといけないな。こういうとき使うんだ
  - 命令を眺める。意味はわかるが、どうしてそうなのかはよくわからない

* Tasks
** TODO GPUのヘルパー関数のテストを書く
:LOGBOOK:
CLOCK: [2023-04-30 Sun 22:42]--[2023-04-30 Sun 23:07] =>  0:25
CLOCK: [2023-04-30 Sun 22:17]--[2023-04-30 Sun 22:42] =>  0:25
CLOCK: [2023-04-04 Tue 23:15]--[2023-04-04 Tue 23:40] =>  0:25
CLOCK: [2023-04-04 Tue 22:32]--[2023-04-04 Tue 22:57] =>  0:25
CLOCK: [2023-04-04 Tue 22:06]--[2023-04-04 Tue 22:31] =>  0:25
CLOCK: [2023-04-04 Tue 21:40]--[2023-04-04 Tue 22:05] =>  0:25
CLOCK: [2023-04-04 Tue 21:14]--[2023-04-04 Tue 21:39] =>  0:25
:END:
まだあまり理解できてないところがある。
** TODO 割込のテストを書く
難しそうな部分。
** TODO CPUのテストを書く
:LOGBOOK:
CLOCK: [2023-04-29 Sat 19:43]--[2023-04-29 Sat 20:08] =>  0:25
CLOCK: [2023-04-29 Sat 19:13]--[2023-04-29 Sat 19:38] =>  0:25
:END:

- フラグあたりがよくわかってない
* Archives
** DONE バスのテストを書く
CLOSED: [2023-03-26 Sun 14:50]
:LOGBOOK:
CLOCK: [2023-03-26 Sun 14:17]--[2023-03-26 Sun 14:42] =>  0:25
CLOCK: [2023-03-26 Sun 13:44]--[2023-03-26 Sun 14:09] =>  0:25
CLOCK: [2023-03-26 Sun 13:19]--[2023-03-26 Sun 13:44] =>  0:25
CLOCK: [2023-03-26 Sun 12:44]--[2023-03-26 Sun 13:09] =>  0:25
CLOCK: [2023-03-26 Sun 12:13]--[2023-03-26 Sun 12:38] =>  0:25
CLOCK: [2023-03-26 Sun 11:48]--[2023-03-26 Sun 12:13] =>  0:25
CLOCK: [2023-03-26 Sun 11:23]--[2023-03-26 Sun 11:48] =>  0:25
:END:

完全に理解するためにテストを書く。

- リトルエンディアンだから逆に格納されているわけか
  - DEAD => AD DE
- 0x0000 に 0xA5 が格納されている
  - 0x0000は配列のインデックスで、0xA5が中に入っている値と考えられる。もちろん ハードウェア的には違うんだろうが、同じことだ
  - 中身は0〜255が入る。これらは16進数で2文字で表せる
- 書き込みしてるのだが、反映されないな
  - バンクコントローラが0の場合は、書き込み不可。ROMしかないから。コントローラによってはRAMがあったりするので、そこでは書き込める
  - まだあまりバンクコントローラについてよくわかっていない
- カートリッジのROMと、バンクコントローラのROMは違うのだろうか
- メモリマッピングを理解した。バスから0x8001番を読み込むと、VRAMの0x0001番を参照するようなことだ。実際のRead, Writeの処理はデバイスに移譲する

** DONE [[https://gihyo.jp/dp/ebook/2019/978-4-297-10822-9][動かしてわかる CPUの作り方10講 | Gihyo Digital Publishing]]
CLOSED: [2023-03-25 Sat 22:47]
:LOGBOOK:
CLOCK: [2023-03-25 Sat 22:22]--[2023-03-25 Sat 22:47] =>  0:25
CLOCK: [2023-03-25 Sat 18:03]--[2023-03-25 Sat 18:28] =>  0:25
CLOCK: [2023-03-25 Sat 17:07]--[2023-03-25 Sat 17:32] =>  0:25
CLOCK: [2023-03-21 Tue 21:43]--[2023-03-21 Tue 22:08] =>  0:25
CLOCK: [2023-03-21 Tue 21:18]--[2023-03-21 Tue 21:43] =>  0:25
CLOCK: [2023-03-21 Tue 20:43]--[2023-03-21 Tue 21:08] =>  0:25
CLOCK: [2023-03-21 Tue 20:18]--[2023-03-21 Tue 20:43] =>  0:25
CLOCK: [2023-03-21 Tue 19:52]--[2023-03-21 Tue 20:17] =>  0:25
CLOCK: [2023-03-21 Tue 18:33]--[2023-03-21 Tue 18:58] =>  0:25
CLOCK: [2023-03-21 Tue 17:55]--[2023-03-21 Tue 18:20] =>  0:25
CLOCK: [2023-03-21 Tue 17:30]--[2023-03-21 Tue 17:55] =>  0:25
CLOCK: [2023-03-21 Tue 16:54]--[2023-03-21 Tue 17:19] =>  0:25
CLOCK: [2023-03-21 Tue 16:11]--[2023-03-21 Tue 16:36] =>  0:25
CLOCK: [2023-03-21 Tue 13:19]--[2023-03-21 Tue 13:44] =>  0:25
CLOCK: [2023-03-21 Tue 12:50]--[2023-03-21 Tue 13:15] =>  0:25
CLOCK: [2023-03-21 Tue 12:19]--[2023-03-21 Tue 12:44] =>  0:25
:END:

CPUの知識が足りないので読む。

- この本で設計するシンプルなRISC型CPUの仕様
  - すべての命令は固定長で15bit
  - 機械語を格納するインストラクション・レジスタやメインメモリのプログラムにおけるデータ長も、命令と同じ長さになる
  - 2バイト(16bit)のデータ表現
    - CPUが扱うデータは2バイト(16bit)
    - 汎用レジスタやメインメモリのデータ領域のデータ長も16bitになる
    - 算術論理演算を行うALUも16bitが基本サイズ
  - 8個の汎用レジスタ
    - 命令長が15bitの制約の中で、命令の種類を表すオペレーションと、最大2つのオペランドを指定する必要がある
    - オペレーションを表す命令コードに4bit、汎用レジスタを指定するオペランドに3bitを割り当てることにする
    - なので命令の数は16個、汎用レジスタの数は8個になる
  - プログラム領域とデータ領域を分離するハーバードアーキテクチャ
    - メインメモリとレジスタ間のデータ転送は、
      - A. プログラム領域とインストラクション・レジスタ間
      - B. データ領域と汎用レジスタ間
    - プログラム領域におけるデータ長が15bit、データ領域におけるデータ長は16bitとなり、1bitのずれがある。そのため独立したデータバスとして扱うハーバードアーキテクチャを採用する
    - メモリマップドI/O
      - 回路構成をシンプルにするため、メインメモリのデータ領域に独立したアドレスを与えてI/Oを配置するメモリマップドI/Oを採用する
  - シンプルさに徹している。命令長を増やせば命令数を増やしたり、オペランド等に割り当てるビット数に余裕が生まれ、汎用レジスタの数やメモリサイズを大きくできるがやらない
- mov
  - 汎用レジスタのデータを移動(コピー)する
  - [命令コード][第1オペランド...to][第2オペランド...from]
  - toの汎用レジスタの内容を、fromの汎用レジスタにコピーする
- add
  - 汎用レジスタのデータを加算
  - [命令コード][第1オペランド...target][第2オペランド...from]
  - target + fromして、計算結果をtargetの汎用レジスタに上書きする

** DONE 命令セットを網羅する
CLOSED: [2023-03-25 Sat 17:03]
:LOGBOOK:
CLOCK: [2023-03-25 Sat 15:22]--[2023-03-25 Sat 15:47] =>  0:25
CLOCK: [2023-03-25 Sat 14:45]--[2023-03-25 Sat 15:10] =>  0:25
CLOCK: [2023-03-25 Sat 14:20]--[2023-03-25 Sat 14:45] =>  0:25
CLOCK: [2023-03-25 Sat 13:55]--[2023-03-25 Sat 14:20] =>  0:25
CLOCK: [2023-03-25 Sat 12:25]--[2023-03-25 Sat 12:50] =>  0:25
CLOCK: [2023-03-25 Sat 12:00]--[2023-03-25 Sat 12:25] =>  0:25
CLOCK: [2023-03-25 Sat 11:31]--[2023-03-25 Sat 11:56] =>  0:25
CLOCK: [2023-03-25 Sat 11:06]--[2023-03-25 Sat 11:31] =>  0:25
CLOCK: [2023-03-24 Fri 00:43]--[2023-03-24 Fri 01:08] =>  0:25
CLOCK: [2023-03-23 Thu 23:14]--[2023-03-23 Thu 23:39] =>  0:25
CLOCK: [2023-03-23 Thu 22:49]--[2023-03-23 Thu 23:14] =>  0:25
CLOCK: [2023-03-23 Thu 22:24]--[2023-03-23 Thu 22:49] =>  0:25
CLOCK: [2023-03-23 Thu 00:11]--[2023-03-23 Thu 00:36] =>  0:25
CLOCK: [2023-03-22 Wed 23:46]--[2023-03-23 Thu 00:11] =>  0:25
CLOCK: [2023-03-21 Tue 23:26]--[2023-03-21 Tue 23:51] =>  0:25
:END:

追加していく。

** CLOSE オペランドを取る関数が何かおかしい
CLOSED: [2023-03-25 Sat 17:03]

第2引数のレジスタとデータが混じっているように見える。

いや、第2引数のレジスタとデータは一部共用だから、混じっていていいんだ。

** DONE 画像によるテスト方法を確認する
CLOSED: [2023-03-28 Tue 00:14]
:LOGBOOK:
CLOCK: [2023-03-27 Mon 23:37]--[2023-03-28 Tue 00:03] =>  0:26
CLOCK: [2023-03-27 Mon 22:41]--[2023-03-27 Mon 23:06] =>  0:25
CLOCK: [2023-03-26 Sun 17:46]--[2023-03-26 Sun 18:11] =>  0:25
CLOCK: [2023-03-26 Sun 17:20]--[2023-03-26 Sun 17:45] =>  0:25
CLOCK: [2023-03-26 Sun 16:52]--[2023-03-26 Sun 17:17] =>  0:25
CLOCK: [2023-03-26 Sun 16:13]--[2023-03-26 Sun 16:38] =>  0:25
CLOCK: [2023-03-26 Sun 01:05]--[2023-03-26 Sun 01:31] =>  0:26
:END:

テストでそれぞれのROM実行結果を画像出力しているので、手動確認しなくていい。これはどうやっているのだろうか。ほかのゲーム開発にも応用できそうだ。

- そもそも画像をどうやって出しているのだろう
  - OpenGLのラッパーライブラリを使うのだが、これはエミュレータとどう絡んでいるか
  - WASMで出せたりするか
  - GPUが色情報の配列を持っている。それを画像サイズに合わせて長さと幅を設定して配置すれば画像になる
  - 3種類のレイヤがある。背景、ウィンドウ、スプライト。それらの重なり具合をうまくやって、1つの色情報の配列になる
  - skipFrameが返す画像
    - emu.next()が返す画像
      - gpu.Step()して、gpu.GetImageData()する
      - フィールドのg.imageDataのゲッター
  - 色情報の配列を描画ライブラリで書き出す
    - それだけのことだから、別に四角い白黒の文字列に置き換えても画面は表示できる

** DONE GPUのテストで画像を出力してみる
CLOSED: [2023-04-02 Sun 11:05]
:LOGBOOK:
CLOCK: [2023-04-02 Sun 00:46]--[2023-04-02 Sun 01:11] =>  0:25
CLOCK: [2023-04-02 Sun 00:21]--[2023-04-02 Sun 00:46] =>  0:25
CLOCK: [2023-04-01 Sat 23:47]--[2023-04-02 Sun 00:12] =>  0:25
CLOCK: [2023-04-01 Sat 23:05]--[2023-04-01 Sat 23:30] =>  0:25
CLOCK: [2023-04-01 Sat 22:36]--[2023-04-01 Sat 23:01] =>  0:25
CLOCK: [2023-04-01 Sat 21:57]--[2023-04-01 Sat 22:22] =>  0:25
CLOCK: [2023-04-01 Sat 21:32]--[2023-04-01 Sat 21:57] =>  0:25
CLOCK: [2023-04-01 Sat 13:48]--[2023-04-01 Sat 14:13] =>  0:25
CLOCK: [2023-04-01 Sat 13:09]--[2023-04-01 Sat 13:34] =>  0:25
CLOCK: [2023-04-01 Sat 12:40]--[2023-04-01 Sat 13:05] =>  0:25
CLOCK: [2023-04-01 Sat 11:41]--[2023-04-01 Sat 12:06] =>  0:25
CLOCK: [2023-04-01 Sat 11:16]--[2023-04-01 Sat 11:41] =>  0:25
CLOCK: [2023-04-01 Sat 10:18]--[2023-04-01 Sat 10:43] =>  0:25
CLOCK: [2023-03-31 Fri 23:35]--[2023-04-01 Sat 00:00] =>  0:25
CLOCK: [2023-03-30 Thu 23:24]--[2023-03-30 Thu 23:49] =>  0:25
CLOCK: [2023-03-30 Thu 22:53]--[2023-03-30 Thu 23:18] =>  0:25
CLOCK: [2023-03-30 Thu 22:28]--[2023-03-30 Thu 22:53] =>  0:25
CLOCK: [2023-03-30 Thu 22:00]--[2023-03-30 Thu 22:25] =>  0:25
CLOCK: [2023-03-28 Tue 23:15]--[2023-03-28 Tue 23:40] =>  0:25
CLOCK: [2023-03-28 Tue 22:34]--[2023-03-28 Tue 22:59] =>  0:25
CLOCK: [2023-03-28 Tue 00:25]--[2023-03-28 Tue 00:50] =>  0:25
CLOCK: [2023-03-26 Sun 18:23]--[2023-03-26 Sun 18:49] =>  0:26
:END:

- なんだかわからない。進まない
  - Readでは、命令を解釈している。渡されたオペコードから、返す情報を決めている。CPUと同じ感じ
  - build系はレイヤごとに色情報を作成する処理をしている
  - build系はStepから呼び出される。step上で分岐してどのbuildを使うか決めている。基本的に1つのセルに対して複数のbuildは使わない
  - 実体はOAMアドレスにあって、そこから設定だのを取り出す
  - lycは何に使ってるんだろう。ly compareのよう。割り込み判定に使ってる
- GBには画像に特殊効果を与えるラスタエフェクトをやるハードウェアはない
  - レジスタで特殊効果を与えている
- 特にテストにするような項目はなさそう
  - 画像を出してみる
  - imageDataには、何らか処理したあとの色の構造体が入っている(buildWindowTileを実行した結果とか)
  - 処理する前のデータはどこにあるのだろう
  - GPUの中にあるlcdcって何
    - GBの画面を制御するLCDC(LCDコントローラ)で、タイル単位で画面を描画するタイルは8x8のビットマップで、専用のメモリ領域に定義する
    - LCDの知識が必要
    - タイルデータはVRAM(8000から97FF)に配置されている
      - 前半はスプライトと背景、後半はオブジェクト
    - タイルマップは9800-9BFFにある
    - つまり8x8の1つ1つと、それらを使って画面を構成する2階層あるということか
  - 背景は出せた。単に行の ~g.ly~ それぞれでbuildBG()しただけ。あの緑色がついた
  - スプライトが出ない
  - タイル指定もできない
  - タイルIDが全部同じになっている
    - タイルID
    - パレットIDを固定すると、出力する色が変わった。パレットにプリセットの色が設定されていて、IDで選択するだけで色を変えられる
    - 2アドレスで1行分を担当している。2アドレスを重ね合わせて濃さを決定する。1x1は濃、1x0はやや濃、0x1はやや薄、0x0は薄
    - アドレス8000に0b1111_1110, アドレス8001に0b1111_1100の場合、1行は░░░░░░▒▓になる。
  - タイルの集合がタイルマップ

** DONE テストでスプライトを出力する
CLOSED: [2023-04-02 Sun 18:14]
:LOGBOOK:
CLOCK: [2023-04-02 Sun 17:31]--[2023-04-02 Sun 17:56] =>  0:25
CLOCK: [2023-04-02 Sun 16:52]--[2023-04-02 Sun 17:17] =>  0:25
CLOCK: [2023-04-02 Sun 16:16]--[2023-04-02 Sun 16:41] =>  0:25
CLOCK: [2023-04-02 Sun 15:51]--[2023-04-02 Sun 16:16] =>  0:25
CLOCK: [2023-04-02 Sun 11:57]--[2023-04-02 Sun 12:22] =>  0:25
CLOCK: [2023-04-02 Sun 11:32]--[2023-04-02 Sun 11:57] =>  0:25
CLOCK: [2023-04-02 Sun 11:07]--[2023-04-02 Sun 11:32] =>  0:25
:END:
スプライトを出してみる。

- paletteIDが0になっているな
  - paletteIDが0だと背景色を優先して描画されない
  - タイルIDはスプライトごとにあり、
  - パレットIDはピクセルごとにあり、実際の色を指定している
  - objPaletteが設定されていなくて、paletteIDが常に背景色のIDになっていた

* Reference
** [[http://yuma.ohgami.jp/GB-Programming-with-Shell-Script/02_tile_on_bg.html][背景にタイルを配置 | シェルスクリプトで ゲームボーイプログラミング 入門]]
LCDについて。
** [[http://gikofami.fc2web.com/][ｷﾞｺ猫でもわかるファミコンプログラミング]]
定番のエミュレータ解説サイト。一般的な仕組みはこっちで学んでおくのがよさそう。
** [[https://gbdev.io/pandocs/About.html][Foreword - Pan Docs]]
ゲームボーイの仕様。
** [[http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf][GameBoy CPU Manual]]
ゲームボーイのCPUマニュアル。

** [[https://gbdev.io/][Projects | gbdev.io]]
開発コミュニティ。
** [[https://gbdev.io/resources.html#tools][Resources | gbdev.io]]
非常に詳しい解説集。
** [[https://www.dkrk-blog.net/game/gb_dev_sprite1][GB ゲーム開発覚え書き: スプライトを動かす1 | きるこの日記帳]]
スプライトのわかりやすい説明。
** [[https://gekkio.fi/files/gb-docs/gbctr.pdf][Game Boy: Complete Technical Reference]]
詳しいリファレンス。
** [[https://w.atwiki.jp/gbspec/pages/35.html][CPU/命令セット - GB Spec - atwiki（アットウィキ）]]
命令セットの一覧。
