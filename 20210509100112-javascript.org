:PROPERTIES:
:ID:       a6980e15-ecee-466e-9ea7-2c0210243c0d
:END:
#+title: JavaScript

* JavaScript
JavaScriptはブラウザ上で動作するのを特徴とするプログラム言語。
WEB開発に多用される。多くの実装、フレームワーク、パッケージが存在する。

JavaScriptおよび取り巻く環境の難しいところ。
- 膨大な関連パッケージ(例: 標準の書き方はどれ)
- 多くの方言、フレームワーク(例: Reactをやろうとすると、同時にいくつも学ぶ必要がある)
* Memo
** スプレッド演算子
~...state~ といった記法。中身を展開するスプレッド演算子。
[[https://stackoverflow.com/questions/31048953/what-does-the-three-dots-notation-do-in-javascript][reactjs - What does the three dots notation do in Javascript? - Stack Overflow]]

↓2つは同じ意味。
#+begin_src javascript
<Modal {...this.props} title='Modal heading' animation={false}>
<Modal a={this.props.a} b={this.props.b} title='Modal heading' animation={false}>
#+end_src
** 特徴
[[https://book.yyts.org/revisiting-javascript/objects-and-classes][JavaScriptのオブジェクトとクラス - サバイバルTypeScript-TypeScript入門]]

#+begin_quote
JavaScriptの特徴はオブジェクトリテラル{}という記法を用いて、簡単にオブジェクトを生成できる点です。

JavaやPHPなどの言語では、オブジェクトを生成するにはまずクラスを定義し、そのクラスを元にインスタンスを作るのが普通ですが、JavaScriptはクラス定義がなくてもこのようにオブジェクトリテラルを書くと、オブジェクトをインラインで作れます。
オブジェクトリテラルがあるおかげで、JavaScriptでは自由度の高いコードが書けるようになっています。
#+end_quote

#+begin_src javascript
// 空っぽのオブジェクトを生成
const object = {};

// プロパティを指定しながらオブジェクトを生成
const person = { name: "Bob", age: 25 };
#+end_src

- メソッド :: オブジェクトに関連づいた関数のことです。

#+begin_src javascript
const object = {
  // キーと値に分けて書いたメソッド定義
  printHello1: function () {
    console.log("Hello");
  },
  // 短い構文を用いたメソッド定義
  printHello2() {
    console.log("Hello");
  },
};
#+end_src

#+begin_quote
JavaやPHPでは、オブジェクトのフィールドとメソッドははっきり区別されます。
一方、JavaScriptではその区別はきっちりしていません。Javaで言うところの
メソッドとフィールドは、JavaScriptでは同じように扱われます。たとえば、
メソッドにnullを代入することで、フィールドに変えてしまうこともできます。
#+end_quote

#+begin_quote
このようにclassでクラスを定義し、newでインスタンスを生成するスタイルは、
JavaやPHP、Rubyなどと使用感がよく似ています。

JavaScriptのクラスの特徴は、クラスもオブジェクトの一種というところです。
オブジェクトとは、プロパティの集合体だと前述しましたが、クラスもオブジェ
クトなのでプロパティの集合体としての性質を持ちます。したがって、定義し
たクラスはプロパティを追加したり、変更したりできます。
#+end_quote

#+begin_src javascript
const myObject = {};
myObject.key = "value"; // プロパティを追加
​class MyClass {}
MyClass.key = "value"; // プロパティを追加
#+end_src

ほかの言語ではクラスを後から変更できない。
#+begin_src typescript
  interface Person {
    name: string;
    age: number;
  }
#+end_src

インターフェースでの型ガードを自前で実装する必要がある。
#+begin_src typescript
  type UnKnownObject<T extends object> = {
    [P in keyof T]: unknown;
  };

  function isStudent(obj: unknown): obj is Student {
    if (typeof obj !== 'object') {
      return false;
    }
    if (obj === null) {
      return false;
    }
    const {
      name,
      age,
      grade
    } = obj as UnKnownObject<Student>;
    if (typeof name !== 'string') {
      return false;
    }
    if (typeof age !== 'number') {
      return false;
    }
    if (typeof grade !== 'number') {
      return false;
    }
    return true;
  }
#+end_src
** 配列
- 配列を処理するときはやりたいことに応じて関数を選択します。するとやりたいことが明確になるのでわかりやすくもなります。除去したときは`filter()`、新しい配列を作るときは`map()`という感じです。
** コールバック関数
- コールバック関数: 他の関数に引数として渡す関数のことです。
[[https://sbfl.net/blog/2019/02/08/javascript-callback-func/][JavaScriptの「コールバック関数」とは一体なんなのか]]
** Eslint無視の方法
#+begin_src json
 "rules": {
     "comma-dangle": "error",
     "require-yield": "error",
     "no-unused-vars": "off",
     "no-undef": "off",
 },
#+end_src

などと書きます。
** クラスを使わずにモジュール分割する
#+begin_src javascript
  var Msg = (function() {
    function test() {
    }
  }
  Msg.test()
#+end_src
** 命名の意味
 - ~_~ で始まるのはプライベートメソッドです。言語によっては未使用変数ということもあります。
** 関数宣言と関数式
2つの関数宣言の方法があります。

#+begin_src javascript
// 関数宣言
function hello() {
  return "hello";
}
#+end_src

#+begin_src javascript
// 関数式で関数を定義
let hello = function () {
    return "hello";
}; //←セミコロン
#+end_src
** 2つの関数式の書き方
関数式には2つの書き方があります。

#+begin_src javascript
// function式を用いた関数式
const hello = function (name) {
  return `Hello, ${name}!`;
};

// アロー関数の関数式
const hello = (name) => {
  return `Hello, ${name}!`;
};
#+end_src

短く書けるのでアロー関数が好まれます。
** NodeList
 - NodeList - https://developer.mozilla.org/ja/docs/Web/API/NodeList
 - text node: タグに囲まれたもの。 ~<p>これ</p>。~
 - element node: ~<p>や、</p>~
 - DOMツリー: ブラウザがアクセスしてHTMLを解析すると文書の内容を表すオブジェクトのツリー構造が構築されます。これがDOMツリーです。DOMツリーを形成する1つ1つのオブジェクトがノードです。さらに子のオブジェクトを持っている可能性があります。
https://qiita.com/KDE_SPACE/items/e21bb31dd4d9c162c4a6
** package.json
パッケージを理解するために不可欠です。
*** scripts
makeのようなもの。
#+begin_src shell
npm run <タスク名>
#+end_src
で実行できる。

#+begin_src json
  "scripts": {
      "build": "NODE_ENV=production babel src --out-dir lib --source-maps",
      "watch": "babel src --out-dir lib --watch --source-maps",
      "prepublish": "npm run --if-present build",
      "test": "mocha --require @babel/register test/*test.js"
  }
#+end_src
*** files
npm installされたときに展開されるファイル、実行されるファイルを指定する。

#+begin_src json
  "main": "lib/index.js",
  "files": [
      "lib",
      "src"
  ],
#+end_src

srcをコンパイルしてlibに格納、パッケージとしてはこちらを使用する、みたいなことを指定する。はず。
*** GitHubリポジトリから読み込むとき
#+begin_src shell
  npm install git@github.com:kijimaD/textlint-plugin-org#develop
#+end_src
** .babelrc
babelの設定。presetは使うbabelと合わせる必要がある。
#+begin_src json
{
  "presets": [
      "@babel/preset-env"
  ],
  "env": {
    "development": {
      "presets": [
          "jsdoc-to-assert",
          "power-assert"
      ]
    }
  }
}
#+end_src
** .eslintrc
*** extends

事前にnode i airbnb-baseしておいて
.eslintrcに追加するとルールセットを追加できる。
#+begin_src json
"extends": "airbnb-base",
#+end_src
** パッケージ関連の言葉
ややこしい。
*** npm パッケージマネージャ

package.jsonに書かれた設定でいろいろ実行。
パッケージインストール、アップデート、タスク実行、などいろいろ。
パッケージをインストールするときには、これが実行されてコンパイルされて使える状態になってたりする。

#+begin_src shell
  npm i
#+end_src

パッケージ内のコマンドを実行する。おそらくbundle execとかと同じ。

#+begin_src shell
  npx lint
#+end_src
*** node 実行環境

#+begin_src shell
  node # repl起動
#+end_src

#+begin_src shell
  node -v
#+end_src

本体をバージョンアップしても反映されないときは実行場所を確認する。
nでバージョンしても、読んでるのはnvmだったりする。.bash_profileなどを確認。
*** 実際にinstallしてCIで確かめることはできないのか
プラグイン本体でテストしてるが、実際にnpm installするわけではないので依存パッケージ検知できないことがある。
ローカルでクリーンインストールでもglobalにインストールしてたりしてるので検知できないのだろう。
** 便利コマンド
ファイルに更新があったらテスト実行する。超便利。
#+begin_src shell
npm test -- --watch
#+end_src
** 役立つ情報
充実したテキストが公開されています。

- https://book.yyts.org/
- http://typescript.ninja/typescript-in-definitelyland/index.html
- https://future-architect.github.io/typescript-guide/index.html
