#+title: JavaScript

* JavaScript
JavaScriptおよび取り巻く環境の難しいところ。
- 膨大な関連パッケージ(例: 標準の書き方はどれ)
- 多くの方言、フレームワーク(例: Reactをやろうとすると、同時にいくつも学ぶ必要がある)
** 特徴
[[https://book.yyts.org/revisiting-javascript/objects-and-classes][JavaScriptのオブジェクトとクラス - サバイバルTypeScript-TypeScript入門]]

#+begin_quote
JavaScriptの特徴はオブジェクトリテラル{}という記法を用いて、簡単にオブジェクトを生成できる点です。

JavaやPHPなどの言語では、オブジェクトを生成するにはまずクラスを定義し、そのクラスを元にインスタンスを作るのが普通ですが、JavaScriptはクラス定義がなくてもこのようにオブジェクトリテラルを書くと、オブジェクトをインラインで作れます。
オブジェクトリテラルがあるおかげで、JavaScriptでは自由度の高いコードが書けるようになっています。
#+end_quote

#+begin_src javascript
// 空っぽのオブジェクトを生成
const object = {};

// プロパティを指定しながらオブジェクトを生成
const person = { name: "Bob", age: 25 };
#+end_src

- メソッド :: オブジェクトに関連づいた関数のことです。

#+begin_src javascript
const object = {
  // キーと値に分けて書いたメソッド定義
  printHello1: function () {
    console.log("Hello");
  },
  // 短い構文を用いたメソッド定義
  printHello2() {
    console.log("Hello");
  },
};
#+end_src

#+begin_quote
JavaやPHPでは、オブジェクトのフィールドとメソッドははっきり区別されます。
一方、JavaScriptではその区別はきっちりしていません。Javaで言うところの
メソッドとフィールドは、JavaScriptでは同じように扱われます。たとえば、
メソッドにnullを代入することで、フィールドに変えてしまうこともできます。
#+end_quote

#+begin_quote
このようにclassでクラスを定義し、newでインスタンスを生成するスタイルは、
JavaやPHP、Rubyなどと使用感がよく似ています。

JavaScriptのクラスの特徴は、クラスもオブジェクトの一種というところです。
オブジェクトとは、プロパティの集合体だと前述しましたが、クラスもオブジェ
クトなのでプロパティの集合体としての性質を持ちます。したがって、定義し
たクラスはプロパティを追加したり、変更したりできます。
#+end_quote

#+begin_src javascript
const myObject = {};
myObject.key = "value"; // プロパティを追加
​class MyClass {}
MyClass.key = "value"; // プロパティを追加
#+end_src

ほかの言語ではクラスを後から変更できない。
#+begin_src typescript
  interface Person {
    name: string;
    age: number;
  }
#+end_src

インターフェースでの型ガードを自前で実装する必要がある。
#+begin_src typescript
  type UnKnownObject<T extends object> = {
    [P in keyof T]: unknown;
  };

  function isStudent(obj: unknown): obj is Student {
    if (typeof obj !== 'object') {
      return false;
    }
    if (obj === null) {
      return false;
    }
    const {
      name,
      age,
      grade
    } = obj as UnKnownObject<Student>;
    if (typeof name !== 'string') {
      return false;
    }
    if (typeof age !== 'number') {
      return false;
    }
    if (typeof grade !== 'number') {
      return false;
    }
    return true;
  }
#+end_src
** 配列
- 配列を処理するときはやりたいことに応じて関数を選択します。するとやりたいことが明確になるのでわかりやすくもなります。除去したときは`filter()`、新しい配列を作るときは`map()`という感じです。
** コールバック関数
- コールバック関数: 他の関数に引数として渡す関数のことです。
[[https://sbfl.net/blog/2019/02/08/javascript-callback-func/][JavaScriptの「コールバック関数」とは一体なんなのか]]
** Eslint無視の方法
#+begin_src json
 "rules": {
     "comma-dangle": "error",
     "require-yield": "error",
     "no-unused-vars": "off",
     "no-undef": "off",
 },
#+end_src

などと書きます。
** クラスを使わずにモジュール分割する
#+begin_src javascript
  var Msg = (function() {
    function test() {
    }
  }
  Msg.test()
#+end_src
** 命名の意味
 - ~_~ で始まるのはプライベートメソッドです。言語によっては未使用変数ということもあります。
** 関数宣言と関数式
2つの関数宣言の方法があります。

#+begin_src javascript
// 関数宣言
function hello() {
  return "hello";
}
#+end_src

#+begin_src javascript
// 関数式で関数を定義
let hello = function () {
    return "hello";
}; //←セミコロン
#+end_src
** 2つの関数式の書き方
関数式には2つの書き方があります。

#+begin_src javascript
// function式を用いた関数式
const hello = function (name) {
  return `Hello, ${name}!`;
};

// アロー関数の関数式
const hello = (name) => {
  return `Hello, ${name}!`;
};
#+end_src

短く書けるのでアロー関数が好まれます。
** NodeList
 - NodeList - https://developer.mozilla.org/ja/docs/Web/API/NodeList
 - text node: タグに囲まれたもの。 ~<p>これ</p>。~
 - element node: ~<p>や、</p>~
 - DOMツリー: ブラウザがアクセスしてHTMLを解析すると文書の内容を表すオブジェクトのツリー構造が構築されます。これがDOMツリーです。DOMツリーを形成する1つ1つのオブジェクトがノードです。さらに子のオブジェクトを持っている可能性があります。
https://qiita.com/KDE_SPACE/items/e21bb31dd4d9c162c4a6
** package.json
パッケージを理解するために不可欠です。
*** scripts
makeのようなもの。
#+begin_src shell
npm run <タスク名>
#+end_src
で実行できる。

#+begin_src json
  "scripts": {
      "build": "NODE_ENV=production babel src --out-dir lib --source-maps",
      "watch": "babel src --out-dir lib --watch --source-maps",
      "prepublish": "npm run --if-present build",
      "test": "mocha --require @babel/register test/*test.js"
  }
#+end_src
*** files
npm installされたときに展開されるファイル、実行されるファイルを指定する。

#+begin_src json
  "main": "lib/index.js",
  "files": [
      "lib",
      "src"
  ],
#+end_src

srcをコンパイルしてlibに格納、パッケージとしてはこちらを使用する、みたいなことを指定する。はず。
*** GitHubリポジトリから読み込むとき
#+begin_src shell
  npm install git@github.com:kijimaD/textlint-plugin-org#develop
#+end_src
** .babelrc
babelの設定。presetは使うbabelと合わせる必要がある。
#+begin_src json
{
  "presets": [
      "@babel/preset-env"
  ],
  "env": {
    "development": {
      "presets": [
          "jsdoc-to-assert",
          "power-assert"
      ]
    }
  }
}
#+end_src
** .eslintrc
*** extends

事前にnode i airbnb-baseしておいて
.eslintrcに追加するとルールセットを追加できる。
#+begin_src json
"extends": "airbnb-base",
#+end_src
** パッケージ関連の言葉
ややこしい。
*** npm パッケージマネージャ

package.jsonに書かれた設定でいろいろ実行。
パッケージインストール、アップデート、タスク実行、などいろいろ。
パッケージをインストールするときには、これが実行されてコンパイルされて使える状態になってたりする。

#+begin_src shell
  npm i
#+end_src

パッケージ内のコマンドを実行する。おそらくbundle execとかと同じ。

#+begin_src shell
  npx lint
#+end_src
*** node 実行環境

#+begin_src shell
  node # repl起動
#+end_src

#+begin_src shell
  node -v
#+end_src

本体をバージョンアップしても反映されないときは実行場所を確認する。
nでバージョンしても、読んでるのはnvmだったりする。.bash_profileなどを確認。
*** 実際にinstallしてCIで確かめることはできないのか
プラグイン本体でテストしてるが、実際にnpm installするわけではないので依存パッケージ検知できないことがある。
ローカルでクリーンインストールでもglobalにインストールしてたりしてるので検知できないのだろう。
** 便利コマンド
ファイルに更新があったらテスト実行する。超便利。
#+begin_src shell
npm test -- --watch
#+end_src
** 役立つ情報
充実したテキストが公開されています。

- https://book.yyts.org/
- http://typescript.ninja/typescript-in-definitelyland/index.html
- https://future-architect.github.io/typescript-guide/index.html
* TypeScript
** 継承
クラス継承はextendsで。

#+begin_src javascript
class Parent {}
class Child extends Parent {}
#+end_src
** インターフェース
[[https://book.yyts.org/features/interfaces][インターフェース (Interfaces) - サバイバルTypeScript-TypeScript入門]]

#+begin_quote
TypeScriptにはabstract修飾子があり抽象クラスを表現できます。
#+end_quote
** 抽象クラス
[[https://book.yyts.org/revisiting-javascript/objects-and-classes][JavaScriptのオブジェクトとクラス - サバイバルTypeScript-TypeScript入門]]

#+begin_quote
avaやPHPなどの言語では、abstract修飾子を使って抽象クラスを定義できます。
抽象クラスは、直接インスタンスを作れないクラスのことです。JavaScriptに
は抽象クラスを定義する構文はありません。
#+end_quote
** アクセス修飾子
#+begin_quote
JavaやPHPなどの言語では、フィールドやメソッドにprivate, protected,
publicを指定できます。JavaScriptでもprivateのようなプロパティを実現する
ためにプライベートクラスフィールドという仕様が実験的に導入されはじめて
はいますが、現状はJavaのようなアクセス修飾子はありません。

TypeScriptにはJava風のアクセス修飾子があります。TypeScriptのアクセス修
飾子については「クラス」をご覧ください。
#+end_quote
** プロトタイプベース
[[https://book.yyts.org/revisiting-javascript/prototype-based][プロトタイプベース - サバイバルTypeScript-TypeScript入門]]

#+begin_quote
- プロトタイプベースとはどういう考え方なのか？
- プロトタイプベースのJavaScriptは、クラスベースのPHPやJavaとどんなとこ
  ろが違う？
- なぜJavaScriptはプロトタイプベースを採用したのか？
- プロトタイプベースの利点は何か？
#+end_quote

こういう疑問から始めるのはいいな。

#+begin_quote
オブジェクト指向プログラミング(OOP)では、オブジェクトを扱います。オブジェ
クトを扱う以上は、オブジェクトを生成する必要があります。

しかし、オブジェクトの生成方式は、OOPで統一的な決まりはありません。言語
によって異なるのです。言語によりオブジェクト生成の細部は異なりますが、
生成方法は大きく分けて「クラスベース」と「プロトタイプベース」がありま
す。
#+end_quote

オブジェクト思考プログラミング言語ではクラス作成 → クラス.newしてインスタンスを作成して目的を達成する。
オブジェクトの素となるのがクラスだから、クラスベースと言う。

#+begin_quote
一方のJavaScriptのオブジェクト生成はプロトタイプベースです。プロトタイ
プベースの特徴は、クラスのようなものが無いこところです。(あったとしても
クラスもオブジェクトの一種だったりと特別扱いされていない)
#+end_quote
** 振る舞い
[[https://book.yyts.org/features/primitive-types][プリミティブ型 (Primitive Types) - サバイバルTypeScript-TypeScript入門]]

#+begin_quote
振る舞いがないとはメソッドを持たないことです。
#+end_quote

#+begin_quote
null.toString();

意図せずこのようにしてしまい実行時エラーになってしまった経験はあるかと
思います。これはnullがtoString()という振る舞いを持っていないことに起因
します。

とはいうもののJavaScriptにおいてプリミティブ型の多くはラッパークラスを
持っています。ラッパークラスを持つプリミティブ型の値はメソッド呼び出し
があれば実行時に、対応するラッパークラスのインスタンスに変換されるため、
あたかもプリミティブ型が振る舞いを持つように見え、またそのように使うこ
とができます。これはJavaを使われている方にとってはおなじみのAutoboxing
というJavaScript の言語機能です。
#+end_quote
** バッククォートリテラル
- 改行できる
- 変数展開できる
#+begin_src typescript
  `console.log(`
hello
world
!!`);
#+end_src
** anyを禁止する
#+begin_quote
TypeScriptのプロジェクトを作る時に必要なtsconfig.jsonにはこのany型の使
用を防ぐためのオプションとしてnoImplicitAnyがあります。既存の
JavaScriptのプロジェクトをTypeScriptに置き換えていくのではなく、スクラッ
チの状態からTypeScriptで作るのであればこの設定を入れるとよいでしょう。
#+end_quote
** 分割代入
#+begin_src typescript
  type TopSecret = {
    height: number;
    weight: number;
  };
  ​function bmi({height, weight}: TopSecret): number {
    const mHeight: number = height / 100.0;
    return weight / (mHeight ** 2);
  }

  bmi({height: 170, weight: 65});
  bmi({weight: 65, height: 170});
#+end_src
** タイプエイリアス
#+begin_src typescript
  type Person = {
    surname: string;
    givenname: string;
  };
  const person: Person = {
    surname: 'Faure',
    givenName: 'Gabriel'
  };

  type Parents = {
    mother: Person;
    father: Person;
  };
  type Family = {
    parents: Parents;
    children: Person[];
    grandparents: Parents[];
  }
  const family: Family = {...};
#+end_src
** オブジェクト内の関数定義
オブジェクトが持つメソッドの定義の方法。
#+begin_src typescript
  type A = {
    merge: (arg1: string, arg2: string) => string;
  };
  type B = {
    merge(arg1: string, arg2: string): string;
  }
#+end_src
** プリミティブ型タイプエイリアス
#+begin_src typescript
  type Surname = string;
  type GivenName = string;
  type Person = {
    surname: Surname;
    givenName: GivenName;
  }
#+end_src

#+begin_src typescript
  const surname: Surname = 'Faure';
  const givenName: GivenName = 'Gabriel';
  const person: Person = {
    surname: givenName,
    givenName: surname
  }
#+end_src

#+begin_src typescript
  type SystemSupportLanguage = 'en' | 'tr' | 'it' | 'es';
#+end_src

~?~ をつけると選択可。
#+begin_src typescript
  type = Person = {
    surname: string;
    middleName?: string;
    givenName: string;
  }
#+end_src

readonly
#+begin_src typescript
  type Person = {
    readOnly surname: string;
    givenName: string;
  };
#+end_src

入れ子までreadonlyにするわけではない。
** インデックス型
#+begin_src typescript
  type Butterfly = {
    [key: string] : string;
  };

  const butterflies: Butterfly = {
    en: 'Butterfly',
    fr: 'Papillon',
    it: 'Farfalla',
    es: 'Mariposa',
    de: 'Schmetterling'
  };
#+end_src
** Mapped type
#+begin_src typescript
  type SystemSupportLanguage = 'en' | 'fr' | 'it' | 'es';
#+end_src

#+begin_src typescript
  const butterflies: Butterfly = {
    en: 'Butterfly',
    fr: 'Papillon',
    it: 'Farfalla',
    es: 'Mariposa',
    de: 'Schmetterling'
  };
// deでエラーになる
#+end_src
** オブジェクト
#+begin_src typescript
  const pokemon = {
    name: 'pikachu',
    no: 25,
    genre: 'mouse pokemon',
    height: 0.4,
    weight: 6.0,
  };
#+end_src

オブジェクト型はプリミティブ型以外の総称。

#+begin_src typescript
  const pikachu: object = {
    name: 'pikachu',
    no: 25,
    genre: 'mouse pokemon',
    height: 0.4,
    weight: 6.0,
  };

  const pokemon: object = new Pokemon{
    'pikachu',
    25,
    'mouse pokemon',
    0.4,
    6.0
  };

  const increment: object = i => i + 1;
#+end_src

⚠object型を与えた変数はその変数の持っているプロパティ、メソッドに対してアクセスできない。

#+begin_src typescript
  pikachu.no;
  // error
#+end_src

オブジェクトのプロパティは上書き可能。readonlyにするなどが必要。
** 分割代入
#+begin_src typescript
  const {
    name,
    no,
    genre
  }: Wild = safari();
#+end_src
** タイプエイリアスとインターフェースのどちらを使うか
** インターフェース
