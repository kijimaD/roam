:PROPERTIES:
:ID:       e5663529-8095-4fc8-8fb5-500dd4471a73
:mtime:    20241102180404 20241028101410
:ctime:    20211107104950
:END:
#+title: Linter
* 概要
Linterとは、静的にプログラムを解析するツール。プログラムにおける解析ツールの総称。実行はできるがエラーにつながる書き方をチェックしてくれたり、チームでの書き方を揃えるのに使う。

一般的にはプログラム言語が対象だが、自然言語に対するlint([[id:d3394774-aba5-4167-bd18-f194eb2bd9ed][TextLint]])も存在する。プログラム言語それぞれでツールが存在する。

- ESLint :: [[id:a6980e15-ecee-466e-9ea7-2c0210243c0d][JavaScript]], [[id:ad1527ee-63b3-4a9b-a553-10899f57c234][TypeScript]]におけるLint
- Rubocop :: [[id:cfd092c4-1bb2-43d3-88b1-9f647809e546][Ruby]]におけるLint。
* Memo
** できることの方向性

静的解析によってできることは多い。

- 特定の書き方を検知する
- コードの数値化
- 自動修正
- 静的解析を助けるメタツール
  - より深い理解につながる

** TODO [[https://docs.google.com/presentation/d/1I4pHnzV2dFOMbRcpA-XD0TaLcX6PBKpls6WxGHoMjOg/edit#slide=id.g80ffbfd5e3_0_168][14. 静的解析とコード生成 - Google Slides]]
:LOGBOOK:
CLOCK: [2023-03-04 Sat 15:26]--[2023-03-04 Sat 15:51] =>  0:25
CLOCK: [2023-03-04 Sat 14:52]--[2023-03-04 Sat 15:17] =>  0:25
CLOCK: [2023-03-04 Sat 14:27]--[2023-03-04 Sat 14:52] =>  0:25
CLOCK: [2023-03-04 Sat 11:55]--[2023-03-04 Sat 12:20] =>  0:25
CLOCK: [2023-03-04 Sat 11:28]--[2023-03-04 Sat 11:53] =>  0:25
CLOCK: [2023-03-03 Fri 23:11]--[2023-03-03 Fri 23:36] =>  0:25
:END:

メモ。

静的開発ツール開発の流れ。

#+begin_src mermaid :file images/20230226004543-H6jQpJeEsi.png
  flowchart LR

  開始 -->|Goファイル| 字句解析
  字句解析 -->|トークン| 構文解析
  構文解析 -->|抽象構文木| 型チェック
  構文解析 -->|抽象構文木| 自作部分
  型チェック -->|型情報| 自作部分
#+end_src

#+RESULTS:
[[file:images/20230226004543-H6jQpJeEsi.png]]

[[id:7cacbaa3-3995-41cf-8b72-58d6e07468b1][Go]]における静的解析のフェーズ。

1. 構文解析
2. 型チェック
3. ~静的単一代入形式~
4. ポインタ解析

言語仕様を読む。

- 抽象構文木を扱うためにGoの構文に詳しくなる
  - [[https://go.dev/ref/spec][言語仕様書]]
  - EBNFを読む
  - 構文を深く理解すれば抽象構文木を自由に扱える
    - どういうノードで構成されているか
    - どういう情報がどういうノードから取得できるか

使い方。

- Preorderはインターフェース型でフィルタできない
- ast.Walkは探索アルゴリズムを切り替えるときに使う
  - visitorインターフェースがアルゴリズム部分
- ノードの置換はApply
- スコープを取得できる

** やること

静的解析で何ができる、の勘所がないのでいくつか作ってみる。ベースがあれば、何かやっているときにひらめくだろう。[[https://docs.google.com/presentation/d/1I4pHnzV2dFOMbRcpA-XD0TaLcX6PBKpls6WxGHoMjOg/edit#slide=id.g80ffbfd5e3_0_168][14. 静的解析とコード生成 - Google Slides]]を参考にしている。

- [X] プライベートだけどタグがついてるフィールドを探す
- [X] 引数をカウント
- [ ] どこからも呼ばれてないパッケージ関数を見つける
- どこからも呼ばれてない識別子を見つける
- int型の式を見つける
- 名前の短いパッケージ変数を探す
- [X] コンテキストを構造体に保持しているのを探す
- サブテストでt.Parallel()を呼び出しているのに親テストで呼び出していないケースを探す
- knifeを使ってコード生成する
- 構造体のフィールドのgetter, setterを作る
  - タグがつけられているものだけ
- GOSSAFUNCを指定してSSA形式を確認する
- godump ASTとSSAのダンプを行うCLIツール
- 使われていない引数を探す
- 自由変数の値を変更しているコードを見つける
- 関数が呼び出されているか

* Tasks
** TODO すべての式・文を使用しているかの判定ツール

- テストで生成する用。いろは歌的にすべてのnodeが登場しているのを確かめる。
- 学ぶ用。すべてのnodeの例を自分で書いて確かめる用

** TODO ast.goを読む

気づいたところを書く。

- interfaceのNodeは、Pos()とEnd()で構成されている。ファイルでの開始位置、終了位置
- Nodeには3種類ある
  - Stmt node 文
  - Expr node 式
  - Decl node 定義

* Reference
** [[https://github.com/dustinspecker/awesome-eslint][dustinspecker/awesome-eslint: A list of awesome ESLint plugins, configs, etc.]]
eslintのplugin集。
種類が多い。
* Archives
** DONE オリジナルで作ったやつを複数走らせる方法がわからない
CLOSED: [2023-03-01 Wed 23:21]
:PROPERTIES:
:Effort:   1:00
:END:
:LOGBOOK:
CLOCK: [2023-03-01 Wed 22:39]--[2023-03-01 Wed 23:04] =>  0:25
CLOCK: [2023-03-01 Wed 21:31]--[2023-03-01 Wed 21:56] =>  0:25
:END:

#+caption: だめな書き方
#+begin_src go
  unitchecker.Main(trashcomment.Analyzer)
  unitchecker.Main(gophersample.Analyzer)
#+end_src

↑だと先に定義した1つ(つまりtrashcomment)しか実行できない。

unitcheckerは引数に複数のAnalyzerを取って実行できる。

#+caption: 正しい
#+begin_src go
  unitchecker.Main(trashcomment.Analyzer, gophersample.Analyzer)
#+end_src

** DONE 1つオリジナルで実装してみる
CLOSED: [2023-03-01 Wed 00:34]
:LOGBOOK:
CLOCK: [2023-02-28 Tue 23:05]--[2023-02-28 Tue 23:30] =>  0:25
CLOCK: [2023-02-28 Tue 22:40]--[2023-02-28 Tue 23:05] =>  0:25
CLOCK: [2023-02-28 Tue 22:15]--[2023-02-28 Tue 22:40] =>  0:25
CLOCK: [2023-02-28 Tue 21:50]--[2023-02-28 Tue 22:15] =>  0:25
:END:

無意味なコメントを検知してみる。
** DONE 引数をカウントする
CLOSED: [2023-03-04 Sat 19:07]
:PROPERTIES:
:Effort:   2:00
:END:
:LOGBOOK:
CLOCK: [2023-03-04 Sat 18:22]--[2023-03-04 Sat 18:47] =>  0:25
CLOCK: [2023-03-04 Sat 17:37]--[2023-03-04 Sat 18:02] =>  0:25
CLOCK: [2023-03-03 Fri 00:18]--[2023-03-03 Fri 00:43] =>  0:25
CLOCK: [2023-03-02 Thu 23:21]--[2023-03-02 Thu 23:46] =>  0:25
CLOCK: [2023-03-02 Thu 22:53]--[2023-03-02 Thu 23:18] =>  0:25
CLOCK: [2023-03-02 Thu 21:55]--[2023-03-02 Thu 22:20] =>  0:25
CLOCK: [2023-03-02 Thu 00:37]--[2023-03-02 Thu 01:02] =>  0:25
CLOCK: [2023-03-02 Thu 00:11]--[2023-03-02 Thu 00:36] =>  0:25
CLOCK: [2023-03-01 Wed 23:24]--[2023-03-01 Wed 23:49] =>  0:25
CLOCK: [2023-03-01 Wed 21:58]--[2023-03-01 Wed 22:23] =>  0:25
:END:

引数が超えると警告する。
** DONE 配信方法を考える
CLOSED: [2023-03-07 Tue 21:37]
:LOGBOOK:
CLOCK: [2023-03-01 Wed 00:41]--[2023-03-01 Wed 01:06] =>  0:25
:END:

オリジナルで作ったけど、それらをひとまとめにして簡単に利用できるようにする。1つにインポートしてまとめて、ビルドしてコンテナに入れればいい。
** DONE ASTをダンプする方法を探す
CLOSED: [2023-03-11 Sat 11:08]
:LOGBOOK:
CLOCK: [2023-03-07 Tue 23:25]--[2023-03-07 Tue 23:50] =>  0:25
CLOCK: [2023-03-07 Tue 22:52]--[2023-03-07 Tue 23:17] =>  0:25
CLOCK: [2023-03-07 Tue 22:26]--[2023-03-07 Tue 22:51] =>  0:25
:END:

よく使うのでツール化する。
** DONE コンテキストを構造体に保持しているのを探す
CLOSED: [2023-03-11 Sat 13:48]
:LOGBOOK:
CLOCK: [2023-03-11 Sat 12:32]--[2023-03-11 Sat 12:57] =>  0:25
CLOCK: [2023-03-11 Sat 12:07]--[2023-03-11 Sat 12:32] =>  0:25
CLOCK: [2023-03-11 Sat 11:34]--[2023-03-11 Sat 11:59] =>  0:25
CLOCK: [2023-03-11 Sat 11:09]--[2023-03-11 Sat 11:34] =>  0:25
CLOCK: [2023-03-07 Tue 21:54]--[2023-03-07 Tue 22:19] =>  0:25
:END:

コンテキストを探す。

1. 構造体である
2. フィールドの型がそれぞれcontext.Contextでないか調べる
3. エラーを出す

インターフェースの場合は、型アサーションしないと個別の型にはアクセスできない。そりゃそう。
** DONE どこからも呼ばれてない識別子を見つける
CLOSED: [2023-03-11 Sat 22:26]
:LOGBOOK:
CLOCK: [2023-03-04 Sat 23:01]--[2023-03-04 Sat 23:26] =>  0:25
CLOCK: [2023-03-04 Sat 22:32]--[2023-03-04 Sat 22:57] =>  0:25
CLOCK: [2023-03-04 Sat 19:14]--[2023-03-04 Sat 19:39] =>  0:25
:END:

どうやってやるのだろう。unusedのコードを調べたが、完全に理解してはいない。識別子はあらゆるパターンで出てきて、それぞれを考慮するのが必要になる。大きく分けると定義か呼び出し。さらに基本型ごとにある。

** DONE プライベートだけどタグがついてるフィールドを探す
CLOSED: [2023-03-11 Sat 22:26]
:PROPERTIES:
:Effort:   2:00
:END:
:LOGBOOK:
CLOCK: [2023-03-11 Sat 18:39]--[2023-03-11 Sat 19:04] =>  0:25
CLOCK: [2023-03-11 Sat 16:45]--[2023-03-11 Sat 17:10] =>  0:25
CLOCK: [2023-03-11 Sat 16:20]--[2023-03-11 Sat 16:45] =>  0:25
:END:
タグはパブリックでないと意味がない。

- タグは実行時に参照可能なメタ情報
- タグ情報はリフレクション経由で取得できる
** DONE 式と文をASTで出力する
CLOSED: [2023-03-13 Mon 00:30]
:LOGBOOK:
CLOCK: [2023-03-11 Sat 23:25]--[2023-03-11 Sat 23:50] =>  0:25
CLOCK: [2023-03-11 Sat 22:08]--[2023-03-11 Sat 22:33] =>  0:25
CLOCK: [2023-03-11 Sat 21:43]--[2023-03-11 Sat 22:08] =>  0:25
CLOCK: [2023-03-11 Sat 21:12]--[2023-03-11 Sat 21:37] =>  0:25
CLOCK: [2023-03-11 Sat 20:20]--[2023-03-11 Sat 20:45] =>  0:25
CLOCK: [2023-03-11 Sat 19:55]--[2023-03-11 Sat 20:20] =>  0:25
CLOCK: [2023-03-11 Sat 19:30]--[2023-03-11 Sat 19:55] =>  0:25
:END:

ひと目でわかるようにする。

interfaceを実装している構造体を一覧で見られれば網羅できるが、調べ方を忘れた。
** DONE context検知ツールの修正
CLOSED: [2023-03-25 Sat 23:03]
:PROPERTIES:
:Effort:   3:00
:END:
:LOGBOOK:
CLOCK: [2023-03-18 Sat 20:58]--[2023-03-18 Sat 21:23] =>  0:25
CLOCK: [2023-03-18 Sat 20:33]--[2023-03-18 Sat 20:58] =>  0:25
CLOCK: [2023-03-18 Sat 20:08]--[2023-03-18 Sat 20:33] =>  0:25
CLOCK: [2023-03-18 Sat 18:42]--[2023-03-18 Sat 19:07] =>  0:25
CLOCK: [2023-03-18 Sat 18:07]--[2023-03-18 Sat 18:32] =>  0:25
CLOCK: [2023-03-18 Sat 17:41]--[2023-03-18 Sat 18:07] =>  0:26
CLOCK: [2023-03-13 Mon 20:45]--[2023-03-13 Mon 21:10] =>  0:25
:END:

自作ツールの考慮にかなり漏れがあるようだ。

- [[https://github.com/gostaticanalysis/ctxfield][gostaticanalysis/ctxfield: Analyzer: reports context.Context which belongs to a struct as a field]]

を参考に修正する。

- analysisutilの関数で一発でcontext.Contextを見つけている
- ResultOfの使い方。なぜident.Mapで型アサーションしているか
- グローバルに定義されてる場合、エクスポートされてる場合はスルー
- 変数ではない・フィールドではない・無名関数の場合はスルー
- ポインタも確認
- インポートしたものをループで処理

テストでの未考慮が多いところに問題がある。問題があるとわかれば、調べて解決できるだろう。
