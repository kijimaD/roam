<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-07-27T11:24:35Z -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>assembly language</title>
<meta name="author" content="kijimaD" />
<meta name="generator" content="Org Mode" />
<link rel='shortcut icon' type='image/x-icon' href='https://kijimad.github.io/roam/favicon.ico' /><link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css' media='print' onload='this.media="all"' /><link rel='stylesheet' href='https://kijimad.github.io/roam/css/site.css' /><link rel='stylesheet' href='https://kijimad.github.io/roam/css/code.css' /><link rel='preconnect' href='https://fonts.googleapis.com'><link rel='preconnect' href='https://fonts.gstatic.com' crossorigin><link href='https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+JP&display=swap' rel='stylesheet'>
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content" class="content">
<h1 class="title">assembly language</h1>
<div id="outline-container-org380b5b0" class="outline-2">
<h2 id="org380b5b0"><a href="#org380b5b0">概要</a></h2>
<div class="outline-text-2" id="text-org380b5b0">
<p>
アセンブリ言語はビット列命令に対応した文字列命令を利用するプログラミング言語の種類。ビット列に対応する文字列命令(ニーモニック)を利用する。アセンブリ言語を用いることで、機械語相当の低水準なコードをより直感的に記述できる。
</p>
</div>
</div>
<div id="outline-container-org0368690" class="outline-2">
<h2 id="org0368690"><a href="#org0368690">Memo</a></h2>
<div class="outline-text-2" id="text-org0368690">
</div>
<div id="outline-container-org502a49e" class="outline-3">
<h3 id="org502a49e"><a href="#org502a49e">objdumpでlsコマンドを逆アセンブルする</a></h3>
<div class="outline-text-3" id="text-org502a49e">
<div class="org-src-container">
<pre class="src src-shell">objdump -d -M intel /bin/ls | head -n 30
</pre>
</div>

<div class="results" id="orga37716a">
<p>

</p>

<p>
/bin/ls:     file format elf64-x86-64
</p>


<p>
Disassembly of section .init:
</p>

<p>
0000000000004000 &lt;.init&gt;:
    4000:	f3 0f 1e fa          	endbr64
    4004:	48 83 ec 08          	sub    rsp,0x8
    4008:	48 8b 05 b1 df 01 00 	mov    rax,QWORD PTR [rip+0x1dfb1]        # 21fc0 &lt;__gmon_start__@Base&gt;
    400f:	48 85 c0             	test   rax,rax
    4012:	74 02                	je     4016 &lt;free@plt-0x66a&gt;
    4014:	ff d0                	call   rax
    4016:	e8 c5 2b 00 00       	call   6be0 &lt;__sprintf_chk@plt+0x1f00&gt;
    401b:	e8 d0 30 01 00       	call   170f0 &lt;_obstack_memory_used@@Base+0x6940&gt;
    4020:	48 83 c4 08          	add    rsp,0x8
    4024:	c3                   	ret
</p>

<p>
Disassembly of section .plt:
</p>

<p>
0000000000004030 &lt;.plt&gt;:
    4030:	ff 35 2a dc 01 00    	push   QWORD PTR [rip+0x1dc2a]        # 21c60 &lt;_obstack_memory_used@@Base+0x114b0&gt;
    4036:	f2 ff 25 2b dc 01 00 	bnd jmp QWORD PTR [rip+0x1dc2b]        # 21c68 &lt;_obstack_memory_used@@Base+0x114b8&gt;
    403d:	0f 1f 00             	nop    DWORD PTR [rax]
    4040:	f3 0f 1e fa          	endbr64
    4044:	68 00 00 00 00       	push   0x0
    4049:	f2 e9 e1 ff ff ff    	bnd jmp 4030 &lt;free@plt-0x650&gt;
    404f:	90                   	nop
    4050:	f3 0f 1e fa          	endbr64
    4054:	68 01 00 00 00       	push   0x1
</p>

</div>
</div>
</div>
<div id="outline-container-org7bc7f77" class="outline-3">
<h3 id="org7bc7f77"><a href="#org7bc7f77">objdumpでオブジェクトファイルの中身を確認する</a></h3>
<div class="outline-text-3" id="text-org7bc7f77">
<p>
abc.cがあるとする。このデータがオブジェクトファイルではどう表現されているかを見る。
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">char</span> <span class="org-variable-name">str</span>[] = <span class="org-string">"ABC"</span>;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>確認する</label><pre class="src src-shell">$ gcc -fno-pic -fomit-frame-pointer -c -o abc.o abc.c
$ objdump -s -j .data abc.o
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>実行結果</label><pre class="src src-nil">abc.o:     file format elf64-x86-64

Contents of section .data:
 0000 41424300                             ABC.
</pre>
</div>

<p>
文字列ABCが、4バイト(0x41, 0x42, 0x43, 0x00)に変換されたことがわかる。
</p>
</div>
</div>
<div id="outline-container-orgf7ae6d7" class="outline-3">
<h3 id="orgf7ae6d7"><a href="#orgf7ae6d7">各種コマンド</a></h3>
<div class="outline-text-3" id="text-orgf7ae6d7">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>コンパイル</label><pre class="src src-shell">$ gcc -c add.c
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>アセンブリ言語のプログラムadd.sにコンパイルする。</label><pre class="src src-shell">$ gcc -S -fno-pic -fomit-frame-pointer add.c
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>アセンブリ言語で書かれたプログラムadd.sを機械語に変換する。</label><pre class="src src-shell">$ as -o add.o add.s
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>アセンブラに-aオプションを指定すると、アセンブル結果を標準出力に表示する。</label><pre class="src src-shell">$ as -a -o add.o add.s
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>実行結果</label><pre class="src src-nil">GAS LISTING add.s                       page 1


   1                            .file   "add.c"
   2                            .text
   3                            .globl  i
   4                            .data
   5                            .align 4
   6                            .type   i, @object
   7                            .size   i, 4
   8                    i:
   9 0000 7B000000              .long   123
  10                            .text
  11                            .globl  main
  12                            .type   main, @function
  13                    main:
  14                    .LFB0:
  15                            .cfi_startproc
  16 0000 F30F1EFA              endbr64
  17 0004 8B050000              movl    i(%rip), %eax
  17      0000
  18 000a 05C80100              addl    $456, %eax
  18      00
  19 000f 89050000              movl    %eax, i(%rip)
  19      0000
  20 0015 B8000000              movl    $0, %eax
  20      00
  21 001a C3                    ret
  22                            .cfi_endproc
  23                    .LFE0:
  24                            .size   main, .-main
  25                            .ident  "GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0"
  26                            .section        .note.GNU-stack,"",@progbits
  27                            .section        .note.gnu.property,"a"
  28                            .align 8
  29 0000 04000000              .long   1f - 0f
  30 0004 10000000              .long   4f - 1f
  31 0008 05000000              .long   5
  32                    0:
  33 000c 474E5500              .string "GNU"
  34                    1:
  35                            .align 8
  36 0010 020000C0              .long   0xc0000002
  37 0014 04000000              .long   3f - 2f
  38                    2:
  39 0018 03000000              .long   0x3
  40                    3:
  41 001c 00000000              .align 8
  42                    4:

GAS LISTING add.s                       page 2


DEFINED SYMBOLS
                            *ABS*:0000000000000000 add.c
               add.s:8      .data:0000000000000000 i
               add.s:13     .text:0000000000000000 main

NO UNDEFINED SYMBOLS
</pre>
</div>
</div>
</div>
<div id="outline-container-org27ebe10" class="outline-3">
<h3 id="org27ebe10"><a href="#org27ebe10">ニーモニック</a></h3>
<div class="outline-text-3" id="text-org27ebe10">
<ul class="org-ul">
<li>ニーモニックは処理内容に応じて各機械語命令に与えられた文字列・命令語。機械語のオペコードに相当する</li>
<li>オペランドは命令の対象・引数</li>
</ul>
</div>
</div>
<div id="outline-container-orgfffd37c" class="outline-3">
<h3 id="orgfffd37c"><a href="#orgfffd37c">機械語との対応</a></h3>
<div class="outline-text-3" id="text-orgfffd37c">
<p>
アセンブリ言語と機械語の表現は一対一で対応している。これに対して、高級言語とアセンブリ言語は一対一対応していない。コンパイラの実装によって結果は異なる。
</p>

<p>
アセンブリ言語と機械語を比較する読み方。gccの-aオプションでコンパイルすると、機械語を見られる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>出力の一部</label><pre class="src src-nil">18 000a 05C80100              addl    $456, %eax
18      00
</pre>
</div>

<p>
これは、メモリ0018番地に、16進数で0x05, 0xc8, 0x01, 0x00という5バイトの機械語を生成したことを意味する。
</p>

<ul class="org-ul">
<li>1つのアセンブリ言語の命令につき1バイト(ret)から5バイト(movl, addl)の機械語が生成されている</li>
<li><code>.</code> から始まる命令に対しては機械語が生成されていない</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2b2bc69" class="outline-2">
<h2 id="org2b2bc69"><a href="#org2b2bc69">Tasks</a></h2>
<div class="outline-text-2" id="text-org2b2bc69">
</div>
<div id="outline-container-org796baa1" class="outline-3">
<h3 id="org796baa1"><a href="#org796baa1"><span class="todo TODO">TODO</span> <a href="https://blog.foresta.me/posts/view_assembly_code/">アセンブリコードを眺めてみる</a></a></h3>
<div class="outline-text-3" id="text-org796baa1">
<p>
簡潔な解説。
</p>
</div>
</div>
<div id="outline-container-orgba39fa5" class="outline-3">
<h3 id="orgba39fa5"><a href="#orgba39fa5"><span class="todo TODO">TODO</span> <a href="https://qiita.com/edo_m18/items/83c63cd69f119d0b9831">アセンブラに手を出してみる - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orgba39fa5">
<p>
アセンブラの説明集。
</p>
</div>
</div>
</div>
<div id="outline-container-orgb57647d" class="outline-2">
<h2 id="orgb57647d"><a href="#orgb57647d">Reference</a></h2>
<div class="outline-text-2" id="text-orgb57647d">
</div>
<div id="outline-container-orgfd27941" class="outline-3">
<h3 id="orgfd27941"><a href="#orgfd27941"><a href="https://schweigi.github.io/assembler-simulator/">Simple 8-bit Assembler Simulator in Javascript</a></a></h3>
<div class="outline-text-3" id="text-orgfd27941">
<p>
シミュレータ。可視化がわかりやすい。
</p>
</div>
</div>
<div id="outline-container-org520addd" class="outline-3">
<h3 id="org520addd"><a href="#org520addd"><a href="https://gist.github.com/tenpoku1000/2250ec65264ff2d639ddeeffd305fe68">インテル関連ドキュメント・リンク集</a></a></h3>
<div class="outline-text-3" id="text-org520addd">
<p>
インテル関連のリンク集。
</p>
</div>
</div>
<div id="outline-container-org6ba1f75" class="outline-3">
<h3 id="org6ba1f75"><a href="#org6ba1f75"><a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E8%A8%80%E8%AA%9E">アセンブリ言語 - Wikipedia</a></a></h3>
<div class="outline-text-3" id="text-org6ba1f75">
<p>
解説。
</p>
</div>
</div>
<div id="outline-container-org2da4e21" class="outline-3">
<h3 id="org2da4e21"><a href="#org2da4e21"><a href="https://github.com/h-ohsaki/asm">h-ohsaki/asm: 「独習アセンブラ 新版」(翔泳社) サポートページ</a></a></h3>
<div class="outline-text-3" id="text-org2da4e21">
<p>
サンプルコード。
</p>
</div>
</div>
</div>
<div id="outline-container-org64f3736" class="outline-2">
<h2 id="org64f3736"><a href="#org64f3736">Archives</a></h2>
<div class="outline-text-2" id="text-org64f3736">
</div>
<div id="outline-container-orge82b063" class="outline-3">
<h3 id="orge82b063"><a href="#orge82b063"><span class="done DONE">DONE</span> <a href="https://qiita.com/kaito_tateyama/items/89272098f4b286b64115">アセンブリに触れてみよう - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orge82b063">
<p>
アセンブリの解説。
</p>

<ul class="org-ul">
<li>raxのA = Accumulator</li>
<li>rbxのB = Base address</li>
<li>rcxのC = Count register</li>
<li>rdxのD = Data register</li>
</ul>

<p>
その他のレジスタ。
</p>

<ul class="org-ul">
<li>ripのipはInstruction Pointer。次に実行する命令のアドレスを記録する</li>
<li>rbpのbpはBase Pointer。現在の処理のスタックフレームの底部分のアドレスを記録する</li>
<li>rspのspはStack Pointer。スタック領域に積まれているデータのうち、一番小さいアドレスを記録する</li>
</ul>
</div>
</div>
<div id="outline-container-org9b402c2" class="outline-3">
<h3 id="org9b402c2"><a href="#org9b402c2"><span class="done DONE">DONE</span> <a href="https://www.amazon.co.jp/%E7%8B%AC%E7%BF%92%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9-%E6%96%B0%E7%89%88-%E5%A4%A7%E5%B4%8E-%E5%8D%9A%E4%B9%8B/dp/4798170291">独習アセンブラ 新版 | 大崎 博之 |本 | 通販 | Amazon</a></a></h3>
<div class="outline-text-3" id="text-org9b402c2">
<p>
IA-32アーキテクチャの章までちゃんと読んだ。あとはいろんなアーキテクチャの解説があったが、そこはざっくりとしか読んでいない。
</p>

<p>
メモ。
</p>

<ul class="org-ul">
<li>「アセンブリ言語のプログラムを、アセンブラを使ってアセンブルする」というのが正しい用法になる
<ul class="org-ul">
<li>アセンブリ: 組み立てるという「行為」</li>
<li>アセンブル: 組み立ての「動作」</li>
<li>アセンブラ: 組み立てる「人や物」</li>
</ul></li>
<li>gccコマンドそのものはCコンパイラの本体ではなく、Cコンパイラのフロントエンドになっている</li>
<li>gcc実行の流れ。コンパイル・アセンブル・リンク
<ol class="org-ol">
<li>C言語(ソースコード)</li>
<li>アセンブリ言語(ソースコード)</li>
<li>機械語(オブジェクトファイル)</li>
<li>機械語(実行ファイル)</li>
</ol></li>
<li>ビットという名前は Binary digIT から来ている</li>
<li>フランス、ドイツ、イタリアでは小数の区切りにはカンマを用いる</li>
<li>文字情報を含んだバイナリファイルやバイナリデータを扱うプログラムを書いたり読んだりする場合には、文字の表現に対する理解が不可欠</li>
<li>制御文字は図形を表示するためのものではない。端末エミュレータ上で出力しても画面には何も表示されない。反対に、図形を表示するための文字をグラフィック文字という</li>
<li>ASCII
<ul class="org-ul">
<li>JISキーボードの数字キーの記号配列は、ASCIIの範囲に対応している
<ol class="org-ol">
<li><code>&amp;</code> の文字コードが知りたい</li>
<li>JISキーボードを見ると <code>&amp;</code> は <code>6</code> キーにある</li>
<li>したがって <code>&amp;</code> の文字コードは0x20 + 6 = 0x26</li>
</ol></li>
<li>0x30 ~ 0x39 には数字の0~9が配置されている。なので数字の文字コードは 0x30 + 数 とわかる</li>
<li>0x41 ~ 0x5a には英大文字A~Zが配置されている。Aは1文字目のアルファベットなので、Aの文字コードは0x40 + 1 = 0x41。Cは3文字目のアルファベットなので、Cの文字コードは0x40 + 3 = 0x43</li>
<li>0x61 ~ 0x7a には英小文字a~zが配置されている。Aとaの文字コードを2進数で表記すると1ビットだけが異なるように意図して配置されている</li>
<li>つまり配置として、多くの記号の文字コード &lt; 英大文字の文字コード &lt; 小文字の文字コードとなる。なので、文字コードでソートしたときに記号、大文字、小文字という順番になる</li>
<li>タブは制御文字とグラフィック文字の両方の側面を持っている</li>
</ul></li>
<li>制御文字LFはラインフィードの意味。タイプライタ時代に用紙を読み込む指示をしていたから。当時のテレタイプには行を送るだけのものと、行を送ったあとキャリッジリターン(行頭に移動)するものがあった。Unixではラインフィードを「改行(行送り+行頭に移動」の意味で解釈している、といえる</li>
<li>一方で<a href="20230308002933-windows.html#ID-a15d346a-f82e-4796-a78b-85a8d227f0ef">Windows</a>での改行は制御文字CRとLFの2文字である。これはラインフィードを「単なる行送り」の意味で解釈しているといえる。キャリッジリターンCRで行頭に戻して、その後ラインフィードLFで1行進めている、といえる</li>
<li>キャリッジリターンという言葉は昔のタイプライタから来ている。キャリッジはタイプライタの用紙を動かす部分の名称。タイプライタは活字が刻印されたハンマーを打ち付けることによって印字する。ハンマーではなく用紙のほうを移動させる。キャリッジリターンはキャリッジを戻すという操作を意味している。キャリッジを戻すことにより、用紙のほうを移動させるという仕組みになっている</li>
<li>DELが 0x7f(0b1111111)に配置されているのは、紙テープがすべて穿孔されていれば間違いがあり意味のないデータとして取り扱っていたため</li>
<li><a href="20230709154946-unicode.html#ID-c76de2cf-e70d-4bc6-aa3a-f14d05debb6e">Unicode</a>
<ul class="org-ul">
<li>世界中の言語で使用されている文字を統一的に扱う規格であるUnicodeと、Unicodeの文字エンコーディング体系であるUTF-8やUTF-16</li>
<li>Unicodeではそれぞれの文字に割り当てられている整数をコードポイントと呼ぶ。例えば「あ」のコードポイントは0x3042</li>
<li>文字とUnicodeのコードポイントが必ずしも1対1で対応しない。アクセントや濁音、半濁音がついた文字は複数の表現がある</li>
<li>Unicodeを使って文字をバイト列として表現するためには、符号化文字の集合に加えて、文字エンコーディング体系が必要になる</li>
<li>UTF-32, UTF-16, UTF-8のいずれかでエンコードされたバイト列を見ても、それがどの文字エンコード体系でエンコードされたのかはわからない。区別のために、BOM(Byte Order Mark)を使用できる</li>
<li><a href="20230709154946-unicode.html#ID-c76de2cf-e70d-4bc6-aa3a-f14d05debb6e">Unicode</a>の特殊文字BOM(コードポイントU+FEFF)をUnicodeテキストの先頭にうめこんでおくと、エンコードしたバイト列から、このバイト列はどの文字エンコーディング体系でエンコードされたものかわかるようになる</li>
<li><a href="20230709154946-unicode.html#ID-c76de2cf-e70d-4bc6-aa3a-f14d05debb6e">Unicode</a>テキストの先頭にU+FEFFがあればそれはBOMを意味するが、Unicodeテキストの2文字目以降にU+FEFFがあれば、それは「幅がゼロの改行できない空白」を意味する。</li>
<li>なのでBOMを表示・印刷しても何も見えない</li>
</ul></li>
<li>ドットから始まる命令はアセンブラの疑似命令であり、ディレクティブとも呼ばれる
<ul class="org-ul">
<li>アセンブラの疑似命令は、CPUが実行する命令ではなく、プログラマからアセンブラへの指示</li>
</ul></li>
<li>.gdbinitでプリント対象の変数を指定できる</li>
<li><code>$ gcc -q add</code> オプションは起動時のメッセージを抑制する</li>
<li>C言語の規格では、各型の最小のビット数と、それぞれの型のビット数の大小関係のみが規定されていて、実際のビット数はそれぞれの処理系によって異なる</li>
<li>ドットから始まる命令はアセンブラの疑似命令。 <code>.L</code> から始まるラベルは局所ラベル</li>
<li>アセンブリ言語によるプログラミングにおけるスタックの利用法
<ul class="org-ul">
<li>計算結果をスタックに一時保存する。複雑な計算をするとレジスタの数が不足するため。スタックはメモリ上に確保されるので、広大なメモリ空間を活用できる</li>
<li>関数やサブルーチンと呼ばれる小さなまとまりのプログラムを実現するためにスタックを利用する</li>
</ul></li>
<li>関数呼び出しを実現するために必要なこと
<ul class="org-ul">
<li>呼び出しにどのように戻るか、リターンアドレスの管理</li>
<li>呼び出し元から関数に引数をどのように渡すか</li>
<li>関数から呼び出し元に返り値をどのように返すか</li>
</ul></li>
<li>コンピュータ内部で情報を保存できるのはレジスタとメモリしかない。したがって情報の受け渡しには、レジスタを使うかメモリを使うかの二択になる</li>
<li><code>call アドレス</code> で、リターンアドレスをスタックにプッシュし、指定されたアドレスにジャンプできる</li>
<li><code>ret</code> で、スタックからリターンアドレスを取り出して、そのアドレスにジャンプできる</li>
<li>スタックの一番上のアドレス = レジスタESP</li>
<li><code>cmpl	$0x1, 0x10(%esp)</code>
<ul class="org-ul">
<li>$0x1 → 整数1</li>
<li>0x10(%esp) → ESPレジスタの値+0x10</li>
<li>を比較する、ということ</li>
</ul></li>
<li>サブルーチンの呼び出しアドレスは、最終的に隣家によって結合された時点で確定する。オブジェクトファイルがまだリンクされていないと、アドレスが未確定のままになっている</li>
<li>writeシステムコールでは、レジスタEBXでファイルディスクリプタを、レジスタECXで文字列が格納されているアドレスを、レジスタEDXで出力する文字列長を指定する</li>
<li>GNUアセンブラ(GAS)は、Cコンパイラの裏方で動作するアセンブラとして設計された
<ul class="org-ul">
<li>CコンパイラはC言語で書かれたプログラムをコンパイルし、アセンブリ言語のプログラムを生成する</li>
<li>GASは、Cコンパイラが生成したアセンブリ言語のプログラムを機械語に変換する</li>
</ul></li>
</ul>

<ul class="org-ul">
<li><code>main</code>, <code>.LFB0</code>, <code>i</code> はシンボル。</li>
<li><code>L</code> や <code>.L</code> から始まるシンボルは局所シンボル</li>
<li><code>main:</code> はラベル。ラベルは末尾にコロンを付与する</li>
<li>局所ラベルは「数字b」「数字f」によって参照できる</li>
<li>ピリオドから始まる命令はGASの疑似命令(アセンブラに対する指示)</li>
<li>アセンブラにおけるセクションとは、ある連続したアドレスの範囲</li>
<li>GASはそれぞれのセクションを0番地から開始する。機械語のプログラムを格納するセクションも、プログラムが使用するデータを格納するセクションも、すべて0番地から開始する。機械語のプログラムも、プログラムが使用するデータも、最終的にはメモリ上のどこかのアドレスに配置されて実行される</li>
<li>アセンブラが生成したオブジェクトファイルを、実際の適切なメモリ上の番地に配置するのはリンカの役割。リンカが、各セクションを配置するアドレスを決定することを再配置とよぶ。GASはそれぞれのセクションが実際のメモリのどこに配置されるかには関与しない</li>
<li>GASは機械語のプログラムを.textセクションに格納する</li>
<li>.dataセクションはプログラムが使用するデータを格納する</li>
<li>.bssセクションは初期化されていないデータ領域のためのセクション。初期化されていないデータの中身は保持しなくてよく、大きさだけ持っていればよいのでデータ削減になる</li>
<li>C言語における関数呼び出しは、C言語で書かれたプログラムを呼び出しているのではなく、もともとはC言語で書かれたプログラムだったが、現在はコンパイルが済んで機械語になっているプログラムを呼び出している</li>
<li><code>movl $123, %eax</code> とあるときの$123を即値という。アドレスの123番地ではなく、123という「値そのもの」を意味するから。値が指す先にあるものではなく、値が即時に表すものなので即値(immediate value)</li>
<li>ビットシフト命令はハードウェアで実行しなければならない処理がはるかに簡単。乗数や除数が2のべき乗であれば、MUL命令やDIV命令を使用せずに、ビットシフト命令を用いることで高速な計算が可能になる</li>
<li>NOP命令は何もしない命令。CPUはNOP命令を単に読み飛ばす。NOP命令は、バイナリファイルを書き換えて、特定の命令を無効化するのに使う</li>
<li>CALL命令はリターンアドレスをスタックにプッシュしたあとでEIPレジスタの値を変更する</li>
<li>IA-32アーキテクチャでアドレスは32ビット(4バイト)なので、スタックポインタの値を4だけ減らす</li>
</ul>
</div>
</div>
<div id="outline-container-org31891b3" class="outline-3">
<h3 id="org31891b3"><a href="#org31891b3"><span class="done DONE">DONE</span> <a href="https://www.sigbus.info/compilerbook">低レイヤを知りたい人のためのCコンパイラ作成入門</a></a></h3>
<div class="outline-text-3" id="text-org31891b3">
</div>
</div>
<div id="outline-container-org959e94e" class="outline-3">
<h3 id="org959e94e"><a href="#org959e94e"><span class="done DONE">DONE</span> <a href="https://qiita.com/tobira-code/items/75d3034aed8bb9828981">x86-64プロセッサのスタックを理解する - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org959e94e">
<p>
図を交えたわかりやすい解説。
</p>
</div>
</div>
<div id="outline-container-orgf74fd46" class="outline-3">
<h3 id="orgf74fd46"><a href="#orgf74fd46"><span class="done DONE">DONE</span> <a href="https://nextpublishing.jp/book/17419.html">RISC-Vから学ぶC言語　ポインタ理解のためのアセンブリ入門 | 電子書籍とプリントオンデマンド（POD） | NextPublishing（ネクストパブリッシング）</a></a></h3>
<div class="outline-text-3" id="text-orgf74fd46">
<p>
ポインタをアセンブリから学ぶ。
</p>
</div>
</div>
</div>
<div id="outline-container-orgf307e86" class="outline-2">
<h2 id="orgf307e86"><a href="#orgf307e86">Backlinks</a></h2>
<div class="outline-text-2" id="text-orgf307e86">
<ul class="org-ul">
<li><a href="./20231014T125935--kdoc-45-プログラミング言語の内部的な違いをアセンブリから調べる__wiki.html">KDOC 45: プログラミング言語の内部的な違いをアセンブリから調べる</a></li>
<li><a href="./20240203T223724--kdoc-69-『go-compiler-intrinsics』__book.html">KDOC 69: 『Go compiler intrinsics』</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer>
</div>
</body>
</html>
