<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-08-12 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>assembly language</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css' /><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css'><link rel='stylesheet' href='../css/site.css' /><link rel='stylesheet' href='../roam/css/code.css' /><link rel='stylesheet' href='css/site.css' /><link rel='stylesheet' href='css/code.css' />
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content">
<h1 class="title">assembly language</h1>
<div id="outline-container-org8c79f54" class="outline-2">
<h2 id="org8c79f54"><a href="#org8c79f54">概要</a></h2>
<div class="outline-text-2" id="text-org8c79f54">
<p>
アセンブリ言語はビット列命令に対応した文字列命令を利用するプログラミング言語の種類。ビット列に対応する文字列命令(ニーモニック)を利用する。アセンブリ言語を用いることで、機械語相当の低水準なコードをより直感的に記述できる。
</p>
</div>
</div>
<div id="outline-container-org04a88c7" class="outline-2">
<h2 id="org04a88c7"><a href="#org04a88c7">Memo</a></h2>
<div class="outline-text-2" id="text-org04a88c7">
</div>
<div id="outline-container-orgb3ba134" class="outline-3">
<h3 id="orgb3ba134"><a href="#orgb3ba134">objdumpでlsコマンドを逆アセンブルする</a></h3>
<div class="outline-text-3" id="text-orgb3ba134">
<div class="org-src-container">
<pre class="src src-shell">objdump -d -M intel /bin/ls | head -n 30
</pre>
</div>

<div class="results" id="orgcec2a4e">
<p>

</p>

<p>
/bin/ls:     file format elf64-x86-64
</p>


<p>
Disassembly of section .init:
</p>

<p>
0000000000004000 &lt;.init&gt;:
    4000:	f3 0f 1e fa          	endbr64
    4004:	48 83 ec 08          	sub    rsp,0x8
    4008:	48 8b 05 b1 df 01 00 	mov    rax,QWORD PTR [rip+0x1dfb1]        # 21fc0 &lt;__gmon_start__@Base&gt;
    400f:	48 85 c0             	test   rax,rax
    4012:	74 02                	je     4016 &lt;free@plt-0x66a&gt;
    4014:	ff d0                	call   rax
    4016:	e8 c5 2b 00 00       	call   6be0 &lt;__sprintf_chk@plt+0x1f00&gt;
    401b:	e8 d0 30 01 00       	call   170f0 &lt;_obstack_memory_used@@Base+0x6940&gt;
    4020:	48 83 c4 08          	add    rsp,0x8
    4024:	c3                   	ret
</p>

<p>
Disassembly of section .plt:
</p>

<p>
0000000000004030 &lt;.plt&gt;:
    4030:	ff 35 2a dc 01 00    	push   QWORD PTR [rip+0x1dc2a]        # 21c60 &lt;_obstack_memory_used@@Base+0x114b0&gt;
    4036:	f2 ff 25 2b dc 01 00 	bnd jmp QWORD PTR [rip+0x1dc2b]        # 21c68 &lt;_obstack_memory_used@@Base+0x114b8&gt;
    403d:	0f 1f 00             	nop    DWORD PTR [rax]
    4040:	f3 0f 1e fa          	endbr64
    4044:	68 00 00 00 00       	push   0x0
    4049:	f2 e9 e1 ff ff ff    	bnd jmp 4030 &lt;free@plt-0x650&gt;
    404f:	90                   	nop
    4050:	f3 0f 1e fa          	endbr64
    4054:	68 01 00 00 00       	push   0x1
</p>

</div>
</div>
</div>

<div id="outline-container-org3fa29d8" class="outline-3">
<h3 id="org3fa29d8"><a href="#org3fa29d8">objdumpでオブジェクトファイルの中身を確認する</a></h3>
<div class="outline-text-3" id="text-org3fa29d8">
<p>
abc.cがあるとする。このデータがオブジェクトファイルではどう表現されているかを見る。
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">char</span> <span class="org-variable-name">str</span>[] = <span class="org-string">"ABC"</span>;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>確認する</label><pre class="src src-shell">$ gcc -fno-pic -fomit-frame-pointer -c -o abc.o abc.c
$ objdump -s -j .data abc.o
</pre>
</div>

<pre class="example">
abc.o:     file format elf64-x86-64

Contents of section .data:
 0000 41424300                             ABC.
</pre>

<p>
文字列ABCが、4バイト(0x41, 0x42, 0x43, 0x00)に変換されたことがわかる。
</p>
</div>
</div>

<div id="outline-container-org6b5b165" class="outline-3">
<h3 id="org6b5b165"><a href="#org6b5b165">各種コマンド</a></h3>
<div class="outline-text-3" id="text-org6b5b165">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>コンパイル</label><pre class="src src-shell">$ gcc -c add.c
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>アセンブリ言語のプログラムadd.sにコンパイルする。</label><pre class="src src-shell">$ gcc -S -fno-pic -fomit-frame-pointer add.c
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>アセンブリ言語で書かれたプログラムadd.sを機械語に変換する。</label><pre class="src src-shell">$ as -o add.o add.s
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>アセンブラに-aオプションを指定すると、アセンブル結果を標準出力に表示する。</label><pre class="src src-shell">$ as -a -o add.o add.s
</pre>
</div>

<pre class="example">
GAS LISTING add.s                       page 1


   1                            .file   "add.c"
   2                            .text
   3                            .globl  i
   4                            .data
   5                            .align 4
   6                            .type   i, @object
   7                            .size   i, 4
   8                    i:
   9 0000 7B000000              .long   123
  10                            .text
  11                            .globl  main
  12                            .type   main, @function
  13                    main:
  14                    .LFB0:
  15                            .cfi_startproc
  16 0000 F30F1EFA              endbr64
  17 0004 8B050000              movl    i(%rip), %eax
  17      0000
  18 000a 05C80100              addl    $456, %eax
  18      00
  19 000f 89050000              movl    %eax, i(%rip)
  19      0000
  20 0015 B8000000              movl    $0, %eax
  20      00
  21 001a C3                    ret
  22                            .cfi_endproc
  23                    .LFE0:
  24                            .size   main, .-main
  25                            .ident  "GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0"
  26                            .section        .note.GNU-stack,"",@progbits
  27                            .section        .note.gnu.property,"a"
  28                            .align 8
  29 0000 04000000              .long   1f - 0f
  30 0004 10000000              .long   4f - 1f
  31 0008 05000000              .long   5
  32                    0:
  33 000c 474E5500              .string "GNU"
  34                    1:
  35                            .align 8
  36 0010 020000C0              .long   0xc0000002
  37 0014 04000000              .long   3f - 2f
  38                    2:
  39 0018 03000000              .long   0x3
  40                    3:
  41 001c 00000000              .align 8
  42                    4:

GAS LISTING add.s                       page 2


DEFINED SYMBOLS
                            *ABS*:0000000000000000 add.c
               add.s:8      .data:0000000000000000 i
               add.s:13     .text:0000000000000000 main

NO UNDEFINED SYMBOLS
</pre>
</div>
</div>

<div id="outline-container-org3e671ac" class="outline-3">
<h3 id="org3e671ac"><a href="#org3e671ac">ニーモニック</a></h3>
<div class="outline-text-3" id="text-org3e671ac">
<ul class="org-ul">
<li>ニーモニックは処理内容に応じて各機械語命令に与えられた文字列・命令語。機械語のオペコードに相当する</li>
<li>オペランドは命令の対象・引数</li>
</ul>
</div>
</div>
<div id="outline-container-orgb052e5d" class="outline-3">
<h3 id="orgb052e5d"><a href="#orgb052e5d">機械語との対応</a></h3>
<div class="outline-text-3" id="text-orgb052e5d">
<p>
アセンブリ言語と機械語の表現は一対一で対応している。これに対して、高級言語とアセンブリ言語は一対一対応していない。コンパイラの実装によって結果は異なる。
</p>

<p>
アセンブリ言語と機械語を比較する読み方。gccの-aオプションでコンパイルすると、機械語を見られる。
</p>

<pre class="example">
18 000a 05C80100              addl    $456, %eax
18      00
</pre>

<p>
これは、メモリ0018番地に、16進数で0x05, 0xc8, 0x01, 0x00という5バイトの機械語を生成したことを意味する。
</p>

<ul class="org-ul">
<li>1つのアセンブリ言語の命令につき1バイト(ret)から5バイト(movl, addl)の機械語が生成されている</li>
<li><code>.</code> から始まる命令に対しては機械語が生成されていない</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcaab7ff" class="outline-2">
<h2 id="orgcaab7ff"><a href="#orgcaab7ff">Tasks</a></h2>
<div class="outline-text-2" id="text-orgcaab7ff">
</div>
<div id="outline-container-orgcd576fb" class="outline-3">
<h3 id="orgcd576fb"><a href="#orgcd576fb"><span class="todo TODO">TODO</span> <a href="https://www.amazon.co.jp/%E7%8B%AC%E7%BF%92%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9-%E6%96%B0%E7%89%88-%E5%A4%A7%E5%B4%8E-%E5%8D%9A%E4%B9%8B/dp/4798170291">独習アセンブラ 新版 | 大崎 博之 |本 | 通販 | Amazon</a></a></h3>
<div class="outline-text-3" id="text-orgcd576fb">
<ul class="org-ul">
<li>107, 130, 196</li>
<li>「アセンブリ言語のプログラムを、アセンブラを使ってアセンブルする」というのが正しい用法になる
<ul class="org-ul">
<li>アセンブリ: 組み立てるという「行為」</li>
<li>アセンブル: 組み立ての「動作」</li>
<li>アセンブラ: 組み立てる「人や物」</li>
</ul></li>
<li>gccコマンドそのものはCコンパイラの本体ではなく、Cコンパイラのフロントエンドになっている</li>
<li>gcc実行の流れ。コンパイル・アセンブル・リンク
<ol class="org-ol">
<li>C言語(ソースコード)</li>
<li>アセンブリ言語(ソースコード)</li>
<li>機械語(オブジェクトファイル)</li>
<li>機械語(実行ファイル)</li>
</ol></li>
<li>ビットという名前は Binary digIT から来ている</li>
<li>フランス、ドイツ、イタリアでは小数の区切りにはカンマを用いる</li>
<li>文字情報を含んだバイナリファイルやバイナリデータを扱うプログラムを書いたり読んだりする場合には、文字の表現に対する理解が不可欠</li>
<li>コンピュータにおける文字の用語
<dl class="org-dl">
<dt>文字(character)</dt><dd>書き言葉における最小の構成要素であり、何らかの意味を持ったものを指す。コンピュータにおける文字は制御文字も含む。文字そのものは抽象的な概念で、具体的にコンピュータでその文字をどのように格納したり、表示するのかとは直接関係ない</dd>
<dt>文字列(string)</dt><dd>1つまたは複数の文字の並び</dd>
<dt>文字集合(character set)</dt><dd>文字(character)の集合(set)。英語大文字26個を集めれば、それは英語大文字の文字集合。通常、文字集合には何らかの書き言葉を構成するすべての文字を含める</dd>
<dt>エンコーディング</dt><dd>何らかのデータを一定の規則に従って変換することを指し、符号化ともいう。ファイルの圧縮や暗号化、画像やビデオの符号化もエンコーディング。文字の表現におけるエンコーディングは文字エンコーディングを意味する。つまり文字の情報をある一定の規則に従って何らかのビット列に変換すること。ASCII, ISO-8859-1, UTF-8, EUC-JP, ISO-2022-JP, Shift_JISなどがある。エンコーディングは文字を一定の規則に従ってビット列に変換すること</dd>
<dt>文字コード</dt><dd>本来、ある特定の文字に定められた符号(code)のこと。例えばASCIIにおいて、英大文字の「A」の文字コードは0x41。より正確には、ASCIIは7ビットのエンコーディングなので、英大文字「A」の文字コードは1000001となる。つまりASCIIにおいて、ある特定の文字「A」に定められた符号は1000001となる。日本では、文字エンコーディングと文字コードという言葉が混同して使用されることが多い…。文字コードとは、エンコーディングごとにそれぞれの文字に対して定められた符号を指す</dd>
<dt>CCS(Coded Character Set)</dt><dd>符号化文字の集合。抽象的な文字の集合から整数の集合への1対1対応のマッピング</dd>
<dt>(no term)</dt><dd>CES(Character Encoding Scheme) ::文字エンコーディング体系。単一もしくは複数の符号化文字の集合CCSから、オクテット列の集合へのマッピング。文字、コード、バイト列との対応関係を定める。CCSの各文字のコードから、それに対応するバイト列への変換方法を定める。例えば1. 文字のコードの上位8バイトに0x80を足したものを1バイト目とする。2.文字のコードの下位8バイトに0x80を足したものを2バイト目とする。という規則で文字のコードからバイト列へと対応させている</dd>
</dl></li>
<li>制御文字は図形を表示するためのものではない。端末エミュレータ上で出力しても画面には何も表示されない。反対に、図形を表示するための文字をグラフィック文字という</li>
<li>ASCII
<ul class="org-ul">
<li>JISキーボードの数字キーの記号配列は、ASCIIの範囲に対応している
<ol class="org-ol">
<li><code>&amp;</code> の文字コードが知りたい</li>
<li>JISキーボードを見ると <code>&amp;</code> は <code>6</code> キーにある</li>
<li>したがって <code>&amp;</code> の文字コードは0x20 + 6 = 0x26</li>
</ol></li>
<li>0x30 ~ 0x39 には数字の0~9が配置されている。なので数字の文字コードは 0x30 + 数 とわかる</li>
<li>0x41 ~ 0x5a には英大文字A~Zが配置されている。Aは1文字目のアルファベットなので、Aの文字コードは0x40 + 1 = 0x41。Cは3文字目のアルファベットなので、Cの文字コードは0x40 + 3 = 0x43</li>
<li>0x61 ~ 0x7a には英小文字a~zが配置されている。Aとaの文字コードを2進数で表記すると1ビットだけが異なるように意図して配置されている</li>
<li>つまり配置として、多くの記号の文字コード &lt; 英大文字の文字コード &lt; 小文字の文字コードとなる。なので、文字コードでソートしたときに記号、大文字、小文字という順番になる</li>
<li>タブは制御文字とグラフィック文字の両方の側面を持っている</li>
</ul></li>
<li>制御文字LFはラインフィードの意味。タイプライタ時代に用紙を読み込む指示をしていたから。当時のテレタイプには行を送るだけのものと、行を送ったあとキャリッジリターン(行頭に移動)するものがあった。Unixではラインフィードを「改行(行送り+行頭に移動」の意味で解釈している、といえる</li>
<li>一方で<a href="20230308002933-windows.html#ID-a15d346a-f82e-4796-a78b-85a8d227f0ef">Windows</a>での改行は制御文字CRとLFの2文字である。これはラインフィードを「単なる行送り」の意味で解釈しているといえる。キャリッジリターンCRで行頭に戻して、その後ラインフィードLFで1行進めている、といえる</li>
<li>キャリッジリターンという言葉は昔のタイプライタから来ている。キャリッジはタイプライタの用紙を動かす部分の名称。タイプライタは活字が刻印されたハンマーを打ち付けることによって印字する。ハンマーではなく用紙のほうを移動させる。キャリッジリターンはキャリッジを戻すという操作を意味している。キャリッジを戻すことにより、用紙のほうを移動させるという仕組みになっている</li>
<li>DELが 0x7f(0b1111111)に配置されているのは、紙テープがすべて穿孔されていれば間違いがあり意味のないデータとして取り扱っていたため</li>
<li><a href="20230709154946-unicode.html#ID-c76de2cf-e70d-4bc6-aa3a-f14d05debb6e">Unicode</a>
<ul class="org-ul">
<li>世界中の言語で使用されている文字を統一的に扱う規格であるUnicodeと、Unicodeの文字エンコーディング体系であるUTF-8やUTF-16</li>
<li>Unicodeではそれぞれの文字に割り当てられている整数をコードポイントと呼ぶ。例えば「あ」のコードポイントは0x3042</li>
<li>文字とUnicodeのコードポイントが必ずしも1対1で対応しない。アクセントや濁音、半濁音がついた文字は複数の表現がある</li>
<li>Unicodeを使って文字をバイト列として表現するためには、符号化文字の集合に加えて、文字エンコーディング体系が必要になる</li>
<li>UTF-32, UTF-16, UTF-8のいずれかでエンコードされたバイト列を見ても、それがどの文字エンコード体系でエンコードされたのかはわからない。区別のために、BOM(Byte Order Mark)を使用できる</li>
<li><a href="20230709154946-unicode.html#ID-c76de2cf-e70d-4bc6-aa3a-f14d05debb6e">Unicode</a>の特殊文字BOM(コードポイントU+FEFF)をUnicodeテキストの先頭にうめこんでおくと、エンコードしたバイト列から、このバイト列はどの文字エンコーディング体系でエンコードされたものかわかるようになる</li>
<li><a href="20230709154946-unicode.html#ID-c76de2cf-e70d-4bc6-aa3a-f14d05debb6e">Unicode</a>テキストの先頭にU+FEFFがあればそれはBOMを意味するが、Unicodeテキストの2文字目以降にU+FEFFがあれば、それは「幅がゼロの改行できない空白」を意味する。</li>
<li>なのでBOMを表示・印刷しても何も見えない</li>
</ul></li>
<li>ドットから始まる命令はアセンブラの疑似命令であり、ディレクティブとも呼ばれる
<ul class="org-ul">
<li>アセンブラの疑似命令は、CPUが実行する命令ではなく、プログラマからアセンブラへの指示</li>
</ul></li>
<li>.gdbinitでプリント対象の変数を指定できる</li>
<li><code>$ gcc -q add</code> オプションは起動時のメッセージを抑制する</li>
<li>C言語の規格では、各型の最小のビット数と、それぞれの型のビット数の大小関係のみが規定されていて、実際のビット数はそれぞれの処理系によって異なる</li>
<li>ドットから始まる命令はアセンブラの疑似命令。 <code>.L</code> から始まるラベルは局所ラベル</li>
<li>アセンブリ言語によるプログラミングにおけるスタックの利用法
<ul class="org-ul">
<li>計算結果をスタックに一時保存する。複雑な計算をするとレジスタの数が不足するため。スタックはメモリ上に確保されるので、広大なメモリ空間を活用できる</li>
<li>関数やサブルーチンと呼ばれる小さなまとまりのプログラムを実現するためにスタックを利用する</li>
</ul></li>
<li>関数呼び出しを実現するために必要なこと
<ul class="org-ul">
<li>呼び出しにどのように戻るか、リターンアドレスの管理</li>
<li>呼び出し元から関数に引数をどのように渡すか</li>
<li>関数から呼び出し元に返り値をどのように返すか</li>
</ul></li>
<li>コンピュータ内部で情報を保存できるのはレジスタとメモリしかない。したがって情報の受け渡しには、レジスタを使うかメモリを使うかの二択になる</li>
<li><code>call アドレス</code> で、リターンアドレスをスタックにプッシュし、指定されたアドレスにジャンプできる</li>
<li><code>ret</code> で、スタックからリターンアドレスを取り出して、そのアドレスにジャンプできる</li>
<li>スタックの一番上のアドレス = レジスタESP</li>
<li><code>cmpl	$0x1, 0x10(%esp)</code>
<ul class="org-ul">
<li>$0x1 → 整数1</li>
<li>0x10(%esp) → ESPレジスタの値+0x10</li>
<li>を比較する、ということ</li>
</ul></li>
<li>サブルーチンの呼び出しアドレスは、最終的に隣家によって結合された時点で確定する。オブジェクトファイルがまだリンクされていないと、アドレスが未確定のままになっている</li>
<li>writeシステムコールでは、レジスタEBXでファイルディスクリプタを、レジスタECXで文字列が格納されているアドレスを、レジスタEDXで出力する文字列長を指定する</li>
</ul>
</div>
</div>

<div id="outline-container-orgc449188" class="outline-3">
<h3 id="orgc449188"><a href="#orgc449188"><span class="todo TODO">TODO</span> <a href="https://qiita.com/edo_m18/items/83c63cd69f119d0b9831">アセンブラに手を出してみる - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orgc449188">
<p>
アセンブラの説明集。
</p>
</div>
</div>
<div id="outline-container-orgb85f159" class="outline-3">
<h3 id="orgb85f159"><a href="#orgb85f159"><span class="todo TODO">TODO</span> <a href="https://tatsu-zine.com/books/my-emulator-x86-architecture">自作エミュレータで学ぶx86アーキテクチャ コンピュータが動く仕組みを徹底理解！【委託】 - 達人出版会</a></a></h3>
<div class="outline-text-3" id="text-orgb85f159">
<p>
エミュレータで再現しながらの解説。
</p>
</div>
</div>
</div>
<div id="outline-container-orgbef4335" class="outline-2">
<h2 id="orgbef4335"><a href="#orgbef4335">Reference</a></h2>
<div class="outline-text-2" id="text-orgbef4335">
</div>
<div id="outline-container-org424f340" class="outline-3">
<h3 id="org424f340"><a href="#org424f340"><a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E8%A8%80%E8%AA%9E">アセンブリ言語 - Wikipedia</a></a></h3>
<div class="outline-text-3" id="text-org424f340">
<p>
解説。
</p>
</div>
</div>
</div>
<div id="outline-container-org4123b7b" class="outline-2">
<h2 id="org4123b7b"><a href="#org4123b7b">Archives</a></h2>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"/>
</div>
</body>
</html>
