:PROPERTIES:
:ID:       ddc21510-6693-4c1e-9070-db0dd2a8160b
:header-args+: :wrap :results raw
:END:
#+title: Rust
* 概要
RustはC言語、C++の置換を目指した[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]。

- 性能
- メモリ安全性
- 安全な並行性

を特徴とする。

[[id:4270d99a-d2b5-429e-b33c-c2e097b20730][Zig]]と方向性が同じ。
* Memo
** マクロの例
マクロの例。identはidentityの略。

#+caption: lintを定義するマクロ
#+begin_src git-permalink
https://github.com/kd-collective/rust/blob/a3beeaa84da241f35888338ded6659938206ff13/src/librustdoc/lint.rs#L66-L83
#+end_src

#+RESULTS:
#+begin_results
macro_rules! declare_rustdoc_lint {
    ($(#[$attr:meta])* $name: ident, $level: ident, $descr: literal $(,)?) => {
        declare_tool_lint! {
            $(#[$attr])* pub rustdoc::$name, $level, $descr
        }
    }
}

declare_rustdoc_lint! {
    /// The `broken_intra_doc_links` lint detects failures in resolving
    /// intra-doc link targets. This is a `rustdoc` only lint, see the
    /// documentation in the [rustdoc book].
    ///
    /// [rustdoc book]: ../../../rustdoc/lints.html#broken_intra_doc_links
    BROKEN_INTRA_DOC_LINKS,
    Warn,
    "failures in resolving intra-doc link targets"
}
#+end_results

printlnマクロの定義。

#+caption: println
#+begin_src git-permalink
https://github.com/kd-collective/rust/blob/a3beeaa84da241f35888338ded6659938206ff13/library/std/src/macros.rs#L101-L108
#+end_src

#+RESULTS:
#+begin_results
macro_rules! println {
    () => {
        $crate::print!("\n")
    };
    ($($arg:tt)*) => {{
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    }};
}
#+end_results

** ライフタイムの概要
[[https://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html][ライフタイムで参照を検証する - The Rust Programming Language 日本語版]]

Rustにおいて参照はすべてライフタイムを保持する。ライフタイムは、その参照が有効になるスコープ。ライフタイムも暗黙的に推論される。複数の型の可能性があるときには、型を注釈しなければならない。

ライフタイムの主な目的は、ダングリング参照…参照するつもりだったデータ以外のデータを参照してしまうこと…を回避すること。コンパイラは借用チェッカーによってチェックしてエラーを出す。

#+caption: 値がスコープを抜けてしまった参照を使用しようとする
#+begin_src rust
  fn main() {
    {
      let r;

      {
        let x = 5;
        r = &x;
      }

      println!("r: {}", r);
    }
  }
#+end_src

#+RESULTS:
#+begin_results
error[E0597]: `x` does not live long enough
  --> /tmp/babel-Mwh0df/rust-H3aWMg:8:11
   |
8  |       r = &x;
   |           ^^ borrowed value does not live long enough
9  |     }
   |     - `x` dropped here while still borrowed
10 |
11 |     println!("r: {}", r);
   |                       - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
#+end_results

関数のジェネリックなライフタイム。

#+caption: 2つの文字列スライスのうち長い方を返す関数。が、ライフタイムに言及するエラーでコンパイルできない
#+begin_src rust
  // 引数は参照である。longest関数に引数の所有権を奪ってほしくないから
  fn longest(x: &str, y: &str) -> &str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }

  fn main() {
      let string1 = String::from("abcd");
      let string2 = "xyz";

      let result = longest(string1.as_str(), string2);
      println!("The longest string is {}", result);
  }
#+end_src

#+RESULTS:
#+begin_results
error[E0106]: missing lifetime specifier
 --> /tmp/babel-Mwh0df/rust-eT95tY:2:33
  |
2 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
2 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
#+end_results

↑戻り値の型はジェネリックなライフタイム引数である引数であるといっている。返している参照が ~x~ か ~y~ のどちらを参照しているか、コンパイラにはわからないから。ifブロックは ~x~ への参照を返し、elseブロックは ~y~ への参照を返すので、どちらかわからない。

エラーを修正するためには、借用チェッカーが解析できるように、参照間の関係を定義するジェネリックなライフタイム引数を追加する。ライフタイム注釈は、参照の生存期間を変えることはない。ライフタイム注釈は、ライフタイムに影響することなく、複数の参照のライフタイムのお互いの関係を記述する。

ライフタイム引数の名前はアポストロフィーで始まらなければならず、通常全て小文字で、ジェネリック型のように短い。慣例的に ~'a~ という名前を使う。

#+begin_src rust
  &i32 // ただの参照
  &'a i32 // 明示的なライフタイム付きの参照
  &'a mut i32 // 明示的なライフタイム付きの可変参照
#+end_src

ライフタイム注釈をつける。
- 何らかのライフタイム'aに対して、関数は2つの引数を取り、どちらも少なくともライフタイム'aと同じだけ生きる文字列スライスであるとコンパイラに教えるようになった
- 返る文字列スライスもライフタイム'aと同じだけ生きると、コンパイラに教えている。実際にはlongest関数が返す参照のライフタイムは、渡された参照のうち、小さい方のライフタイムと同じということになる

#+caption: ライフタイム注釈を引数、返り値につける
#+begin_src rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }

  fn main() {
      let string1 = String::from("abcd");
      let string2 = "xyz";

      let result = longest(string1.as_str(), string2);
      println!("The longest string is {}", result);
  }
  main();
#+end_src

#+RESULTS:
#+begin_results
The longest string is abcd
()
#+end_results

- ライフタイム引数を指定する時、いかなる値のライフタイムも変更していない。longest関数は、 ~x~ と ~y~ の正確な生存期間を知っている必要はなく、このシグニチャを満たすようなスコープを'aに代入できることを知っているだけ
- 関数にライフタイムを注釈するときは、注釈は関数の本体ではなくシグニチャに付与する
  - コンパイラは注釈がなくとも関数内のコードを解析できる。が、関数に関数外からの参照や関数外への参照がある場合、コンパイラが引数や戻り値のライフタイムも自力で解決することはほとんど不可能になる。
  - そのライフタイムは関数が呼び出されるたびに異なる可能性があるので、手動でライフタイムを注釈する必要がある

** トレイトの概要
[[https://doc.rust-jp.rs/book-ja/ch10-02-traits.html][トレイト：共通の振る舞いを定義する - The Rust Programming Language 日本語版]]

トレイトを使用すると、あるジェネリックが、特定の振る舞いをもつあらゆる型になり得ることを指定できる。

#+caption: メソッドシグニチャのあとに、セミコロンを使用している。このトレイトに実装する型はそれぞれ、メソッドの本体に独自の振る舞いを提供しなければならない
#+begin_src rust
  pub trait Summary {
      fn summarize(&self) -> String;
  }
#+end_src

トレイトを型に実装する。

#+caption: 同じメソッド名summarizeで型によって振る舞いが異なる
#+begin_src rust
  pub trait Summary {
      fn summarize(&self) -> String;
  }

  pub struct NewsArticle {
      pub headline: String,
      pub location: String,
      pub author: String,
      pub content: String,
  }

  // impl トレイト for 構造体
  impl Summary for NewsArticle {
      fn summarize(&self) -> String {
          format!("{}, by {} ({})", self.headline, self.author, self.location)
      }
  }

  pub struct Tweet {
      pub username: String,
      pub content: String,
      pub reply: bool,
      pub retweet: bool,
  }

  impl Summary for Tweet {
      fn summarize(&self) -> String {
          format!("{}: {}", self.username, self.content)
      }
  }

  fn main() {
      let article = NewsArticle {
          headline: String::from("Big news!"),
          location: String::from("Tokyo"),
          author: String::from("Me"),
          content: String::from("Birthday"),
      };

      println!("1 new news: {}", article.summarize());

      let tweet = Tweet {
          username: String::from("horse_ebooks"),
          content: String::from(
              "of course, as you probably already know, people",
          ),
          reply: false,
          retweet: false,
      };

      println!("1 new tweet: {}", tweet.summarize());
  }
  main()
#+end_src

#+RESULTS:
#+begin_results
1 new news: Big news!, by Me (Tokyo)
1 new tweet: horse_ebooks: of course, as you probably already know, people
()
#+end_results

制約: 外部のトレイトを外部の型に対して実装できない。コヒーレンス、孤児のルールと呼ばれる特性の一部。この制約によって、他の人のコードが自分のコードを壊したり、その逆が起きないことを保証する。

デフォルト実装。各メソッドのデフォルト実装があると、すべての型に対して実装を要求しないので便利。

#+caption: Summaryトレイトのsummarizeメソッドにデフォルト実装を指定する
#+begin_src rust :results output
  pub struct NewsArticle {
      pub headline: String,
      pub location: String,
      pub author: String,
      pub content: String,
  }

  pub trait Summary {
      fn summarize(&self) -> String {
          String::from("(Read more...)")
      }
  }

  impl Summary for NewsArticle { }

  fn main() {
      let article = NewsArticle {
          headline: String::from("Big news!"),
          location: String::from("Tokyo"),
          author: String::from("Me"),
          content: String::from("Birthday"),
      };
      println!("New article available! {}", article.summarize());
  }
  main()
#+end_src

#+RESULTS:
#+begin_results
New article available! (Read more...)
()
#+end_results

デフォルト実装は、自らのトレイトのデフォルト実装を持たない他のメソッドを呼び出すことができる。↑の場合は実装メソッドがないため、デフォルト実装が使われた。

一部だけデフォルト実装にする例。

#+begin_src rust
  pub struct Tweet {
      pub username: String,
      pub content: String,
      pub reply: bool,
      pub retweet: bool,
  }

  pub trait Summary {
      fn summarize_author(&self) -> String;

      fn summarize(&self) -> String {
          format!("Read more from {}...", self.summarize_author())
      }
  }

  impl Summary for Tweet {
      fn summarize_author(&self) -> String {
          format!("@{}", self.username)
      }
  }

  fn main() {
      let tweet = Tweet {
          username: String::from("horse_ebooks"),
          content: String::from(
              "of course, as you probably already know, people",
          ),
          reply: false,
          retweet: false,
      };

      println!("summarize: {}", tweet.summarize());
      println!("summarize_author: {}", tweet.summarize_author());
  }

  main()
#+end_src

#+RESULTS:
#+begin_results
summarize: Read more from @horse_ebooks...
summarize_author: @horse_ebooks
()
#+end_results

引数itemのsummarizeメソッドを呼ぶ関数notifyを定義する。引数itemはSummaryトレイトを実装している何らかの型。

#+begin_src rust
  pub struct Tweet {
      pub username: String,
      pub content: String,
      pub reply: bool,
      pub retweet: bool,
  }

  pub trait Summary {
      fn summarize_author(&self) -> String;

      fn summarize(&self) -> String {
          format!("Read more from {}...", self.summarize_author())
      }
  }

  impl Summary for Tweet {
      fn summarize_author(&self) -> String {
          format!("@{}", self.username)
      }
  }

  // 引数: &impl トレイト
  pub fn notify(item: &impl Summary) {
      println!("Breaking news! {}", item.summarize());
  }

  // ↑と等価で、冗長に書いたバージョン。トレイト境界
  // 山カッコの中にジェネリックな型引数の宣言を書き、型引数の後ろにコロンを挟んでトレイト境界を置く
  // pub fn notify<T: Summary>(item: &T) {
  //   // 速報! {}
  //   println!("Breaking news! {}", item.summarize());
  // }

  fn main() {
      let tweet = Tweet {
          username: String::from("horse_ebooks"),
          content: String::from(
              "of course, as you probably already know, people",
          ),
          reply: false,
          retweet: false,
      };

      notify(&tweet);
  }

  main()
#+end_src

#+RESULTS:
#+begin_results
Breaking news! Read more from @horse_ebooks...
()
#+end_results

トレイトを実装している型を返す。impl Trait構文を戻り値型のところで使うことで、あるトレイトを実装する何らかの型を返す。

#+begin_src rust
  pub struct Tweet {
      pub username: String,
      pub content: String,
      pub reply: bool,
      pub retweet: bool,
  }

  pub trait Summary {
      fn summarize_author(&self) -> String;

      fn summarize(&self) -> String {
          format!("Read more from {}...", self.summarize_author())
      }
  }

  impl Summary for Tweet {
      fn summarize_author(&self) -> String {
          format!("@{}", self.username)
      }
  }

  // impl Trait構文を戻り値型のところで使うことで、**あるトレイトを実装する**何らかの型を返す
  // 具体的な型を指定してないところがポイント
  // これはクロージャとイテレータを扱うときに特に便利。ある関数はIteratorトレイトを実装するある型を返すのだ、と簡潔に指定できる
  fn returns_summarizable() -> impl Summary {
      Tweet {
          username: String::from("horse_ebooks"),
          content: String::from(
              "of course, as you probably already know, people",
          ),
          reply: false,
          retweet: false,
      }
  }

  fn main() {
    let tweet = returns_summarizable();
    println!("result: {}", tweet.summarize_author());
  }

  main()
#+end_src

#+RESULTS:
#+begin_results
result: @horse_ebooks
()
#+end_results

- ただしimpl Traitの制約として、1種類の型を返す場合にのみ使える

関数に渡したスライスの値の型が、PartialOrdとCopyを実装する限りコンパイルできる、ジェネリックなlargest関数。

#+begin_src rust :result :outputs
  fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
      let mut largest = list[0];

      for &item in list {
          if item > largest {
              largest = item;
          }
      }

      largest
  }

  fn main() {
      let number_list = vec![34, 50, 25, 100, 65];
      let result = largest(&number_list);
      println!("The largest number is {}", result);

      let char_list = vec!['y', 'm', 'a', 'q'];
      let result = largest(&char_list);
      println!("The largest char is {}", result);
  }

  main()
#+end_src

#+RESULTS:
#+begin_results
The largest number is 100
The largest char is y
()
#+end_results

トレイト境界を使用して、メソッド実装を条件分けする。
- Pair<T>は常にnew関数を実装する。
- Pair<T>は、内部の型Tが比較を可能にするPartialOrdトレイトと出力を可能にするDisplayトレイトを実装しているときのみ、cmp_displayメソッドを実装する。

#+caption: トレイト境界によってジェネリックな型に対するメソッド実装を条件分けする
#+begin_src rust :result outputs
    use std::fmt::Display;

    struct Pair<T> {
        x: T,
        y: T,
    }

    impl<T> Pair<T>{
        fn new(x: T, y: T) -> Self {
            Self { x, y }
        }
    }

    impl <T: Display + PartialOrd> Pair<T> {
        fn cmp_display(&self) {
            if self.x >= self.y {
                println!("The largest member is x = {}", self.x);
            } else {
                println!("The largest member is y = {}", self.y);
            }
        }
    }

    fn main() {
        let pair = Pair{ x: 1, y: 2};
        pair.cmp_display();
    }
  main();

#+end_src

#+RESULTS:
#+begin_results
The largest member is y = 2
()
#+end_results

別のトレイトを実装するあらゆる型に対するトレイト実装を条件分けできる。トレイト境界を満たすあらゆる型にトレイトを実装することは、ブランケット実装と呼ばれ、Rustの標準ライブラリで広く使用される。

#+caption: rustのソースコード。標準ライブラリは、Displayトレイトを実装するあらゆる型にToStringトレイトを実装している
#+begin_src git-permalink
https://github.com/kd-collective/rust/blob/8b954910c59a7a362c60959e93110892b6e9a691/library/alloc/src/string.rs#L2388-L2402
#+end_src

#+RESULTS:
#+begin_results rust
impl<T: fmt::Display + ?Sized> ToString for T {
    // A common guideline is to not inline generic functions. However,
    // removing `#[inline]` from this method causes non-negligible regressions.
    // See <https://github.com/rust-lang/rust/pull/74852>, the last attempt
    // to try to remove it.
    #[inline]
    default fn to_string(&self) -> String {
        let mut buf = String::new();
        let mut formatter = core::fmt::Formatter::new(&mut buf);
        // Bypass format_args!() to avoid write_str with zero-length strs
        fmt::Display::fmt(self, &mut formatter)
            .expect("a Display implementation returned an error unexpectedly");
        buf
    }
}
#+end_results

整数はDisplayを実装するので、整数値を対応するString値に変換できる。
#+begin_src rust
  fn main() {
      println!("{}", 3.to_string());
  }
  main();
#+end_src

#+RESULTS:
#+begin_results
3
()
#+end_results

** ジェネリクスの概要
[[https://doc.rust-jp.rs/book-ja/ch10-00-generics.html][ジェネリック型、トレイト、ライフタイム - The Rust Programming Language 日本語版]]

#+caption: Option enumの定義にもジェネリック型が使われている。
#+begin_src rust
  enum Option<T> {
    Some(T),
    None,
  }
#+end_src

型Tの値を保持するSomeと、値を何も保持しないNone。

複数のジェネリックな型を使用できる。

#+caption: Result Enumの定義
#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

メソッド定義にも使える。

#+caption: implの直後にTを宣言しなければならない。そうすることでPointの山カッコ内の方が、具体的な型ではなくジェネリックな型であることを認識できる
#+begin_src rust
    struct Point<T> {
      x: T,
      y: T,
    }

  impl<T> Point<T> {
    fn x(&self) -> &T {
      &self.x
    }
  }

  fn main() {
    let p = Point { x: 5, y: 10};
    println!("p.x = {}", p.x());
  }
#+end_src

** matchとOption
[[https://doc.rust-jp.rs/book-ja/ch06-02-match.html][match制御フロー演算子 - The Rust Programming Language 日本語版]]

#+begin_src rust
  enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
  }

  fn value_in_cents(coin: Coin) -> u32 {
    match Coin {
      Coin::Penny => 1,
      Coin::Nickel => 5,
      Coin::Dime => 10,
      Coin::Quarter => 25,
    }
  }
#+end_src

値に束縛されるパターン。Quarterが保持するenumを増やす。

#+caption: Quarterにenumが増えた
#+begin_src rust :results output
  #[derive(Debug)]
  enum UsState {
      Alabama,
      Alaska,
  }

  enum Coin {
      Penny,
      Nickel,
      Dime,
      Quarter(UsState),
  }

  fn value_in_cents(coin: Coin) -> u32 {
      match coin {
          Coin::Penny => 1,
          Coin::Nickel => 5,
          Coin::Dime => 10,
          Coin::Quarter(state) => {
              // stateに束縛されるのは、UsState::Alabama
              println!("state quarter from {:?}!", state);
              25
          },
      }
  }

  value_in_cents(Coin::Quarter(UsState::Alabama))
#+end_src

#+RESULTS:
#+begin_results
state quarter from Alabama!
25
#+end_results

Option<T>とのマッチ。
- マッチは包括的なので、もしNoneアームがなかったとしたらエラーを出してくれる。

#+caption: 中に値があったらその値に1を足す。値がなければNoneを返す
#+begin_src rust
  fn plus_one(x: Option<i32>) -> Option<i32> {
      match x {
          None => None,
          Some(i) => Some(i + 1),
      }
  }

  fn main() {
      let five = Some(5);
      let six = plus_one(five);
      let none = plus_one(None);
  }

#+end_src

単にif letで短く書ける。

#+begin_src rust
  if let Some(thing) = thing {
     // 中身の値があるとき実行
    ｝else {
     // 中身の値がないとき実行
#+end_src
  }

#+RESULTS:
#+begin_results
error[E0433]: failed to resolve: use of undeclared type `Coin`
 --> /tmp/babel-Mwh0df/rust-jR2DGi:4:12
  |
4 |     if let Coin::Quarter(state) = coin {
  |            ^^^^ use of undeclared type `Coin`

error[E0425]: cannot find value `coin` in this scope
 --> /tmp/babel-Mwh0df/rust-jR2DGi:4:35
  |
4 |     if let Coin::Quarter(state) = coin {
  |                                   ^^^^ not found in this scope

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.
#+end_results

** enumと構造体
[[https://doc.rust-jp.rs/book-ja/ch06-01-defining-an-enum.html][Enumを定義する - The Rust Programming Language 日本語版]]

#+caption: enumの各列挙子にデータを直接添付できる
#+begin_src rust
  enum IpAddr {
      V4(String),
      V6(String),
  }

  fn main () {
      let home = IpAddr::V4(String::from("127.0.0.1"));
      let loopback = IpAddr::V6(String::from("::1"));
  }

  main()
#+end_src

別の例。

#+caption: これは当然、異なる構造体でも実現できる。しかしenumだと、この種のメッセージいずれもとる関数を簡単に定義できるメリットがある
#+begin_src rust
  enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
  }
#+end_src

Optionも、標準ライブラリにより定義されているEnum。初期化処理(prelude)に含まれているため、明示的にスコープに導入する必要がない。

#+caption: 定義
#+begin_src git-permalink
https://github.com/kd-collective/rust/blob/8b954910c59a7a362c60959e93110892b6e9a691/library/core/src/option.rs#L514-L523
#+end_src

#+RESULTS:
#+begin_results rust
pub enum Option<T> {
    /// No value
    #[lang = "None"]
    #[stable(feature = "rust1", since = "1.0.0")]
    None,
    /// Some value `T`
    #[lang = "Some"]
    #[stable(feature = "rust1", since = "1.0.0")]
    Some(#[stable(feature = "rust1", since = "1.0.0")] T),
}
#+end_results

Option値を使って数値型や文字列型を保持する例。
#+begin_src rust
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
#+end_src

Option<T>とTは異なる。Option<T>を使うためには変換が必要になる。nullである場合を明示的に処理する必要がある。

** 構造体のインスタンス化
[[https://doc.rust-jp.rs/book-ja/ch05-03-method-syntax.html][メソッド記法 - The Rust Programming Language 日本語版]]

newはない。

#+begin_src rust :results outputs
  struct Rectangle {
      width: u32,
      height: u32,
  }

  fn main() {
      let rect1 = Rectangle { width: 30, height: 50 };

      println!("The area of the rectangle is {} square pixels.", area(&rect1));
  }

  fn area(rectangle: &Rectangle) -> u32{ rectangle.width *
                                         rectangle.height }

  main()
#+end_src

#+RESULTS:
#+begin_results
The area of the rectangle is 1500 square pixels.
()
#+end_results

構造体で情報出力するために、debug注釈を追加する。

#+caption: 注釈を追加して、構造体の中身を表示できるようになる
#+begin_src rust :results outputs
  #[derive(Debug)]
  struct Rectangle {
    width: u32,
    height: u32,
  }

  fn main() {
    let rect = Rectangle { width: 1, height: 1};
    println!("rect is {:?}", rect);
  }

  main()
#+end_src

#+RESULTS:
#+begin_results
rect is Rectangle { width: 1, height: 1 }
()
#+end_results

構造体上にメソッドを実装する。

#+caption: rect1.area()で呼び出せる。型に実装することでグルーピングできる
#+begin_src rust :results outputs
  #[derive(Debug)]
  struct Rectangle {
      width: i32,
      height: i32,
  }

  impl Rectangle {
      // メソッドなので、selfはRectangle。
      fn area(&self) -> u32 {
          self.width * self.height
      }
  }

  fn main() {
      let rect1 = Rectangle{ width: 1, height: 1 }
      println!(
          "The area of the rectangle is {} square pixels.",
          rect1.area()
      );
  }
#+end_src

新しいメソッド。

#+begin_src rust :results outputs
  #[derive(Debug)]
  struct Rectangle {
      width: i32,
      height: i32,
  }

  impl Rectangle {
      fn can_hold(&self, other: &Rectangle) -> bool {
          self.width > other.width && self.height > other.height
      }
  }

  fn main() {
      let rect1 = Rectangle{ width: 30, height: 50 };
      let rect2 = Rectangle{ width: 10, height: 40 };
      let rect3 = Rectangle{ width: 60, height: 45 };

      println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
      println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
  }

  main()
#+end_src

#+RESULTS:
#+begin_results
Can rect1 hold rect2? true
Can rect1 hold rect3? false
()
#+end_results

** ライフタイム
ライフタイムを使うと、構造体に他の何かに所有されたデータへの参照を保持させることができる。
** フィールドのない構造体: ユニット様構造体
[[https://doc.rust-jp.rs/book-ja/ch05-01-defining-structs.html#%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%E3%81%AE%E3%81%AA%E3%81%84%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E6%A7%98%E3%82%88%E3%81%86%E6%A7%8B%E9%80%A0%E4%BD%93][構造体を定義し、インスタンス化する - The Rust Programming Language 日本語版]]

#+begin_quote
また、一切フィールドのない構造体を定義することもできます！これらは、()、ユニット型と似たような振る舞いをすることから、 ユニット様構造体と呼ばれます。ユニット様構造体は、ある型にトレイトを実装するけれども、 型自体に保持させるデータは一切ない場面に有効になります。トレイトについては第10章で議論します。
#+end_quote

#+caption: 使用例
#+begin_src rust
pub struct Monster {}
#+end_src

** マクロ作成
コンパイル前に動的にコードを展開して、実行することで柔軟性を得られる。

#+caption: &ast.identでパースした関数名が取れる
#+begin_src git-permalink
https://github.com/kd-collective/specs/blob/f07c484ad3caf8dccbf55c96af4ef1e3475dea28/specs-derive/src/lib.rs#L56-L57
#+end_src

#+RESULTS:
#+begin_results
fn impl_component(ast: &DeriveInput) -> proc_macro2::TokenStream {
    let name = &ast.ident;
#+end_results

#+caption: 取得した関数名を使って、quote!でマクロ展開する。quote!内が実際にコードとして実行される
#+begin_src git-permalink
https://github.com/kd-collective/specs/blob/f07c484ad3caf8dccbf55c96af4ef1e3475dea28/specs-derive/src/lib.rs#L71-L75
#+end_src

#+RESULTS:
#+begin_results rust
    quote! {
        impl #impl_generics Component for #name #ty_generics #where_clause {
            type Storage = #storage<Self>;
        }
    }
#+end_results

** unwrap()は何か
unwrap() は、 Option<T> 型や Result<T, E> 型の値（つまり、何かしらの値を ラップ している値）から中身の値を取り出す関数。たとえば Option<T> 型の値に対して unwrap() を呼ぶと、それが内包する T 型の値を返す。それらの型には値が入ってない可能性もあり、入ってない場合にはunwrapは失敗する。

[[https://ja.stackoverflow.com/questions/1730/rust%E3%81%AEunwrap%E3%81%AF%E4%BD%95%E3%82%92%E3%81%99%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B][rust - Rustの"unwrap()"は何をするものですか？ - スタック・オーバーフロー]]
** イテレータを定義する
[[https://docs.microsoft.com/ja-jp/learn/modules/rust-generic-types-traits/5-iterators][反復子を使用する - Learn | Microsoft Docs]]

#+begin_src rust
  trait Iterator {
      type Item;
      fn next(&mut self) -> Option<Self::Item>;
  }

  #[derive(Debug)]
  struct Counter {
      length: usize,
      count: usize,
  }

  impl Counter {
      fn new(length: usize) -> Counter {
          Counter {
              count: 0,
              length,
          }
      }
  }

  impl Iterator for Counter {
      type Item = usize;

      fn next(&mut self) -> Option<Self::Item> {
          self.count += 1;
          if self.count <= self.length {
              Some(self.count)
          } else {
              None
          }
      }
  }

  fn main() {
      for number in Counter::new(10) {
          println!("{}", number);
      }
  }
#+end_src

#+RESULTS:
#+begin_results
#+end_results

** Box、スマートポインタは何か
スマートポインタはポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造。
[[https://doc.rust-jp.rs/book-ja/ch15-00-smart-pointers.html][スマートポインタ - The Rust Programming Language 日本語版]]

Rustでは、boxを使う。

#+caption: Boxは値5を示し、値5はヒープに保存されている
#+begin_src rust
  fn main() {
      let b = Box::new(5);
      println!("b = {}", b);
  }
#+end_src

#+RESULTS:
#+begin_results
#+end_results

Rustでスマートポインタを利用するのに使う。
スタックではなくヒープにデータを保存する。

使う場面。

- コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時
- 多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたい時
- 値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時

[[https://doc.rust-jp.rs/book-ja/ch15-01-box.html][ヒープのデータを指すBox<T>を使用する - The Rust Programming Language 日本語版]]
** 変更を検知して自動ビルドする
変更したら自動でcargo runしてほしいときがある。

#+caption: cargo-watchを使う
#+begin_src shell
cargo install cargo-watch
cargo watch -x run
#+end_src
** ~println!~ マクロとは何か
#+begin_src rust
  println!("hello world!");
  println!("{} days", 31);
  println!("{0}, this is {1}, {1}, this is {0}", "Alice", "Bob");
  println!("{} of {:b} people know binary, the other half doesn't", 1, 2);
  println!("{number:>0width$}", number=1, width=6);
  println!("{subject} {verb} {object}", object="the lazy dog", subject="the quick brown fox", verb="jumps over");
#+end_src

#+RESULTS:
#+begin_results
hello world!
31 days
Alice, this is Bob, Bob, this is Alice
1 of 10 people know binary, the other half doesn't
000001
the quick brown fox jumps over the lazy dog
#+end_results

引数チェックもしてくれる。
#+begin_src rust
  println!("My name is {0}, {1} {0}", "Bond");
#+end_src

#+RESULTS:
#+begin_results
error: invalid reference to positional argument 1 (there is 1 argument)
 --> /tmp/babel-wnDbpn/rust-W98kSP:2:27
  |
2 | println!("My name is {0}, {1} {0}", "Bond");
  |                           ^^^
  |
  = note: positional arguments are zero-based

error: aborting due to previous error
#+end_results

マーカーの変更。
#+begin_src rust
  println!("This struct `{}` won't print...", Structure(3));
#+end_src

#+RESULTS:
#+begin_results
error[E0425]: cannot find function, tuple struct or tuple variant `Structure` in this scope
 --> /tmp/babel-wnDbpn/rust-If17CF:2:45
  |
2 | println!("This struct `{}` won't print...", Structure(3));
  |                                             ^^^^^^^^^ not found in this scope

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
#+end_results

#+begin_src rust
  #[derive(Debug)]
  struct Structure(i32);
  println!("This struct `{:?}` won't print...", Structure(3));
#+end_src

#+RESULTS:
#+begin_results
This struct `Structure(3)` won't print...
#+end_results

* パッケージ
** ホームディレクトリのチルダを展開するライブラリ
:LOGBOOK:
CLOCK: [2022-08-01 Mon 10:32]--[2022-08-01 Mon 10:57] =>  0:25
CLOCK: [2022-07-31 Sun 22:24]--[2022-07-31 Sun 22:49] =>  0:25
:END:
- [[https://github.com/netvl/shellexpand][netvl/shellexpand: A library for shell-like expansions of variables in strings]]

どういうわけかデフォルトで展開してくれないので、ライブラリで変換する必要がある。

#+caption: ホームディレクトリで ls コマンドを実行する
#+begin_src rust
  extern crate shellexpand;

  fn main() {
      let cwd = format!("{}", shellexpand::tilde("~/"));
      Command::new("ls").current_dir(&cwd);
  }
#+end_src

** OSディレクトリライブラリ
- [[https://github.com/xdg-rs/dirs][xdg-rs/dirs: a low-level library that provides config/cache/data paths, following the respective conventions on Linux, macOS and Windows]]

OS間のディレクトリの違いを吸収するライブラリ。ミニマルでコードを読みやすい。
** [[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]をRustで書き直すプロジェクト
EmacsのC言語で書かれた部分をRustに書き直すリポジトリがある。
[[https://github.com/remacs/remacs][remacs/remacs: Rust Emacs]]
** 超高速検索できるripgrep
高速検索するripgrepは、ほかのどのgrepツールより早いらしい。

- repository :: [[https://github.com/BurntSushi/ripgrep][BurntSushi/ripgrep]]
** 外観がかっこいい[[id:585d3b5e-989d-4363-bcc3-894402fcfcf9][Shell]], nushell
[[id:fa497359-ae3f-494a-b24a-9822eefe67ad][System Crafters]]の動画[[https://www.youtube.com/watch?v=IHeKUeO7bpo][Integrating Nushell with Emacs]]のコラボ回で出たパッケージ。
リッチな出力形式、便利コマンドがすごい。
- repository :: [[https://github.com/nushell/nushell][nushell/nushell: A new type of shell]]
* Tasks
** [[https://slide-rs.github.io/specs-website/docs/book/master/01_intro.html#introduction][Introduction - The Specs Book]]
ECSとSpecsのドキュメント。
** [[https://docs.microsoft.com/ja-jp/learn/paths/rust-first-steps/][Rust の最初のステップ - Learn | Microsoft Docs]]
:LOGBOOK:
CLOCK: [2022-05-14 Sat 17:23]--[2022-05-14 Sat 17:48] =>  0:25
CLOCK: [2022-05-14 Sat 16:41]--[2022-05-14 Sat 17:06] =>  0:25
CLOCK: [2022-05-14 Sat 16:02]--[2022-05-14 Sat 16:27] =>  0:25
CLOCK: [2022-05-14 Sat 11:57]--[2022-05-14 Sat 12:22] =>  0:25
:END:
Microsoftのチュートリアル。
** TODO [[https://doc.rust-jp.rs/rust-by-example-ja/][Introduction - Rust By Example 日本語版]]
** TODO [[https://doc.rust-jp.rs/book-ja/title-page.html][The Rust Programming Language 日本語版]]
:LOGBOOK:
CLOCK: [2022-07-18 Mon 21:13]--[2022-07-18 Mon 21:38] =>  0:25
CLOCK: [2022-07-17 Sun 21:19]--[2022-07-17 Sun 21:44] =>  0:25
CLOCK: [2022-07-03 Sun 23:24]--[2022-07-03 Sun 23:49] =>  0:25
CLOCK: [2022-07-03 Sun 21:57]--[2022-07-03 Sun 22:22] =>  0:25
CLOCK: [2022-07-03 Sun 21:09]--[2022-07-03 Sun 21:34] =>  0:25
CLOCK: [2022-07-03 Sun 19:47]--[2022-07-03 Sun 20:12] =>  0:25
CLOCK: [2022-07-03 Sun 19:15]--[2022-07-03 Sun 19:40] =>  0:25
CLOCK: [2022-07-03 Sun 17:04]--[2022-07-03 Sun 17:29] =>  0:25
CLOCK: [2022-07-03 Sun 16:39]--[2022-07-03 Sun 17:04] =>  0:25
CLOCK: [2022-07-03 Sun 16:05]--[2022-07-03 Sun 16:30] =>  0:25
CLOCK: [2022-07-03 Sun 15:40]--[2022-07-03 Sun 16:05] =>  0:25
CLOCK: [2022-07-03 Sun 11:47]--[2022-07-03 Sun 12:12] =>  0:25
CLOCK: [2022-07-03 Sun 11:14]--[2022-07-03 Sun 11:39] =>  0:25
CLOCK: [2022-07-03 Sun 10:38]--[2022-07-03 Sun 11:03] =>  0:25
CLOCK: [2022-07-03 Sun 00:40]--[2022-07-03 Sun 01:05] =>  0:25
CLOCK: [2022-07-02 Sat 22:12]--[2022-07-02 Sat 22:37] =>  0:25
CLOCK: [2022-07-02 Sat 21:44]--[2022-07-02 Sat 22:09] =>  0:25
CLOCK: [2022-06-16 Thu 23:00]--[2022-06-16 Thu 23:25] =>  0:25
CLOCK: [2022-06-11 Sat 18:10]--[2022-06-11 Sat 18:35] =>  0:25
CLOCK: [2022-06-11 Sat 17:32]--[2022-06-11 Sat 17:57] =>  0:25
CLOCK: [2022-06-11 Sat 10:35]--[2022-06-11 Sat 11:00] =>  0:25
:END:
- 10
* Reference
** [[https://scrapbox.io/nwtgck/Rust%E3%81%A7%E5%80%A4%E3%81%8B%E3%82%89%E5%9E%8B%E6%83%85%E5%A0%B1%E3%82%92%E6%96%87%E5%AD%97%E5%88%97%E3%81%A8%E3%81%97%E3%81%A6%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%EF%BC%88stable%EF%BC%89][Rustで値から型情報を文字列として取得する（stable） - nwtgck / Ryo Ota]]
デバッグで便利そう。
** [[https://qiita.com/smicle/items/29a4d5d1d14ad7f77f60][rust String &str の変換と、文字列 数値 の変換 - Qiita]]
** [[https://qiita.com/yagince/items/e7474839246ced595f7a][[Rust] &strとStringを理解しようと思ったらsliceやmutを理解できてないことに気づいた話 - Qiita]]
** [[https://zenn.dev/toga/books/rust-atcoder/viewer/01-intro][序｜RustCoder ―― AtCoder と Rust で始める競技プログラミング入門]]
入門本。
** [[https://ja.wikipedia.org/wiki/Rust_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E)][Rust (プログラミング言語) - Wikipedia]]
* Archives
** DONE [[https://rust-cli.github.io/book/index.html][Getting started - Command Line Applications in Rust]]
CLOSED: [2022-05-04 Wed 16:40]
:LOGBOOK:
CLOCK: [2022-05-04 Wed 16:39]--[2022-05-04 Wed 16:40] =>  0:01
CLOCK: [2022-05-04 Wed 16:05]--[2022-05-04 Wed 16:30] =>  0:25
CLOCK: [2022-05-04 Wed 11:12]--[2022-05-04 Wed 11:37] =>  0:25
CLOCK: [2022-05-04 Wed 10:47]--[2022-05-04 Wed 11:12] =>  0:25
CLOCK: [2022-05-03 Tue 10:27]--[2022-05-03 Tue 10:52] =>  0:25
:END:
コマンドラインプログラムを作るチュートリアル。
** DONE [[https://www.amazon.co.jp/-/en/%E3%82%AF%E3%82%B8%E3%83%A9%E9%A3%9B%E8%A1%8C%E6%9C%BA/dp/4802613512/ref=sr_1_5?crid=14EZ2K0WKN0UY&keywords=Rust&qid=1648043657&sprefix=rus%2Caps%2C165&sr=8-5][手を動かして考えればよくわかる 高効率言語 Rust 書きかた・作りかた]] :Read:
CLOSED: [2022-05-03 Tue 09:50]
:LOGBOOK:
CLOCK: [2022-04-29 Fri 13:36]--[2022-04-29 Fri 14:01] =>  0:25
CLOCK: [2022-04-29 Fri 13:10]--[2022-04-29 Fri 13:35] =>  0:25
CLOCK: [2022-04-28 Thu 10:27]--[2022-04-28 Thu 10:53] =>  0:26
CLOCK: [2022-04-28 Thu 09:48]--[2022-04-28 Thu 10:13] =>  0:25
CLOCK: [2022-04-24 Sun 16:37]--[2022-04-24 Sun 17:02] =>  0:25
CLOCK: [2022-04-24 Sun 14:43]--[2022-04-24 Sun 15:08] =>  0:25
CLOCK: [2022-04-24 Sun 14:06]--[2022-04-24 Sun 14:31] =>  0:25
CLOCK: [2022-04-24 Sun 12:26]--[2022-04-24 Sun 12:51] =>  0:25
CLOCK: [2022-04-10 Sun 19:35]--[2022-04-10 Sun 20:00] =>  0:25
CLOCK: [2022-04-10 Sun 19:09]--[2022-04-10 Sun 19:34] =>  0:25
CLOCK: [2022-04-07 Thu 23:12]--[2022-04-07 Thu 23:37] =>  0:25
CLOCK: [2022-03-26 Sat 19:24]--[2022-03-26 Sat 19:49] =>  0:25
CLOCK: [2022-03-26 Sat 00:12]--[2022-03-26 Sat 00:37] =>  0:25
CLOCK: [2022-03-25 Fri 09:51]--[2022-03-25 Fri 10:16] =>  0:25
CLOCK: [2022-03-23 Wed 23:33]--[2022-03-23 Wed 23:58] =>  0:25
CLOCK: [2022-03-23 Wed 22:54]--[2022-03-23 Wed 23:19] =>  0:25
:END:
*** 構造体に実装する
#+caption: 型に実装する
#+begin_src rust :results output
    fn main() {
      let body = Body::new(163.0, 75.2, "田中");
      body.print_result();
      let body = Body::new(158.2, 55.0, "鈴木");
      body.print_result();
      let body = Body::new(174.2, 54.2, "井上");
      body.print_result();
    }

  struct BmiRange {
      min: f64,
      max: f64,
      label: String,
  }

  impl BmiRange {
    fn new(min: f64, max: f64, label: &str) -> Self {
      BmiRange{ min, max, label: label.to_string() }
    }

    fn test(&self, v: f64) -> bool {
      (self.min <= v) && (v < self.max)
    }
  }

  struct Body {
    height: f64,
    weight: f64,
    name: String,
  }

  impl Body {
    fn new(height: f64, weight: f64, name: &str) -> Self {
        Body{ height, weight, name: name.to_string() }
    }

    fn calc_bmi(&self) -> f64 {
      self.weight / (self.height / 100.0).powf(2.0)
    }

    fn print_result(&self) {
      let bmi = self.calc_bmi();
      let bmi_list = [
        BmiRange::new(0.0, 18.5, "低体重"),
        BmiRange::new(18.5, 25.0, "普通体重"),
        BmiRange::new(25.0, 30.0, "肥満1度"),
        BmiRange::new(30.0, 35.0, "肥満2度"),
        BmiRange::new(35.0, 40.0, "肥満3度"),
      ];
      let mut result = String::from("不明");
      for range in bmi_list {
        if range.test(bmi) {
          result = range.label.clone();
          break;
        }
      }
      println!("{}さん、 BMI={:.1}, 判定={}",
      self.name, bmi, result);
    }
  }
main()
#+end_src

#+RESULTS:
#+begin_results
田中さん、 BMI=28.3, 判定=肥満1度
鈴木さん、 BMI=22.0, 判定=普通体重
井上さん、 BMI=17.9, 判定=低体重
()
#+end_results
*** None, Result
#+caption: 列挙型を使う
#+begin_src rust :results output
  struct Counter {
    value: i64,
  }

  impl Counter {
    fn new() -> Self {
      Counter { value: 0 }
    }

    fn inc(&mut self) {
      self.value += 1;
      println!("value={}", self.value);
    }
  }

  fn count(counter: Option<&mut Counter>) {
    match counter{
      None => return,
      Some(c) => c.inc(),
    };
  }

  fn main() {
    let mut a = Counter::new();
    count(Some(&mut a));
    count(Some(&mut a));
    let a = None;
    count(a);
  }
  main();
#+end_src

#+RESULTS:
#+begin_results
value=1
value=2
()
#+end_results
** DONE [[https://bfnightly.bracketproductions.com/][Introduction - Roguelike Tutorial - In Rust]]
CLOSED: [2022-05-14 Sat 11:40]
:LOGBOOK:
CLOCK: [2022-04-02 Sat 23:33]--[2022-04-02 Sat 23:58] =>  0:25
CLOCK: [2022-04-02 Sat 21:36]--[2022-04-02 Sat 22:01] =>  0:25
CLOCK: [2022-04-02 Sat 21:11]--[2022-04-02 Sat 21:36] =>  0:25
CLOCK: [2022-04-02 Sat 20:13]--[2022-04-02 Sat 20:38] =>  0:25
CLOCK: [2022-04-02 Sat 19:14]--[2022-04-02 Sat 19:39] =>  0:25
CLOCK: [2022-04-02 Sat 17:55]--[2022-04-02 Sat 18:20] =>  0:25
CLOCK: [2022-04-02 Sat 17:24]--[2022-04-02 Sat 17:49] =>  0:25
CLOCK: [2022-04-02 Sat 16:46]--[2022-04-02 Sat 17:11] =>  0:25
CLOCK: [2022-04-02 Sat 16:17]--[2022-04-02 Sat 16:42] =>  0:25
CLOCK: [2022-04-02 Sat 15:52]--[2022-04-02 Sat 16:17] =>  0:25
CLOCK: [2022-04-02 Sat 15:26]--[2022-04-02 Sat 15:51] =>  0:25
CLOCK: [2022-04-02 Sat 11:35]--[2022-04-02 Sat 12:00] =>  0:25
CLOCK: [2022-04-02 Sat 11:10]--[2022-04-02 Sat 11:35] =>  0:25
CLOCK: [2022-04-01 Fri 22:52]--[2022-04-01 Fri 23:17] =>  0:25
CLOCK: [2022-04-01 Fri 22:00]--[2022-04-01 Fri 22:25] =>  0:25
CLOCK: [2022-04-01 Fri 20:19]--[2022-04-01 Fri 20:44] =>  0:25
CLOCK: [2022-03-31 Thu 22:30]--[2022-03-31 Thu 22:55] =>  0:25
CLOCK: [2022-03-31 Thu 21:23]--[2022-03-31 Thu 21:48] =>  0:25
CLOCK: [2022-03-31 Thu 09:38]--[2022-03-31 Thu 10:03] =>  0:25
CLOCK: [2022-03-31 Thu 09:13]--[2022-03-31 Thu 09:38] =>  0:25
CLOCK: [2022-03-31 Thu 00:11]--[2022-03-31 Thu 00:36] =>  0:25
CLOCK: [2022-03-30 Wed 23:45]--[2022-03-31 Thu 00:10] =>  0:25
CLOCK: [2022-03-30 Wed 23:20]--[2022-03-30 Wed 23:45] =>  0:25
CLOCK: [2022-03-30 Wed 10:31]--[2022-03-30 Wed 10:56] =>  0:25
CLOCK: [2022-03-30 Wed 09:56]--[2022-03-30 Wed 10:21] =>  0:25
CLOCK: [2022-03-29 Tue 22:48]--[2022-03-29 Tue 23:13] =>  0:25
CLOCK: [2022-03-28 Mon 23:58]--[2022-03-29 Tue 00:23] =>  0:25
CLOCK: [2022-03-28 Mon 22:28]--[2022-03-28 Mon 22:53] =>  0:25
CLOCK: [2022-03-28 Mon 10:26]--[2022-03-28 Mon 10:51] =>  0:25
CLOCK: [2022-03-28 Mon 09:58]--[2022-03-28 Mon 10:23] =>  0:25
CLOCK: [2022-03-28 Mon 09:21]--[2022-03-28 Mon 09:46] =>  0:25
CLOCK: [2022-03-27 Sun 23:09]--[2022-03-27 Sun 23:34] =>  0:25
CLOCK: [2022-03-27 Sun 22:44]--[2022-03-27 Sun 23:09] =>  0:25
CLOCK: [2022-03-27 Sun 22:16]--[2022-03-27 Sun 22:41] =>  0:25
CLOCK: [2022-03-27 Sun 21:51]--[2022-03-27 Sun 22:16] =>  0:25
CLOCK: [2022-03-27 Sun 21:12]--[2022-03-27 Sun 21:37] =>  0:25
CLOCK: [2022-03-27 Sun 20:46]--[2022-03-27 Sun 21:11] =>  0:25
CLOCK: [2022-03-27 Sun 19:43]--[2022-03-27 Sun 20:08] =>  0:25
CLOCK: [2022-03-27 Sun 19:18]--[2022-03-27 Sun 19:43] =>  0:25
CLOCK: [2022-03-27 Sun 18:36]--[2022-03-27 Sun 19:01] =>  0:25
CLOCK: [2022-03-27 Sun 17:43]--[2022-03-27 Sun 18:08] =>  0:25
CLOCK: [2022-03-27 Sun 17:08]--[2022-03-27 Sun 17:33] =>  0:25
CLOCK: [2022-03-27 Sun 16:33]--[2022-03-27 Sun 16:58] =>  0:25
CLOCK: [2022-03-27 Sun 15:50]--[2022-03-27 Sun 16:15] =>  0:25
CLOCK: [2022-03-27 Sun 15:11]--[2022-03-27 Sun 15:36] =>  0:25
CLOCK: [2022-03-27 Sun 14:43]--[2022-03-27 Sun 15:08] =>  0:25
CLOCK: [2022-03-27 Sun 14:17]--[2022-03-27 Sun 14:42] =>  0:25
CLOCK: [2022-03-27 Sun 00:37]--[2022-03-27 Sun 01:02] =>  0:25
CLOCK: [2022-03-26 Sat 23:32]--[2022-03-26 Sat 23:57] =>  0:25
CLOCK: [2022-03-26 Sat 23:06]--[2022-03-26 Sat 23:31] =>  0:25
CLOCK: [2022-03-26 Sat 21:08]--[2022-03-26 Sat 21:33] =>  0:25
CLOCK: [2022-03-26 Sat 18:43]--[2022-03-26 Sat 19:08] =>  0:25
CLOCK: [2022-03-26 Sat 17:56]--[2022-03-26 Sat 18:21] =>  0:25
CLOCK: [2022-03-26 Sat 16:19]--[2022-03-26 Sat 16:44] =>  0:25
CLOCK: [2022-03-26 Sat 15:46]--[2022-03-26 Sat 16:11] =>  0:25
CLOCK: [2022-03-26 Sat 15:06]--[2022-03-26 Sat 15:31] =>  0:25
CLOCK: [2022-03-26 Sat 11:36]--[2022-03-26 Sat 12:01] =>  0:25
CLOCK: [2022-03-26 Sat 11:02]--[2022-03-26 Sat 11:27] =>  0:25
CLOCK: [2022-03-26 Sat 09:54]--[2022-03-26 Sat 10:19] =>  0:25
CLOCK: [2022-03-25 Fri 23:44]--[2022-03-26 Sat 00:09] =>  0:25
CLOCK: [2022-03-25 Fri 23:18]--[2022-03-25 Fri 23:43] =>  0:25
CLOCK: [2022-03-25 Fri 22:46]--[2022-03-25 Fri 23:11] =>  0:25
CLOCK: [2022-03-25 Fri 10:33]--[2022-03-25 Fri 10:58] =>  0:25
CLOCK: [2022-03-25 Fri 09:23]--[2022-03-25 Fri 09:48] =>  0:25
CLOCK: [2022-03-24 Thu 23:26]--[2022-03-24 Thu 23:51] =>  0:25
CLOCK: [2022-03-24 Thu 23:00]--[2022-03-24 Thu 23:25] =>  0:25
CLOCK: [2022-03-22 Tue 23:37]--[2022-03-23 Wed 00:02] =>  0:25
CLOCK: [2022-03-22 Tue 22:27]--[2022-03-22 Tue 22:52] =>  0:25
CLOCK: [2022-03-21 Mon 23:31]--[2022-03-21 Mon 23:57] =>  0:26
CLOCK: [2022-03-21 Mon 22:34]--[2022-03-21 Mon 22:59] =>  0:25
CLOCK: [2022-03-21 Mon 21:18]--[2022-03-21 Mon 21:43] =>  0:25
CLOCK: [2022-03-21 Mon 20:39]--[2022-03-21 Mon 21:04] =>  0:25
CLOCK: [2022-03-21 Mon 20:01]--[2022-03-21 Mon 20:26] =>  0:25
CLOCK: [2022-03-21 Mon 18:59]--[2022-03-21 Mon 19:24] =>  0:25
CLOCK: [2022-03-21 Mon 17:17]--[2022-03-21 Mon 17:42] =>  0:25
CLOCK: [2022-03-21 Mon 16:26]--[2022-03-21 Mon 16:51] =>  0:25
CLOCK: [2022-03-21 Mon 15:48]--[2022-03-21 Mon 16:13] =>  0:25
CLOCK: [2022-03-21 Mon 14:58]--[2022-03-21 Mon 15:23] =>  0:25
CLOCK: [2022-03-21 Mon 14:27]--[2022-03-21 Mon 14:52] =>  0:25
CLOCK: [2022-03-21 Mon 13:53]--[2022-03-21 Mon 14:18] =>  0:25
CLOCK: [2022-03-21 Mon 13:11]--[2022-03-21 Mon 13:36] =>  0:25
CLOCK: [2022-03-21 Mon 00:10]--[2022-03-21 Mon 00:35] =>  0:25
CLOCK: [2022-03-20 Sun 22:33]--[2022-03-20 Sun 22:58] =>  0:25
CLOCK: [2022-03-20 Sun 21:28]--[2022-03-20 Sun 21:53] =>  0:25
CLOCK: [2022-03-20 Sun 20:55]--[2022-03-20 Sun 21:20] =>  0:25
CLOCK: [2022-03-20 Sun 20:20]--[2022-03-20 Sun 20:45] =>  0:25
CLOCK: [2022-03-20 Sun 18:30]--[2022-03-20 Sun 18:55] =>  0:25
CLOCK: [2022-03-20 Sun 17:56]--[2022-03-20 Sun 18:21] =>  0:25
CLOCK: [2022-03-20 Sun 15:53]--[2022-03-20 Sun 16:18] =>  0:25
CLOCK: [2022-03-20 Sun 15:20]--[2022-03-20 Sun 15:45] =>  0:25
CLOCK: [2022-03-20 Sun 14:49]--[2022-03-20 Sun 15:14] =>  0:25
CLOCK: [2022-03-20 Sun 10:34]--[2022-03-20 Sun 10:59] =>  0:25
CLOCK: [2022-03-20 Sun 00:28]--[2022-03-20 Sun 00:54] =>  0:26
CLOCK: [2022-03-19 Sat 22:17]--[2022-03-19 Sat 22:42] =>  0:25
CLOCK: [2022-03-19 Sat 21:45]--[2022-03-19 Sat 22:10] =>  0:25
CLOCK: [2022-03-19 Sat 19:56]--[2022-03-19 Sat 20:21] =>  0:25
CLOCK: [2022-03-19 Sat 18:40]--[2022-03-19 Sat 19:05] =>  0:25
CLOCK: [2022-03-19 Sat 17:12]--[2022-03-19 Sat 17:37] =>  0:25
CLOCK: [2022-03-19 Sat 16:33]--[2022-03-19 Sat 16:58] =>  0:25
CLOCK: [2022-03-19 Sat 15:56]--[2022-03-19 Sat 16:21] =>  0:25
CLOCK: [2022-03-19 Sat 15:13]--[2022-03-19 Sat 15:38] =>  0:25
:END:

[[id:50ac66da-89f2-42dc-a746-d20b041d06ae][roguelike]]を作る長大なチュートリアル。
とりあえず14章までやり、理解を確かめるため自作改造フェーズに入った。
残りの部分はチュートリアルとしてやるというより、自作するうえで都度参照していく。
** DONE clone ツール
CLOSED: [2022-07-31 Sun 10:53]
:LOGBOOK:
CLOCK: [2022-07-31 Sun 11:30]--[2022-07-31 Sun 11:55] =>  0:25
CLOCK: [2022-07-30 Sat 22:59]--[2022-07-30 Sat 23:24] =>  0:25
CLOCK: [2022-07-30 Sat 22:33]--[2022-07-30 Sat 22:58] =>  0:25
CLOCK: [2022-07-30 Sat 21:57]--[2022-07-30 Sat 22:22] =>  0:25
CLOCK: [2022-07-30 Sat 21:29]--[2022-07-30 Sat 21:54] =>  0:25
CLOCK: [2022-07-30 Sat 20:54]--[2022-07-30 Sat 21:19] =>  0:25
CLOCK: [2022-07-30 Sat 20:15]--[2022-07-30 Sat 20:40] =>  0:25
CLOCK: [2022-07-30 Sat 19:45]--[2022-07-30 Sat 20:10] =>  0:25
CLOCK: [2022-07-30 Sat 19:20]--[2022-07-30 Sat 19:45] =>  0:25
CLOCK: [2022-07-30 Sat 16:11]--[2022-07-30 Sat 16:36] =>  0:25
:END:

git cloneをコード管理するツール。初期化したときに、再度cloneしまくるのがメンドいため。とりあえず完了。
