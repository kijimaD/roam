<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-11-01 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Scala</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel='shortcut icon' type='image/x-icon' href='/roam/favicon.ico' /><link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css' /><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css' /><link rel='stylesheet' href='../css/site.css' /><link rel='stylesheet' href='../roam/css/code.css' /><link rel='stylesheet' href='css/site.css' /><link rel='stylesheet' href='css/code.css' />
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content">
<h1 class="title">Scala</h1>
<div id="outline-container-org210c367" class="outline-2">
<h2 id="org210c367"><a href="#org210c367">概要</a></h2>
<div class="outline-text-2" id="text-org210c367">
<p>
Scalaはオブジェクト指向言語と関数型の特徴を合わせた<a href="20210509101246-programming_language.html#ID-868ac56a-2d42-48d7-ab7f-7047c85a8f39">Programming Language</a>。
<a href="20210926143813-clojure.html#ID-6218deb2-43df-473a-8cdf-910c47edd801">Clojure</a>と同様に<a href="20211007104541-java.html#ID-9fa3711b-a22e-4cf5-ae97-5c057083674a">Java</a>仮想マシン上で動作するため、<a href="20211007104541-java.html#ID-9fa3711b-a22e-4cf5-ae97-5c057083674a">Java</a>のコードベース流用ができる。
</p>
</div>
</div>
<div id="outline-container-org5bbaeeb" class="outline-2">
<h2 id="org5bbaeeb"><a href="#org5bbaeeb">Memo</a></h2>
<div class="outline-text-2" id="text-org5bbaeeb">
</div>
<div id="outline-container-orgb63ffa4" class="outline-3">
<h3 id="orgb63ffa4"><a href="#orgb63ffa4">ammonite</a></h3>
<div class="outline-text-3" id="text-orgb63ffa4">
<p>
replがあると気軽に試せる。
実行にはammoniteを使う。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>インストールと実行</label><pre class="src src-shell">$ sudo sh -c <span class="org-string">'(echo "#!/usr/bin/env sh" &amp;&amp; curl -L https://github.com/com-lihaoyi/Ammonite/releases/download/2.4.0/2.13-2.4.0) &gt; /usr/local/bin/amm &amp;&amp; chmod +x /usr/local/bin/amm'</span>
$ amm
</pre>
</div>

<p>
ファイル実行が便利。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>-w(= &#x2013;watch) で自動実行できる</label><pre class="src src-shell">amm test.sc
amm -w test.sc <span class="org-comment-delimiter"># </span><span class="org-comment">&#22793;&#26356;&#12434;&#26908;&#30693;&#12375;&#12390;&#33258;&#21205;&#12467;&#12531;&#12497;&#12452;&#12523;</span>
</pre>
</div>

<p>
ファイルの関数を読み込んだ状態でreplをスタートする。すぐに実行できる。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>&#x2013;predef オプション</label><pre class="src src-shell">amm --predef test.sc
</pre>
</div>
</div>
</div>
<div id="outline-container-org2659a8f" class="outline-3">
<h3 id="org2659a8f"><a href="#org2659a8f">sbt</a></h3>
<div class="outline-text-3" id="text-org2659a8f">
<p>
sbtはScalaのビルドツールのこと。
</p>
</div>
</div>
</div>
<div id="outline-container-org5863b1c" class="outline-2">
<h2 id="org5863b1c"><a href="#org5863b1c"><a href="https://www.oreilly.co.jp/books/9784873114811/">O&rsquo;Reilly Japan - プログラミングScala</a></a></h2>
<div class="outline-text-2" id="text-org5863b1c">
</div>
<div id="outline-container-org1d7c502" class="outline-3">
<h3 id="org1d7c502"><a href="#org1d7c502">_</a></h3>
<div class="outline-text-3" id="text-org1d7c502">
<p>
scalaの入門本。
のはずだが、後半は全くわからなかった。経験積んで戻る必要がある。
</p>
</div>
</div>
<div id="outline-container-org389457b" class="outline-3">
<h3 id="org389457b"><a href="#org389457b">progress</a></h3>
<div class="outline-text-3" id="text-org389457b">
</div>
<div id="outline-container-orgd287fb7" class="outline-4">
<h4 id="orgd287fb7"><a href="#orgd287fb7"><span class="done DONE">DONE</span> 100</a></h4>
<div class="outline-text-4" id="text-orgd287fb7">
</div>
</div>
<div id="outline-container-org537c8a0" class="outline-4">
<h4 id="org537c8a0"><a href="#org537c8a0"><span class="done DONE">DONE</span> 200</a></h4>
<div class="outline-text-4" id="text-org537c8a0">
</div>
</div>
<div id="outline-container-orgaecb75d" class="outline-4">
<h4 id="orgaecb75d"><a href="#orgaecb75d"><span class="done DONE">DONE</span> 300</a></h4>
<div class="outline-text-4" id="text-orgaecb75d">
</div>
</div>
<div id="outline-container-org33f5d36" class="outline-4">
<h4 id="org33f5d36"><a href="#org33f5d36"><span class="done DONE">DONE</span> 400</a></h4>
<div class="outline-text-4" id="text-org33f5d36">
</div>
</div>
<div id="outline-container-org0ba4d29" class="outline-4">
<h4 id="org0ba4d29"><a href="#org0ba4d29"><span class="done DONE">DONE</span> 500</a></h4>
<div class="outline-text-4" id="text-org0ba4d29">
</div>
</div>
</div>
<div id="outline-container-org1f10350" class="outline-3">
<h3 id="org1f10350"><a href="#org1f10350">Hello, world</a></h3>
<div class="outline-text-3" id="text-org1f10350">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Upperクラス、upperメソッドを書く</label><pre class="src src-scala">class Upper {
  def upper(strings: String*): Seq[String] = {
    strings.map((s:String) =&gt; s.toUpperCase())
  }
}
val up = new Upper
Console.println(up.upper("A", "First", "Scala", "Program"))
</pre>
</div>

<div class="results" id="orgcaefbaf">
<p>
ArraySeq(A, FIRST, SCALA, PROGRAM)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>↑の例と同じ結果で短く書く。Upperをシングルトンであるobjectとして宣言する</label><pre class="src src-scala">  object Upper {
    def upper(strings: String*) = strings.map(_.toUpperCase())
  }
Console.println(Upper.upper("A", "First", "Scala", "Program")) // new Upper によってインスタンスを生成する代わりに、単にUpperオブジェクトのUpperメソッドを直接呼ぶ
</pre>
</div>

<div class="results" id="orge0fd023">
<p>
ArraySeq(A, FIRST, SCALA, PROGRAM)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>さらにリファクタリング。_プレースホルダは省略記法</label><pre class="src src-scala">object Upper {
  def main(args: Array[String]) = {
    args.map(_.toUpperCase()).foreach(printf("%s ",_))
    println("")
  }
}

Upper.main(Array("Hello", "World"))
</pre>
</div>

<div class="results" id="org078fbc2">
<p>
HELLO WORLD
</p>

</div>
</div>
</div>

<div id="outline-container-orgd8b822e" class="outline-3">
<h3 id="orgd8b822e"><a href="#orgd8b822e">非同期実行</a></h3>
<div class="outline-text-3" id="text-orgd8b822e">
<ul class="org-ul">
<li>valキーワードは、同名の読み取り専用のフィールドと同名の公開読み取りメソッドに自動的に変換される
<ul class="org-ul">
<li>Pointをインスタンス化した場合、そのフィールドをpoint.xやpoint.yで読み取ることができる</li>
</ul></li>
<li>scalaでは、具象メソッドをオーバーライドする場合、overrideキーワードが必要</li>
<li>Shapeは抽象クラス。つまりインスタンス化できない
<ul class="org-ul">
<li>Shapeのメソッドは抽象メソッド。本体をもたない</li>
</ul></li>
<li>drawメソッドが返すUnitは、<a href="20210911104632-c_language.html#ID-656a0aa4-e5d3-416f-82d5-f909558d0639">C language</a>などにおけるvoidに相当する</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>shapes.scala</label><pre class="src src-scala">package shapes {
  class Point (val x: Double, val y: Double) {
    override def toString() = "Point(" + x + "," + y + ")"
  }

  abstract class Shape() {
    def draw() : Unit
  }

  class Circle(val center: Point, val radius: Double) extends Shape {
    def draw() = println("Circle.draw: " + this)
    override def toString() = "Circle(" + center + "," + radius + ")"
  }

  class Rectangle(val lowerLeft: Point, val height: Double, val width: Double)
      extends Shape {
    def draw() = println("Rectangle.draw: " + this)
    override def toString() =
      "Rectangle(" + lowerLeft + "," + height + "," + width + ")"
  }

  class Triangle(val point1: Point, val point2: Point, val point3: Point)
      extends Shape {
    def draw() = println("Triangle.draw: " + this)
    override def toString() =
      "Triangle(" + point1 + "," + point2 + "," + point3 + ")"
  }
}
</pre>
</div>

<ul class="org-ul">
<li>importでの <code>_</code> は、すべての型をインポートすることを示す( <code>*</code> は関数名として有効だから)</li>
<li>actメソッドは抽象メソッドなので、オーバーライドするのに明示的なoverrideキーワードは不要</li>
</ul>

<div class="org-src-container">
<pre class="src src-scala">packages shapes {
  import scala.actors._
  import scala.actors.Actor._

  object ShapeDrawingActor extends Actor {
    def act() {
      loop {
        receive {
          case s: Shape =&gt; s.draw()
          case "exit" =&gt; println("exiting..."); exit
          case x: Any =&gt; println("Error: Unknown message! " + x)
        }
      }
    }
  }
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>shapes-actor-script.scala アクターを使用する</label><pre class="src src-scala">import shapes._
ShapeDrawingActor.start()
ShapeDrawingActor | new Circle(new Point(0.0,0.0), 1.0)
ShapeDrawingActor | new Rectangle(new Point(0.0,0.0), 2, 5)
ShapeDrawingActor | new Triangle(new Point(0.0,0.0),
                                 new Point(1.0,0.0),
                                 new Point(0.0,1.0))
ShapeDrawingActor | 3.14159
ShapeDrawingActor | "exit"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf098052" class="outline-3">
<h3 id="orgf098052"><a href="#orgf098052">変数宣言</a></h3>
<div class="outline-text-3" id="text-orgf098052">
<ul class="org-ul">
<li>不変の変数は、キーワード <code>val</code> を使う。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>変数宣言</label><pre class="src src-scala">val array: Array[String] = new Array(5)
array
</pre>
</div>

<div class="results" id="org9cab262">
<p>
[Ljava.lang.String;@6d304f9d
</p>

</div>

<p>
array参照を変更できないことを確かめる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>再代入できない</label><pre class="src src-scala">val array: Array[String] = new Array(5)
array = new Array(2)
</pre>
</div>

<div class="results" id="org9d46322">
<p>
/tmp/babel-LymR61/scala-PllbQI:7: error: reassignment to val
array = new Array(2)
</p>

</div>

<p>
参照は変更できないが、配列そのものは変更できる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>中身が出力されないが、コンソールで打つとたしかに中身が書き換わっている</label><pre class="src src-scala">val array: Array[String] = new Array(5)
array(0) = "Hello"
array
</pre>
</div>

<div class="results" id="org629e84c">
<p>
[Ljava.lang.String;@51cd7ffc
</p>

</div>

<ul class="org-ul">
<li>不変: val</li>
<li>可変: var</li>
</ul>

<p>
紛らわしいな。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>varは可変で、再代入できる</label><pre class="src src-scala">var stockPrice: Double = 100.0
stockPrice = 10.0
stockPrice
</pre>
</div>

<div class="results" id="orgc8552da">
<p>
10.0
</p>

</div>
</div>
</div>

<div id="outline-container-orge6eb2cc" class="outline-3">
<h3 id="orge6eb2cc"><a href="#orge6eb2cc">デフォルト引数</a></h3>
<div class="outline-text-3" id="text-orge6eb2cc">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>引数を結合するメソッド。separatorがデフォルト引数を指定している</label><pre class="src src-scala">object StringUtil {
  def joiner(strings: List[String], separator: String = " "): String = strings.mkString(separator)
}
import StringUtil._
println(joiner(List("Programming", "Scala")))
</pre>
</div>

<div class="results" id="org283dfd3">
<p>
Programming Scala
</p>

</div>
</div>
</div>

<div id="outline-container-org14b464c" class="outline-3">
<h3 id="org14b464c"><a href="#org14b464c">名前付き引数</a></h3>
<div class="outline-text-3" id="text-org14b464c">
<p>
名前付き引数。引数が何かわかりやすい。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>すべて同じ意味</label><pre class="src src-scala">object StringUtil {
  def joiner(strings: List[String], separator: String = " "): String = strings.mkString(separator)
}
import StringUtil._
println(joiner(List("Programming", "Scala")))
println(joiner(strings = List("Programming", "Scala")))
println(joiner(List("Programming", "Scala"), " "))
println(joiner(List("Programming", "Scala"), separator = " "))
println(joiner(strings = List("Programming", "Scala"), separator = " "))
</pre>
</div>

<div class="results" id="org2e4f09a">
<p>
Programming Scala
Programming Scala
Programming Scala
Programming Scala
Programming Scala
</p>

</div>
</div>
</div>

<div id="outline-container-org89405e2" class="outline-3">
<h3 id="org89405e2"><a href="#org89405e2">入れ子のメソッド定義</a></h3>
<div class="outline-text-3" id="text-org89405e2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>階乗計算を入れ子で定義する</label><pre class="src src-scala">def factorial(i: Int): Int = {
  def fact(i: Int, accumulator: Int): Int = {
    if (i &lt;= 1)
      accumulator
    else
      fact(i - 1, i * accumulator)
  }
  fact(i, 1)
}

println(factorial(0))
println(factorial(1))
println(factorial(2))
println(factorial(3))
println(factorial(4))
println(factorial(5))
</pre>
</div>

<div class="results" id="orga631ca3">
<p>
1
1
2
6
24
120
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>入れ子の外側で定義された変数を使う</label><pre class="src src-scala">def countTo(n: Int):Unit = {
  def count(i: Int):Unit = {
    if (i &lt;= n) { // nをcountメソッドから参照できる
      println(i)
      count(i + 1)
    }
  }
  count(1)
}
countTo(5)
</pre>
</div>

<div class="results" id="org9f20515">
<p>
1
2
3
4
5
</p>

</div>
</div>
</div>

<div id="outline-container-orga8c3655" class="outline-3">
<h3 id="orga8c3655"><a href="#orga8c3655">型推論</a></h3>
<div class="outline-text-3" id="text-orga8c3655">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>右辺では実際に使う型であるHashMapをインスタンス化しているが、型パラメータを書く必要はない</label><pre class="src src-scala">import java.util.Map
import java.util.HashMap

val intToStringMap: Map[Integer, String] = new HashMap
</pre>
</div>

<div class="results" id="orgedde540">

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>型情報が左辺にあるバージョン</label><pre class="src src-scala">import java.util.Map
import java.util.HashMap

val intToStringMap2 = new HashMap[Integer, String]
</pre>
</div>

<div class="results" id="org592dbc1">

</div>

<ul class="org-ul">
<li>Scalaの場合、純粋関数言語(<a href="20210907223510-haskell.html#ID-c4c3816f-e03f-41a8-9a97-ddcfd3d738ff">Haskell</a>とか)より多くの型アノテーションを付ける必要がある。オブジェクト指向の型付けと関数型の片付けをサポートしないといけないから。</li>
</ul>

<p>
メソッドの戻り値の型に対して明示的な宣言が必要な例。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>長さゼロの文字列に対する条件付きのreturn文</label><pre class="src src-scala">def upCase(s: String) = {
  if (s.length == 0)
    return s
  else
    s.toUpperCase()
}

println(upCase(""))
println(upCase("Hello"))
</pre>
</div>

<div class="results" id="orgdd33599">
<p>
/tmp/babel-LymR61/scala-TQZ3UB:8: error: method upCase has return statement; needs result type
    return s
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>upCaseの戻り値を指定するとコンパイルできる</label><pre class="src src-scala">def upCase(s: String): String = {
  if (s.length == 0)
    return s
  else
    s.toUpperCase()
}

println(upCase(""))
println(upCase("Hello"))
</pre>
</div>

<div class="results" id="orgfb6ab0d">
<p>

</p>

<p>
HELLO
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>makeListに対して推論された戻り値の型がList[Any]</label><pre class="src src-scala">  def makeList(strings: String*) = {
    if (strings.length == 0)
      List(0)
    else
      strings.toList
  }

val list: List[String] = makeList()
</pre>
</div>

<div class="results" id="orge0ff8a8">
<p>
/tmp/babel-LymR61/scala-x73fET:13: error: type mismatch;
 found   : List[Any]
 required: List[String]
val list: List[String] = makeList()
</p>

</div>

<p>
strings.lengthが0のときにList(0)…List[Int]を返す。正しくはList()。
メソッドの推論された戻り値の型は、List[Int]とList[String]のもっとも近い共通のスーパー型、List[Any]になる。
</p>

<p>
別の例。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>Mapの型パラメータは[Nothing]と推論された</label><pre class="src src-scala">val map = Map()
map.update("book", "Programming Scala")
</pre>
</div>

<div class="results" id="orgc7d2216">
<p>
/tmp/babel-LymR61/scala-JI2yYc:7: error: value update is not a member of scala.collection.immutable.Map[Nothing,Nothing]
</p>

</div>

<p>
Mapにおける型パラメータは[Nothing, Nothing]と推論された。なのでStringを入れるとエラー。
</p>
</div>
</div>
<div id="outline-container-org2972310" class="outline-3">
<h3 id="org2972310"><a href="#org2972310">等号</a></h3>
<div class="outline-text-3" id="text-org2972310">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>Int型の引数を取り、Unit型を返す定義になっている。Int型を返さない</label><pre class="src src-scala">def double(i: Int) { 2 * i }
println(double(2))
</pre>
</div>

<div class="results" id="orgf2bdc13">
<p>
()
</p>

</div>

<ul class="org-ul">
<li>本体の前に等号を持つメソッドを関数の定義とみなす</li>
<li>先頭に等号がないメソッドの本体を見つけると、プログラマが「手続き」の定義としてメソッドを書いたとみなす。手続きは、Unit型の戻り値しか持たず副作用を伴う処理を実行するためのもの</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>本来意図していた挙動</label><pre class="src src-scala">def double(i: Int) = { 2 * i }
println(double(2))
</pre>
</div>

<div class="results" id="org0656bd7">
<p>
4
</p>

</div>
</div>
</div>

<div id="outline-container-org53d7025" class="outline-3">
<h3 id="org53d7025"><a href="#org53d7025">タプル</a></h3>
<div class="outline-text-3" id="text-org53d7025">
<p>
t._NはN番目の項目を取得するが、1始まりなのに注意。
</p>

<div class="org-src-container">
<pre class="src src-scala">def tupleator(x1: Any, x2: Any, x3: Any) = (x1, x2, x3)

val t = tupleator("Hello", 1, 2.3)
println("Print the whole tuple: " + t)
println("Print the first item: " + t._1)
println("Print the second item: " + t._2)
println("Print the third item: " + t._3)

val (t1, t2, t3) = tupleator("World", '!', 0x22)
println(t1 + " " + t2 + " " + t3)
</pre>
</div>

<div class="results" id="orga189c2a">
<p>
Print the whole tuple: (Hello,1,2.3)
Print the first item: Hello
Print the second item: 1
Print the third item: 2.3
World ! 34
</p>

</div>

<p>
Option型は、nullを返すことがあることを明示する。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>scala.collection.immutable.HashMap の getの実装(Scala 2.7)</label><pre class="src src-scala">def get(key: A): Option[B] = {
  if (contains(key))
    new Some(getValue(key))
  else
    None
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb609ce" class="outline-3">
<h3 id="orgdb609ce"><a href="#orgdb609ce">名前空間</a></h3>
<div class="outline-text-3" id="text-orgdb609ce">
<div class="org-src-container">
<pre class="src src-scala">package com {
  package example {
    package pkg1 {
      class Class11 {
        def m = "m11"
      }
      class Class12 {
        def m = "m12"
      }
    }

    package pkg2 {
      class Class21 {
        def m = "m21"
        def makeClass11 = {
          new pkg1.Class11
        }
        def makeClass12 = {
          new pkg1.Class12
        }
      }
    }

    package pkg3.pkg31.pkg311 {
      class Class311 {
        def m = "m21"
      }
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7dca519" class="outline-3">
<h3 id="org7dca519"><a href="#org7dca519">インポート</a></h3>
<div class="outline-text-3" id="text-org7dca519">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>_でワイルドカード</label><pre class="src src-scala">import java.awt._
import java.io.File
import java.io.File._
import java.util.{Map, HashMap}
</pre>
</div>

<div class="results" id="orgef44c73">

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span>特定の型だけインポート</label><pre class="src src-scala">def writeAboutBigInteger() = {
import java.math.BigInteger.{
ONE =&gt; _, // インポートしたスコープのスコープ内から隠し、利用できなくする
TEN,
ZERO =&gt; JAVAZERO } // 別名をつけてインポート

// println("ONE: " +ONE) // 未定義
println("TEN: " +TEN)
println("ZERO: " +JAVAZERO)}
writeAboutBigInteger
</pre>
</div>

<div class="results" id="orge81d1d4">
<p>
TEN: 10
ZERO: 0
</p>

</div>
</div>
</div>

<div id="outline-container-org54a7bae" class="outline-3">
<h3 id="org54a7bae"><a href="#org54a7bae">抽象型</a></h3>
<div class="outline-text-3" id="text-org54a7bae">
<div class="org-src-container">
<pre class="src src-scala">import java.io._

abstract class BulkReader {
  type In
  val source: In
  def read: String
}

class StringBulkReader(val source: String) extends BulkReader {
  type In = String
  def read = source
}

class FileBulkReader(val source: File) extends BulkReader {
  type In = File
  def read = {
    val in = new BufferedInputStream(new FileInputStream(source))
    val numBytes = in.available()
    val bytes = new Array[Byte](numBytes)
    in.read(bytes, 0, numBytes)
    new String(bytes)
  }
}

println(new StringBulkReader("Hello Scala!").read)
println(new FileBulkReader(new File(".gitattributes")).read)
</pre>
</div>

<div class="results" id="orgb5f8134">
<p>
Hello Scala!
public/* linguist-vendored
public/*/* linguist-vendored
</p>

</div>

<ul class="org-ul">
<li>インスタンスは具象クラスからのみ生成できる</li>
<li>具象クラスにはすべてのメンバが定義されていなければならない</li>
<li>StringBulkReader, FileBulkReaderという派生クラスは、BulkReaderで定義した抽象メンバに対する具体的な定義を与える</li>
</ul>
</div>
</div>
<div id="outline-container-org4d2bf9a" class="outline-3">
<h3 id="org4d2bf9a"><a href="#org4d2bf9a">基本文法</a></h3>
<div class="outline-text-3" id="text-org4d2bf9a">
<ul class="org-ul">
<li>もっとも重要で基本的なコンセプト: 演算子に見えるものは実際にはすべてメソッド</li>
</ul>

<p>
<code>1 + 2</code> は、 <code>1.+(2)</code> と同じ。
</p>

<ul class="org-ul">
<li>慣習的に、副作用のないメソッドの呼び出しには()を使う</li>
<li>引数なしのメソッドや引数が1つだけのメソッドを呼び出すときには、ドットを省略することができる</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 31: </span>左結合のメソッド呼び出しは、単純に左から右の順に束縛される</label><pre class="src src-scala">val list = List('b', 'c', 'd')
println(list)

println('a' :: list)
println(list.::('a')) // ↑と同じ意味
</pre>
</div>

<div class="results" id="org206ffad">
<p>
List(b, c, d)
List(a, b, c, d)
List(a, b, c, d)
</p>

</div>

<p>
if式やその他のほとんどの文が実際には式である。そのため、if式の結果を代入できる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span>if式の結果を代入する</label><pre class="src src-scala">val configFile = new java.io.File(".myapprc")

val configFilePath = if(configFile.exists()) {
  configFile.getAbsolutePath()
} else {
  configFile.createNewFile()
  configFile.getAbsolutePath()
}
</pre>
</div>

<div class="results" id="org3009865">

</div>
</div>
</div>

<div id="outline-container-orgf973ec1" class="outline-3">
<h3 id="orgf973ec1"><a href="#orgf973ec1">for式</a></h3>
<div class="outline-text-3" id="text-orgf973ec1">
<p>
基本的なfor式。
</p>
<div class="org-src-container">
<pre class="src src-scala">val dogBreeds = List("Doberman", "Yorkshire Terrirorf", "Dachshund",
"Scottish Terrir", "Creat Dane", "Portuguess Water Dog")
for (breed &lt;- dogBreeds)
println(breed)
</pre>
</div>

<div class="results" id="org860d671">
<p>
Doberman
Yorkshire Terrirorf
Dachshund
Scottish Terrir
Creat Dane
Portuguess Water Dog
</p>

</div>

<p>
&lt;-演算子はジェネレータという。
for式の内側で参照される一時変数に、コレクションの要素を1つずつ代入する矢印。
</p>

<p>
フィルタリングの結果をプログラムの別の部分に渡すとき、yieldを使う。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span>for式を通過するたびに、フィルタの結果がbreedと名付けられた値で生成される。結果の集合がfilteredBreedsに代入される</label><pre class="src src-scala">val dogBreeds = List("Doberman", "Yorkshire Terrier", "Dachshund",
  "Scottish Terrier", "Great Dane", "Portuguese Water Dog")
val filteredBreeds = for {
  breed &lt;- dogBreeds
  if breed.contains("Terrier")
  if !breed.startsWith("Yorkshire")
} yield breed
println(filteredBreeds)
</pre>
</div>

<div class="results" id="org71c9b74">
<p>
List(Scottish Terrier)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 35: </span>for式の内側に定義した変数をあとで使用できる</label><pre class="src src-scala">val dogBreeds = List("Doberman", "Yorkshire Terrier", "Dachshund",
  "Scottish Terrier", "Great Dane", "Portuguese Water Dog")
for {
  breed &lt;- dogBreeds
  upcasedBreed = breed.toUpperCase()
} println(upcasedBreed)
</pre>
</div>

<div class="results" id="org0929d17">
<p>
DOBERMAN
YORKSHIRE TERRIER
DACHSHUND
SCOTTISH TERRIER
GREAT DANE
PORTUGUESE WATER DOG
</p>

</div>
</div>
</div>

<div id="outline-container-org42770a0" class="outline-3">
<h3 id="org42770a0"><a href="#org42770a0">do-whileループ</a></h3>
<div class="outline-text-3" id="text-org42770a0">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 36: </span>whileループとの違い…do-whileはブロックを実行したあとで状態が真がどうかをチェックする</label><pre class="src src-scala">var count = 0
do {
  count += 1
  println(count)
} while (count &lt; 10)
</pre>
</div>

<div class="results" id="org4b6bee6">
<p>
1
2
3
4
5
6
7
8
9
10
</p>

</div>
</div>
</div>

<div id="outline-container-org8357e0d" class="outline-3">
<h3 id="org8357e0d"><a href="#org8357e0d">ジェネレータ式</a></h3>
<div class="outline-text-3" id="text-org8357e0d">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 37: </span>アロー演算子で書ける</label><pre class="src src-scala">for (i &lt;- 1 to 10) println(i)
</pre>
</div>

<div class="results" id="org1ff2fdf">
<p>
1
2
3
4
5
6
7
8
9
10
</p>

</div>

<ul class="org-ul">
<li>コンパイラは暗黙の型変換を呼び出し、Intの1をRichIntに変換する。toメソッドを呼び出し、Range.Inclusiveのインスタンスを返す。</li>
</ul>
</div>
</div>

<div id="outline-container-org638b0fc" class="outline-3">
<h3 id="org638b0fc"><a href="#org638b0fc">パターンマッチ</a></h3>
<div class="outline-text-3" id="text-org638b0fc">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 38: </span>_ は上のcaseで定義されていないすべてのケースにマッチする</label><pre class="src src-scala">val bools = List(true, false)

for (bool &lt;- bools) {
  bool match {
    case true =&gt; println("heads")
    case false =&gt; println("tails")
    case _ =&gt; println("something other than heads or tails (yikes!)")
  }
}
</pre>
</div>

<div class="results" id="orgdad4111">
<p>
heads
tails
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 39: </span>7が否かで分岐</label><pre class="src src-scala">import scala.util.Random

val randomInt = new Random() .nextInt(10)

randomInt match {
  case 7 =&gt; println("lucky seven!")
  case otherNumber =&gt; println("boo, got boring ol' " + otherNumber)
}
</pre>
</div>

<div class="results" id="org47db115">
<p>
boo, got boring ol&rsquo; 2
</p>

</div>
</div>
</div>
<div id="outline-container-org417e6b5" class="outline-3">
<h3 id="org417e6b5"><a href="#org417e6b5">型に対するマッチ</a></h3>
<div class="outline-text-3" id="text-org417e6b5">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 40: </span>型の条件で条件分け</label><pre class="src src-scala">val sundries = List(23, "Hello", 8.5, 'q')

for (sundry &lt;- sundries) {
  sundry match {
    case i: Int =&gt; println("got an Integer: " + i)
    case s: String =&gt; println("got an String: " + s)
    case f: Double =&gt; println("got an Double: " + f)
    case other =&gt;println("got soumething else: " + other)
  }
}
</pre>
</div>

<div class="results" id="org6ece76e">
<p>
got an Integer: 23
got an String: Hello
got an Double: 8.5
got soumething else: q
</p>

</div>
</div>
</div>
<div id="outline-container-orge46fd83" class="outline-3">
<h3 id="orge46fd83"><a href="#orge46fd83">シーケンスに対するマッチ</a></h3>
<div class="outline-text-3" id="text-orge46fd83">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 41: </span>条件に合うシーケンスだけが選択される</label><pre class="src src-scala">val willWork = List(1, 3, 23, 90)
val willNotWork = List(4, 18, 52)
val empty = List()

for (l &lt;- List(willWork, willNotWork, empty)) {
  l match {
    case List(_, 3, _, _) =&gt; println("Four elements, with the 2nd being '3'.")
    case List(_*) =&gt; println("Any other list with 0 or more elements.")
  }
}
</pre>
</div>

<div class="results" id="orgb1279eb">
<p>
Four elements, with the 2nd being &rsquo;3&rsquo;.
Any other list with 0 or more elements.
Any other list with 0 or more elements.
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 42: </span>headにはリストの最初の要素が代入され、tailにはリストの残りが代入される</label><pre class="src src-scala">val willWork = List(1, 3, 23, 90)
val willNotWork = List(4, 18, 52)
val empty = List()

def processList(l: List[Any]): Unit = l match {
  case head :: tail =&gt;
    printf("%s ", head)
    processList(tail)
  case Nil =&gt; println("")
}

for (l &lt;- List(willWork, willNotWork, empty)) {
  print("List: ")
  processList(l)
}
</pre>
</div>

<div class="results" id="orgfaccc84">
<p>
List: 1 3 23 90
List: 4 18 52
List:
</p>

</div>
</div>
</div>

<div id="outline-container-org38ca44e" class="outline-3">
<h3 id="org38ca44e"><a href="#org38ca44e">タプルに対するマッチ</a></h3>
<div class="outline-text-3" id="text-org38ca44e">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 43: </span>2つの項目を持つタプルをテストするのに、タプルに対するマッチが使える。タプルのあとのif条件はガード</label><pre class="src src-scala">val tupA = ("Good", "Morning!")
val tupB = ("Guten", "Tag!")

for (tup &lt;- List(tupA, tupB)) {
  tup match {
    case (thingOne, thingTwo) if thingOne == "Good" =&gt;
      println("A two-tuple starting with 'Good'.")
    case (thingOne, thingTwo) =&gt;
      println("This has two things: " + thingOne + " and " + thingTwo)
}}
</pre>
</div>

<div class="results" id="orgd5ab387">
<p>
A two-tuple starting with &rsquo;Good&rsquo;.
This has two things: Guten and Tag!
</p>

</div>
</div>
</div>

<div id="outline-container-org6e7a983" class="outline-3">
<h3 id="org6e7a983"><a href="#org6e7a983">ケースクラスに対するマッチ</a></h3>
<div class="outline-text-3" id="text-org6e7a983">
<p>
中身を調べる深いマッチ。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 44: </span>ケースクラスでオブジェクトの中身を調べる</label><pre class="src src-scala">case class Person(name: String, age: Int) // ケースクラス

val alice = new Person("Alice", 25)
val bob = new Person("Bob", 32)
val charlie = new Person("Charlie", 32)

for (person &lt;- List (alice, bob, charlie)) {
  person match {
    case Person("Alice", 25) =&gt; println("Hi Alice!")
    case Person("Bob", 32) =&gt; println("Hi Bob!")
    case Person(name, age) =&gt;
      println("Who are you, " + age + " year-old person named " + name + "?")
  }
}
</pre>
</div>

<div class="results" id="orgd42ae91">
<p>
Hi Alice!
Hi Bob!
Who are you, 32 year-old person named Charlie?
</p>

</div>

<ul class="org-ul">
<li>ケースクラスを他のケースクラスから継承するのは避ける</li>
</ul>
</div>
</div>
<div id="outline-container-org3cdbe96" class="outline-3">
<h3 id="org3cdbe96"><a href="#org3cdbe96">正規表現</a></h3>
<div class="outline-text-3" id="text-org3cdbe96">
<div class="org-src-container">
<pre class="src src-scala">val BookExtractorRE = """Book: title=([^,]+),\s+authors=(.+)""".r
val MagazineExtractorRE = """Magazine: title=([^,]+),\s+issue=(.+)""".r

val catalog = List (
  "Book: title=Programming Scala, authors=Dean Wampler, Alex Payne",
  "Magazine: title=The New Yorker, issue=January 2009",
  "Book: title=War and Peace, authors=Leo Tolstoy",
  "Magazine: title=The SAtlantic, issue=February 2009",
  "BadData: text=Who put this here??"
)

for (item &lt;- catalog) {
  item match {
    case BookExtractorRE(title, authors) =&gt;
      println("Book \"" + title + "\", written by " + authors)
    case MagazineExtractorRE(title, issue) =&gt;
      println("Magazine \"" + title + "\", issue " + issue)
    case entry =&gt; println("Unrecognized entry: " + entry)
  }
}
</pre>
</div>

<div class="results" id="org686e4a6">
<p>
Book &ldquo;Programming Scala&rdquo;, written by Dean Wampler, Alex Payne
Magazine &ldquo;The New Yorker&rdquo;, issue January 2009
Book &ldquo;War and Peace&rdquo;, written by Leo Tolstoy
Magazine &ldquo;The SAtlantic&rdquo;, issue February 2009
Unrecognized entry: BadData: text=Who put this here??
</p>

</div>
</div>
</div>
<div id="outline-container-org880f2cb" class="outline-3">
<h3 id="org880f2cb"><a href="#org880f2cb">enum</a></h3>
<div class="outline-text-3" id="text-org880f2cb">
<div class="org-src-container">
<pre class="src src-scala">object Breed extends Enumeration {
  val doberman = Value("Doberman Pinscher")
  val yorkie = Value("Yorkshire Terrier")
  val scottie = Value("Scottish Terrier")
  val dane = Value("Great Dane")
  val portie = Value("Portuguese Water Dog")
}

println("ID\tBreed")
for (breed &lt;- Breed.values) println(breed.id + "\t" + breed)

println("\nJust Terriers:")
Breed.values.filter(_.toString.endsWith("Terrier")).foreach(println)
</pre>
</div>

<div class="results" id="org2d1500f">
<p>
ID	Breed
0	Doberman Pinscher
1	Yorkshire Terrier
2	Scottish Terrier
3	Great Dane
4	Portuguese Water Dog
</p>

<p>
Just Terriers:
Yorkshire Terrier
Scottish Terrier
</p>

</div>
</div>
</div>
<div id="outline-container-orgf8ad36f" class="outline-3">
<h3 id="orgf8ad36f"><a href="#orgf8ad36f">トレイト</a></h3>
<div class="outline-text-3" id="text-orgf8ad36f">
<p>
トレイトは関心事の分離を保ちながらも、ミックスインによって要求に応じて振る舞いを変えられる。
</p>

<ul class="org-ul">
<li><a href="20211007104541-java.html#ID-9fa3711b-a22e-4cf5-ae97-5c057083674a">Java</a>でいうと、実装を持つこともできるインターフェースといえる。</li>
<li><a href="20210509095513-ruby.html#ID-cfd092c4-1bb2-43d3-88b1-9f647809e546">Ruby</a>でいうと、モジュールのようなもの。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 47: </span>Traits/ui/button.scala</label><pre class="src src-scala">package ui

class Button(val label: String) extends Widget {
  def click() = {
    // クリックされたボタンの見た目を変更する…
  }
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 48: </span>Traits/ui/widget.scala</label><pre class="src src-scala">package ui
abstract class Widget
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 49: </span>Traits/observer/observer.scala</label><pre class="src src-scala">package observer
trait Subject {
  type Observer = { def receiveUpdate(subject: Any) }

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (_.receiveUpdate(this))
}
</pre>
</div>

<p>
定義したSubjectトレイトを使ってみる。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 50: </span>/Traits/ui/observable-button.scala</label><pre class="src src-scala">package ui
import observer._
class ObservableButton(name: String) extends Button(name) with Subject {
  override def click() = {
    super.click()
    notifyObservers
  }
}
</pre>
</div>

<p>
クラスと同じように、トレイトを使うインスタンスが生成されるたびにトレイトの本体が実行される。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 51: </span>実行される順番に注目する</label><pre class="src src-scala">trait T1 {
  println(" in T1: x = " + x)
  val x=1
  println(" in T1: x = " + x)
}
trait T2 {
  println(" in T2: y = " + y)
  val y="T2"
  println(" in T2: y = " + y)
}

class Base12 {
  println(" in Base12: b = " + b)
  val b="Basel12"
  println(" in Base12: b = " + b)
}
class C12 extends Base12 with T1 with T2 {
  println(" in C12: c = " + c)
  val c="C12"
  println(" in C12: c = " + c)
}
println("Creating C12:")
new C12
println("After Creating C12")
</pre>
</div>

<div class="results" id="org1ae62e8">
<p>
Creating C12:
 in Base12: b = null
 in Base12: b = Basel12
 in T1: x = 0
 in T1: x = 1
 in T2: y = null
 in T2: y = T2
 in C12: c = null
 in C12: c = C12
After Creating C12
</p>

</div>

<ul class="org-ul">
<li>トレイトのコンストラクタに引数を渡すことはできない</li>
<li>フィールドをデフォルト値で上書きすることや、抽象フィールドにしておくことは可能</li>
<li>クラスかトレイトのどちらかにすべきかを考えるとき、ミックスインとしてのトレイトは「付加的な」ふるまいにもっともふさわしい</li>
</ul>
</div>
</div>
<div id="outline-container-orgec5fef8" class="outline-3">
<h3 id="orgec5fef8"><a href="#orgec5fef8">公開可視性</a></h3>
<div class="outline-text-3" id="text-orgec5fef8">
<p>
デフォルトで公開(public)。つまりどこからでも参照できる。
</p>
</div>
</div>
<div id="outline-container-org69f7b41" class="outline-3">
<h3 id="org69f7b41"><a href="#org69f7b41">オーバーライド</a></h3>
<div class="outline-text-3" id="text-org69f7b41">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 52: </span>ui3/widget.scala</label><pre class="src src-scala">package ui3
abstract class Widget {
  def draw(): Unit
  override def toString() = "(widget)"
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 53: </span>ui3/button.scala</label><pre class="src src-scala">package ui3

class Button(val label: String) extends Widget with Clickable {
  def click() = {
    // ...
  }

  def draw() = {
    // ...
  }

  override def toString() =
    "(button: label=" + label + ", " + super.toString() + ")"
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org4053635" class="outline-3">
<h3 id="org4053635"><a href="#org4053635">apply</a></h3>
<div class="outline-text-3" id="text-org4053635">
<p>
appleは新たなインスタンスを返すファクトリメソッドとして使われるのが慣例になっている。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 54: </span>newなしにPairのインスタンスを生成しているように見える</label><pre class="src src-scala">type Pair[+A, +B] = Tuple2[A, B]
object Pair {
  def apply[A, B] (x: A, y: B) = Tuple2(x, y)
  def unapply[A, B] (x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}

val p = Pair(1, "one")
println(p)
</pre>
</div>

<div class="results" id="orgac1f49e">
<p>
(1,one)
</p>

</div>

<p>
暗黙のうちにList.applyが使われるスクリプトの例。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 55: </span>&rsquo;fourはシンボル。LispやRubyと同じ識別子を表現する</label><pre class="src src-scala">val list1 = List()
val list2 = List(1, 2.2, "three", 'four)
val list3 = List("1", "2.2", "three", "four")
println("1: "+list1)
println("2: "+list2)
println("3: "+list3)
</pre>
</div>

<div class="results" id="org3eaf0ef">
<p>
1: List()
2: List(1, 2.2, three, Symbol(four))
3: List(1, 2.2, three, four)
</p>

</div>
</div>
</div>
<div id="outline-container-orga25ae8c" class="outline-3">
<h3 id="orga25ae8c"><a href="#orga25ae8c">関数型プログラミング言語</a></h3>
<div class="outline-text-3" id="text-orga25ae8c">
<ul class="org-ul">
<li>不変なものこそが値である</li>
<li>すでに値を持った変数に新しい値を代入することはできない</li>
</ul>

<p>
Scalaはどの書き方も強制しないが、できるだけ関数言語のスタイルを使うほうがわかりやすい。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 56: </span>_ * 2 は i =&gt; i * 2を省略した関数リテラル</label><pre class="src src-scala">println(List(1, 2, 3, 4, 5) map { _ * 2 })
</pre>
</div>

<div class="results" id="org8e90262">
<p>
List(2, 4, 6, 8, 10)
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 57: </span>畳み込み</label><pre class="src src-scala">println(List(1, 2, 3, 4, 5) reduceLeft { _ * _ })
</pre>
</div>

<div class="results" id="org7d64f3c">
<p>
120
</p>

</div>

<div class="org-src-container">
<pre class="src src-scala">var factor = 3
val multiplier = (i: Int) =&gt; i * factor
val l1 = List(1, 2, 3, 4, 5) map multiplier

factor = 5
val l2 = List(1, 2, 3, 4, 5) map multiplier

println(l1)
println(l2)
</pre>
</div>

<div class="results" id="orgb399873">
<p>
List(3, 6, 9, 12, 15)
List(5, 10, 15, 20, 25)
</p>

</div>

<p>
再帰を使う。
</p>
<div class="org-src-container">
<pre class="src src-scala">  def factorial (i: BigInt): BigInt = i match {
    case _ if i == 1 =&gt; i
    case _ =&gt; i * factorial(i - 1)
  }

for (i &lt;- 1 to 10)
printf("%s: %s\n", i, factorial(i))
</pre>
</div>

<div class="results" id="org572ec39">
<p>
1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800
</p>

</div>
</div>
</div>
<div id="outline-container-org0f6ae85" class="outline-3">
<h3 id="org0f6ae85"><a href="#org0f6ae85">末尾再帰</a></h3>
<div class="outline-text-3" id="text-org0f6ae85">
<p>
再帰にはパフォーマンスのオーバーヘッドとスタックオーバーフローの危険性がある。
末尾再帰はループに変換はループに変換することで最適化できる。
</p>

<p>
末尾再帰でない例。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 60: </span>末尾再帰でないバージョン</label><pre class="src src-scala">def factorial(i: BigInt): BigInt = i match {
  case _ if i == 1 =&gt; i
  case _ =&gt; i * factorial(i - 1)
}

for (i &lt;- 1 to 10)
  printf("%s: %s\n", i, factorial(i))
</pre>
</div>

<div class="results" id="orgcf939d1">
<p>
1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800
</p>

</div>

<p>
末尾再帰の例。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 61: </span>末尾再帰バージョン。計算結果を保持するために引数を渡すので、末尾再帰になる</label><pre class="src src-scala">def factorial(i: BigInt): BigInt = {
  def fact(i: BigInt, accumulator: BigInt): BigInt = i match {
    case _ if i == 1 =&gt; accumulator
    case _ =&gt; fact(i - 1, i * accumulator)
  }
  fact(i, 1)
}

for (i &lt;- 1 to 10)
  printf("%s: %s\n", i , factorial(i))
</pre>
</div>

<div class="results" id="org86f0987">
<p>
1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800
</p>

</div>
</div>
</div>
<div id="outline-container-org6f3760a" class="outline-3">
<h3 id="org6f3760a"><a href="#org6f3760a">走査</a></h3>
<div class="outline-text-3" id="text-org6f3760a">
<div class="org-src-container">
<pre class="src src-scala">List(1, 2, 3, 4, 5) foreach { i =&gt; println("Int: " + i) }

val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Janeau",
  "Wyoming" -&gt; "Cheyenne")
stateCapitals foreach { kv =&gt; println(kv._1 + ": " + kv._2) }
</pre>
</div>

<div class="results" id="org4c1aedd">
<p>
Int: 1
Int: 2
Int: 3
Int: 4
Int: 5
Alabama: Montgomery
Alaska: Janeau
Wyoming: Cheyenne
</p>

</div>
</div>
</div>
<div id="outline-container-orgee91f60" class="outline-3">
<h3 id="orgee91f60"><a href="#orgee91f60">フィルタリング</a></h3>
<div class="outline-text-3" id="text-orgee91f60">
<div class="org-src-container">
<pre class="src src-scala">val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska" -&gt; "Juneau",
  "Wyoming" -&gt; "Cheyenne")

val map2 = stateCapitals filter { kv =&gt; kv._1 startsWith "A" }

println(map2)
</pre>
</div>

<div class="results" id="org526dbfb">
<p>
Map(Alabama -&gt; Montgomery, Alaska -&gt; Juneau)
</p>

</div>
</div>
</div>

<div id="outline-container-org0333ab0" class="outline-3">
<h3 id="org0333ab0"><a href="#org0333ab0">畳み込み</a></h3>
<div class="outline-text-3" id="text-org0333ab0">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 64: </span>入力のリストと同じ順序でリストを返すために、reverseを呼び出す</label><pre class="src src-scala">List(1, 2, 3, 4, 5, 6).foldLeft(List[String] ()) {
  (list, x) =&gt; ("&lt;" + x + "&gt;") :: list
}.reverse
</pre>
</div>

<div class="results" id="org6278d82">

</div>

<p>
Iterableの畳み込みと簡約の操作のシグネチャ。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 65: </span>演算子を見る</label><pre class="src src-scala">trait Iterable[+A] {
  def foldLeft [B] (z : B) (op : (B, A) =&gt; B) : B

  def foldRight [B] (z : B) (op : (A, B) =&gt; B) : B

  def /: [B] (z : B) (op : (B, A) =&gt; B) : B

  def :\ [B] (z : B) (op : (A, B) =&gt; B) : B

  def reduceLeft [B &gt;: A] (op : (B, A) =&gt; B) : B

  def reduceRight [B &gt;: A] (op : (A, B) =&gt; B) : B
}
</pre>
</div>

<div class="results" id="orgb2b104b">

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 66: </span>reverseは必要なくなった</label><pre class="src src-scala">List(1, 2, 3, 4, 5, 6).foldRight(List[String] ()) {
  (x, list) =&gt; ("&lt;" + x + "&gt;") :: list
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org334e262" class="outline-3">
<h3 id="org334e262"><a href="#org334e262">部分適用</a></h3>
<div class="outline-text-3" id="text-org334e262">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 67: </span>引数を部分適用している</label><pre class="src src-scala">def concatUpper(s1: String, s2: String) : String = (s1 + " " + s2).toUpperCase

val c = concatUpper _
println(c("short", "pants"))
val c2 = concatUpper("short", _: String)
println(c2("pants"))
</pre>
</div>

<div class="results" id="org293894a">
<p>
SHORT PANTS
SHORT PANTS
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 68: </span>PartialFunctionトレイト</label><pre class="src src-scala">val pantsTest: PartialFunction[String, String] = {
  case "pants" =&gt; "yes, we have pants!"
}

println(pantsTest.isDefinedAt("pants"))
println(pantsTest.isDefinedAt("skort"))
</pre>
</div>

<div class="results" id="org67abcaa">
<p>
true
false
</p>

</div>
</div>
</div>

<div id="outline-container-org6ff3417" class="outline-3">
<h3 id="org6ff3417"><a href="#org6ff3417">カリー化</a></h3>
<div class="outline-text-3" id="text-org6ff3417">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 69: </span>部分的に引数を適用してカリー化</label><pre class="src src-scala">def multiplier(i: Int) (factor: Int) = i * factor
val byFive = multiplier(5) _
val byTen = multiplier(10) _

println(byFive(2))
println(byTen(2))
</pre>
</div>

<div class="results" id="org5a5b2e1">
<p>
10
20
</p>

</div>
</div>
</div>

<div id="outline-container-org0a35a37" class="outline-3">
<h3 id="org0a35a37"><a href="#org0a35a37">名前渡しパラメータ</a></h3>
<div class="outline-text-3" id="text-org0a35a37">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 70: </span>関数内で呼び出されるまで評価したくない式をパラメータとして受け取る</label><pre class="src src-scala">def whileAwesome(conditional: =&gt; Boolean) (f: =&gt; Unit) {
  if (conditional) {
    f
    whileAwesome(conditional) (f)
  }
}

var count = 0
whileAwesome(count &lt; 5) {
  println("still awesome")
  count += 1
}
</pre>
</div>

<div class="results" id="org837c5d2">
<p>
still awesome
still awesome
still awesome
still awesome
still awesome
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org1a659b7" class="outline-2">
<h2 id="org1a659b7"><a href="#org1a659b7">Tasks</a></h2>
<div class="outline-text-2" id="text-org1a659b7">
</div>
<div id="outline-container-org1ba799d" class="outline-3">
<h3 id="org1ba799d"><a href="#org1ba799d"><span class="todo TODO">TODO</span> <a href="https://scala-text.github.io/scala_text/">Introduction · Scala研修テキスト</a></a></h3>
<div class="outline-text-3" id="text-org1ba799d">
<p>
<a href="20220108003324-scala.html#ID-b2f63c13-4b30-481c-9c95-8abe388254fd">Scala</a>のテキスト。
</p>
</div>
</div>
</div>
<div id="outline-container-org6786e0b" class="outline-2">
<h2 id="org6786e0b"><a href="#org6786e0b">Reference</a></h2>
<div class="outline-text-2" id="text-org6786e0b">
</div>
<div id="outline-container-org2ec93ff" class="outline-3">
<h3 id="org2ec93ff"><a href="#org2ec93ff"><a href="https://ja.wikipedia.org/wiki/Scala">Scala - Wikipedia</a></a></h3>
</div>
<div id="outline-container-orged3ca0b" class="outline-3">
<h3 id="orged3ca0b"><a href="#orged3ca0b"><a href="http://xerial.org/scala-cookbook/">Scala Cookbook | Scala Cookbook</a></a></h3>
<div class="outline-text-3" id="text-orged3ca0b">
<p>
日本語の情報。
</p>
</div>
</div>
</div>
<div id="outline-container-orge01e746" class="outline-2">
<h2 id="orge01e746"><a href="#orge01e746">Archives</a></h2>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"/>
</div>
</body>
</html>
