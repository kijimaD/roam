:PROPERTIES:
:ID:       a23ceb84-e89a-4905-b931-1944a0b828b7
:mtime:    20250501193334
:ctime:    20210615101425
:END:
#+title: Learning

* 概要
プログラムの学び方についてまとめる。

ほかのページに比べて主観的なポエムが多くを占める。
プログラムの学び方についてよく考えるのは、すごくできる人と平均的にできる差が非常に大きいためだ。すごくできるプログラマは平均的なプログラマ100人分の仕事をする、なんてざらにある。ほかの職業でここまで明確に差が出ることは少ない。

[[id:bb71747d-8599-4aee-b747-13cb44c05773][OSS]]の99％は、1% ~ 0.1%のプログラマが支えているように見える。そのプロジェクトの作者でもあったのか、ということはよくある。偉大な人はさらに何かを生み出し続け、人類を辞めていくようだ。

この大きな違いをもたらしているのは、まず1つは頭の作りが違うとかそういうことだ。しかしこれは先天的なものが大きいのと、脳の動きを再現できないのでなんとも言えない。
違いをもたらすように見える2つ目は、学ぶ方法だ。これは再現可能だし、希望的・建設的なのでよく観察する価値がある。
* Memo
** 実装との矛盾

わからないものは実装するとどうやって動いているか理解できる。理解していないと実装できない。ただ、それをどうやるかという問題がある。なにかの記事で見たものをなぞるだけでは、それ以上の理解に達しない場合が多い。かといってなぞらないことには、方法がまったくわからない。書いてある以上に何か自分で考えてプラスでやってみないといけない。

** 説明する
説明することで、どれだけ自分が自明と思っていることに頼っているか確かめられる。自明だと思っていることは、ほかの知識レベルにある人にとっては自明ではない。うまく説明できればなぜそれが必要か、という背景まで理解できているということがわかる。説明できないなら真に理解はできてなく、そういうもんだ、そういう仕様なんだというところで止まっている可能性がある。

具体的な人を思い浮かべて、その人に完全に説明できるようにするんだ。
** 上達したいなら公開する
公開せず、1人でやるものはなかなか上達しない。できるようになったら見せよう、という種類のものはうまくならないだけでなく、だいたい途中でやめることになる。逆に下手くそでもどんどん人に見せて、フィードバックをもらって、よく準備したものを何か賞にでも送って、という人がプロとして成功するように見える。また、仕事にすると嫌でも向上する。人に見てもらうからだ。一人の天才が狭い部屋で何か革新的なものを作る、というのは稀にみるが、誰かに見せて何らかのフィードバックを得ていて、想像ほど孤独なプロセスではないことが多い。

1人がうまくいきづらいのは、うまくやるプレッシャーが働きにくいからだ。これを相手に見せたらどうなるだろう、という仮定はよくブラッシュアップさせ、意図を言葉で説明できるようにする。

また、人間相手だとかけられる時間に上限がある。聞かれたら、その場で答えられないと議論にならない。他人のコードをその場で理解して何らかのフィードバックをすることが必要になる。逆に時間の制約が全くなく、会ったこともない他人のコード…たとえば[[id:bb71747d-8599-4aee-b747-13cb44c05773][OSS]]の場合は理解の必然性がなく身近でもないので、後回しになりがちだ。なのでわからないままだ。

OSSに取り組む価値があることは明らかだ。仕事ではできない抽象度の高い問題は難しく、根源的な仕組みに対する理解を必要とする。問題が解けることは、理解していることを意味する。貴重な経験が得られる。公開、人の巻き込み、時間制限。これらをうまく使うことで、上達できると考えているが、今のところうまくいっていない。

** 正しい訓練をやる
1. 現状よりも高い具体的な目標のある練習を
2. 集中して
3. フィードバックを受けながら
4. 居心地の悪い状態で
5. 継続する

- どんなトップパフォーマンスを弾き出す人でも、限界的練習は苦しい
- 「楽しいことだから、いつまでも没頭して練習を続けられる」というのは誤り
- 「努力しつづけなさい、そうすれば目標を達成できる」は間違っている。正しい訓練を、十分な期間にわたって継続することが向上につながる
** 早く書く
:LOGBOOK:
CLOCK: [2022-08-04 Thu 10:06]--[2022-08-04 Thu 10:31] =>  0:25
:END:
プログラムを早く書けることは、問題解決、学ぶことにおいて重要だ。

- 思考のサイズ的問題
- 戻るコストの問題
- 質とスピードを選べる
- 経験値

最初から問題を正しく理解して、書くことは難しい。あれこれ考慮するうちに、堂々巡りになって何も進まずにいることはよくある。スコープを絞って不完全でも動くように作っていき、あとから修正するのが、結局一番速かったりする。

動かしてみないとわからない種類の問題もある。そのときはやり直しになるので、それまでにかけたコストが低いほど、失うものが少ない。

早く書けるということは、そこから品質重視か速度重視かによって、選択できるということだ。早く書くことと品質はトレードオフでない。遅い人はその選択ができないので、遅延しやすくなる。

書くのが速いと、成功も、失敗も、経験の数が多くなる。単純にたくさん書いているからそれだけ見覚えのある問題は増えるし、馴染んだ表現が増える。失敗にしたって、得られるものは成功よりも多い。刻みつけられた問題意識や、切り抜けた経験は次の行動につながる。同じ情報に触れても、吸収できる量が増えるため、より吸収する速度に倍率がかかるだろう。

** 言語の練習方法と習熟段階
- 本を読む
  - はじめやすさ: ~★~ 誰でも始められる
  - 習熟学習ステージ1
  - 理解できたかテストできない
  - サンプルコードをやるだけではあまり身につかない
- 個人開発する(新規リポジトリ)
  - はじめやすさ: ~★~ 誰でも始められる
  - フィードバックがないとモチベーションを保つのが難しい
  - アピール: ~★~ 少なくとも最低限の能力は持っていることを証明できる
  - 習熟ステージ2
  - ありがちなコードや問題だとググればすぐわかるので、理解できたかテストするのは難しい
  - 緊張感、フィードバックがない
- 有名な開発者の、小さめのリポジトリを覗く
  - 有益な情報が多いかつ、ハードル低め
- 仕事にする(メイン/副業)
  - はじめやすさ: 言語による
    - 求人が少ない言語は難しい
    - 既存技術スタックと言語特性が離れていると、難しい。
    - 例: [[id:cfd092c4-1bb2-43d3-88b1-9f647809e546][Ruby]] → [[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C言語]]は難しい(逆はイージー)
    - 静/動的型付け、スクリプト/コンパイル、WEB/組み込み
  - フィードバックが得られる
  - アピール: ~★★~ 業務経験〜年は非常に強力
  - 手頃なレベルのタスクを探しやすい
  - 実際の問題を解決するため、理解せざるを得ない状況になる
  - 習熟ステージ2→3にしやすい
- 既存リポジトリにコントリビュートする
  - はじめやすさ: ~★★★~ 規模によるが、読むのは新規に書くより格段に難しい
  - アピール: ~★★~
  - 理解できるなら、非常に参考になる
  - 理解せざるを得ない状況になる
  - コード以外に障壁は存在しない。技術とモチベーションだけが問題
  - 難易度が高く、モチベーションを保つのが難しい
  - 習熟ステージ3→4
- 他者との協働の場でないと、正しく把握・理解するプレッシャー、テストが存在しない
** 常に正しい道を選ぶというより、軌道修正する能力が高い
できるプログラマーの書いたコードを見ていると、常に素早く、正しい選択をしているように見える。
不思議だ。
実際には、途中で方向修正していることが多い。正しい道を選ぶというか、軌道修正できる前提でコードを書いているなど、変更の能力が高いように見える。結果として、素早く実装して運用の中で正しい道を把握していく。
普通の人は、正しい道を選ぼうとしてベストプラクティスを丸々参考にし、運用後の変更は考えていない。期間が経つと負債になることが多い。

ということで、長期的に見て正しい選択をするためにはスピード・後から変更できること、が必要に見える。
* Tasks
* References
* Archives
** DONE changelogを読みやすく
CLOSED: [2023-05-27 Sat 20:19]
:LOGBOOK:
CLOCK: [2023-05-27 Sat 19:50]--[2023-05-27 Sat 20:15] =>  0:25
CLOCK: [2023-05-27 Sat 19:12]--[2023-05-27 Sat 19:37] =>  0:25
CLOCK: [2023-05-27 Sat 18:35]--[2023-05-27 Sat 19:00] =>  0:25
:END:

elfeedを設定した。
