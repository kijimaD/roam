:properties:
:ID: 20240612T011737
:end:
#+title:      KDOC 189: Goでスライスがどのように保存されているか調べる
#+date:       [2024-06-12 Wed 01:17]
#+filetags:   :draft:code:
#+identifier: 20240612T011737

# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。

* この文書のステータス
- 作成
  - [X] 2024-06-20 貴島
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
# 本文(タイトルをつける)。
[[id:7cacbaa3-3995-41cf-8b72-58d6e07468b1][Go]]でスライスが、どのようにメモリに保存されているか調べる。
* 調べる

まず、スライスの定義は↓のようになっており、配列の先頭要素へのポインタにすぎない。

#+caption: スライスの定義
#+begin_src go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
#+end_src

したがって、それぞれの要素を先頭にしたスライスを作り指すポインタを見ると、それぞれの要素が位置するアドレスがわかる。

#+caption: s1~s3のポインタから、スライスの要素はメモリに1バイトずつ保存されていることがわかる。s4はcapを超えてappendされ、スライスのコピーが走って別の位置に保存される
#+begin_src go :imports fmt
    func main(){
            s1 := []byte{1, 2, 3}
            s2 := s1[1:]
            s3 := s1[2:]
            s4 := s1
            s4 = append(s4, 4)
            fmt.Printf("s1: %v, addr: %p, len: %d, cap: %d\n", s1, s1, len(s1), cap(s1))
            fmt.Printf("s2: %v, addr: %p, len: %d, cap: %d\n", s2, s2, len(s2), cap(s2))
            fmt.Printf("s3: %v, addr: %p, len: %d, cap: %d\n", s3, s3, len(s3), cap(s3))
            fmt.Printf("s4: %v, addr: %p, len: %d, cap: %d\n", s4, s4, len(s4), cap(s4))
    }
#+end_src

#+RESULTS:
#+begin_src
s1: [1 2 3], addr: 0xc0000120e0, len: 3, cap: 3
s2: [2 3], addr: 0xc0000120e1, len: 2, cap: 2
s3: [3], addr: 0xc0000120e2, len: 1, cap: 1
s4: [1 2 3 4], addr: 0xc0000120e8, len: 4, cap: 8
#+end_src

図にするとこうなる。再割り当てされる位置は元の位置と空いているが、その箇所には何が入っているのだろうか。どうやって調べればよいか。

#+caption: スライスの値とポインタの図
#+begin_src
 addr 0 1 2 3 4 5 6 7 8 9 a b
 val  1 2 3 ? ? ? ? ? 1 2 3 4
#+end_src

* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# この事実は自分のこのアイデアとどう整合するか。
# この現象はあの理論でどう説明できるか。
# ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# いま聞いた内容は以前に聞いたことがなかったか。
# メモ y についてメモ x はどういう意味か。
- [[id:20240608T113006][KDOC 188: 『Visual Guide to Slices in Go』]]。読んで参考にした元ネタ。実際に試してみた
