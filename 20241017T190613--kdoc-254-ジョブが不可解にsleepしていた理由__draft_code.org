:properties:
:ID: 20241017T190613
:end:
#+title:      KDOC 254: ジョブが不可解にSleepしていた理由
#+date:       [2024-10-17 Thu 19:06]
#+filetags:   :draft:code:
#+identifier: 20241017T190613

# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。

* この文書のステータス
- 作成
  - [X] 2024-10-17 貴島
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
# 本文(タイトルをつける)。

数時間かかる機械学習の推論処理をブラウザからキック + 進捗ログを確認できるようにする、ということをした。ジョブワーカーを起動して非同期処理をできるようにしたのだが、そこで不可解な事象にあたって悩んだので書いていく。ちゃんとわかっている人であれば秒で解決できただろう。

前提。

- タスクのステータス(Running, Success, Failed, ...)はFlowerで確認できる
- ワーカーはDockerコンテナ上で動いている

事象。

- タスクが永遠にRunningのままで、 終了ステータスにならない。ログを見ると同じ箇所で進まなくなっている
  - 調べると、タスクプロセスがスリープステータスになっていた。終了はしていない
  - スリープだけあって、CPU使用率はほぼ0%に近い。いっぽうメモリは率が高いままになっている
  - スリープになったプロセスを再開させても、すぐスリープに戻る
  - システムログにめぼしいメッセージは出ていない
  - マシンリソースには余裕がある
- 特定の入力データだけで起こる。データサイズに違いはない
- 直にシェルから実行すると成功する。ジョブワーカー経由で実行すると失敗する
- straceで該当プロセスのシステムコールをトレースしてみると、最後に実行されているのは ~write(2, "Warning: ...")~ であった。プロセスを再開させて(すぐ終了する)トレースしても、最後に ~write(2, "Warning: ...")~ が実行されていた。

原因。

結論としては、タスク内で実行しているサブプロセスで標準エラー出力を取り出せておらず、標準エラー出力が詰まっていたためだった。完全に溜まった結果、プロセスがスリープしていた。

- うまくいかない入力データでは、実行の過程でWarningが大量に出ており、このWarningは標準エラー出力に出されていた
- うまくいく入力データでは、Warningはあまり出ていない

Warningは実行終了時に、まとめてログに書き込まれていた。標準エラー出力に書き込まれたそのタイミングでログに記録されるのではなく、終了時に標準エラー出力がまとめて書き込まれていた。推論コードはあまり見ていないので、標準エラー出力が最後にまとめて出ているのがおかしいことに気づかなかった。

シェルで実行するときは標準エラー出力が即時に取り出される。そのためエラーが起きない。ジョブワーカー経由では、エラー出力を正しく処理できていなかったために、貯まってしまうようになっていた。

* 関連
なし。
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# この事実は自分のこのアイデアとどう整合するか。
# この現象はあの理論でどう説明できるか。
# ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# いま聞いた内容は以前に聞いたことがなかったか。
# メモ y についてメモ x はどういう意味か。
