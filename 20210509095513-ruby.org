:PROPERTIES:
:ID:       cfd092c4-1bb2-43d3-88b1-9f647809e546
:END:
#+title: Ruby
* 概要
Rubyはオブジェクト指向の[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]である。
Webフレームワークの[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]が有名で、採用されるケースはRailsを使うためが多い。

コンパイル不要なスクリプト言語、静的型付け、WEBに使用される、といった点で[[id:a6c9c9ad-d9b1-4e13-8992-75d8590e464c][Python]]と競合している。
* Memo
** ファイルを作らずにファイルオブジェクトを作ってテストする
ファイル入力のあるプログラムがあるとする。
テストするとき、普通はファイルを作って読み込むことになる。
しかしいちいちファイルを用意するほどではない、みたいな場合もある。
そのときは ~StringIO~ を使うと気軽に試せる。

#+begin_src ruby
  require 'stringio'
  string = <<EOM
    aaa
    "aaa"
  EOM

  file1 = StringIO.new(string)
  file.read # => aaa\n"aaa"
  file2 = StringIO.new('')
  file.read # => ""
#+end_src
としておいて、あとは普通のFIleオブジェクトにするように、 ~StringIO~ オブジェクトに対して各種操作ができる。
** Ruby kaigi 2021
*** VSCode extension for ruby type
https://www.slideshare.net/mametter/typeprof-for-ide-enrich-development-experience-without-annotations

- 言語自体を変えなくても、現代的なIDEの恩恵を受けられる。
- 特に静的型付け言語だと引数の型などを表示できる。
- RBS :: ruby official type definition language
- 型レベルに抽象化して情報を解析する。

- https://github.com/usaito Special Thanksに載ってた人。年下だ…。本物の工学の人。
- あまり専門的な内容には触れなかった。
*** Why Ruby's JIT was slow
- RubyのJITの状況、高速化。
- 方式の違い。
*** RuboCop in 2021: Stable and Beyond
- Rubocopの状況。過去、現在、未来。
- autocorrectが安全な修正をするように設計。
*** The Art of Execution Control for Ruby's Debugger
- 歯のメンテナンス
- 新しいデバッガ: ~debug.gem~ Rails7からこれを使うようになるよう
- rubyにおけるデバッガーの状況、ツール作った理由、使い方。
- gem ~rdbg~
- ~info~ コマンド
- 一部分だけトレースできる。
- PostMortem debugging…検死、なぜプログラムが終了したか調べる。
- Record and play debug…戻れる。
*** Toycol: Define your own application protocol
- プロトコルの各レイヤーが責任を持つ
- プロトコルをサーバとクライアントが知っているものであれば、なんだって通信。自作プロトコルでも。
- 自作プロトコルの使い方と動作の仕組み
*** dRuby in the real-world embedded systems
- CT装置
- 胆石
*** Regular Expressions: Amazing and Dangerous
なぜ危険か。
- ~+?~ によって非常に時間がかかる[[id:f054b2d4-c7f9-4bf2-be9c-e29a7f97cb45][Regular Expression]]になる可能性がある。文字列が非常に長い場合、組み合わせ数が爆発的に増えるため。
- サービスがダウンすることもある。Stack Overflow, Cloudflare, Atom...であったインシデントのいくつか...はRubyの[[id:f054b2d4-c7f9-4bf2-be9c-e29a7f97cb45][Regular Expression]]由来のものだった
- gemの中から危険な表現が使われているところを検索する。多くヒットした

対策。
- ~//x~ を使う
- 正規表現のテストを書く。カバレッジは正規表現の中までは見ない…
- 入力の長さを制限する
*** Demystifying DSLs for better analysis and understanding
- Domain Specific Language
- [[id:f054b2d4-c7f9-4bf2-be9c-e29a7f97cb45][Regular Expression]], Rakefile, RSpec...
- [[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]] provide many DSL
- Tapioca gem
- generate rbi file from Model
*** The Future Shape of Ruby Objects
- Rubyのオブジェクトの実装を見ながら解説。
- オブジェクト指向言語[[id:2a420174-482b-4a3e-868a-3a447572f1be][Smalltalk]]のselfオブジェクト
- classとshape
- [[id:a6980e15-ecee-466e-9ea7-2c0210243c0d][JavaScript]]とかのプロトタイプ言語的アプローチ。
- [[https://github.com/Shopify/truffleruby][Shopify/truffleruby]]
*** PRK Firmware: Keyboard is Essentially Ruby
- 自作キーボードを制御するfirmwareをRubyで書く
*** The newsletter of RBS updates
- [[https://github.com/ruby/rbs][ruby/rbs]]
- RBS → Rubyで型を定義するためのDSL
- サードパーティgemのRBSコレクションを作成している
- Railsに導入する方法
*** Parsing Ruby
- Rubyの記法の変遷。パーサの変遷
- コアに追従することは難しい
- 少しの文法の変更でも大きな影響範囲がある
- 少しの変更も拡張が難しい
*** Use Macro all the time ~ マクロを使いまくろ ~
- ASTレベルでRubyコードを置き換える
- パッケージの紹介
*** Charty: Statistical data visualization in Ruby
- Rubyでのグラフ描画ツール、charty
- パッケージの紹介
*** Dive into Encoding
- Relineのバグ修正で文字コードを深く知るきっかけ
- 文字コードを実装して学ぶ
- Coded Charcter Set
- Character Encoding Scheme
- Conversion table
- Encoding constant
*** How to develop the Standard Libraries of Ruby
- 標準ライブラリの作り方
- gemification - 本体添付からgemに切り離す
- [[https://github.com/rubygems/rubygems][rubygems/rubygems]]
*** Ruby, Ractor, QUIC
- QUICはGoogleによって開発された高速なプロトコル。
- クラウドゲーミングでは高速性が必要
- TCPとUDPの特性の違い
*** 10 years of Ruby-powered citizen science
- [[https://github.com/Safecast/safecastapi][Safecast/safecastapi: The app that powers api.safecast.org]]
- 放射線の観測デバイス
- デバイスが送信する観測データを各クラウドにキャストする
- Dashboardで加工、アクセスできるようにする
- マップ、グラフ、UI/UX、データバリデーション…課題はまだまだある
*** Matz Keynote
- Ruby 3.0
- 互換性大事
- 静的型付け言語が流行している。ほかの動的言語にも導入されている。Rubyにはどうか、答えはNo。
- 言語仕様としては型を実装することはない。周辺ツールで行う
- 型,LSP,チェッカ,...ツールを応援する
- パフォーマンスは重要。動機づけになる、問題を解決する
- パフォーマンスは評判に直結する
- マイクロベンチマーク(素数解析とか、単純な計算をもとにパフォーマンスを示す)は現実世界に影響するか → 実際にはしないけど、人々は信用しがちなので重要ではある
- Ruby3x3 :: Ruby3.XはRuby3.0より3倍早い
*** Graphical Terminal User Interface of Ruby 3.1
- 沢登り
- irbに補完機能をつける
*** Ruby Committers vs the World
- Rubyコミッターの人たちによる座談会
- cool
** count
countにブロックを渡して配列の数を調べられる。
↓二行は同じ意味。
#+begin_src ruby
expect(item_type_pool.types.select { |t| t.category == :canon }.length).to be > 10
expect(item_type_pool.types.count { |t| t.category == :canon }).to be > 10
#+end_src
** 継承関係を辿る
#+begin_src ruby
  true.class.ancestors
#+end_src
** オブジェクトのメソッド一覧を見る
#+begin_src ruby
true.public_methods
#+end_src

falseを渡すと祖先のメソッドを表示しない。
#+begin_src ruby
  true.public_methods(false)
  =# => [:===, :^, :inspect, :to_s, :&, :|]
#+end_src
** group_by
~Enumerable#group_by~
ブロックを評価した結果をキー、対応する要素の配列を値とするハッシュを返す。

QueryMethodの ~where~ で取った値をハッシュにして、後で使いまわせる。N+1問題の回避に使える。QueryMethodぽい名前だが無関係。
** index_by
 viewで何かモデルに関することをループさせないといけないときに役立つ。モデルを一度にハッシュとして取ることで、パフォーマンスを改善できる。
** インスタンスメソッドを調査する
 ~String.instance_methods(false).sort~
 ~false~ によってクラスの継承メソッドを表示しないため、クラス単体を調べるのに役立つ。
** トップレベルで実行できる理由
 クラスがなくトップレベルで定義されたメソッドのレシーバーは ~Object~ クラス。クラスの中にないトップレベルメソッドでさまざまなことが行えるのは、 ~Object~ のおかげ。 ~ruby -e 'p Kernel.private_instance_methods.sort'~ でチェックできる。
 - ~puts~ がレシーバーなしで呼び出せるのは、 ~Object~ クラスが ~puts~ のある ~Kernel~ クラスをincludeしているから。
 - ~.to_d~ - BigDecimalに変換する。
 - ~index~ - 配列を検索して添字を返す。
** 何のメソッドがわからないとき
 - [[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]だと ~robe-doc~ がとても便利。すでにあるローカルにあるドキュメントを活用するべき。
** when句
https://stackoverflow.com/questions/3908380/ruby-class-types-and-case-statements/3908411

#+begin_src ruby
case item
when MyClass
...
when Array
...
when String
...
#+end_src
is really

#+begin_src ruby
if MyClass === item
...
elsif Array === item
...
elsif String === item
...
#+end_src

~===~ は内部的に ~is_a?~ を使っている。

#+begin_src ruby
if item.is_a?(MyClass)
...
elsif item.is_a?(Array)
...
elsif item.is_a?(String)
...
#+end_src
をcaseに書き換えるには一番上の書き方でよい。たぶん。
** singletonをクリーンにテストする
singletonをそのまま使うと状況依存のテストになるため、毎回newする必要がある。

https://stackoverflow.com/questions/1909181/how-to-test-a-singleton-class

#+begin_src ruby
def self.instance
  @instance ||= new
end

private_class_method :new
#+end_src

So you can bypass the memoization altogether by calling the private method new using send

#+begin_src ruby
let(:instance) { GlobalClass.send(:new) }
#+end_src
A nice benefit of this way is that no global state is modified as a result of your tests running.

Probably a better way, from this answer:

#+begin_src ruby
let(:instance) { Class.new(GlobalClass).instance }
#+end_src
** 評価結果アノテーションを付与するxmpfilter
便利ツールを集めた https://github.com/rcodetools/rcodetools というgemがある。
そのなかにインラインで実行した結果を表示するスクリプトがある。
[[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]用のコードもある。https://github.com/rcodetools/rcodetools/blob/master/misc/rcodetools.el rubykitch氏作成。
#+begin_src ruby
1.to_s # => "1"
#+end_src
というように、irbのように挿入してくれる。とても便利。
* Tasks
** TODO 何かgemを見てみる
まず探すのが大変なので、読んでみるgemを選ぶ。
手軽にできるのが良い。
** TODO rubocop issue(allow multiline)
:LOGBOOK:
CLOCK: [2021-09-16 Thu 23:04]--[2021-09-16 Thu 23:29] =>  0:25
:END:
https://github.com/rubocop/rubocop/issues/9365
どうにかなりそうではある。コメントルールをマルチラインに対応させる。

#+begin_src ruby
  # これは検知される
  foo(
    # aaaa

    22
  )

  # これはセーフ。これで間に合うように感じる。
  foo(
    # bbbb
    22
  )
#+end_src

コメントのあとは空白行を無視したいらしいが、あまり意味を感じない。実装はできるが、目的があまりよくないように思える。
** TODO rubocop issue(yoda expression)
:LOGBOOK:
CLOCK: [2021-09-14 Tue 23:00]--[2021-09-14 Tue 23:25] =>  0:25
CLOCK: [2021-09-14 Tue 00:10]--[2021-09-14 Tue 00:35] =>  0:25
CLOCK: [2021-09-13 Mon 22:57]--[2021-09-13 Mon 23:22] =>  0:25
CLOCK: [2021-09-13 Mon 22:26]--[2021-09-13 Mon 22:51] =>  0:25
CLOCK: [2021-09-13 Mon 21:42]--[2021-09-13 Mon 22:07] =>  0:25
:END:
https://github.com/rubocop/rubocop/issues/9222
New cop for yoda expressions.

TSLintにすでにあるので、実装の参考にすればいい。
[[https://palantir.github.io/tslint/rules/binary-expression-operand-order/][Rule: binary-expression-operand-order]]

- 二項演算子(Binary Operator) :: 式を書いたときに、被演算子（変数とか値）が2つ登場する演算子

#+begin_src ruby
  def on_send(node)
    method = node.method_name
    lhs = node.receiver
    rhs = node.first_argument

    # a.+(b)
    # a -> lhs
    # + -> method
    # b -> rhs
  end
#+end_src

conditionの方と合体させてもよさそう。TSLintはそうしてる。共通しているところは多い。
全く別のcopにする方針で一応書けたが、本質的にcondition operatorとやってることは同じだ。

方式が違うので難しいな。
明らかにTSLintのやり方が簡潔に書かれているように見える。rubocopの方はゴテゴテと条件が多い。単に対応オペレータを増やすだけだが、よくわからない。conditionを前提に書かれているところも難しい。

ちょっとやってどうにかなるものでなさそう。追加されないのには、理由があった。
まず既存のがごちゃついてるので、それを整理する必要がある。
1ヶ月くらいかけて取り組んでみる。
** TODO Practical Ruby Project
Rubyでの面白いプロジェクトを紹介している。
- Lispを実装。
- 経済ゲームを作る。
** TODO Rubyの公式リファレンスが読めるようになる本
- https://zenn.dev/jnchito/books/how-to-read-ruby-reference
** TODO The well-grounded rubyist [54%]
DEADLINE: <2021-09-30 Thu>
*** DONE 420
:LOGBOOK:
CLOCK: [2021-09-23 Thu 14:05]--[2021-09-23 Thu 14:34] =>  0:29
:END:
CLOSED: [2021-09-23 Thu 14:49]
*** DONE 430
CLOSED: [2021-09-23 Thu 22:38] DEADLINE: <2021-09-23 Thu>
:LOGBOOK:
CLOCK: [2021-09-23 Thu 15:23]--[2021-09-23 Thu 16:24] =>  1:01
:END:
*** DONE 440
CLOSED: [2021-09-23 Thu 23:59] DEADLINE: <2021-09-23 Thu>
:LOGBOOK:
CLOCK: [2021-09-23 Thu 22:38]--[2021-09-23 Thu 23:59] =>  1:21
:END:
*** DONE 450
CLOSED: [2021-09-24 Fri 10:28]
:LOGBOOK:
CLOCK: [2021-09-24 Fri 09:04]--[2021-09-24 Fri 10:27] =>  1:23
:END:
<2021-09-24 Fri>
*** DONE 460
CLOSED: [2021-09-25 Sat 12:30]
:LOGBOOK:
CLOCK: [2021-09-25 Sat 11:19]--[2021-09-25 Sat 12:30] =>  1:11
:END:
<2021-09-25 Sat>
*** DONE 470
CLOSED: [2021-09-26 Sun 01:20]
:LOGBOOK:
CLOCK: [2021-09-26 Sun 00:28]--[2021-09-26 Sun 01:20] =>  0:52
CLOCK: [2021-09-25 Sat 23:26]--[2021-09-26 Sun 00:15] =>  0:49
:END:
<2021-09-25 Sat>
*** TODO 480
<2021-09-26 Sun>
*** TODO 490
<2021-09-26 Sun>
*** TODO 500
*** TODO 510
*** TODO 520
