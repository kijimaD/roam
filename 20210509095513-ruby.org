:PROPERTIES:
:ID:       cfd092c4-1bb2-43d3-88b1-9f647809e546
:header-args+: :wrap :results raw
:END:
#+title: Ruby
* 概要
Rubyはオブジェクト指向の[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]である。
Webフレームワークの[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]が有名で、採用されるケースはRailsを使うためが多い。

コンパイル不要なスクリプト言語、静的型付け、WEBに使用される、といった点で[[id:a6c9c9ad-d9b1-4e13-8992-75d8590e464c][Python]]と競合している。
* Memo
** 日付計算でのRational
日付計算でDate同士を計算するときがある。
そのとき返ってくる値を表示すると-1/1みたいに表示される。
これはRational(有理数)オブジェクトである。
.to_iで整数に変換できる。

[[https://docs.ruby-lang.org/ja/2.4.0/method/Date/i/=2d.html][Date#- (Ruby 2.4.0 リファレンスマニュアル)]]
** マッチした部分文字列の配列を返すscan
#+caption: 2文字づつ分割
#+begin_src ruby :results raw
  "foobar".scan(/../)
#+end_src

#+RESULTS:
#+begin_results
["fo", "ob", "ar"]
#+end_results

#+caption: 数字クラスごとで分割
#+begin_src ruby
  "1 2 3".scan(/\d+/)
#+end_src

#+RESULTS:
#+begin_results
["1", "2", "3"]
#+end_results

#+caption: セパレータが違っても↑と同じ結果を返す
#+begin_src ruby
  "1, 2, 3".scan(/\d+/)
#+end_src

#+RESULTS:
#+begin_results
["1", "2", "3"]
#+end_results

** メモリ使用量を調べる
#+caption: すべてのメモリ使用量を調べる
#+begin_src ruby
  require 'objspace'
  puts "#{ObjectSpace.memsize_of_all / (1000.0 * 1000.0)} MB"
#+end_src

** irbでgemを読み込む
#+begin_src ruby
  require 'rspec'
  include RSpec::Matchers

  include ActionView::Helpers::OutputSafetyHelper
#+end_src

** クラスの読み込み順
親(抽象)クラスは、子(具体)クラスよりも先に読み込む必要がある。
普通に開発していると1つのファイルに入れることはないので気づきにくい、はまりやすい。

↓はエラーになる。
#+caption: Bが名前解決できずエラー
#+begin_src ruby
class A < B
end

class B
end
#+end_src

** 名前空間の絶対指定と相対指定                                        :Write:
** 親クラスから子クラスの定数にアクセス
#+caption: 具体クラスの定数が入る。子クラスに移譲できる
#+begin_src ruby
  class Abstruct
    def print_child_constant
      self.class::NAME
    end
  end

  class A < Abstruct
    NAME = 'AA'
  end

  class B < Abstruct
    NAME = 'BB'
  end

  p A.new.print_child_constant # AA
#+end_src

[[https://easyramble.com/access-subclass-constant-from-superclass.html][Rubyで親クラスから子クラスの定数を参照 | EasyRamble]]
** 配列をマージ/結合
~merge~ メソッドはHashクラスのメソッドであり、配列では使えない。

単純な結合。

#+caption: 結合
#+begin_src ruby
['a', 'b'] + ['a', 'b']
#+end_src

#+RESULTS:
#+begin_results
["a", "b", "a", "b"]
#+end_results

マージ(=かぶってたら削除)。
#+caption: マージ
#+begin_src ruby
['a', 'b'] | ['a', 'b']
#+end_src

#+RESULTS:
#+begin_results
["a", "b"]
#+end_results

uniqでも同じ。
#+caption: uniq
#+begin_src ruby
(['a', 'b'] + ['a', 'b']).uniq
#+end_src

#+RESULTS:
#+begin_results
["a", "b"]
#+end_results
** Struct(構造体クラス)
structは簡易的なclassのようなもの。
データをまとめるのに使う。

#+caption: structで定義する
#+begin_src ruby
  user = Struct.new(:name, :age)
  user.new('taro', 15)
#+end_src

#+RESULTS:
#+begin_results
#<struct name="taro", age=15>
#+end_results

[[https://qiita.com/k-penguin-sato/items/54189d5ed4e5f7463266][【Ruby】Struct(構造体クラス)を理解する - Qiita]]
** thor
thorはコマンドを作るgem。
同じようなライブラリにrakeがあるが、rakeは引数を渡す方法が特殊なのでthorが好まれる。
#+begin_src ruby
  module Gemat
    class Cli < Thor
      class_options input: :string, output: :string, columns: :array, all: :boolean
      # メソッド共通のオプション

      desc 'csv', 'csv command description'
      def csv
      end

      desc md, 'md command description'
      def md
      end

      no_tasks do
        def command(options, method_name)
        end
      end
    end
  end
#+end_src

#+begin_src shell
  $ gemat csv
#+end_src
** pp
Hashが見づらいときは、 ~pp~ を使うと綺麗に表示できる。
https://docs.ruby-lang.org/ja/latest/library/pp.html
** map
mapの返り値は、ブロックの最後の値である。
だから↓みたく途中でセットしたい、というときは最後配列に入れたいものを置く必要がある。
#+begin_src ruby
  options[:columns].map do |column|
    od = OutDsl.new(column)
    od.idx = index
    od # ここ
  end
#+end_src
mapは1行で書くこと多いので忘れがち。
** rubygemsのcredential入手
https://rubygems.org/ であらかじめログインしておく。
#+begin_src ruby
  curl -u {user名} https://rubygems.org/api/v1/api_key.yaml > ~/.gem/credentials; chmod 0600 ~/.gem/credentials
#+end_src

#+begin_src shell
  rake release
#+end_src
* Mastering Ruby Closure
CLOSED: [2021-11-21 Sun 00:38]
:LOGBOOK:
CLOCK: [2021-11-20 Sat 21:45]--[2021-11-20 Sat 22:54] =>  1:09
CLOCK: [2021-11-20 Sat 15:31]--[2021-11-20 Sat 17:16] =>  1:45
CLOCK: [2021-11-19 Fri 21:57]--[2021-11-19 Fri 23:04] =>  1:07
CLOCK: [2021-11-17 Wed 23:22]--[2021-11-17 Wed 23:54] =>  0:32
CLOCK: [2021-11-16 Tue 21:13]--[2021-11-16 Tue 22:31] =>  1:18
CLOCK: [2021-11-15 Mon 10:35]--[2021-11-15 Mon 10:55] =>  0:20
CLOCK: [2021-11-14 Sun 10:55]--[2021-11-14 Sun 11:00] =>  0:05
CLOCK: [2021-11-13 Sat 20:58]--[2021-11-13 Sat 21:38] =>  0:40
:END:

DEADLINE: <2021-11-21 Sun>
- 10, 15, 20, 36, 38, 55, 57, 61, 68

** 定義
- 関数を必要とする
- 親スコープで定義される変数を参照する
** レキシカルバインディング
#+begin_src ruby :results output
  msg = "aaa"
  3.times do
    prefix = "I"
    puts "#{prefix} #{msg}"
  end
#+end_src

#+RESULTS:
#+begin_results
I aaa
I aaa
I aaa
#+end_results

ブロックの内側から外側にはアクセスできる。

#+begin_src ruby
  msg = "aaa"
  3.times do
    prefix = "I"
    puts "#{prefix} #{msg}"
  end
  prefix
#+end_src

ブロックの外側から内側にアクセスできない。
** 自由変数
#+begin_src ruby
  chalkboard_gag = lambda do |msg|
    lambda do
      prefix = "I will not"
      "#{prefix} #{msg}"
    end
  end
  chalkboard_gag
  inner_lambda = chalkboard_gag.call("drive the car")
  inner_lambda.call
#+end_src

#+RESULTS:
#+begin_results
I will not drive the car
#+end_results
** 例) カウンター
2つ目のlambdaから見ると、 ~x~ は注入されてるので自由変数。
#+begin_src ruby :results output
  counter = lambda do
    x = 0
    get_x = lambda { p x } # x is free variable
    incr = lambda { p x += 1 }
    decr = lambda { p x -= 1 }

    {get_x: get_x, incr: incr, decr: decr}
  end
  c1 = counter.call
  c1[:incr].call
  c1[:incr].call
  c1[:incr].call
  c1[:get_x].call
  c1[:decr].call
  c1[:decr].call

  c2 = counter.call
  c2[:get_x].call
#+end_src

#+RESULTS:
#+begin_results
1
2
3
3
2
1
0
#+end_results

** コールバック関数
#+begin_src ruby
  class Generator
    attr_reader :report

    def initialize(report)
      @report = report
    end

    def run
      report.to_csv
    end

  Notifier.new(Generator.new(good_report),
               on_success: lambda { |r| puts "Send #{r} to boss" },
               on_failure: lambda { puts "Send to ben" }
              ).tap do |n|
    n.run
  end
#+end_src

#+RESULTS:

#+begin_src ruby
  is_even = lambda { |x| x % 2 == 0 }
  is_even.call(3)
#+end_src

#+RESULTS:
#+begin_results
false
#+end_results

#+begin_src ruby
  is_even = lambda { |x| x % 2 == 0 }
  def complement(predicate, value)
    not predicate.call(value)
  end
  complement(is_even, 3)
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

#+begin_src ruby
  is_even = lambda { |x| x % 2 == 0 }
  def complement(predicate)
    lambda do |value|
      not predicate.call(value)
    end
  end
  complement(is_even).call(4)
  complement(is_even).call(5)
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

#+begin_src ruby
  class Generator
    attr_reader :report

    def initialize(report)
      @report = report
    end

    def run
      report.to_csv
    end
  end

  class Notifier
    attr_reader :generator, :callbacks

    def initialize(generator, callbacks)
      @generator = generator
      @callbacks = callbacks
    end

    def run
      result = generator.run
      if result
        callbacks.fetch(:on_success).call(result)
      else
        callbacks.fetch(:on_failure).call
      end
    end
  end

  good_report = OpenStruct.new(to_csv: "59.99, Great Success")

  Notifier.new(Generator.new(good_report),
               on_success: lambda { |r| puts "Send #{r} to boss" },
               on_failure: lambda { puts "Send email to ben" }
              ).tap do |n|
    n.run #=> send 59.99, great succes to boss
  end
#+end_src

#+RESULTS:

#+begin_src ruby
  good_report = OpenStruct.new(to_csv: nil)

  Notifier.new(Generator.new(good_report),
               on_success: lambda { |r| puts "Send #{r} to boss" },
               on_failure: lambda { puts "Send email to ben" }
              ).tap do |n|
    n.run #=> ben
  end
#+end_src
元のNotifierクラスに手を加えることなく、ログ機能を追加できた。
** reduce
既存のreduceの例。
#+begin_src ruby
  [1, 2, 3, 4, 5].reduce(10) { |acc, x| p "#{acc}, #{x}"; acc + x }
#+end_src

#+RESULTS:
#+begin_results
25
#+end_results

eachを使わずに実装。再帰になる。

#+begin_src ruby
  adder = lambda do |acc, arr|
    if arr.empty?
      acc
    else
      adder.call(acc + arr.first, arr.drop(1))
    end
  end
  adder.call(10, [1, 2, 3, 4, 5])
#+end_src

#+RESULTS:
#+begin_results
25
#+end_results

#+begin_src ruby
  multiplier = lambda do |acc, arr|
    if arr.empty?
      acc
    else
      multiplier.call(acc * arr.first, arr.drop(1))
    end
  end
  multiplier.call(10, [1, 2, 3, 4, 5])
#+end_src

#+RESULTS:
#+begin_results
1200
#+end_results

変わったのは演算子だけで、DRYでない。
抽象化する。

#+begin_src ruby
  reducer = lambda do |acc, arr, binary_function|
    if arr.empty?
      acc
    else
      reducer.call(binary_function.call(acc, arr.first), arr.drop(1), binary_function)
    end
  end
  reducer.call(1, [1, 2, 3, 4, 5], lambda { |x, y| x + y })
#+end_src

#+RESULTS:
#+begin_results
16
#+end_results

#+begin_src ruby
  reducer = lambda do |acc, arr, binary_function|
    reducer_aux = lambda do |acc, arr|
      if arr.empty?
        acc
      else
        reducer_aux.call(binary_function.call(acc, arr.first), arr.drop(1))
      end
    end

    reducer_aux.call(acc, arr)
  end

  reducer.call(1, [1, 2, 3, 4, 5], lambda { |x, y| x + y })
#+end_src

#+RESULTS:
#+begin_results
16
#+end_results
** ex1
#+begin_src ruby
  def is_larger_than(amount)
    lambda do |a|
      a > amount # amount is free variable
    end
  end

  larger_than_5 = is_larger_than(5)
  larger_than_5.call(7)
  larger_than_5.call(3)
#+end_src

#+RESULTS:
#+begin_results
false
#+end_results

#+begin_src ruby :results output
  new_db = lambda do
    db = {}
    insert = lambda do |key, value|
      p db.store(key, value)
    end
    dump = lambda { p db }
    delete = lambda do |key|
      p db.delete(key)
    end
    {insert: insert, dump: dump, delete: delete}
  end
  db = new_db.call
  db[:insert].call("this is key", "this is value")
  db[:dump].call
  db[:delete].call("this is key")
  db[:dump].call
#+end_src

#+RESULTS:
#+begin_results
"this is value"
{"this is key"=>"this is value"}
"this is value"
{}
#+end_results

#+begin_src ruby
  complement = lambda do |function|
    lambda do |arg|
      not function.call(arg)
    end
  end

  is_even = lambda { |x| x % 2 == 0 }
  complement.call(is_even).call(5)
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

この部分遅延させる感じが本質か。

畳み込み演算の配列バージョン。
#+begin_src ruby
  [1, 2, 3, 4, 5].reduce(Array.new()) { |result, item| result << item * 2 }
#+end_src

#+RESULTS:
#+begin_results
[2, 4, 6, 8, 10]
#+end_results
** ブロック
#+begin_src ruby
  def do_it
    yield
  end
  do_it {"I'm doing it."}
#+end_src

#+RESULTS:
#+begin_results
I'm doing it.
#+end_results

#+begin_src ruby
  def do_it
    yield
  end
  do_it { [1, 2, 3] << 4}
#+end_src

#+RESULTS:
#+begin_results
[1, 2, 3, 4]
#+end_results

#+begin_src ruby results: output
  def do_it(x, y)
    yield(x, y)
  end
  do_it(2, 3) { |x, y| x + y }
  do_it("Ohai", "Dictator") do |greeting, title|
      "#{greeting}, #{title}!!!"
  end
#+end_src

#+RESULTS:
#+begin_results
Ohai, Dictator!!!
#+end_results

#+begin_src ruby
  def do_it(x)
    yield x
  end
  do_it(42) { |num, line| "#{num}: #{line}" }
#+end_src

#+RESULTS:
#+begin_results
42:
#+end_results

ブロックは無名関数に似ている。

名前がかぶると外側にあっても上書きする。
#+begin_src ruby
  x = "outside x"
  1.times { x = "modified from the outside block" }
  x
#+end_src

#+RESULTS:
#+begin_results
modified from the outside block
#+end_results

ブロック変数を使うとブロック外を上書きしない。
#+begin_src ruby
  x = "outside x"
  1.times { |;x| x = "modified from the outside block" }
  x
#+end_src

#+RESULTS:
#+begin_results
outside x
#+end_results
** Fixnum#times
↓みたいなことができるのはどうしてか。
#+begin_src ruby :results output
3.times { puts "D'oh!" }
#+end_src

#+RESULTS:
#+begin_results
D'oh!
D'oh!
D'oh!
#+end_results

#+begin_src ruby
  class Fixnum
    def times
      puts "This does nothing yet!"
    end
  end
  3.times { puts "D'oh!" }
#+end_src

#+begin_src ruby
  class Array
    def each
    end
  end
  %w(look ma no for loops).each do |x|
    puts x
  end
#+end_src

eachを作ってみる。
#+begin_src ruby
  class Array
    def each
      x = 0
      while x < self.length
        yield self[x]
        x += 1
      end
    end
  end

  %w(look me no for loops).each do |x|
    puts x
  end

  # look
  # me
  # no
  # for
  # loops
#+end_src

** IO close利用
ブロックはファイルクローズのし忘れ防止にも使える。
これはどうやって実装しているか。
#+begin_src ruby
  File.open() do |f|
    f << "aaa"
  end
#+end_src

実装してみる。
#+begin_src ruby
  class File
    def self.open(name, mode)
      file = new(name, mode)
      return file unless block_given?
      yield(file)
    ensure
      file.close
    end
  end
#+end_src

** オブジェクトの初期化
ブロックはオブジェクトの初期化にも使える。
#+begin_src ruby
  module Twitter
    module REST
      class Client
        attr_accessor :consumer_key, :consumer_secret,
                      :access_token, :access_token_secret
        def initialize
          yield self if block_given?
        end
      end
    end
  end

  client = Twitter::REST::Client.new do |config|
    config.consumer_key        = "YOUR_CONSUMER_KEY"
    config.consumer_secret     = "YOUR_CONSUMER_SECRET"
    config.access_token        = "YOUR_ACCESS_TOKEN"
    config.access_token_secret = "YOUR_ACCESS_SECRET"
  end

  #<Twitter::REST::Client:0x000056204ff8f410 @consumer_key="YOUR_CONSUMER_KEY", @consumer_secret="YOUR_CONSUMER_SECRET", @access_token="YOUR_ACCESS_TOKEN", @access_token_secret="YOUR_ACCESS_SECRET">
#+end_src

#+begin_src ruby
  class Router
    def initialize
      yield self
    end

    def match(route)
      puts route
    end
  end

  routes = Router.new do |r|
    r.match '/about' => 'home#about'
    r.match '/users' => 'users#index'
  end
#+end_src

[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]のrouterでやっているように、ここからどうやってレシーバーの ~r~ を使わずに指定できるのか。

#+begin_src ruby
  def foo
    yield self
  end

  foo do
    puts self
  end
  # => main
#+end_src

ブロック内のselfはブロックが定義されたところのselfになる。
ということで、selfを変えたければブロックが定義されるコンテキストを変えなければならない。

#+begin_src ruby
  class Router
    def initialize(&block)
      instance_eval &block
    end

    def match(route)
      puts route
    end
  end

  routes = Router.new do
    match '/about' => 'home#about'
  end
#+end_src
Routerコンテキストになるので、デフォルトレシーバーでmatchが呼べる。

オプションをハッシュで受け取る。
#+begin_src ruby
  module Twitter
    module REST
      class Client
        attr_accessor :consumer_key, :consumer_secret,
                      :access_token, :access_token_secret

        def initialize(options = {}, &block)
          options.each { |k, v| send("#{k}=", v) }
          instance_eval(&block) if block_given?
        end
      end
    end
  end

  client = Twitter::REST::Client.new({consumer_key: "YOUR_CONSUMER_KEY"}) do
    consumer_secret     = "YOUR_CONSUMER_SECRET"
    access_token        = "YOUR_ACCESS_TOKEN"
    access_token_secret = "YOUR_ACCESS_SECRET"
  end
#+end_src
オプションハッシュを使うか、ブロックを使うか、あるいは両方を使うか選択できる。
** ex2
eachを使ってmapを実装する。
#+begin_src ruby
  class Array
    def map
      array = []
      each do |x|
        array.push(yield x)
      end
      array
    end
  end
  goal = %w(look ma no for loops).map do |x|
    x.upcase
  end
  p goal

#+end_src

each_wordを実装する。
例えば↓みたいな動作イメージ。
#+begin_src ruby
  "Nothing lasts forever but cold November Rain".each_word do |x|
    puts x
  end
  # => Nothing
  # => lasts
  # => forever ...
#+end_src

#+begin_src ruby
  class String
    def each_word
      split.each do |x|
        yield x
      end
    end
  end

  "Nothing lasts forever but cold November Rain".each_word do |x|
    puts x
  end
#+end_src

Active RecordのDSLを実装する。
例えば。
#+begin_src ruby
  ActiveRecord::Schema.define(version: 20130314230445) do
    create_table "microposts", force: true do |t|
      t.string "content"
      t.integer "user_id"
      t.datetime "created_at"
      t.datetime "updated_at"
    end
  end
#+end_src

#+begin_src ruby
module ActiveRecord
  class Schema
    def self.define(version, &block)
      version
      instance_eval(&block) if block_given?
    end

    def self.create_table(table_name, options = {}, &block)
      t = Table.new(table_name, options)
      yield t if block_given?
    end
  end
end

class Table
  def initialize(name, options)
    @name = name
    @options = options
  end

  def string(value)
    puts "Creating column of type string named #{value}"
  end

  def integer(value)
    puts "Creating column of type integer named #{value}"
  end

  def datetime(value)
    puts "Creating column of type datetime named #{value}"
  end
end

ActiveRecord::Schema.define(version: 20130315230445) do
  create_table "microposts", force: true do |t|
    t.string "content"
    t.integer "user_id"
    t.datetime "created_at"
    t.datetime "updated_at"
  end
end

# Output
# Creating column of type string named content
# Creating column of type string named user_id
# Creating column of type string named created_at
# Creating column of type string named updated_at
#+end_src
** Proc
ブロックは単体で存在できないが、ProcとLambdaは単体でオブジェクトとして存在できる。

#+begin_src ruby
p = proc { |x, y| x + y }
#+end_src

#+RESULTS:
#+begin_results
#<Proc:0x000055b7801c80d0 -:3>
#+end_results

#+begin_src ruby
p = Kernel.proc { |x, y| x + y }
#+end_src

#+RESULTS:
#+begin_results
#<Proc:0x0000557970bb7a58 -:3>
#+end_results

#+begin_src ruby :results output
  p = proc { |x, y| p x + y }
  p.call("oh", "ai")
  p.call(4, 2)
#+end_src

#+RESULTS:
#+begin_results
"ohai"
6
#+end_results

短縮記法もある。
#+begin_src ruby :results output
  p = proc { |x, y| p x + y }
  p.("oh", "ai")
  p.(1, 2)
#+end_src

#+RESULTS:
#+begin_results
"ohai"
3
#+end_results

この記法は、call()が実装されているクラスならどこでも使用できる。
#+begin_src ruby
  class Carly
    def call(who)
      "call #{who}, maybe"
    end
  end
  c = Carly.new
  c.("me")
#+end_src

#+begin_src ruby :results output
  even = proc { |x| x % 2 == 0 }
  p even === 11
  p even === 10
#+end_src

#+RESULTS:
#+begin_results
false
true
#+end_results
** Lambda
lambdaのクラスはProcである。
#+begin_src ruby
  lambda {}.class
#+end_src

#+RESULTS:
#+begin_results
Proc
#+end_results

procのクラスはProcである。
#+begin_src ruby
proc {}.class
#+end_src

#+RESULTS:
#+begin_results
Proc
#+end_results

#+begin_src ruby
  lambda { |x, y| x + y }.call(x, y)
  lambda { |x, y| x + y }[x, y]
  lambda { |x, y| x + y }.(x, y)
  lambda { |x, y| x + y } === [x, y]

  -> (x, y){ x + y }.call(x, y)
  -> (x, y){ x + y }[x, y]
  -> (x, y){ x + y }.(x, y)
  -> (x, y){ x + y } === [x, y]
#+end_src

#+RESULTS:
#+begin_results
#+end_results

->がよくラムダ計算表記に使われるのは、λに似てるかららしい。まじか。

procは引数の数が合ってなくてもエラーにならない。
#+begin_src ruby :results output
  l = lambda { |x, y| puts "x: #{x}, y: #{y}" }
  l.call("Ohai", "Gentle Reader")
  p = proc { |x, y| puts "x: #{x}, y: #{y}" }
  p.call("Ohai", "Gentle Reader")
  p.call("Ohai")
#+end_src

#+RESULTS:
#+begin_results
x: Ohai, y: Gentle Reader
x: Ohai, y: Gentle Reader
x: Ohai, y:
#+end_results

lambdaは引数の数が合ってないとエラーになる。
#+begin_src ruby :eval never
  l = lambda { |x, y| puts "x: #{x}, y: #{y}" }
  l.call("Ohai")
#+end_src

#+RESULTS:
#+begin_results
-:3:in `block in main': wrong number of arguments (given 1, expected 2) (ArgumentError)
	from -:4:in `main'
	from -:6:in `<main>'
#+end_results

#+begin_src ruby :eval never
class SomeClass
  def method_that_calls_proc_or_lambda(procy)
    puts "calling #{proc_or_lambda(procy)} now!"
    procy.call
    puts "#{proc_or_lambda(procy)} gets called!"
  end

  def proc_or_lambda(proc_like_thing)
    proc_like_thing.lambda? ? "lambda" : "Proc"
  end
end

c = SomeClass.new
c.method_that_calls_proc_or_lambda lambda { return } # OK
c.method_that_calls_proc_or_lambda proc { return } # gets calledまで到達しない。procはmainコンテキストで作られる。
#+end_src
** Symbol#to_proc
Rubyでは、 ~&~ があるとprocに変換しようとする。
なので↓は。
#+begin_src ruby
["a", "i", "u"].map { |s| s.length }
#+end_src

#+RESULTS:
#+begin_results
[1, 1, 1]
#+end_results

省略記法で書ける。
#+begin_src ruby
["a", "i", "u"].map(&:length)
#+end_src

#+RESULTS:
#+begin_results
[1, 1, 1]
#+end_results

これは引数がProcでないのでエラーになる。
Objectクラスがprocへの変換のやり方を知らないため。
#+begin_src ruby :eval never
  obj = Object.new
  [1, 2, 3].map &obj
#+end_src

↓こうするとエラーにはならない。
#+begin_src ruby
class Object
  def to_proc
    proc {}
  end
end
obj = Object.new
p [1, 2, 3].map &obj # => [nil, nil, nil]
#+end_src

#+begin_src ruby
class Object
  def to_proc
    proc { |x| "Here's #{x}!" }
  end
end
obj = Object.new
p [1, 2, 3].map(&obj) # => ["Here's 1!", "Here's 2!", "Here's 3!"]
#+end_src

汎用化させる。
#+begin_src ruby
  class Symbol
    def to_proc
      proc { |obj| obj.send(self) }
    end
  end
  p ["ai", "iue", "u"].map(&:length)
  # => [2, 3, 1]
  p ["ai", "iue", "u"].map(&:upcase)
  # => ["AI", "IUE", "U"]
#+end_src

#+begin_src ruby :results output
  p [1, 2, 3].inject(0) { |result, element| result + element }
  p [1, 2, 3].inject(&:+)
#+end_src

#+RESULTS:
#+begin_results
6
6
#+end_results

#+begin_src ruby :eval never
  class Symbol
    def to_proc
      lambda { |obj, args| obj.send(self, *args) }
    end
  end
  p [1, 2, 3].inject(&:+)
#+end_src
** カリー化
評価を遅延させること。
#+begin_src ruby
  discriminant = lambda { |a| lambda { |b| lambda { |c| b **2 - 4*a*c } } }
  discriminant.call(5).call(6).call(7)
#+end_src

#+RESULTS:
#+begin_results
-104
#+end_results

同じ意味で、簡潔に書ける。
#+begin_src ruby
  discriminant = lambda { |a, b, c| b**2 - 4*a*c }.curry
  discriminant.call(5).call(6).call(7)
#+end_src

#+RESULTS:
#+begin_results
-104
#+end_results

これが利用できるシチュエーションを考える。
↓は重複がたくさんある。
#+begin_src ruby
  sum_ints = lambda do |start,stop|
    (start..stop).inject{ |sum,x| sum + x }
  end

  sum_of_squares= lambda do |start,stop|
    (start..stop).inject{ |sum,x| sum + x*x }
  end

  sum_of_cubes = lambda do |start,stop|
    (start..stop).inject{ |sum,x| sum + x*x*x}
  end
#+end_src

共通化できる。
#+begin_src ruby :results output
  sum = lambda do |fun, start, stop|
    (start..stop).inject { |sum, x| sum + fun.call(x) }
  end

  p sum_of_ints = sum.(lambda { |x| x }, 1, 10)
  p sum_of_square = sum.(lambda { |x| x*x }, 1, 10)
  p sum_of_cubes = sum.(lambda { |x| x*x*x }, 1, 10)
#+end_src

#+RESULTS:
#+begin_results
55
385
3025
#+end_results

さらにカリー化。

#+begin_src ruby
  sum = lambda do |fun, start, stop|
    (start..stop).inject { |sum, x| sum + fun.call(x) }
  end

  sum_of_squares = sum.curry.(lambda { |x| x*x })
  sum_of_squares.(1).(10)
  sum_of_squares.(50).(100)
#+end_src

#+RESULTS:
#+begin_results
295475
#+end_results
** ex3
#+begin_src ruby
  class Symbol
    def to_proc
      proc { |obj, args| obj.send(self, *args) }
    end
  end
#+end_src

#+begin_src ruby
"aaaa".send(:length)
#+end_src

#+RESULTS:
#+begin_results
4
#+end_results

to_procを初期化に使うことができる。
#+begin_src ruby
  class SpiceGirl
    def initialize(name, nick)
      @name = name
      @nick = nick
    end

    def inspect
      "#{@name} (#{@nick} Spice)"
    end

    def self.to_proc
      proc { |obj| self.new(obj[0], obj[1]) }
    end
  end

  spice_girls = [["tarou", "T"], ["jirou", "J"]]
  p spice_girls.map(&SpiceGirl)
  # => [tarou (T Spice), jirou (J Spice)]
#+end_src

#+begin_src ruby :results output
  p proc {}.class
  p proc {}.lambda?
  p lambda {}.class
  p lambda {}.lambda?
  p -> {}.class
  p lambda {}.lambda?
#+end_src

#+RESULTS:
#+begin_results
Proc
false
Proc
true
Proc
true
#+end_results

lambdaは引数の数が合わないとエラーになる。
#+begin_src ruby
  j1 = proc   { |x,y,z| "#{x}, #{y}, #{z}" }
  j2 = lambda { |x,y,z| "#{x}, #{y}, #{z}" }
  j1.call("hello", "world")
  # j2.call("hello", "world") # argument error
#+end_src

#+RESULTS:
#+begin_results
hello, world,
#+end_results

#+begin_src ruby
  j1 = proc { |x,y,z| x + y + z }
  j2 = lambda { |x,y,z| x + y + z }
  # j1.call(1, 2) # -:3:in `+': nil can't be coerced into Integer (TypeError)
  # j2.call(1, 2) # -:4:in `block in main': wrong number of arguments (given 2, expected 3) (ArgumentError)
#+end_src
** enumerable
- enumerable: 機能を持ったモジュール(ArrayとかHashと同列)。include先のクラスが持つ each メソッドを元に、様々なメソッドを提供する。
- enumerator: 実際にenumerateするオブジェクト。each 以外のメソッドにも Enumerable の機能を提供するためのラッパークラス。外部イテレータとしても使える。
#+begin_src ruby :results output
  p 1.upto(Float::INFINITY) # 評価せずオブジェクトを返す
  p 1.upto(5).to_a # 評価する
  # p 1.upto(Float::INFINITY).to_a # 処理は終わらない
#+end_src

#+RESULTS:
#+begin_results
#<Enumerator: 1:upto(Infinity)>
[1, 2, 3, 4, 5]
#+end_results

#+begin_src ruby :results output
  p 1.upto(Float::INFINITY).lazy.map { |x| x * x }
  p 1.upto(Float::INFINITY).lazy.map { |x| x * x }.take(10)
  p 1.upto(Float::INFINITY).lazy.map { |x| x * x }.take(10).to_a
#+end_src

#+RESULTS:
#+begin_results
#<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator: 1:upto(Infinity)>>:map>
#<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator: 1:upto(Infinity)>>:map>:take(10)>
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
#+end_results
** internal iterationとexternal iteration
internalは、Arrayオブジェクトがiterateをコントロールする。戻れない。
externalは、包んでいる外部のオブジェクトがiterateをコントロールする。状態を持っているので戻ったり止めたりできる。

EnumeratorはEnumerableを包んでいる。
Arrayを入れてみる。
#+begin_src ruby :results output
  p e = Enumerator.new([1, 2, 3])
  p e.next
  p e.next
  p e.next
#+end_src

#+RESULTS:
#+begin_results
#<Enumerator: [1, 2, 3]:each>
1
2
3
#+end_results

#+begin_src ruby
  e = Enumerator.new do |yielder|
    [1, 2, 3].each do |val|
      yielder << val
    end
  end
#+end_src

fiberクラスは内部iteratorを外部iteratorに変換する。

#+begin_src ruby :results output
  f = Fiber.new do
    x = 0
    loop do
      Fiber.yield x
      x += 1
    end
  end

  p f.resume
  p f.resume
  p f.resume
#+end_src

#+RESULTS:
#+begin_results
0
1
2
#+end_results
** EnumerableとEnumerator
#+begin_src ruby
module Enumerable
  def lax
    Lax.new(self)
  end
end

class Lax < Enumerator
  def initialize(receiver)
    super() do |yielder|
      receiver.each do |val|
        yielder << val
      end
    end
  end
end

e = 1.upto(Float::INFINITY).lax
p e.next # 1
p e.next # 2
#+end_src

#+begin_src ruby
  module Enumerable
    def lax
      Lax.new(self)
    end
  end

  class Lax < Enumerator
    def initialize(receiver)
      super() do |yielder|
        receiver.each do |val|
          puts "add: #{val}"
          yielder << val
        end
      end
    end
  end

  lax = Lax.new([1, 2, 3])
  lax.map { |x| puts "map: #{x}; x" }

  # add: 1
  # map: 1; x
  # add: 2
  # map: 2; x
  # add: 3
  # map: 3; x
#+end_src

lazy mapの実装。
#+begin_src ruby
  module Enumerable
    def lax
      Lax.new(self)
    end
  end

  class Lax < Enumerator
    def initialize(receiver)
      super() do |yielder|
        receiver.each do |val|
          if block_given?
            yield(yielder, val)
          else
            yielder << val
          end
        end
      end
    end

    def map(&block)
      Lax.new(self) do |yielder, val|
        yielder << block.call(val)
      end
    end
  end

  p 1.upto(Float::INFINITY).lax.map { |x| x*x }.map { |x| x+1 }.first(5)
  # [2, 5, 10, 17, 26]
#+end_src

lazy takeの実装。
#+begin_src ruby
  def take(n)
    taken = 0
    Lax.new(self) do |yielder, val|
      if taken < n
        yielder << val
        taken += 1
      else
        raise StopIteration
      end
    end
  end
  p 1.upto(Float::INFINITY).lax.take(5).first(5)
  # [1, 2, 3, 4, 5]
#+end_src

まとめ。
#+begin_src ruby
class Lax < Enumerator
  def initialize(receiver)
    super() do |yielder|
      receiver.each do |val|
        if block_given?
          yield(yielder, val)
        else
          yielder << val
        end
      end
    rescue StopIteration
    end
  end

  def map(&block)
    Lax.new(self) do |yielder, val|
      yielder << block.call(val)
    end
  end

  def take(n)
    taken = 0
    Lax.new(self) do |yielder, val|
      if taken < n
        yielder << val
        taken += 1
      else
        raise StopIteration
      end
    end
  end
end

p 1.upto(Float::INFINITY).lax.map { |x| x*x }.map { |x| x+1 }.first(5)
p 1.upto(Float::INFINITY).lax.map { |x| x*x }.map { |x| x+1 }.take(5).to_a # ↑と結果は同じ
#+end_src
** ex4
selectのlazy版。
  #+begin_src ruby
    def select(&block)
      Lax.new(self) do |yielder, val|
        if block.call(val)
          yielder << val
        end
      end
    end

    p 1.upto(Float::INFINITY).lax.take(5).select { |x| x % 2 == 0 }.to_a
    # => [2, 4]
  #+end_src

dropのlazy版。
#+begin_src ruby
  def drop(n)
    dropped = 0
    Lax.new(self) do |yielder, val|
      if dropped < n
        dropped += 1
      else
        yielder << val
      end
    end
  end

  p 1.upto(Float::INFINITY).lax.take(5).drop(3).to_a
  # => [4, 5]
#+end_src

** presense
~present?~ の結果がtrueのときレシーバ自身を返す。falseのときはnilを返す。

#+begin_src ruby
  object.present? ? object : nil
  object.presense
#+end_src

これらは等価である。

- https://apidock.com/rails/Object/presence
** tap
処理に関わらずselfを返す。
メソッドチェーンへのデバッグに便利。

#+begin_src ruby :results output
  p ( 1 .. 5 )
  .tap{|obj| puts obj.class}
  .to_a.tap{|obj| puts obj.class}
#+end_src

#+RESULTS:
#+begin_results
Range
Array
[1, 2, 3, 4, 5]
#+end_results

メソッドチェーンの途中で分岐として使えそう。
** min_by
配列から最大/最小の値を取りたいというとき、min_byが便利。
#+begin_src ruby
  [5, -8, 3, 9].min_by{|num| num.abs }
#+end_src

#+RESULTS:
: 3

order → first と冗長に書いてしまいがち。
** &: 記法
#+begin_src ruby
%w{ a b c }.map(&:capitalize)
#+end_src
- & -> ~to_proc~ trigger
- : -> symbol
** ファイルを作らずにファイルオブジェクトを作ってテストする
ファイル入力のあるプログラムがあるとする。
テストするとき、普通はファイルを作って読み込むことになる。
しかしいちいちファイルを用意するほどではない、みたいな場合もある。
そのときは ~StringIO~ を使うと気軽に試せる。

#+begin_src ruby
  require 'stringio'
  string = <<EOM
    aaa
    "aaa"
  EOM

  file1 = StringIO.new(string)
  file.read # => aaa\n"aaa"
  file2 = StringIO.new('')
  file.read # => ""
#+end_src
としておいて、あとは普通のFIleオブジェクトにするように、 ~StringIO~ オブジェクトに対して各種操作ができる。
* Ruby kaigi 2021
** VSCode extension for ruby type
https://www.slideshare.net/mametter/typeprof-for-ide-enrich-development-experience-without-annotations

- 言語自体を変えなくても、現代的なIDEの恩恵を受けられる。
- 特に静的型付け言語だと引数の型などを表示できる。
- RBS :: ruby official type definition language
- 型レベルに抽象化して情報を解析する。

- https://github.com/usaito Special Thanksに載ってた人。年下だ…。本物の工学の人。
- あまり専門的な内容には触れなかった。
** Why Ruby's JIT was slow
- RubyのJITの状況、高速化。
- 方式の違い。
** RuboCop in 2021: Stable and Beyond
- Rubocopの状況。過去、現在、未来。
- autocorrectが安全な修正をするように設計。
** The Art of Execution Control for Ruby's Debugger
- 歯のメンテナンス
- 新しいデバッガ: ~debug.gem~ Rails7からこれを使うようになるよう
- rubyにおけるデバッガーの状況、ツール作った理由、使い方。
- gem ~rdbg~
- ~info~ コマンド
- 一部分だけトレースできる。
- PostMortem debugging…検死、なぜプログラムが終了したか調べる。
- Record and play debug…戻れる。
** Toycol: Define your own application protocol
- プロトコルの各レイヤーが責任を持つ
- プロトコルをサーバとクライアントが知っているものであれば、なんだって通信。自作プロトコルでも。
- 自作プロトコルの使い方と動作の仕組み
** dRuby in the real-world embedded systems
- CT装置
- 胆石
** Regular Expressions: Amazing and Dangerous
なぜ危険か。
- ~+?~ によって非常に時間がかかる[[id:f054b2d4-c7f9-4bf2-be9c-e29a7f97cb45][Regular Expression]]になる可能性がある。文字列が非常に長い場合、組み合わせ数が爆発的に増えるため。
- サービスがダウンすることもある。Stack Overflow, Cloudflare, Atom...であったインシデントのいくつか...はRubyの[[id:f054b2d4-c7f9-4bf2-be9c-e29a7f97cb45][Regular Expression]]由来のものだった
- gemの中から危険な表現が使われているところを検索する。多くヒットした

対策。
- ~//x~ を使う
- 正規表現のテストを書く。カバレッジは正規表現の中までは見ない…
- 入力の長さを制限する
** Demystifying DSLs for better analysis and understanding
- Domain Specific Language
- [[id:f054b2d4-c7f9-4bf2-be9c-e29a7f97cb45][Regular Expression]], Rakefile, RSpec...
- [[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]] provide many DSL
- Tapioca gem
- generate rbi file from Model
** The Future Shape of Ruby Objects
- Rubyのオブジェクトの実装を見ながら解説。
- オブジェクト指向言語[[id:2a420174-482b-4a3e-868a-3a447572f1be][Smalltalk]]のselfオブジェクト
- classとshape
- [[id:a6980e15-ecee-466e-9ea7-2c0210243c0d][JavaScript]]とかのプロトタイプ言語的アプローチ。
- [[https://github.com/Shopify/truffleruby][Shopify/truffleruby]]
** PRK Firmware: Keyboard is Essentially Ruby
- 自作キーボードを制御するfirmwareをRubyで書く
** The newsletter of RBS updates
- [[https://github.com/ruby/rbs][ruby/rbs]]
- RBS → Rubyで型を定義するためのDSL
- サードパーティgemのRBSコレクションを作成している
- Railsに導入する方法
** Parsing Ruby
- Rubyの記法の変遷。パーサの変遷
- コアに追従することは難しい
- 少しの文法の変更でも大きな影響範囲がある
- 少しの変更も拡張が難しい
** Use Macro all the time ~ マクロを使いまくろ ~
- ASTレベルでRubyコードを置き換える
- パッケージの紹介
** Charty: Statistical data visualization in Ruby
- Rubyでのグラフ描画ツール、charty
- パッケージの紹介
** Dive into Encoding
- Relineのバグ修正で文字コードを深く知るきっかけ
- 文字コードを実装して学ぶ
- Coded Charcter Set
- Character Encoding Scheme
- Conversion table
- Encoding constant
** How to develop the Standard Libraries of Ruby
- 標準ライブラリの作り方
- gemification - 本体添付からgemに切り離す
- [[https://github.com/rubygems/rubygems][rubygems/rubygems]]
** Ruby, Ractor, QUIC
- QUICはGoogleによって開発された高速なプロトコル。
- クラウドゲーミングでは高速性が必要
- TCPとUDPの特性の違い
** 10 years of Ruby-powered citizen science
- [[https://github.com/Safecast/safecastapi][Safecast/safecastapi: The app that powers api.safecast.org]]
- 放射線の観測デバイス
- デバイスが送信する観測データを各クラウドにキャストする
- Dashboardで加工、アクセスできるようにする
- マップ、グラフ、UI/UX、データバリデーション…課題はまだまだある
** Matz Keynote
- Ruby 3.0
- 互換性大事
- 静的型付け言語が流行している。ほかの動的言語にも導入されている。Rubyにはどうか、答えはNo。
- 言語仕様としては型を実装することはない。周辺ツールで行う
- 型,LSP,チェッカ,...ツールを応援する
- パフォーマンスは重要。動機づけになる、問題を解決する
- パフォーマンスは評判に直結する
- マイクロベンチマーク(素数解析とか、単純な計算をもとにパフォーマンスを示す)は現実世界に影響するか → 実際にはしないけど、人々は信用しがちなので重要ではある
- Ruby3x3 :: Ruby3.XはRuby3.0より3倍早い
** Graphical Terminal User Interface of Ruby 3.1
- 沢登り
- irbに補完機能をつける
** Ruby Committers vs the World
- Rubyコミッターの人たちによる座談会
- cool
** countにブロックを渡す
countにブロックを渡して配列の数を調べられる。
↓二行は同じ意味。
#+begin_src ruby
expect(item_type_pool.types.select { |t| t.category == :canon }.length).to be > 10
expect(item_type_pool.types.count { |t| t.category == :canon }).to be > 10
#+end_src

** 継承関係を辿る
#+begin_src ruby
  true.class.ancestors
#+end_src

** オブジェクトのメソッド一覧を見る
#+begin_src ruby
true.public_methods
#+end_src

falseを渡すと祖先のメソッドを表示しない。
#+begin_src ruby
  true.public_methods(false)
  =# => [:===, :^, :inspect, :to_s, :&, :|]
#+end_src
** group_by
~Enumerable#group_by~
ブロックを評価した結果をキー、対応する要素の配列を値とするハッシュを返す。

QueryMethodの ~where~ で取った値をハッシュにして、後で使いまわせる。N+1問題の回避に使える。QueryMethodぽい名前だが無関係。
** index_by
 viewで何かモデルに関することをループさせないといけないときに役立つ。モデルを一度にハッシュとして取ることで、パフォーマンスを改善できる。
** インスタンスメソッドを調査する
 ~String.instance_methods(false).sort~
 ~false~ によってクラスの継承メソッドを表示しないため、クラス単体を調べるのに役立つ。
** トップレベルで実行できる理由
 クラスがなくトップレベルで定義されたメソッドのレシーバーは ~Object~ クラス。クラスの中にないトップレベルメソッドでさまざまなことが行えるのは、 ~Object~ のおかげ。 ~ruby -e 'p Kernel.private_instance_methods.sort'~ でチェックできる。
 - ~puts~ がレシーバーなしで呼び出せるのは、 ~Object~ クラスが ~puts~ のある ~Kernel~ クラスをincludeしているから。
 - ~.to_d~ - BigDecimalに変換する。
 - ~index~ - 配列を検索して添字を返す。
** 何のメソッドがわからないとき
 - [[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]だと ~robe-doc~ がとても便利。すでにあるローカルにあるドキュメントを活用するべき。
** when句
https://stackoverflow.com/questions/3908380/ruby-class-types-and-case-statements/3908411

#+begin_src ruby
case item
when MyClass
...
when Array
...
when String
...
#+end_src
is really

#+begin_src ruby
if MyClass === item
...
elsif Array === item
...
elsif String === item
...
#+end_src

~===~ は内部的に ~is_a?~ を使っている。

#+begin_src ruby
if item.is_a?(MyClass)
...
elsif item.is_a?(Array)
...
elsif item.is_a?(String)
...
#+end_src
をcaseに書き換えるには一番上の書き方でよい。たぶん。
** singletonをクリーンにテストする
singletonをそのまま使うと状況依存のテストになるため、毎回newする必要がある。

https://stackoverflow.com/questions/1909181/how-to-test-a-singleton-class

#+begin_src ruby
def self.instance
  @instance ||= new
end

private_class_method :new
#+end_src

So you can bypass the memoization altogether by calling the private method new using send

#+begin_src ruby
let(:instance) { GlobalClass.send(:new) }
#+end_src
A nice benefit of this way is that no global state is modified as a result of your tests running.

Probably a better way, from this answer:

#+begin_src ruby
let(:instance) { Class.new(GlobalClass).instance }
#+end_src
** 評価結果アノテーションを付与するxmpfilter
便利ツールを集めた https://github.com/rcodetools/rcodetools というgemがある。
そのなかにインラインで実行した結果を表示するスクリプトがある。
[[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]用のコードもある。https://github.com/rcodetools/rcodetools/blob/master/misc/rcodetools.el rubykitch氏作成。
#+begin_src ruby
1.to_s # => "1"
#+end_src
というように、irbのように挿入してくれる。とても便利。
* Source code
コードで気になったところのメモ。
** attr_accessor
- https://github.com/kd-collective/ruby/blob/f5829e293583aa6ba6a1f1314ee22881d58a5f96/object.c#L2204
* Tasks
** TODO [[https://danieljamescolson.com/blog/meta-factory][Metaprogramming All The Way Down]]
FactoryBotの詳細な説明。
** TODO [[https://docs.ruby-lang.org/ja/latest/method/Enumerable/i/inject.html][Enumerable#inject (Ruby 3.0.0 リファレンスマニュアル)]]
使えるようにしておく。まとめる。
** TODO [[http://ruby-operators.herokuapp.com/rose_memoization][Ruby Operators]]
Rubyの特殊な演算子の名前と説明。
** TODO [[https://techracho.bpsinc.jp/hachi8833/2020_11_06/59639][Ruby: eachよりもmapなどのコレクションを積極的に使おう（社内勉強会）｜TechRacho by BPS株式会社]]
** TODO rubocop issue(allow multiline)
:LOGBOOK:
CLOCK: [2021-09-16 Thu 23:04]--[2021-09-16 Thu 23:29] =>  0:25
:END:
https://github.com/rubocop/rubocop/issues/9365
どうにかなりそうではある。コメントルールをマルチラインに対応させる。

#+begin_src ruby
  # これは検知される
  foo(
    # aaaa

    22
  )

  # これはセーフ。これで間に合うように感じる。
  foo(
    # bbbb
    22
  )
#+end_src

コメントのあとは空白行を無視したいらしいが、あまり意味を感じない。実装はできるが、目的があまりよくないように思える。
** TODO rubocop issue(yoda expression)
:LOGBOOK:
CLOCK: [2021-09-14 Tue 23:00]--[2021-09-14 Tue 23:25] =>  0:25
CLOCK: [2021-09-14 Tue 00:10]--[2021-09-14 Tue 00:35] =>  0:25
CLOCK: [2021-09-13 Mon 22:57]--[2021-09-13 Mon 23:22] =>  0:25
CLOCK: [2021-09-13 Mon 22:26]--[2021-09-13 Mon 22:51] =>  0:25
CLOCK: [2021-09-13 Mon 21:42]--[2021-09-13 Mon 22:07] =>  0:25
:END:
https://github.com/rubocop/rubocop/issues/9222
New cop for yoda expressions.

TSLintにすでにあるので、実装の参考にすればいい。
[[https://palantir.github.io/tslint/rules/binary-expression-operand-order/][Rule: binary-expression-operand-order]]

- 二項演算子(Binary Operator) :: 式を書いたときに、被演算子（変数とか値）が2つ登場する演算子

#+begin_src ruby
  def on_send(node)
    method = node.method_name
    lhs = node.receiver
    rhs = node.first_argument

    # a.+(b)
    # a -> lhs
    # + -> method
    # b -> rhs
  end
#+end_src

conditionの方と合体させてもよさそう。TSLintはそうしてる。共通しているところは多い。
全く別のcopにする方針で一応書けたが、本質的にcondition operatorとやってることは同じだ。

方式が違うので難しいな。
明らかにTSLintのやり方が簡潔に書かれているように見える。rubocopの方はゴテゴテと条件が多い。単に対応オペレータを増やすだけだが、よくわからない。conditionを前提に書かれているところも難しい。

ちょっとやってどうにかなるものでなさそう。追加されないのには、理由があった。
まず既存のがごちゃついてるので、それを整理する必要がある。
** TODO Practical Ruby Project
:LOGBOOK:
CLOCK: [2022-01-20 Thu 08:20]--[2022-01-20 Thu 08:45] =>  0:25
CLOCK: [2022-01-19 Wed 23:38]--[2022-01-20 Thu 00:03] =>  0:25
CLOCK: [2022-01-19 Wed 10:22]--[2022-01-19 Wed 10:47] =>  0:25
CLOCK: [2022-01-19 Wed 09:40]--[2022-01-19 Wed 10:05] =>  0:25
CLOCK: [2022-01-18 Tue 00:54]--[2022-01-18 Tue 01:19] =>  0:25
CLOCK: [2022-01-17 Mon 23:15]--[2022-01-17 Mon 23:40] =>  0:25
CLOCK: [2022-01-17 Mon 22:44]--[2022-01-17 Mon 23:09] =>  0:25
CLOCK: [2022-01-17 Mon 22:16]--[2022-01-17 Mon 22:41] =>  0:25
CLOCK: [2022-01-17 Mon 09:54]--[2022-01-17 Mon 10:19] =>  0:25
CLOCK: [2022-01-17 Mon 09:21]--[2022-01-17 Mon 09:46] =>  0:25
CLOCK: [2022-01-16 Sun 23:31]--[2022-01-16 Sun 23:56] =>  0:25
CLOCK: [2022-01-16 Sun 22:10]--[2022-01-16 Sun 22:35] =>  0:25
CLOCK: [2022-01-16 Sun 17:13]--[2022-01-16 Sun 17:38] =>  0:25
CLOCK: [2022-01-16 Sun 12:11]--[2022-01-16 Sun 12:36] =>  0:25
CLOCK: [2022-01-16 Sun 11:23]--[2022-01-16 Sun 11:48] =>  0:25
CLOCK: [2022-01-15 Sat 23:56]--[2022-01-16 Sun 00:21] =>  0:25
CLOCK: [2022-01-15 Sat 22:25]--[2022-01-15 Sat 22:50] =>  0:25
CLOCK: [2022-01-15 Sat 21:37]--[2022-01-15 Sat 22:02] =>  0:25
CLOCK: [2021-10-15 Fri 09:59]--[2021-10-15 Fri 10:42] =>  0:43
:END:
- 254, 265, 272, 283

Rubyでのちょっと変わった、面白いプロジェクトを紹介している。
- 経済ゲームを作る
- Lispを実装
- パーサを実装
** TODO [[https://magazine.rubyist.net/articles/0061/0061-ForeWord.html][0061号 コンピュータサイエンスが気になるプログラマに勧める書籍リスト]]
** TODO [[https://i.loveruby.net/ja/rhg/book/][Rubyソースコード完全解説]]
** TODO Refactoring Ruby Edition
* Archives
** DONE The well-grounded rubyist [100%]
CLOSED: [2021-09-27 Mon 23:48] DEADLINE: <2021-09-30 Thu>
*** DONE 420
CLOSED: [2021-09-23 Thu 14:49]
:LOGBOOK:
CLOCK: [2021-09-23 Thu 14:05]--[2021-09-23 Thu 14:34] =>  0:29
:END:
*** DONE 430
CLOSED: [2021-09-23 Thu 22:38] DEADLINE: <2021-09-23 Thu>
:LOGBOOK:
CLOCK: [2021-09-23 Thu 15:23]--[2021-09-23 Thu 16:24] =>  1:01
:END:
*** DONE 440
CLOSED: [2021-09-23 Thu 23:59] DEADLINE: <2021-09-23 Thu>
:LOGBOOK:
CLOCK: [2021-09-23 Thu 22:38]--[2021-09-23 Thu 23:59] =>  1:21
:END:
*** DONE 450
CLOSED: [2021-09-24 Fri 10:28]
:LOGBOOK:
CLOCK: [2021-09-24 Fri 09:04]--[2021-09-24 Fri 10:27] =>  1:23
:END:
<2021-09-24 Fri>
*** DONE 460
CLOSED: [2021-09-25 Sat 12:30]
:LOGBOOK:
CLOCK: [2021-09-25 Sat 11:19]--[2021-09-25 Sat 12:30] =>  1:11
:END:
<2021-09-25 Sat>
*** DONE 470
CLOSED: [2021-09-26 Sun 01:20]
:LOGBOOK:
CLOCK: [2021-09-26 Sun 00:28]--[2021-09-26 Sun 01:20] =>  0:52
CLOCK: [2021-09-25 Sat 23:26]--[2021-09-26 Sun 00:15] =>  0:49
:END:
<2021-09-25 Sat>
*** DONE 480
CLOSED: [2021-09-26 Sun 20:30]
:LOGBOOK:
CLOCK: [2021-09-26 Sun 19:14]--[2021-09-26 Sun 20:30] =>  1:16
CLOCK: [2021-09-26 Sun 16:06]--[2021-09-26 Sun 16:24] =>  0:18
:END:
<2021-09-26 Sun>
*** DONE 490
CLOSED: [2021-09-27 Mon 23:44]
:LOGBOOK:
CLOCK: [2021-09-27 Mon 22:05]--[2021-09-27 Mon 23:41] =>  1:36
:END:
<2021-09-27 Mon>
** CLOSE 見てみるgemを選ぶ
CLOSED: [2021-09-27 Mon 23:49]
まず探すのが大変なので、読んでみるgemを選ぶ。
手軽にできるのが良い。

曖昧なタスクなのでcloseする。
** DONE Rubyの公式リファレンスが読めるようになる本
CLOSED: [2021-10-02 Sat 22:51]
:LOGBOOK:
CLOCK: [2021-10-02 Sat 22:01]--[2021-10-02 Sat 22:51] =>  0:50
:END:
- https://zenn.dev/jnchito/books/how-to-read-ruby-reference
** CLOSE おみくじ作り
CLOSED: [2022-01-22 Sat 13:12]
:LOGBOOK:
CLOCK: [2022-01-22 Sat 12:03]--[2022-01-22 Sat 12:28] =>  0:25
CLOCK: [2022-01-22 Sat 11:14]--[2022-01-22 Sat 11:39] =>  0:25
CLOCK: [2022-01-21 Fri 10:14]--[2022-01-21 Fri 10:39] =>  0:25
CLOCK: [2022-01-21 Fri 09:43]--[2022-01-21 Fri 10:08] =>  0:25
CLOCK: [2022-01-20 Thu 21:52]--[2022-01-20 Thu 22:17] =>  0:25
CLOCK: [2022-01-20 Thu 09:27]--[2022-01-20 Thu 09:52] =>  0:25
:END:
Ruby上で[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]を実装しておみくじを作ってみる。

funcallを実装しようとして詰まる。単純な例だとできるようになったが、ネストしたときにうまく動いてない。
テストをちゃんと書くことと、デバッグ方法をちゃんとしないと厳しい。

1週間でできそうということではじめたが、時間がかかるので後回し。
言語実装に取り組むのはもっとも抽象的で難しい。だが無限の可能性を持っていてめちゃくちゃ楽しい。
最も難しいことをしたおかげで、ほかのことに自信をもって取り組みやすくなったように思える。ほとんどのことは言語を実装することに比べれば、簡単だ。
** DONE 誤字修正
CLOSED: [2022-01-30 Sun 10:50]
るりまの誤字を発見した。いくつか発見してまとめてPRを送ろう。

- 同じにように(Proc)
** DONE [[https://softantenna.com/blog/gem-codesearch/][gem-codesearch – rubygemsをフルテキストサーチすることができる豪快なソフト | ソフトアンテナ]]
CLOSED: [2022-02-12 Sat 13:56]
面白そう。
* References
** [[https://rurema.clear-code.com/3.0.0/doc/glossary.html][Ruby用語集 (Ruby 3.0.0)]]
おもしろい。
** [[http://franzejr.github.io/best-ruby/][Introduction | Ruby Tricks, Idiomatic Ruby, Refactorings and Best Practices]]
Rubyのベストプラクティス集。
** [[https://practicingruby.com/articles/building-enumerable-and-enumerator][Building Enumerable & Enumerator in Ruby]]
Enumerableの詳しい解説。
** [[https://blog.freedom-man.com/try-rubygem-codereading][RubyGemコードリーディングのすすめ]]
** [[http://www.aoky.net/articles/why_poignant_guide_to_ruby/index.html][ホワイの(感動的)Rubyガイド]]
ちょっと変わったRuby入門。
** [[https://docs.ruby-lang.org/ja/][プログラミング言語 Ruby リファレンスマニュアル]]
rubyのドキュメント。
** [[https://rubular.com/][Rubular: a Ruby regular expression editor]]
Rubyの正規表現チェッカ。
