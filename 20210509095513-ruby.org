:PROPERTIES:
:ID:       cfd092c4-1bb2-43d3-88b1-9f647809e546
:END:
#+title: Ruby
#+filetags: Programming Language
* 概要
Rubyはオブジェクト指向のプログラミング言語である。
Webフレームワークの[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]が有名で、採用されるケースはRailsを使うためが多い。
* Memo
countにブロックを渡して配列の数を調べられる。
↓二行は同じ意味。
#+begin_src ruby
expect(item_type_pool.types.select { |t| t.category == :canon }.length).to be > 10
expect(item_type_pool.types.count { |t| t.category == :canon }).to be > 10
#+end_src
** 継承関係を辿る
#+begin_src ruby
  true.class.ancestors
#+end_src

** オブジェクトのメソッド一覧を見る
#+begin_src ruby
true.public_methods
#+end_src

falseを渡すと祖先のメソッドを表示しない。
#+begin_src ruby
  true.public_methods(false)
  =# => [:===, :^, :inspect, :to_s, :&, :|]
#+end_src
** group_by
~Enumerable#group_by~
ブロックを評価した結果をキー、対応する要素の配列を値とするハッシュを返す。

QueryMethodの ~where~ で取った値をハッシュにして、後で使いまわせる。N+1問題の回避に使える。QueryMethodぽい名前だが無関係。
** index_by
 viewで何かモデルに関することをループさせないといけないときに役立つ。モデルを一度にハッシュとして取ることで、パフォーマンスを改善できる。
** インスタンスメソッドを調査する
 ~String.instance_methods(false).sort~
 ~false~ によってクラスの継承メソッドを表示しないため、クラス単体を調べるのに役立つ。
** トップレベルで実行できる理由
 クラスがなくトップレベルで定義されたメソッドのレシーバーは ~Object~ クラス。クラスの中にないトップレベルメソッドでさまざまなことが行えるのは、 ~Object~ のおかげ。 ~ruby -e 'p Kernel.private_instance_methods.sort'~ でチェックできる。
 - ~puts~ がレシーバーなしで呼び出せるのは、 ~Object~ クラスが ~puts~ のある ~Kernel~ クラスをincludeしているから。
 - ~.to_d~ - BigDecimalに変換する。
 - ~index~ - 配列を検索して添字を返す。
** 何のメソッドがわからないとき
 - [[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]だと ~robe-doc~ がとても便利。すでにあるローカルにあるドキュメントを活用するべき。
** when句
https://stackoverflow.com/questions/3908380/ruby-class-types-and-case-statements/3908411

#+begin_src ruby
case item
when MyClass
...
when Array
...
when String
...
#+end_src
is really

#+begin_src ruby
if MyClass === item
...
elsif Array === item
...
elsif String === item
...
#+end_src

~===~ は内部的に ~is_a?~ を使っている。

#+begin_src ruby
if item.is_a?(MyClass)
...
elsif item.is_a?(Array)
...
elsif item.is_a?(String)
...
#+end_src
をcaseに書き換えるには一番上の書き方でよい。たぶん。
** singletonをクリーンにテストする
singletonをそのまま使うと状況依存のテストになるため、毎回newする必要がある。

https://stackoverflow.com/questions/1909181/how-to-test-a-singleton-class

#+begin_src ruby
def self.instance
  @instance ||= new
end

private_class_method :new
#+end_src

So you can bypass the memoization altogether by calling the private method new using send

#+begin_src ruby
let(:instance) { GlobalClass.send(:new) }
#+end_src
A nice benefit of this way is that no global state is modified as a result of your tests running.

Probably a better way, from this answer:

#+begin_src ruby
let(:instance) { Class.new(GlobalClass).instance }
#+end_src
** xmp
便利ツールを集めた https://github.com/rcodetools/rcodetools というgemがある。
そのなかにインラインで実行した結果を表示するスクリプトがある。
[[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]用のコードもある。https://github.com/rcodetools/rcodetools/blob/master/misc/rcodetools.el rubykitch氏作成。
#+begin_src ruby
1.to_s # => "1"
#+end_src
というように、irbのように挿入してくれる。とても便利。
* Tasks
** TODO Practical Ruby Project
Rubyでの面白いプロジェクトを紹介している。
- Lispを実装。
- 経済ゲームを作る。
** TODO Rubyの公式リファレンスが読めるようになる本
https://zenn.dev/jnchito/books/how-to-read-ruby-reference
