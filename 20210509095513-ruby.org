#+title: Ruby

* 単発メモ
** 継承関係を辿る
#+begin_src ruby
  true.class.ancestors
#+end_src

** オブジェクトのメソッド一覧を見る
#+begin_src ruby
true.public_methods
#+end_src

falseを渡すと祖先のメソッドを表示しない。
#+begin_src ruby
  true.public_methods(false)
  =# => [:===, :^, :inspect, :to_s, :&, :|]
#+end_src
** `group_by`
 `Enumerable#group_by`
 >ブロックを評価した結果をキー、対応する要素の配列を値とするハッシュを返します。
 QueryMethodの`where`で取った値をハッシュにして、後で使いまわせます。N+1問題の回避に使えます。QueryMethodぽい名前ですが無関係です。
** `index_by`
 viewで何かモデルに関することをループさせないといけないときに役立ちます。モデルを一度にハッシュとして取ることで、パフォーマンスを改善できます。
** インスタンスメソッドを調査する
 `String.instance_methods(false).sort`
 `false`によってクラスの継承メソッドを表示しないため、クラス単体を調べるのに役立ちます。
** トップレベルで実行できる理由
 クラスがなくトップレベルで定義されたメソッドのレシーバーは`Object`クラスです。クラスの中にないトップレベルメソッドでさまざまなことが行えるのは、`Object`のおかげです。`ruby -e 'p Kernel.private_instance_methods.sort'`でチェックできます。
 - `puts` がレシーバーなしで呼び出せるのは、`Object`クラスがputsのある`Kernel`クラスをincludeしているからです。
 - `.to_d` - BigDecimalに変換する。
 - `index` - 配列を検索して添字を返す。
** 何のメソッドがわからないとき
 - Emacsだと`robe-doc`を使うと非常に便利です。すでにあるローカルにあるドキュメントを活用しましょう。
** when句
https://stackoverflow.com/questions/3908380/ruby-class-types-and-case-statements/3908411

#+begin_src ruby
case item
when MyClass
...
when Array
...
when String
...
#+end_src
is really

#+begin_src ruby
if MyClass === item
...
elsif Array === item
...
elsif String === item
...
#+end_src

~===~ は内部的に ~is_a?~ を使っている。

#+begin_src ruby
if item.is_a?(MyClass)
...
elsif item.is_a?(Array)
...
elsif item.is_a?(String)
...
#+end_src
をcaseに書き換えるには一番上の書き方でよい。たぶん。
** singletonをクリーンにテストする
singletonをそのまま使うと状況依存のテストになるため、毎回newする必要がある。

https://stackoverflow.com/questions/1909181/how-to-test-a-singleton-class

#+begin_src ruby
def self.instance
  @instance ||= new
end

private_class_method :new
#+end_src

So you can bypass the memoization altogether by calling the private method new using send

#+begin_src ruby
let(:instance) { GlobalClass.send(:new) }
#+end_src
A nice benefit of this way is that no global state is modified as a result of your tests running.

Probably a better way, from this answer:

#+begin_src ruby
let(:instance) { Class.new(GlobalClass).instance }
#+end_src
