<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-11-08 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rust</title>
<meta name="author" content="root" />
<meta name="generator" content="Org Mode" />
<link rel='shortcut icon' type='image/x-icon' href='/roam/favicon.ico' /><link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css' /><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css' /><link rel='stylesheet' href='../css/site.css' /><link rel='stylesheet' href='../roam/css/code.css' /><link rel='stylesheet' href='css/site.css' /><link rel='stylesheet' href='css/code.css' />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content" class="content">
<h1 class="title">Rust</h1>
<div id="outline-container-org2720cb1" class="outline-2">
<h2 id="org2720cb1"><a href="#org2720cb1">概要</a></h2>
<div class="outline-text-2" id="text-org2720cb1">
<p>
RustはC言語、C++の置換を目指した<a href="20210509101246-programming_language.html#ID-868ac56a-2d42-48d7-ab7f-7047c85a8f39">Programming Language</a>。
</p>

<ul class="org-ul">
<li>性能</li>
<li>メモリ安全性</li>
<li>安全な並行性</li>
</ul>

<p>
を特徴とする。
</p>

<p>
<a href="20210901100517-zig.html#ID-4270d99a-d2b5-429e-b33c-c2e097b20730">Zig</a>と方向性が同じ。
</p>
</div>
</div>
<div id="outline-container-orgfd9a92d" class="outline-2">
<h2 id="orgfd9a92d"><a href="#orgfd9a92d">Memo</a></h2>
<div class="outline-text-2" id="text-orgfd9a92d">
</div>
<div id="outline-container-org59ea531" class="outline-3">
<h3 id="org59ea531"><a href="#org59ea531">book-summaryのエラー</a></h3>
<div class="outline-text-3" id="text-org59ea531">
<ul class="org-ul">
<li><a href="https://github.com/kd-collective/book-summary/blob/db03f5c7e95ee8ebad5d446e7ed1ddc2a0d49561/src/main.rs#L222">https://github.com/kd-collective/book-summary/blob/db03f5c7e95ee8ebad5d446e7ed1ddc2a0d49561/src/main.rs#L222</a></li>
<li>book-summaryを実行したときにエラーになる</li>
<li>配列のインデックスがないといっている</li>
<li>tomlが含まれているところで実行するとだめっぽい</li>
<li>該当箇所的にもそう</li>
<li>設定にtitleがないとエラーになる
<ul class="org-ul">
<li>だが、titleがなくてもbuildはできる</li>
<li>メインツールでオプショナルなのに依存するのはおかしいし、不親切なのでせめてメッセージを出すようにしたい</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org5d1de42" class="outline-3">
<h3 id="org5d1de42"><a href="#org5d1de42">ビルドエラー <code>failed to run custom build command for `proc-macro2 v1.0.42`</code></a></h3>
<div class="outline-text-3" id="text-org5d1de42">
<p>
新しいマシンにしたとき発生した。原因不明。ライブラリ名は若干変わるときがある。共通しているのはcustom build commandということ。手元のビルドだけでなく、cargo installも失敗する。
</p>

<p>
さっぱりわからない。検索しても似たような現象の人は出ない。開発用のライブラリを入れたら直ったという記事もあったが、すでに入っている。
</p>

<ul class="org-ul">
<li>バージョンを下げてもだめだった</li>
<li>curlで入れる方法をやり直してもだめだった</li>
<li>aptで入れ直してもだめだった</li>
</ul>
</div>
</div>

<div id="outline-container-org98c1bd6" class="outline-3">
<h3 id="org98c1bd6"><a href="#org98c1bd6">cloneとcopyの違い</a></h3>
<div class="outline-text-3" id="text-org98c1bd6">
<ul class="org-ul">
<li><a href="https://teratail.com/questions/253918">RustのCloneとCopyについての素朴な疑問</a>の回答からコピペ</li>
</ul>

<blockquote>
<p>
まず明確にしておかなけばならないのは、Copyトレイトを実装した型で行われる値のコピーと、Cloneトレイトを実装した型で行われる値のclone()は多くの場合は異なる操作だということです。
</p>

<p>
前者はメモリ上のバイト列を単純にコピーする操作で、Cのmemcpyに相当します。このような操作は一般的にはshallow copy（浅いコピー）と呼ばれます。
</p>

<p>
後者はその型に実装されたclone()メソッドを呼び出す操作です。どういうことをするかはclone()メソッドの実装に依存しますが、多くの場合はmemcpyよりも複雑なdeep copy（深いコピー）を行います。
</p>

<p>
たとえばString型は文字列データをVec&lt;u8&gt;型で持ちます。Vec&lt;T&gt;型はT型の各要素を格納するメモリ領域と、3つの要素を持つ構造体で表現されています。その構造体の要素は、前述のメモリ領域を指すポインタ、Vec&lt;T&gt;の容量（capacity）、Vec&lt;T&gt;の長さになっています。
</p>

<p>
仮にStringがCopyトレイトを実装できたとすると、shallow copyによってコピーされるのはVec&lt;u8&gt;の構造体の部分だけになります。u8型の各要素を格納するメモリ領域はコピーされず、また構造体の中にあるポインタも（memcpy相当なので）みな同じアドレスを指します。つまり、コピーによって作られた複数のStringが、同じu8型の要素を共有することになります。
</p>

<p>
Copyトレイトはmemcpy相当の操作だけで完全にコピーできる型にしか実装できないようになっています。たとえばu8型の値はmemcpyでコピーすれば十分（他にコピーするものがない）なのでCopyトレイトが実装されています。一方、Vec&lt;T&gt;はmemcpyでは不十分（shallow copyになる）なのでCopyトレイトを実装できません。
</p>

<p>
一方、Vec&lt;T&gt;のclone()メソッドはdeep copyを行うように実装されています。各要素を格納するメモリ領域が新たに割り当てられ、構造体の値も新たに作られます。また個々の要素も、そのclone()メソッドを呼ぶことでコピーされます。つまり、clone()によって作られた複数のStringは、それぞれが異なるメモリ領域にあるu8型の要素を持つことになります。
</p>

<p>
さて本題のRustの配列型の初期化構文[s; 2]では、なぜsのところにCopyトレイトを実装した型しか受け付けないかですが、その理由はドキュメントに書かれてないので、あくまでも私の推測を元に説明します。
</p>

<p>
Rustの配列はあらかじめ言語に組み込まれている型（プリミティブ型）です。また、初期化の構文[s; 2]も言語に組み込まれています。そのような構文からは、clone()のようにRustコードで実装されたメソッドを呼び出すことができないのかもしれません。メソッドは呼べないので、型の実装に依存しないmemcpy相当のコピーを行うのではないでしょうか。memcpy相当の操作で完全にコピーできることを保証するには、sがCopyトレイトを実装していなければなりません。
</p>

<p>
Vec&lt;T&gt;には配列の初期化にそっくりのvec![s; 2]の構文があります。Vec&lt;T&gt;はプリミティブ型ではなく、Rustコードで実装されたユーザー定義型です。またvec![s; 2]はマクロで実装されており、これもコンパイル時にRustコードに変換されます。そのためだと思いますが、vec![s; 2]ではsがCopyを実装している必要はなく、Cloneを実装していれば初期化できます。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org565bedc" class="outline-3">
<h3 id="org565bedc"><a href="#org565bedc">マクロの例</a></h3>
<div class="outline-text-3" id="text-org565bedc">
<p>
マクロの例。identはidentityの略。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>lintを定義するマクロ</label><pre class="src src-git-permalink">https://github.com/kd-collective/rust/blob/a3beeaa84da241f35888338ded6659938206ff13/src/librustdoc/lint.rs#L66-L83
</pre>
</div>

<div class="results" id="orgb73ebc3">
<p>
macro_rules! declare_rustdoc_lint {
    ($(#[$attr:meta])* $name: ident, $level: ident, $descr: literal $(,)?) =&gt; {
        declare_tool_lint! {
            $(#[$attr])* pub rustdoc::$name, $level, $descr
        }
    }
}
</p>

<p>
declare_rustdoc_lint! {
    <i>/</i> The `broken_intra_doc_links` lint detects failures in resolving
    <i>/</i> intra-doc link targets. This is a `rustdoc` only lint, see the
    <i>/</i> documentation in the [rustdoc book].
    <i>/</i>
    <i>/</i> [rustdoc book]: ../../../rustdoc/lints.html#broken_intra_doc_links
    BROKEN_INTRA_DOC_LINKS,
    Warn,
    &ldquo;failures in resolving intra-doc link targets&rdquo;
}
</p>

</div>

<p>
printlnマクロの定義。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>println</label><pre class="src src-git-permalink">https://github.com/kd-collective/rust/blob/a3beeaa84da241f35888338ded6659938206ff13/library/std/src/macros.rs#L101-L108
</pre>
</div>

<div class="results" id="org564c952">
<p>
macro_rules! println {
    () =&gt; {
        \(crate::print!("\n")
    };
    (\)($arg:tt)*) =&gt; {{
        $crate::io::_print(\(crate::format_args_nl!(\)($arg)*));
    }};
}
</p>

</div>
</div>
</div>

<div id="outline-container-orgc7346ef" class="outline-3">
<h3 id="orgc7346ef"><a href="#orgc7346ef">ライフタイムの概要</a></h3>
<div class="outline-text-3" id="text-orgc7346ef">
<ul class="org-ul">
<li><a href="https://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html">ライフタイムで参照を検証する - The Rust Programming Language 日本語版</a></li>
</ul>

<p>
Rustにおいて参照はすべてライフタイムを保持する。ライフタイムは、その参照が有効になるスコープ。ライフタイムも暗黙的に推論される。複数の型の可能性があるときには、型を注釈しなければならない。
</p>

<p>
ライフタイムの主な目的は、ダングリング参照…参照するつもりだったデータ以外のデータを参照してしまうこと…を回避すること。コンパイラは借用チェッカーによってチェックしてエラーを出す。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>値がスコープを抜けてしまった参照を使用しようとする</label><pre class="src src-rust">fn main() {
  {
    let r;

    {
      let x = 5;
      r = &amp;x;
    }

    println!("r: {}", r);
  }
}
</pre>
</div>

<pre class="example">
error[E0597]: `x` does not live long enough
  --&gt; /tmp/babel-Mwh0df/rust-H3aWMg:8:11
   |
8  |       r = &amp;x;
   |           ^^ borrowed value does not live long enough
9  |     }
   |     - `x` dropped here while still borrowed
10 |
11 |     println!("r: {}", r);
   |                       - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
</pre>

<p>
関数のジェネリックなライフタイム。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>2つの文字列スライスのうち長い方を返す関数。が、ライフタイムに言及するエラーでコンパイルできない</label><pre class="src src-rust">// 引数は参照である。longest関数に引数の所有権を奪ってほしくないから
fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
</pre>
</div>

<pre class="example">
error[E0106]: missing lifetime specifier
 --&gt; /tmp/babel-Mwh0df/rust-eT95tY:2:33
  |
2 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
2 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
</pre>

<p>
↑戻り値の型はジェネリックなライフタイム引数である引数であるといっている。返している参照が <code>x</code> か <code>y</code> のどちらを参照しているか、コンパイラにはわからないから。ifブロックは <code>x</code> への参照を返し、elseブロックは <code>y</code> への参照を返すので、どちらかわからない。
</p>

<p>
エラーを修正するためには、借用チェッカーが解析できるように、参照間の関係を定義するジェネリックなライフタイム引数を追加する。ライフタイム注釈は、参照の生存期間を変えることはない。ライフタイム注釈は、ライフタイムに影響することなく、複数の参照のライフタイムのお互いの関係を記述する。
</p>

<p>
ライフタイム引数の名前はアポストロフィーで始まらなければならず、通常全て小文字で、ジェネリック型のように短い。慣例的に <code>'a</code> という名前を使う。
</p>

<div class="org-src-container">
<pre class="src src-rust">&amp;i32 // ただの参照
&amp;'a i32 // 明示的なライフタイム付きの参照
&amp;'a mut i32 // 明示的なライフタイム付きの可変参照
</pre>
</div>

<p>
ライフタイム注釈をつける。
</p>
<ul class="org-ul">
<li>何らかのライフタイム&rsquo;aに対して、関数は2つの引数を取り、どちらも少なくともライフタイム&rsquo;aと同じだけ生きる文字列スライスであるとコンパイラに教えるようになった</li>
<li>返る文字列スライスもライフタイム&rsquo;aと同じだけ生きると、コンパイラに教えている。実際にはlongest関数が返す参照のライフタイムは、渡された参照のうち、小さいほうのライフタイムと同じということになる</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>ライフタイム注釈を引数、返り値につける</label><pre class="src src-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
main();
</pre>
</div>

<div class="results" id="org55305ca">
<p>
The longest string is abcd
()
</p>

</div>

<ul class="org-ul">
<li>ライフタイム引数を指定するとき、いかなる値のライフタイムも変更していない。longest関数は、 <code>x</code> と <code>y</code> の正確な生存期間を知っている必要はなく、このシグニチャを満たすようなスコープを&rsquo;aに代入できることを知っているだけ</li>
<li>関数にライフタイムを注釈するときは、注釈は関数の本体ではなくシグニチャに付与する
<ul class="org-ul">
<li>コンパイラは注釈がなくとも関数内のコードを解析できる。が、関数に関数外からの参照や関数外への参照がある場合、コンパイラが引数や戻り値のライフタイムも自力で解決することはほとんど不可能になる。</li>
<li>そのライフタイムは関数が呼び出されるたびに異なる可能性があるので、手動でライフタイムを注釈する必要がある</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org05a38f0" class="outline-3">
<h3 id="org05a38f0"><a href="#org05a38f0">トレイトの概要</a></h3>
<div class="outline-text-3" id="text-org05a38f0">
<p>
<a href="https://doc.rust-jp.rs/book-ja/ch10-02-traits.html">トレイト：共通の振る舞いを定義する - The Rust Programming Language 日本語版</a>
</p>

<p>
トレイトを使用すると、あるジェネリックが、特定の振る舞いをもつあらゆる型になり得ることを指定できる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>メソッドシグニチャのあとに、セミコロンを使用している。このトレイトに実装する型はそれぞれ、メソッドの本体に独自の振る舞いを提供しなければならない</label><pre class="src src-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</pre>
</div>

<p>
トレイトを型に実装する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>同じメソッド名summarizeで型によって振る舞いが異なる</label><pre class="src src-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

// impl トレイト for 構造体
impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}

fn main() {
    let article = NewsArticle {
        headline: String::from("Big news!"),
        location: String::from("Tokyo"),
        author: String::from("Me"),
        content: String::from("Birthday"),
    };

    println!("1 new news: {}", article.summarize());

    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
main()
</pre>
</div>

<div class="results" id="org6e02229">
<p>
1 new news: Big news!, by Me (Tokyo)
1 new tweet: horse_ebooks: of course, as you probably already know, people
()
</p>

</div>

<p>
制約: 外部のトレイトを外部の型に対して実装できない。コヒーレンス、孤児のルールと呼ばれる特性の一部。この制約によって、他の人のコードが自分のコードを壊したり、その逆が起きないことを保証する。
</p>

<p>
デフォルト実装。各メソッドのデフォルト実装があると、すべての型に対して実装を要求しないので便利。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>Summaryトレイトのsummarizeメソッドにデフォルト実装を指定する</label><pre class="src src-rust">pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")
    }
}

impl Summary for NewsArticle { }

fn main() {
    let article = NewsArticle {
        headline: String::from("Big news!"),
        location: String::from("Tokyo"),
        author: String::from("Me"),
        content: String::from("Birthday"),
    };
    println!("New article available! {}", article.summarize());
}
main()
</pre>
</div>

<div class="results" id="org60639d3">
<p>
New article available! (Read more&#x2026;)
()
</p>

</div>

<p>
デフォルト実装は、自らのトレイトのデフォルト実装を持たない他のメソッドを呼び出すことができる。↑の場合は実装メソッドがないため、デフォルト実装が使われた。
</p>

<p>
一部だけデフォルト実装にする例。
</p>

<div class="org-src-container">
<pre class="src src-rust">pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("Read more from {}...", self.summarize_author())
    }
}

impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("summarize: {}", tweet.summarize());
    println!("summarize_author: {}", tweet.summarize_author());
}

main()
</pre>
</div>

<div class="results" id="orge9aefda">
<p>
summarize: Read more from @horse_ebooks&#x2026;
summarize_author: @horse_ebooks
()
</p>

</div>

<p>
引数itemのsummarizeメソッドを呼ぶ関数notifyを定義する。引数itemはSummaryトレイトを実装している何らかの型。
</p>

<div class="org-src-container">
<pre class="src src-rust">pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("Read more from {}...", self.summarize_author())
    }
}

impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}

// 引数: &amp;impl トレイト
pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

// ↑と等価で、冗長に書いたバージョン。トレイト境界
// 山カッコの中にジェネリックな型引数の宣言を書き、型引数の後ろにコロンを挟んでトレイト境界を置く
// pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
//   // 速報! {}
//   println!("Breaking news! {}", item.summarize());
// }

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    notify(&amp;tweet);
}

main()
</pre>
</div>

<div class="results" id="org9263a09">
<p>
Breaking news! Read more from @horse_ebooks&#x2026;
()
</p>

</div>

<p>
トレイトを実装している型を返す。impl Trait構文を戻り値型のところで使うことで、あるトレイトを実装する何らかの型を返す。
</p>

<div class="org-src-container">
<pre class="src src-rust">pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("Read more from {}...", self.summarize_author())
    }
}

impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}

// impl Trait構文を戻り値型のところで使うことで、**あるトレイトを実装する**何らかの型を返す
// 具体的な型を指定してないところがポイント
// これはクロージャとイテレータを扱うときに特に便利。ある関数はIteratorトレイトを実装するある型を返すのだ、と簡潔に指定できる
fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}

fn main() {
  let tweet = returns_summarizable();
  println!("result: {}", tweet.summarize_author());
}

main()
</pre>
</div>

<div class="results" id="orgcdbe8da">
<p>
result: @horse_ebooks
()
</p>

</div>

<ul class="org-ul">
<li>ただしimpl Traitの制約として、1種類の型を返す場合にのみ使える</li>
</ul>

<p>
関数に渡したスライスの値の型が、PartialOrdとCopyを実装する限りコンパイルできる、ジェネリックなlargest関数。
</p>

<div class="org-src-container">
<pre class="src src-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}

main()
</pre>
</div>

<div class="results" id="org71560dd">
<p>
The largest number is 100
The largest char is y
()
</p>

</div>

<p>
トレイト境界を使用して、メソッド実装を条件分けする。
</p>
<ul class="org-ul">
<li>Pair&lt;T&gt;は常にnew関数を実装する。</li>
<li>Pair&lt;T&gt;は、内部の型Tが比較を可能にするPartialOrdトレイトと出力を可能にするDisplayトレイトを実装しているときのみ、cmp_displayメソッドを実装する。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>トレイト境界によってジェネリックな型に対するメソッド実装を条件分けする</label><pre class="src src-rust">  use std::fmt::Display;

  struct Pair&lt;T&gt; {
      x: T,
      y: T,
  }

  impl&lt;T&gt; Pair&lt;T&gt;{
      fn new(x: T, y: T) -&gt; Self {
          Self { x, y }
      }
  }

  impl &lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
      fn cmp_display(&amp;self) {
          if self.x &gt;= self.y {
              println!("The largest member is x = {}", self.x);
          } else {
              println!("The largest member is y = {}", self.y);
          }
      }
  }

  fn main() {
      let pair = Pair{ x: 1, y: 2};
      pair.cmp_display();
  }
main();

</pre>
</div>

<div class="results" id="org9852b15">
<p>
The largest member is y = 2
()
</p>

</div>

<p>
別のトレイトを実装するあらゆる型に対するトレイト実装を条件分けできる。トレイト境界を満たすあらゆる型にトレイトを実装することは、ブランケット実装と呼ばれ、Rustの標準ライブラリで広く使用される。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>rustのソースコード。標準ライブラリは、Displayトレイトを実装するあらゆる型にToStringトレイトを実装している</label><pre class="src src-git-permalink">https://github.com/kd-collective/rust/blob/8b954910c59a7a362c60959e93110892b6e9a691/library/alloc/src/string.rs#L2388-L2402
</pre>
</div>

<div class="results" id="orge4c05b2">
<p>
impl&lt;T: fmt::Display + ?Sized&gt; ToString for T {
    <i>/ A common guideline is to not inline generic functions. However,
    /</i> removing `#[inline]` from this method causes non-negligible regressions.
    <i>/ See <a href="https://github.com/rust-lang/rust/pull/74852">https://github.com/rust-lang/rust/pull/74852</a>, the last attempt
    /</i> to try to remove it.
    #[inline]
    default fn to_string(&amp;self) -&gt; String {
        let mut buf = String::new();
        let mut formatter = core::fmt::Formatter::new(&amp;mut buf);
        // Bypass format_args!() to avoid write_str with zero-length strs
        fmt::Display::fmt(self, &amp;mut formatter)
            .expect(&ldquo;a Display implementation returned an error unexpectedly&rdquo;);
        buf
    }
}
</p>

</div>

<p>
整数はDisplayを実装するので、整数値を対応するString値に変換できる。
</p>
<div class="org-src-container">
<pre class="src src-rust">fn main() {
    println!("{}", 3.to_string());
}
main();
</pre>
</div>

<div class="results" id="org26543b8">
<p>
3
()
</p>

</div>
</div>
</div>

<div id="outline-container-org648e6db" class="outline-3">
<h3 id="org648e6db"><a href="#org648e6db">ジェネリクスの概要</a></h3>
<div class="outline-text-3" id="text-org648e6db">
<p>
<a href="https://doc.rust-jp.rs/book-ja/ch10-00-generics.html">ジェネリック型、トレイト、ライフタイム - The Rust Programming Language 日本語版</a>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>Option enumの定義にもジェネリック型が使われている。</label><pre class="src src-rust">enum Option&lt;T&gt; {
  Some(T),
  None,
}
</pre>
</div>

<p>
型Tの値を保持するSomeと、値を何も保持しないNone。
</p>

<p>
複数のジェネリックな型を使用できる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>Result Enumの定義</label><pre class="src src-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</pre>
</div>

<p>
メソッド定義にも使える。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>implの直後にTを宣言しなければならない。そうすることでPointの山カッコ内の方が、具体的な型ではなくジェネリックな型であることを認識できる</label><pre class="src src-rust">  struct Point&lt;T&gt; {
    x: T,
    y: T,
  }

impl&lt;T&gt; Point&lt;T&gt; {
  fn x(&amp;self) -&gt; &amp;T {
    &amp;self.x
  }
}

fn main() {
  let p = Point { x: 5, y: 10};
  println!("p.x = {}", p.x());
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4af9f59" class="outline-3">
<h3 id="org4af9f59"><a href="#org4af9f59">matchとOption</a></h3>
<div class="outline-text-3" id="text-org4af9f59">
<p>
<a href="https://doc.rust-jp.rs/book-ja/ch06-02-match.html">match制御フロー演算子 - The Rust Programming Language 日本語版</a>
</p>

<div class="org-src-container">
<pre class="src src-rust">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
  match Coin {
    Coin::Penny =&gt; 1,
    Coin::Nickel =&gt; 5,
    Coin::Dime =&gt; 10,
    Coin::Quarter =&gt; 25,
  }
}
</pre>
</div>

<p>
値に束縛されるパターン。Quarterが保持するenumを増やす。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>Quarterにenumが増えた</label><pre class="src src-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            // stateに束縛されるのは、UsState::Alabama
            println!("state quarter from {:?}!", state);
            25
        },
    }
}

value_in_cents(Coin::Quarter(UsState::Alabama))
</pre>
</div>

<div class="results" id="org6c87003">
<p>
state quarter from Alabama!
25
</p>

</div>

<p>
Option&lt;T&gt;とのマッチ。
</p>
<ul class="org-ul">
<li>マッチは包括的なので、もしNoneアームがなかったとしたらエラーを出してくれる。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>中に値があったらその値に1を足す。値がなければNoneを返す</label><pre class="src src-rust">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}

</pre>
</div>

<p>
単にif letで短く書ける。
</p>

<div class="org-src-container">
<pre class="src src-rust">if let Some(thing) = thing {
   // 中身の値があるとき実行
  ｝else {
   // 中身の値がないとき実行
  }
</pre>
</div>

<pre class="example">
error[E0433]: failed to resolve: use of undeclared type `Coin`
 --&gt; /tmp/babel-Mwh0df/rust-jR2DGi:4:12
  |
4 |     if let Coin::Quarter(state) = coin {
  |            ^^^^ use of undeclared type `Coin`

error[E0425]: cannot find value `coin` in this scope
 --&gt; /tmp/babel-Mwh0df/rust-jR2DGi:4:35
  |
4 |     if let Coin::Quarter(state) = coin {
  |                                   ^^^^ not found in this scope

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0425, E0433.
For more information about an error, try `rustc --explain E0425`.
</pre>
</div>
</div>

<div id="outline-container-org53e7581" class="outline-3">
<h3 id="org53e7581"><a href="#org53e7581">enumと構造体</a></h3>
<div class="outline-text-3" id="text-org53e7581">
<p>
<a href="https://doc.rust-jp.rs/book-ja/ch06-01-defining-an-enum.html">Enumを定義する - The Rust Programming Language 日本語版</a>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>enumの各列挙子にデータを直接添付できる</label><pre class="src src-rust">enum IpAddr {
    V4(String),
    V6(String),
}

fn main () {
    let home = IpAddr::V4(String::from("127.0.0.1"));
    let loopback = IpAddr::V6(String::from("::1"));
}

main()
</pre>
</div>

<p>
別の例。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>これは当然、異なる構造体でも実現できる。しかしenumだと、この種のメッセージいずれもとる関数を簡単に定義できるメリットがある</label><pre class="src src-rust">enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
</pre>
</div>

<p>
Optionも、標準ライブラリにより定義されているEnum。初期化処理(prelude)に含まれているため、明示的にスコープに導入する必要がない。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>定義</label><pre class="src src-git-permalink">https://github.com/kd-collective/rust/blob/8b954910c59a7a362c60959e93110892b6e9a691/library/core/src/option.rs#L514-L523
</pre>
</div>

<div class="results" id="orgd69b415">
<p>
pub enum Option&lt;T&gt; {
    <i>/</i> No value
    #[lang = &ldquo;None&rdquo;]
    #[stable(feature = &ldquo;rust1&rdquo;, since = &ldquo;1.0.0&rdquo;)]
    None,
    <i>/</i> Some value `T`
    #[lang = &ldquo;Some&rdquo;]
    #[stable(feature = &ldquo;rust1&rdquo;, since = &ldquo;1.0.0&rdquo;)]
    Some(#[stable(feature = &ldquo;rust1&rdquo;, since = &ldquo;1.0.0&rdquo;)] T),
}
</p>

</div>

<p>
Option値を使って数値型や文字列型を保持する例。
</p>
<div class="org-src-container">
<pre class="src src-rust">let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option&lt;i32&gt; = None;
</pre>
</div>

<p>
Option&lt;T&gt;とTは異なる。Option&lt;T&gt;を使うためには変換が必要になる。nullである場合を明示的に処理する必要がある。
</p>
</div>
</div>

<div id="outline-container-org34aa00d" class="outline-3">
<h3 id="org34aa00d"><a href="#org34aa00d">構造体のインスタンス化</a></h3>
<div class="outline-text-3" id="text-org34aa00d">
<p>
<a href="https://doc.rust-jp.rs/book-ja/ch05-03-method-syntax.html">メソッド記法 - The Rust Programming Language 日本語版</a>
</p>

<p>
newはない。
</p>

<div class="org-src-container">
<pre class="src src-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("The area of the rectangle is {} square pixels.", area(&amp;rect1));
}

fn area(rectangle: &amp;Rectangle) -&gt; u32{ rectangle.width *
                                       rectangle.height }

main()
</pre>
</div>

<div class="results" id="org76658b6">
<p>
The area of the rectangle is 1500 square pixels.
()
</p>

</div>

<p>
構造体で情報出力するために、debug注釈を追加する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>注釈を追加して、構造体の中身を表示できるようになる</label><pre class="src src-rust">#[derive(Debug)]
struct Rectangle {
  width: u32,
  height: u32,
}

fn main() {
  let rect = Rectangle { width: 1, height: 1};
  println!("rect is {:?}", rect);
}

main()
</pre>
</div>

<div class="results" id="org177716b">
<p>
rect is Rectangle { width: 1, height: 1 }
()
</p>

</div>

<p>
構造体上にメソッドを実装する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>rect1.area()で呼び出せる。型に実装することでグルーピングできる</label><pre class="src src-rust">#[derive(Debug)]
struct Rectangle {
    width: i32,
    height: i32,
}

impl Rectangle {
    // メソッドなので、selfはRectangle。
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle{ width: 1, height: 1 }
    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
</pre>
</div>

<p>
新しいメソッド。
</p>

<div class="org-src-container">
<pre class="src src-rust">#[derive(Debug)]
struct Rectangle {
    width: i32,
    height: i32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle{ width: 30, height: 50 };
    let rect2 = Rectangle{ width: 10, height: 40 };
    let rect3 = Rectangle{ width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
}

main()
</pre>
</div>

<div class="results" id="org7345ff6">
<p>
Can rect1 hold rect2? true
Can rect1 hold rect3? false
()
</p>

</div>
</div>
</div>

<div id="outline-container-orga3aeb0a" class="outline-3">
<h3 id="orga3aeb0a"><a href="#orga3aeb0a">ライフタイム</a></h3>
<div class="outline-text-3" id="text-orga3aeb0a">
<p>
ライフタイムを使うと、構造体に他の何かに所有されたデータへの参照を保持させることができる。
</p>
</div>
</div>
<div id="outline-container-orgd983866" class="outline-3">
<h3 id="orgd983866"><a href="#orgd983866">フィールドのない構造体: ユニット様構造体</a></h3>
<div class="outline-text-3" id="text-orgd983866">
<p>
<a href="https://doc.rust-jp.rs/book-ja/ch05-01-defining-structs.html#%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%E3%81%AE%E3%81%AA%E3%81%84%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E6%A7%98%E3%82%88%E3%81%86%E6%A7%8B%E9%80%A0%E4%BD%93">構造体を定義し、インスタンス化する - The Rust Programming Language 日本語版</a>
</p>

<blockquote>
<p>
また、一切フィールドのない構造体を定義することもできます！これらは、()、ユニット型と似たような振る舞いをすることから、 ユニット様構造体と呼ばれます。ユニット様構造体は、ある型にトレイトを実装するけれども、 型自体に保持させるデータは一切ない場面に有効になります。トレイトについては第10章で議論します。
</p>
</blockquote>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>使用例</label><pre class="src src-rust">pub struct Monster {}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3d4f59" class="outline-3">
<h3 id="orgb3d4f59"><a href="#orgb3d4f59">マクロ作成</a></h3>
<div class="outline-text-3" id="text-orgb3d4f59">
<p>
コンパイル前に動的にコードを展開して、実行することで柔軟性を得られる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>&amp;ast.identでパースした関数名が取れる</label><pre class="src src-git-permalink">https://github.com/kd-collective/specs/blob/f07c484ad3caf8dccbf55c96af4ef1e3475dea28/specs-derive/src/lib.rs#L56-L57
</pre>
</div>

<div class="results" id="org2cc4b09">
<p>
fn impl_component(ast: &amp;DeriveInput) -&gt; proc_macro2::TokenStream {
    let name = &amp;ast.ident;
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>取得した関数名を使って、quote!でマクロ展開する。quote!内が実際にコードとして実行される</label><pre class="src src-git-permalink">https://github.com/kd-collective/specs/blob/f07c484ad3caf8dccbf55c96af4ef1e3475dea28/specs-derive/src/lib.rs#L71-L75
</pre>
</div>

<div class="results" id="orga027637">
<p>
quote! {
    impl #impl_generics Component for #name #ty_generics #where_clause {
	type Storage = #storage&lt;Self&gt;;
    }
}
</p>

</div>
</div>
</div>

<div id="outline-container-org3e39e7c" class="outline-3">
<h3 id="org3e39e7c"><a href="#org3e39e7c">unwrap()は何か</a></h3>
<div class="outline-text-3" id="text-org3e39e7c">
<p>
unwrap() は、 Option&lt;T&gt; 型や Result&lt;T, E&gt; 型の値（つまり、何かしらの値を ラップ している値）から中身の値を取り出す関数。たとえば Option&lt;T&gt; 型の値に対して unwrap() を呼ぶと、それが内包する T 型の値を返す。それらの型には値が入ってない可能性もあり、入ってない場合にはunwrapは失敗する。
</p>

<p>
<a href="https://ja.stackoverflow.com/questions/1730/rust%E3%81%AEunwrap%E3%81%AF%E4%BD%95%E3%82%92%E3%81%99%E3%82%8B%E3%82%82%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B">rust - Rustの&ldquo;unwrap()&rdquo;は何をするものですか？ - スタック・オーバーフロー</a>
</p>
</div>
</div>
<div id="outline-container-org072d4cb" class="outline-3">
<h3 id="org072d4cb"><a href="#org072d4cb">イテレータを定義する</a></h3>
<div class="outline-text-3" id="text-org072d4cb">
<p>
<a href="https://docs.microsoft.com/ja-jp/learn/modules/rust-generic-types-traits/5-iterators">反復子を使用する - Learn | Microsoft Docs</a>
</p>

<div class="org-src-container">
<pre class="src src-rust">trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}

#[derive(Debug)]
struct Counter {
    length: usize,
    count: usize,
}

impl Counter {
    fn new(length: usize) -&gt; Counter {
        Counter {
            count: 0,
            length,
        }
    }
}

impl Iterator for Counter {
    type Item = usize;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;
        if self.count &lt;= self.length {
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    for number in Counter::new(10) {
        println!("{}", number);
    }
}
</pre>
</div>

<div class="results" id="orged5aa9e">

</div>
</div>
</div>

<div id="outline-container-org280f437" class="outline-3">
<h3 id="org280f437"><a href="#org280f437">Box、スマートポインタは何か</a></h3>
<div class="outline-text-3" id="text-org280f437">
<p>
スマートポインタはポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造。
<a href="https://doc.rust-jp.rs/book-ja/ch15-00-smart-pointers.html">スマートポインタ - The Rust Programming Language 日本語版</a>
</p>

<p>
Rustでは、boxを使う。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>Boxは値5を示し、値5はヒープに保存されている</label><pre class="src src-rust">fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
</pre>
</div>

<div class="results" id="org8ba3eec">

</div>

<p>
Rustでスマートポインタを利用するのに使う。
スタックではなくヒープにデータを保存する。
</p>

<p>
使う場面。
</p>

<ul class="org-ul">
<li>コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用するとき</li>
<li>多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたいとき</li>
<li>値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけているとき</li>
</ul>

<p>
<a href="https://doc.rust-jp.rs/book-ja/ch15-01-box.html">ヒープのデータを指すBox&lt;T&gt;を使用する - The Rust Programming Language 日本語版</a>
</p>
</div>
</div>
<div id="outline-container-orgeb4b2c5" class="outline-3">
<h3 id="orgeb4b2c5"><a href="#orgeb4b2c5">変更を検知して自動ビルドする</a></h3>
<div class="outline-text-3" id="text-orgeb4b2c5">
<p>
変更したら自動でcargo runしてほしいときがある。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span>cargo-watchを使う</label><pre class="src src-shell">cargo install cargo-watch
cargo watch -x run
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc7f3720" class="outline-3">
<h3 id="orgc7f3720"><a href="#orgc7f3720"><code>println!</code> マクロとは何か</a></h3>
<div class="outline-text-3" id="text-orgc7f3720">
<div class="org-src-container">
<pre class="src src-rust">println!("hello world!");
println!("{} days", 31);
println!("{0}, this is {1}, {1}, this is {0}", "Alice", "Bob");
println!("{} of {:b} people know binary, the other half doesn't", 1, 2);
println!("{number:&gt;0width$}", number=1, width=6);
println!("{subject} {verb} {object}", object="the lazy dog", subject="the quick brown fox", verb="jumps over");
</pre>
</div>

<div class="results" id="org77372c9">
<p>
hello world!
31 days
Alice, this is Bob, Bob, this is Alice
1 of 10 people know binary, the other half doesn&rsquo;t
000001
the quick brown fox jumps over the lazy dog
</p>

</div>

<p>
引数チェックもしてくれる。
</p>
<div class="org-src-container">
<pre class="src src-rust">println!("My name is {0}, {1} {0}", "Bond");
</pre>
</div>

<pre class="example">
error: invalid reference to positional argument 1 (there is 1 argument)
 --&gt; /tmp/babel-wnDbpn/rust-W98kSP:2:27
  |
2 | println!("My name is {0}, {1} {0}", "Bond");
  |                           ^^^
  |
  = note: positional arguments are zero-based

error: aborting due to previous error
</pre>

<p>
マーカーの変更。
</p>
<div class="org-src-container">
<pre class="src src-rust">println!("This struct `{}` won't print...", Structure(3));
</pre>
</div>

<pre class="example">
error[E0425]: cannot find function, tuple struct or tuple variant `Structure` in this scope
 --&gt; /tmp/babel-wnDbpn/rust-If17CF:2:45
  |
2 | println!("This struct `{}` won't print...", Structure(3));
  |                                             ^^^^^^^^^ not found in this scope

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
</pre>

<div class="org-src-container">
<pre class="src src-rust">#[derive(Debug)]
struct Structure(i32);
println!("This struct `{:?}` won't print...", Structure(3));
</pre>
</div>

<div class="results" id="org4c7ad6d">
<p>
This struct `Structure(3)` won&rsquo;t print&#x2026;
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org5f60da5" class="outline-2">
<h2 id="org5f60da5"><a href="#org5f60da5">パッケージ</a></h2>
<div class="outline-text-2" id="text-org5f60da5">
</div>
<div id="outline-container-org2d79eb2" class="outline-3">
<h3 id="org2d79eb2"><a href="#org2d79eb2">ホームディレクトリのチルダを展開するライブラリ</a></h3>
<div class="outline-text-3" id="text-org2d79eb2">
<ul class="org-ul">
<li><a href="https://github.com/netvl/shellexpand">netvl/shellexpand: A library for shell-like expansions of variables in strings</a></li>
</ul>

<p>
どういうわけかデフォルトで展開してくれないので、ライブラリで変換する必要がある。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>ホームディレクトリで ls コマンドを実行する</label><pre class="src src-rust">extern crate shellexpand;

fn main() {
    let cwd = format!("{}", shellexpand::tilde("~/"));
    Command::new("ls").current_dir(&amp;cwd);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org154ce73" class="outline-3">
<h3 id="org154ce73"><a href="#org154ce73">OSディレクトリライブラリ</a></h3>
<div class="outline-text-3" id="text-org154ce73">
<ul class="org-ul">
<li><a href="https://github.com/xdg-rs/dirs">xdg-rs/dirs: a low-level library that provides config/cache/data paths, following the respective conventions on Linux, macOS and Windows</a></li>
</ul>

<p>
OS間のディレクトリの違いを吸収するライブラリ。ミニマルでコードを読みやすい。
</p>
</div>
</div>
<div id="outline-container-org075179e" class="outline-3">
<h3 id="org075179e"><a href="#org075179e"><a href="20210508234743-emacs.html#ID-1ad8c3d5-97ba-4905-be11-e6f2626127ad">Emacs</a>をRustで書き直すプロジェクト</a></h3>
<div class="outline-text-3" id="text-org075179e">
<p>
EmacsのC言語で書かれた部分をRustに書き直すリポジトリがある。
<a href="https://github.com/remacs/remacs">remacs/remacs: Rust Emacs</a>
</p>
</div>
</div>
<div id="outline-container-org855ef71" class="outline-3">
<h3 id="org855ef71"><a href="#org855ef71">超高速検索できるripgrep</a></h3>
<div class="outline-text-3" id="text-org855ef71">
<p>
高速検索するripgrepは、ほかのどのgrepツールより早いらしい。
</p>

<dl class="org-dl">
<dt>repository</dt><dd><a href="https://github.com/BurntSushi/ripgrep">BurntSushi/ripgrep</a></dd>
</dl>
</div>
</div>
<div id="outline-container-org1b46055" class="outline-3">
<h3 id="org1b46055"><a href="#org1b46055">外観がかっこいい<a href="20210606192338-shell.html#ID-585d3b5e-989d-4363-bcc3-894402fcfcf9">Shell</a>, nushell</a></h3>
<div class="outline-text-3" id="text-org1b46055">
<p>
<a href="20210915221421-systemcrafters.html#ID-fa497359-ae3f-494a-b24a-9822eefe67ad">System Crafters</a>の動画<a href="https://www.youtube.com/watch?v=IHeKUeO7bpo">Integrating Nushell with Emacs</a>のコラボ回で出たパッケージ。
リッチな出力形式、便利コマンドがすごい。
</p>
<dl class="org-dl">
<dt>repository</dt><dd><a href="https://github.com/nushell/nushell">nushell/nushell: A new type of shell</a></dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-org14f80e6" class="outline-2">
<h2 id="org14f80e6"><a href="#org14f80e6">Tasks</a></h2>
<div class="outline-text-2" id="text-org14f80e6">
</div>
<div id="outline-container-org62c2abe" class="outline-3">
<h3 id="org62c2abe"><a href="#org62c2abe"><span class="todo TODO">TODO</span> <a href="https://techracho.bpsinc.jp/yoshi/2023_08_30/134157">Rustの借用の話をする｜TechRacho by BPS株式会社</a></a></h3>
<div class="outline-text-3" id="text-org62c2abe">
<p>
借用の解説。
</p>
</div>
</div>
<div id="outline-container-org3926a99" class="outline-3">
<h3 id="org3926a99"><a href="#org3926a99"><span class="todo TODO">TODO</span> <a href="https://rustc-dev-guide.rust-lang.org/">Getting Started - Rust Compiler Development Guide</a></a></h3>
<div class="outline-text-3" id="text-org3926a99">
<p>
Rustコンパイラ開発のガイド。
</p>
</div>
</div>
<div id="outline-container-org98552ff" class="outline-3">
<h3 id="org98552ff"><a href="#org98552ff"><span class="todo TODO">TODO</span> <a href="https://os.phil-opp.com/">Writing an OS in Rust</a></a></h3>
<div class="outline-text-3" id="text-org98552ff">
<p>
OSをrustで書く本。詳しく書かれている。
</p>
</div>
</div>
<div id="outline-container-org85d869c" class="outline-3">
<h3 id="org85d869c"><a href="#org85d869c">型やライブラリの調べ方&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DontKnow">DontKnow</span></span></a></h3>
<div class="outline-text-3" id="text-org85d869c">
<p>
何かしたいときにうまく型を見つけるためにはどうしたら良いのか。ドキュメントを見てもいまいちわからない。
</p>
</div>
</div>
<div id="outline-container-org87fd261" class="outline-3">
<h3 id="org87fd261"><a href="#org87fd261">型でorはどうやるのか&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DontKnow">DontKnow</span></span></a></h3>
<div class="outline-text-3" id="text-org87fd261">
<p>
文字列もしくは整数、みたいな型はどうやって表現するのか。<a href="20210831232330-typescript.html#ID-ad1527ee-63b3-4a9b-a553-10899f57c234">TypeScript</a>でいうところのunion型みたいな。
</p>
</div>
</div>
<div id="outline-container-org5153bef" class="outline-3">
<h3 id="org5153bef"><a href="#org5153bef"><a href="https://slide-rs.github.io/specs-website/docs/book/master/01_intro.html#introduction">Introduction - The Specs Book</a></a></h3>
<div class="outline-text-3" id="text-org5153bef">
<p>
ECSとSpecsのドキュメント。
</p>
</div>
</div>
<div id="outline-container-org2c09d34" class="outline-3">
<h3 id="org2c09d34"><a href="#org2c09d34"><a href="https://docs.microsoft.com/ja-jp/learn/paths/rust-first-steps/">Rust の最初のステップ - Learn | Microsoft Docs</a></a></h3>
<div class="outline-text-3" id="text-org2c09d34">
<p>
Microsoftのチュートリアル。
</p>
</div>
</div>
<div id="outline-container-org13274ce" class="outline-3">
<h3 id="org13274ce"><a href="#org13274ce"><span class="todo TODO">TODO</span> <a href="https://doc.rust-jp.rs/rust-by-example-ja/">Introduction - Rust By Example 日本語版</a></a></h3>
</div>
<div id="outline-container-orgf9e4886" class="outline-3">
<h3 id="orgf9e4886"><a href="#orgf9e4886"><span class="todo TODO">TODO</span> <a href="https://doc.rust-jp.rs/book-ja/title-page.html">The Rust Programming Language 日本語版</a></a></h3>
<div class="outline-text-3" id="text-orgf9e4886">
<ul class="org-ul">
<li>10</li>
</ul>
</div>
</div>
<div id="outline-container-org78daa8e" class="outline-3">
<h3 id="org78daa8e"><a href="#org78daa8e"><a href="https://www.warp.dev/blog/why-is-building-a-ui-in-rust-so-hard">Why is building a UI in Rust so hard? | Warp</a></a></h3>
<div class="outline-text-3" id="text-org78daa8e">
<p>
RustでのUI作成はなぜつらいか。
</p>
</div>
</div>
</div>
<div id="outline-container-org305005e" class="outline-2">
<h2 id="org305005e"><a href="#org305005e">Reference</a></h2>
<div class="outline-text-2" id="text-org305005e">
</div>
<div id="outline-container-org423efac" class="outline-3">
<h3 id="org423efac"><a href="#org423efac"><a href="https://scrapbox.io/nwtgck/Rust%E3%81%A7%E5%80%A4%E3%81%8B%E3%82%89%E5%9E%8B%E6%83%85%E5%A0%B1%E3%82%92%E6%96%87%E5%AD%97%E5%88%97%E3%81%A8%E3%81%97%E3%81%A6%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%EF%BC%88stable%EF%BC%89">Rustで値から型情報を文字列として取得する（stable） - nwtgck / Ryo Ota</a></a></h3>
<div class="outline-text-3" id="text-org423efac">
<p>
デバッグで便利そう。
</p>
</div>
</div>
<div id="outline-container-orgf5ee100" class="outline-3">
<h3 id="orgf5ee100"><a href="#orgf5ee100"><a href="https://qiita.com/smicle/items/29a4d5d1d14ad7f77f60">rust String &amp;str の変換と、文字列 数値 の変換 - Qiita</a></a></h3>
</div>
<div id="outline-container-org0496ebf" class="outline-3">
<h3 id="org0496ebf"><a href="#org0496ebf"><a href="https://qiita.com/yagince/items/e7474839246ced595f7a">[Rust] &amp;strとStringを理解しようと思ったらsliceやmutを理解できてないことに気づいた話 - Qiita</a></a></h3>
</div>
<div id="outline-container-orgf3191c4" class="outline-3">
<h3 id="orgf3191c4"><a href="#orgf3191c4"><a href="https://zenn.dev/toga/books/rust-atcoder/viewer/01-intro">序｜RustCoder ―― AtCoder と Rust で始める競技プログラミング入門</a></a></h3>
<div class="outline-text-3" id="text-orgf3191c4">
<p>
入門本。
</p>
</div>
</div>
<div id="outline-container-orga4f1edf" class="outline-3">
<h3 id="orga4f1edf"><a href="#orga4f1edf"><a href="https://ja.wikipedia.org/wiki/Rust_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E)">Rust (プログラミング言語) - Wikipedia</a></a></h3>
</div>
</div>
<div id="outline-container-org7f0364f" class="outline-2">
<h2 id="org7f0364f"><a href="#org7f0364f">Archives</a></h2>
<div class="outline-text-2" id="text-org7f0364f">
</div>
<div id="outline-container-orgc8a504a" class="outline-3">
<h3 id="orgc8a504a"><a href="#orgc8a504a"><span class="done DONE">DONE</span> <a href="https://rust-cli.github.io/book/index.html">Getting started - Command Line Applications in Rust</a></a></h3>
<div class="outline-text-3" id="text-orgc8a504a">
<p>
コマンドラインプログラムを作るチュートリアル。
</p>
</div>
</div>
<div id="outline-container-org4ade408" class="outline-3">
<h3 id="org4ade408"><a href="#org4ade408"><span class="done DONE">DONE</span> <a href="https://www.amazon.co.jp/-/en/%E3%82%AF%E3%82%B8%E3%83%A9%E9%A3%9B%E8%A1%8C%E6%9C%BA/dp/4802613512/ref=sr_1_5?crid=14EZ2K0WKN0UY&amp;keywords=Rust&amp;qid=1648043657&amp;sprefix=rus%2Caps%2C165&amp;sr=8-5">手を動かして考えればよくわかる 高効率言語 Rust 書きかた・作りかた</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Read">Read</span></span></a></h3>
<div class="outline-text-3" id="text-org4ade408">
</div>
<div id="outline-container-org0ed7c14" class="outline-4">
<h4 id="org0ed7c14"><a href="#org0ed7c14">構造体に実装する</a></h4>
<div class="outline-text-4" id="text-org0ed7c14">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>型に実装する</label><pre class="src src-rust">    fn main() {
      let body = Body::new(163.0, 75.2, "田中");
      body.print_result();
      let body = Body::new(158.2, 55.0, "鈴木");
      body.print_result();
      let body = Body::new(174.2, 54.2, "井上");
      body.print_result();
    }

  struct BmiRange {
      min: f64,
      max: f64,
      label: String,
  }

  impl BmiRange {
    fn new(min: f64, max: f64, label: &amp;str) -&gt; Self {
      BmiRange{ min, max, label: label.to_string() }
    }

    fn test(&amp;self, v: f64) -&gt; bool {
      (self.min &lt;= v) &amp;&amp; (v &lt; self.max)
    }
  }

  struct Body {
    height: f64,
    weight: f64,
    name: String,
  }

  impl Body {
    fn new(height: f64, weight: f64, name: &amp;str) -&gt; Self {
        Body{ height, weight, name: name.to_string() }
    }

    fn calc_bmi(&amp;self) -&gt; f64 {
      self.weight / (self.height / 100.0).powf(2.0)
    }

    fn print_result(&amp;self) {
      let bmi = self.calc_bmi();
      let bmi_list = [
        BmiRange::new(0.0, 18.5, "低体重"),
        BmiRange::new(18.5, 25.0, "普通体重"),
        BmiRange::new(25.0, 30.0, "肥満1度"),
        BmiRange::new(30.0, 35.0, "肥満2度"),
        BmiRange::new(35.0, 40.0, "肥満3度"),
      ];
      let mut result = String::from("不明");
      for range in bmi_list {
        if range.test(bmi) {
          result = range.label.clone();
          break;
        }
      }
      println!("{}さん、 BMI={:.1}, 判定={}",
      self.name, bmi, result);
    }
  }
main()
</pre>
</div>

<div class="results" id="org4deca4d">
<p>
田中さん、 BMI=28.3, 判定=肥満1度
鈴木さん、 BMI=22.0, 判定=普通体重
井上さん、 BMI=17.9, 判定=低体重
()
</p>

</div>
</div>
</div>
<div id="outline-container-orgae8ffdf" class="outline-4">
<h4 id="orgae8ffdf"><a href="#orgae8ffdf">None, Result</a></h4>
<div class="outline-text-4" id="text-orgae8ffdf">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>列挙型を使う</label><pre class="src src-rust">struct Counter {
  value: i64,
}

impl Counter {
  fn new() -&gt; Self {
    Counter { value: 0 }
  }

  fn inc(&amp;mut self) {
    self.value += 1;
    println!("value={}", self.value);
  }
}

fn count(counter: Option&lt;&amp;mut Counter&gt;) {
  match counter{
    None =&gt; return,
    Some(c) =&gt; c.inc(),
  };
}

fn main() {
  let mut a = Counter::new();
  count(Some(&amp;mut a));
  count(Some(&amp;mut a));
  let a = None;
  count(a);
}
main();
</pre>
</div>

<div class="results" id="orgac5cb85">
<p>
value=1
value=2
()
</p>

</div>
</div>
</div>
</div>
<div id="outline-container-org8477b9c" class="outline-3">
<h3 id="org8477b9c"><a href="#org8477b9c"><span class="done DONE">DONE</span> <a href="https://bfnightly.bracketproductions.com/">Introduction - Roguelike Tutorial - In Rust</a></a></h3>
<div class="outline-text-3" id="text-org8477b9c">
<p>
<a href="20220319131144-roguelike.html#ID-50ac66da-89f2-42dc-a746-d20b041d06ae">roguelike</a>を作る長大なチュートリアル。
とりあえず14章までやり、理解を確かめるため自作改造フェーズに入った。
残りの部分はチュートリアルとしてやるというより、自作するうえで都度参照していく。
</p>
</div>
</div>
<div id="outline-container-org1c28a77" class="outline-3">
<h3 id="org1c28a77"><a href="#org1c28a77"><span class="done DONE">DONE</span> clone ツール</a></h3>
<div class="outline-text-3" id="text-org1c28a77">
<p>
git cloneをコード管理するツール。初期化したときに、再度cloneしまくるのがメンドいため。とりあえず完了。
</p>
</div>
</div>
</div>


<div id="outline-container-orge20b778" class="outline-2">
<h2 id="orge20b778"><a href="#orge20b778">Backlinks</a></h2>
<div class="outline-text-2" id="text-orge20b778">
<ul class="org-ul">
<li><a href="./20210624232811-digger.html">ローグライク作り</a></li>
<li><a href="./20210817003906-history.html">History</a></li>
<li><a href="./20210901100517-zig.html">Zig</a></li>
<li><a href="./20210922010155-nushell.html">nushell</a></li>
<li><a href="./20210926150327-oss.html">OSS</a></li>
<li><a href="./20220809233721-bracket_lib.html">bracket-lib</a></li>
<li><a href="./20230101T175751--kdoc-16-2022年のまとめ__essay.html">KDOC 16: 2022年のまとめ</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"/>
</div>
</body>
</html>
