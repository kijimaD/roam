<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-02-10 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Haskell</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel='shortcut icon' type='image/x-icon' href='/roam/favicon.ico' /><link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css' /><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css' /><link rel='stylesheet' href='../css/site.css' /><link rel='stylesheet' href='../roam/css/code.css' /><link rel='stylesheet' href='css/site.css' /><link rel='stylesheet' href='css/code.css' />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content">
<h1 class="title">Haskell</h1>
<div id="outline-container-orga43fd90" class="outline-2">
<h2 id="orga43fd90"><a href="#orga43fd90">概要</a></h2>
<div class="outline-text-2" id="text-orga43fd90">
<p>
Haskellは純粋関数型<a href="20210509101246-programming_language.html#ID-868ac56a-2d42-48d7-ab7f-7047c85a8f39">Programming Language</a>。
</p>
</div>
</div>
<div id="outline-container-org11db016" class="outline-2">
<h2 id="org11db016"><a href="#org11db016">Memo</a></h2>
<div class="outline-text-2" id="text-org11db016">
</div>
<div id="outline-container-org57434ab" class="outline-3">
<h3 id="org57434ab"><a href="#org57434ab">QuickCheck</a></h3>
<div class="outline-text-3" id="text-org57434ab">
<p>
QuickCheckというテストライブラリがある。型に基づくプロパティテスト、というもののよう。
</p>

<p>
<a href="https://haskell.e-bigmoon.com/stack/test/quickcheck.html">【基礎】ランダムテスト (QuickCheck)</a>
</p>
</div>
</div>
<div id="outline-container-org6742cbd" class="outline-3">
<h3 id="org6742cbd"><a href="#org6742cbd">stack</a></h3>
<div class="outline-text-3" id="text-org6742cbd">
<p>
stackはHaskellの開発ツール。
</p>
<ul class="org-ul">
<li><a href="https://docs.haskellstack.org/en/stable/README/">Home - The Haskell Tool Stack</a></li>
</ul>
</div>
</div>
<div id="outline-container-org5df6181" class="outline-3">
<h3 id="org5df6181"><a href="#org5df6181">REPL</a></h3>
<div class="outline-text-3" id="text-org5df6181">
<p>
対話実行環境を立ち上げる。
</p>
<div class="org-src-container">
<pre class="src src-haskell">ghci
&gt;&gt; :load -- ファイル読み込み
&gt;&gt; :reload -- 再読込。org-babelがおかしくなったときに使える
&gt;&gt; :quit -- ghci終了
</pre>
</div>

<p>
プロンプトをセット。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:set prompt "GHCi&gt; "
</pre>
</div>
</div>
</div>
<div id="outline-container-org5013ea4" class="outline-3">
<h3 id="org5013ea4"><a href="#org5013ea4">前置引数</a></h3>
<div class="outline-text-3" id="text-org5013ea4">
<div class="org-src-container">
<pre class="src src-haskell">(+) 2 2
</pre>
</div>

<div class="results" id="orge8a0e02">
<p>
4
</p>

</div>
</div>
</div>
<div id="outline-container-org2ddda71" class="outline-3">
<h3 id="org2ddda71"><a href="#org2ddda71">マイナス演算子</a></h3>
<div class="outline-text-3" id="text-org2ddda71">
<div class="org-src-container">
<pre class="src src-haskell">2 + (- 1)
</pre>
</div>

<div class="results" id="orgd53e588">
<p>
1
</p>

</div>
</div>
</div>
<div id="outline-container-orgfcfdf9f" class="outline-3">
<h3 id="orgfcfdf9f"><a href="#orgfcfdf9f">:infoコマンド</a></h3>
<div class="outline-text-3" id="text-orgfcfdf9f">
<p>
<code>infixl</code> が演算子の優先順位。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:info (+)
</pre>
</div>

<div class="results" id="orga5a53a8">
<p>
class Num a where
  (+) :: a -&gt; a -&gt; a
  &#x2026;
  &#x2013; Defined in ‘GHC.Num’
infixl 6 +
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:info (*)
</pre>
</div>

<div class="results" id="org94a420c">
<p>
class Num a where
  &#x2026;
  (*) :: a -&gt; a -&gt; a
  &#x2026;
  &#x2013; Defined in ‘GHC.Num’
infixl 7 *
</p>

</div>
</div>
</div>
<div id="outline-container-orgd6d275d" class="outline-3">
<h3 id="orgd6d275d"><a href="#orgd6d275d">定数</a></h3>
<div class="outline-text-3" id="text-orgd6d275d">
<div class="org-src-container">
<pre class="src src-haskell">pi
</pre>
</div>

<div class="results" id="org0a7f3ea">
<p>
3.141592653589793
</p>

</div>
</div>
</div>
<div id="outline-container-org77021d9" class="outline-3">
<h3 id="org77021d9"><a href="#org77021d9">代入</a></h3>
<div class="outline-text-3" id="text-org77021d9">
<div class="org-src-container">
<pre class="src src-haskell">let e = exp 1
(e ** pi) - pi
</pre>
</div>

<div class="results" id="org8b004ca">
<p>
19.99909997918947
</p>

</div>
</div>
</div>
<div id="outline-container-orge0c0ef9" class="outline-3">
<h3 id="orge0c0ef9"><a href="#orge0c0ef9">リスト</a></h3>
<div class="outline-text-3" id="text-orge0c0ef9">
<div class="org-src-container">
<pre class="src src-haskell">["foo", "bar", "baz"]
</pre>
</div>

<div class="results" id="org6927ce4">
<p>
[&ldquo;foo&rdquo;,&ldquo;bar&rdquo;,&ldquo;baz&rdquo;]
</p>

</div>
</div>
</div>
<div id="outline-container-org16d6b9e" class="outline-3">
<h3 id="org16d6b9e"><a href="#org16d6b9e">列挙表記</a></h3>
<div class="outline-text-3" id="text-org16d6b9e">
<div class="org-src-container">
<pre class="src src-haskell">[1..10]
</pre>
</div>

<div class="results" id="org164c7f2">
<p>
[1,2,3,4,5,6,7,8,9,10]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">[1.0,1.25..2.0]
</pre>
</div>

<div class="results" id="orgeac7c64">
<p>
[1.0,1.25,1.5,1.75,2.0]
</p>

</div>
</div>
</div>
<div id="outline-container-orga287ba7" class="outline-3">
<h3 id="orga287ba7"><a href="#orga287ba7">リスト結合</a></h3>
<div class="outline-text-3" id="text-orga287ba7">
<div class="org-src-container">
<pre class="src src-haskell">[3,1,3] ++ [3,7]
</pre>
</div>

<div class="results" id="org7bee076">
<p>
[3,1,3,3,7]
</p>

</div>
</div>
</div>
<div id="outline-container-org33f71f9" class="outline-3">
<h3 id="org33f71f9"><a href="#org33f71f9">cons</a></h3>
<div class="outline-text-3" id="text-org33f71f9">
<div class="org-src-container">
<pre class="src src-haskell">1 : [2, 3]
</pre>
</div>

<div class="results" id="org7aef807">
<p>
[1,2,3]
</p>

</div>
</div>
</div>
<div id="outline-container-orgad27a0b" class="outline-3">
<h3 id="orgad27a0b"><a href="#orgad27a0b">型情報</a></h3>
<div class="outline-text-3" id="text-orgad27a0b">
<p>
⚠babelで実行すると実行されなくなるので、GHCIだけで試すこと。
</p>
<div class="org-src-container">
<pre class="src src-haskell">Prelude&gt; :set +t
Prelude&gt; 'c'
'c'
it :: Char

Prelude&gt; :unset +t
</pre>
</div>
</div>
</div>
<div id="outline-container-org2c2d77d" class="outline-3">
<h3 id="org2c2d77d"><a href="#org2c2d77d">型エラー</a></h3>
<div class="outline-text-3" id="text-org2c2d77d">
<div class="org-src-container">
<pre class="src src-haskell">1.2 % 3.4
</pre>
</div>

<div class="results" id="org5c7bf56">
<p>
&lt;interactive&gt;:6213:5: error:
    Variable not in scope: (%) :: Double -&gt; Double -&gt; t
</p>

</div>
</div>
</div>
<div id="outline-container-org7b4fb3f" class="outline-3">
<h3 id="org7b4fb3f"><a href="#org7b4fb3f">:type</a></h3>
<div class="outline-text-3" id="text-org7b4fb3f">
<div class="org-src-container">
<pre class="src src-haskell">:type 1
</pre>
</div>

<div class="results" id="org9a55189">
<p>
1 :: Num p =&gt; p
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type "abc"
</pre>
</div>

<div class="results" id="org322c174">
<p>
&ldquo;abc&rdquo; :: [Char]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type it
</pre>
</div>

<div class="results" id="org2588b69">
<p>
it :: [Char]
</p>

</div>
</div>
</div>
<div id="outline-container-org0d1146e" class="outline-3">
<h3 id="org0d1146e"><a href="#org0d1146e">いくつかの数値型関数</a></h3>
<div class="outline-text-3" id="text-org0d1146e">
<div class="org-src-container">
<pre class="src src-haskell">succ 6
</pre>
</div>

<div class="results" id="orgf8e7a34">
<p>
7
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">pred 9
</pre>
</div>

<div class="results" id="orgadf3d38">
<p>
8
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">sin (pi / 2)
</pre>
</div>

<div class="results" id="orgb09d471">
<p>
1.0
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">truncate pi
</pre>
</div>

<div class="results" id="org43a150e">
<p>
3
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">round 3.4
</pre>
</div>

<div class="results" id="org30d6672">
<p>
3
</p>

</div>
</div>
</div>
<div id="outline-container-org5b95564" class="outline-3">
<h3 id="org5b95564"><a href="#org5b95564"><code>:?</code> コマンド</a></h3>
<div class="outline-text-3" id="text-org5b95564">
<div class="org-src-container">
<pre class="src src-haskell">:?
</pre>
</div>

<div class="results" id="org1942d75">
<p>
display this list of commands
   :info[!] [&lt;name&gt; &#x2026;]       display information about the given names
                               (!: do not filter instances)
   :issafe [&lt;mod&gt;]             display safe haskell information of module &lt;mod&gt;
   :kind[!] &lt;type&gt;             show the kind of &lt;type&gt;
                               (!: also print the normalised type)
   :load[!] [*]&lt;module&gt; &#x2026;    load module(s) and their dependents
                               (!: defer type errors)
   :main [&lt;arguments&gt; &#x2026;]     run the main function with the given arguments
   :module [+/-] [*]&lt;mod&gt; &#x2026;  set the context for expression evaluation
   :quit                       exit GHCi
   :reload[!]                  reload the current module set
                               (!: defer type errors)
   :run function [&lt;arguments&gt; &#x2026;] run the function with the given arguments
   :script &lt;file&gt;              run the script &lt;file&gt;
   :type &lt;expr&gt;                show the type of &lt;expr&gt;
   :type +d &lt;expr&gt;             show the type of &lt;expr&gt;, defaulting type variables
   :type +v &lt;expr&gt;             show the type of &lt;expr&gt;, with its specified tyvars
   :unadd &lt;module&gt; &#x2026;         remove module(s) from the current target set
   :undef &lt;cmd&gt;                undefine user-defined command :&lt;cmd&gt;
   :!&lt;command&gt;                 run the shell command &lt;command&gt;
</p>

<p>
&#x2013; Commands for debugging:
</p>

<p>
:abandon                    at a breakpoint, abandon current computation
:back [&lt;n&gt;]                 go back in the history N steps (after :trace)
:break [&lt;mod&gt;] &lt;l&gt; [&lt;col&gt;]  set a breakpoint at the specified location
:break &lt;name&gt;               set a breakpoint on the specified function
:continue                   resume after a breakpoint
:delete &lt;number&gt;            delete the specified breakpoint
:delete *                   delete all breakpoints
:force &lt;expr&gt;               print &lt;expr&gt;, forcing unevaluated parts
:forward [&lt;n&gt;]              go forward in the history N step s(after :back)
:history [&lt;n&gt;]              after :trace, show the execution history
:list                       show the source code around current breakpoint
:list &lt;identifier&gt;          show the source code for &lt;identifier&gt;
:list [&lt;module&gt;] &lt;line&gt;     show the source code around line number &lt;line&gt;
:print [&lt;name&gt; &#x2026;]         show a value without forcing its computation
:sprint [&lt;name&gt; &#x2026;]        simplified version of :print
:step                       single-step after stopping at a breakpoint
:step &lt;expr&gt;                single-step into &lt;expr&gt;
:steplocal                  single-step within the current top-level binding
:stepmodule                 single-step restricted to the current module
:trace                      trace after stopping at a breakpoint
:trace &lt;expr&gt;               evaluate &lt;expr&gt; with tracing on (see :history)
</p>

<p>
&#x2013; Commands for changing settings:
</p>

<p>
:set &lt;option&gt; &#x2026;           set options
:seti &lt;option&gt; &#x2026;          set options for interactive evaluation only
:set args &lt;arg&gt; &#x2026;         set the arguments returned by System.getArgs
:set prog &lt;progname&gt;        set the value returned by System.getProgName
:set prompt &lt;prompt&gt;        set the prompt used in GHCi
:set prompt-cont &lt;prompt&gt;   set the continuation prompt used in GHCi
:set prompt-function &lt;expr&gt; set the function to handle the prompt
:set prompt-cont-function &lt;expr&gt;set the function to handle the continuation prompt
:set editor &lt;cmd&gt;           set the command used for :edit
:set stop [&lt;n&gt;] &lt;cmd&gt;       set the command to run when a breakpoint is hit
:unset &lt;option&gt; &#x2026;         unset options
</p>

<p>
Options for &rsquo;:set&rsquo; and &rsquo;:unset&rsquo;:
</p>

<p>
+m            allow multiline commands
+r            revert top-level expressions after each evaluation
+s            print timing/memory stats after each evaluation
+t            print type after evaluation
+c            collect type/location info after loading modules
-&lt;flags&gt;      most GHC command line flags can also be set here
		     (eg. -v2, -XFlexibleInstances, etc.)
		for GHCi-specific flags, see User&rsquo;s Guide,
		Flag reference, Interactive-mode options
</p>

<p>
&#x2013; Commands for displaying information:
</p>

<p>
:show bindings              show the current bindings made at the prompt
:show breaks                show the active breakpoints
:show context               show the breakpoint context
:show imports               show the current imports
:show linker                show current linker state
:show modules               show the currently loaded modules
:show packages              show the currently active package flags
:show paths                 show the currently active search paths
:show language              show the currently active language flags
:show targets               show the current set of targets
:show &lt;setting&gt;             show value of &lt;setting&gt;, which is one of
			       [args, prog, editor, stop]
:showi language             show language flags for interactive evaluation
</p>

</div>
</div>
</div>
<div id="outline-container-orgb23bcbc" class="outline-3">
<h3 id="orgb23bcbc"><a href="#orgb23bcbc">型推論</a></h3>
<div class="outline-text-3" id="text-orgb23bcbc">
<p>
式の後ろに書く::と型の組み合わせのことを <code>型シグネチャ</code> という。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type 'a'
'a' :: Char
</pre>
</div>

<div class="results" id="org740112e">
<p>
&rsquo;a&rsquo; :: Char
&rsquo;a&rsquo;
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">[1, 2, 3] :: Int
</pre>
</div>

<div class="results" id="org12115c1">
<p>
In an equation for ‘it’: it = [1, 2, 3] :: Int
</p>

</div>
</div>
</div>
<div id="outline-container-orge38ed3c" class="outline-3">
<h3 id="orge38ed3c"><a href="#orge38ed3c">関数適用</a></h3>
<div class="outline-text-3" id="text-orge38ed3c">
<div class="org-src-container">
<pre class="src src-haskell">odd 3
</pre>
</div>

<div class="results" id="org8b2ec67">
<p>
True
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">odd 6
</pre>
</div>

<div class="results" id="org88ea9d5">
<p>
False
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">compare 3 3
</pre>
</div>

<div class="results" id="org3b91d12">
<p>
EQ
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">compare 3 2
</pre>
</div>

<div class="results" id="orgce15457">
<p>
GT
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">(compare 2 3) == LT
compare 2 3 == LT
</pre>
</div>

<div class="results" id="org387e9c1">
<p>
True
True
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">compare (sqrt 3) (sqrt 6)
</pre>
</div>

<div class="results" id="org01db35f">
<p>
LT
</p>

</div>
</div>
</div>
<div id="outline-container-org94f39f2" class="outline-3">
<h3 id="org94f39f2"><a href="#org94f39f2">合成データ型: リスト</a></h3>
<div class="outline-text-3" id="text-org94f39f2">
<p>
合成データ型は他のデータ型から構成する。よく使う合成データ型はリスト(可変長)とタプル(固定長)。
</p>

<p>
リスト型は <code>多相的</code> である。多相型を書く場合には <code>型変数</code> を使う。
<code>head :: [a] -&gt; a</code> は「どんな型の値を含むかはわからないが、その型の値のリストは作れる」と言っている。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:type head
head [1,2,3,4]
head ['a','b','c']
tail [1,2,3,4]
tail [True,False]
</pre>
</div>

<div class="results" id="orgce814bf">
<p>
&lt;interactive&gt;:5924:1-17: error:
    • No instance for (Show Bool) arising from a use of ‘print’
      There are instances for similar types:
        instance Show Prelude.Bool &#x2013; Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">-- 評価結果のBoolがリンクで解釈されてエクスポート時にエラーになるので再評価しない。
:type [[True],[False,False]]
</pre>
</div>

<div class="results" id="orgaf7462f">
<p>
[[True],[False,False]] :: <code>[[Bool]]</code>
</p>

</div>

<p>
異なる型ではエラー。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type [1, 'a']
</pre>
</div>

<div class="results" id="orgafe9ba5">
<p>
&lt;interactive&gt;:1:2: error:
    • No instance for (Num Char) arising from the literal ‘1’
    • In the expression: 1
      In the expression: [1, &rsquo;a&rsquo;]
</p>

</div>
</div>
</div>

<div id="outline-container-org63518a6" class="outline-3">
<h3 id="org63518a6"><a href="#org63518a6">合成データ型: タプル</a></h3>
<div class="outline-text-3" id="text-org63518a6">
<p>
リストと違ってタプルは型が異なっていてもOK。
</p>

<div class="org-src-container">
<pre class="src src-haskell">(1964, "Labyrinths")
()
</pre>
</div>

<div class="results" id="orge53ddca">
<p>
(1964,&ldquo;Labyrinths&rdquo;)
()
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type (True, "hello")
</pre>
</div>

<div class="results" id="orgbec7d6e">
<p>
(True, &ldquo;hello&rdquo;) :: (Bool, [Char])
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type (4, ['a', 'm'], (16, True))
</pre>
</div>

<div class="results" id="orgd5c8961">
<p>
(4, [&rsquo;a&rsquo;, &rsquo;m&rsquo;], (16, True))
  :: (Num a1, Num a2) =&gt; (a1, [Char], (a2, Bool))
</p>

</div>

<p>
タプルの型は数/位置/その位置に含まれる要素の型、で表す。
含まれている要素の型や数が異なれば別の型。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type (False, 'a')
</pre>
</div>

<div class="results" id="org4ad80fd">
<p>
(False, &rsquo;a&rsquo;) :: (Bool, Char)
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type ('a', False)
</pre>
</div>

<div class="results" id="orgb6c2940">
<p>
(&rsquo;a&rsquo;, False) :: (Char, Bool)
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type (False, 'a')
</pre>
</div>

<div class="results" id="orgc6d4296">
<p>
(False, &rsquo;a&rsquo;) :: (Bool, Char)
</p>

</div>
</div>
</div>
<div id="outline-container-org4f3c1d6" class="outline-3">
<h3 id="org4f3c1d6"><a href="#org4f3c1d6">関数</a></h3>
<div class="outline-text-3" id="text-org4f3c1d6">
<div class="org-src-container">
<pre class="src src-haskell">take 2 [1,2,3,4,5]
</pre>
</div>

<div class="results" id="org86fa103">
<p>
[1,2]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">drop 3 [1,2,3,4,5]
</pre>
</div>

<div class="results" id="org2bdffe9">
<p>
[4,5]
</p>

</div>

<p>
⚠ <code>fst(1,'a')</code> と空白なしで書くと、引数2つに見えるが、違うことに注意。
単一のペアへの関数の適用である。
</p>

<div class="org-src-container">
<pre class="src src-haskell">fst (1,'a')
</pre>
</div>

<div class="results" id="org7990a31">
<p>
1
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">snd (1,'a')
</pre>
</div>

<div class="results" id="org5fef489">
<p>
&rsquo;a&rsquo;
</p>

</div>
</div>
</div>
<div id="outline-container-orge4963ef" class="outline-3">
<h3 id="orge4963ef"><a href="#orge4963ef">関数の型</a></h3>
<div class="outline-text-3" id="text-orge4963ef">
<div class="org-src-container">
<pre class="src src-haskell">:type lines
</pre>
</div>

<div class="results" id="orgda2f9d0">
<p>
lines :: String -&gt; [String]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">lines "the quick\nbrown for\njumps"
</pre>
</div>

<div class="results" id="orgc12cac7">
<p>
[&ldquo;the quick&rdquo;,&ldquo;brown for&rdquo;,&ldquo;jumps&rdquo;]
</p>

</div>

<p>
副作用がある関数で結果の型は <code>IO</code> ではじまる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type readFile
</pre>
</div>

<div class="results" id="org93c42ea">
<p>
readFile :: FilePath -&gt; IO String
</p>

</div>
</div>
</div>
<div id="outline-container-orga60e2d0" class="outline-3">
<h3 id="orga60e2d0"><a href="#orga60e2d0">関数定義</a></h3>
<div class="outline-text-3" id="text-orga60e2d0">
<p>
Haskellのコードの中では、記号 <code>=</code> は「〜を意味する」ということ。左辺の名前は右辺の式であると定義される。
変数は式に名前をつける手段。
</p>

<blockquote>
<p>
命令形言語を使ってきたのなら、変数は、異なる辞典で、異なる値を格納し得るメモリの番地(またはそれに類するもの)を特定する方法と考えるのが自然かもしれません。命令形言語では、いつでも変数の値を変更することが可能です。したがって、その変数のメモリ番地を確認するたびに違う結果になりえます。
変数に対する、この2つの概念には決定的な違いがあります。Haskellでは、式にいったん束縛した変数は、いつでも元の式に置き換えても良いのです。変数の値は変わらないからです。命令形言語はこの置き換え可能性を保持していません。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-haskell">add a b = a + b
add 1 2
</pre>
</div>

<div class="results" id="orge3aedd5">
<p>

</p>

<p>
3
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">drop 2 "foobar"
drop 4 "foobar"
drop 4 [1, 2]
drop 0 [1, 2]
drop 7 []
drop (-2) "foo"
</pre>
</div>

<div class="results" id="orgcf34ad0">
<p>
obar
ar
[]
[1,2]
[]
foo
</p>

</div>
</div>
</div>
<div id="outline-container-orgd7e8d25" class="outline-3">
<h3 id="orgd7e8d25"><a href="#orgd7e8d25">myDrop関数</a></h3>
<div class="outline-text-3" id="text-orgd7e8d25">
<p>
インデントによって既存の定義が継続する。
org-babelでは1行ごとで新しいセッションになってしまうよう。 <code>:{</code> と <code>}:</code> を使って複数行評価されるようにする。
</p>

<p>
変数名 <code>xs</code> は <code>x</code> の複数形という意味。
</p>

<p>
式指向のためelseが必須(elseに入ったとき結果や型がないという事態になるため)。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
  myDrop n xs = if n &lt;= 0 || null xs
                then xs
                else myDrop (n - 1) (tail xs)
:}

myDrop 2 "foobar"
myDrop 4 "foobar"
myDrop 4 [1, 2]
myDrop 0 [1, 2]
myDrop 7 []
myDrop(-2) "foo"
</pre>
</div>

<div class="results" id="org9ddb0aa">
<p>

</p>

<p>
GHCi&gt; &ldquo;obar&rdquo;
ar
[]
[1,2]
[]
foo
</p>

</div>

<p>
論理演算子。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:type null
:type (||)
</pre>
</div>

<div class="results" id="org64a9142">
<p>
null :: Foldable t =&gt; t a -&gt; Prelude.Bool
(||) :: Prelude.Bool -&gt; Prelude.Bool -&gt; Prelude.Bool
</p>

</div>
</div>
</div>
<div id="outline-container-org83726e3" class="outline-3">
<h3 id="org83726e3"><a href="#org83726e3">遅延評価</a></h3>
<div class="outline-text-3" id="text-org83726e3">
<p>
正格評価: 関数を適用する前に関数への引数を評価する。
<b>非正格評価(遅延評価)</b>: 評価せず、値が必要になったとき計算する「プロミス」を作る。未評価の式を追跡するのに使うレコードを <b>サンク</b> という。式の結果が使われないなら、値は計算されない。
</p>

<div class="org-src-container">
<pre class="src src-haskell">isOdd n = mod n 2 == 1
isOdd 3
</pre>
</div>

<div class="results" id="org74842f5">
<p>

</p>

<p>
True
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">print (myDrop 2 "abcd")

:type 2 &lt;= 0 || null "abcd"
null "abcd"
</pre>
</div>

<div class="results" id="org63ef469">
<p>
cd
GHCi&gt; 2 &lt;= 0 || null &ldquo;abcd&rdquo; :: Prelude.Bool
False
</p>

</div>
</div>
</div>
<div id="outline-container-org6c40d23" class="outline-3">
<h3 id="org6c40d23"><a href="#org6c40d23">型変数</a></h3>
<div class="outline-text-3" id="text-org6c40d23">
<div class="org-src-container">
<pre class="src src-haskell">last [1,2,3]
last "baz"
:type last
</pre>
</div>

<div class="results" id="org605b73a">
<p>
3
&rsquo;z&rsquo;
last :: [a] -&gt; a
</p>

</div>

<p>
この <code>a</code> が型変数。
型シグネチャに型変数を持つときには引数のいくつかはどのような型にでもなれることを示している。→ 多相的である。
</p>
</div>
</div>
<div id="outline-container-org77de527" class="outline-3">
<h3 id="org77de527"><a href="#org77de527">多相関数</a></h3>
<div class="outline-text-3" id="text-org77de527">
<div class="org-src-container">
<pre class="src src-haskell">:type fst
</pre>
</div>

<div class="results" id="org41ef1a6">
<p>
fst :: (a, b) -&gt; a
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type take
</pre>
</div>

<div class="results" id="org27972b9">
<p>
take :: Int -&gt; [a] -&gt; [a]
</p>

</div>

<p>
これは実際にはこういうこと↓。
</p>

<p>
<code>take :: Int -&gt; ([a] -&gt; [a])</code>
</p>
</div>
</div>
<div id="outline-container-orgea0d020" class="outline-3">
<h3 id="orgea0d020"><a href="#orgea0d020">純粋性</a></h3>
<div class="outline-text-3" id="text-orgea0d020">
<div class="org-src-container">
<pre class="src src-haskell">:type not
</pre>
</div>

<div class="results" id="orgcf438c2">
<p>
not :: Prelude.Bool -&gt; Prelude.Bool
</p>

</div>
</div>
</div>
<div id="outline-container-org9a13bd9" class="outline-3">
<h3 id="org9a13bd9"><a href="#org9a13bd9">型定義</a></h3>
<div class="outline-text-3" id="text-org9a13bd9">
<p>
↓ BookInfoを <code>型構成子</code> という。
続く Bookは <code>値構成子</code> という。
Int, String, [String]は <code>構成要素</code> という。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
data BookInfo = Book Int String [String]
                deriving (Show)
:}
</pre>
</div>

<div class="results" id="orgc1d0f98">

</div>

<p>
同じ構造を持っていても、2つの型を区別する。型構成子と値構成子の名前が違うから。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
data MagazineInfo = Magazine Int String [String]
                    deriving (Show)
:}
</pre>
</div>

<div class="results" id="orgcec36cf">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:info BookInfo

myInfo = Book 9780135072455 "Algebra of Programming" ["Richard Bird", "Oege de Moor"]
myInfo
:type myInfo
:type Book
</pre>
</div>

<div class="results" id="org833a424">
<p>
data BookInfo = Book Int String [String]
  &#x2013; Defined at &lt;interactive&gt;:6313:1
instance [safe] Show BookInfo &#x2013; Defined at &lt;interactive&gt;:6314:27
GHCi&gt; GHCi&gt; Book 9780135072455 &ldquo;Algebra of Programming&rdquo; [&ldquo;Richard Bird&rdquo;,&ldquo;Oege de Moor&rdquo;]
myInfo :: BookInfo
Book :: Int -&gt; String -&gt; [String] -&gt; BookInfo
</p>

</div>
</div>
</div>
<div id="outline-container-org693b74a" class="outline-3">
<h3 id="org693b74a"><a href="#org693b74a">型シノニム</a></h3>
<div class="outline-text-3" id="text-org693b74a">
<p>
型シノニムはコードを読みやすくするだけのもの。
</p>

<div class="org-src-container">
<pre class="src src-haskell">type CustomerID = Int
type ReviewBody = String
data BetterReview = BetterReview BookInfo CustomerID ReviewBody
</pre>
</div>

<div class="results" id="orgdd59312">

</div>
</div>
</div>
<div id="outline-container-org648f878" class="outline-3">
<h3 id="org648f878"><a href="#org648f878">代数データ型</a></h3>
<div class="outline-text-3" id="text-org648f878">
<p>
値構成子が2つある。 <b>選択肢</b> あるいは <b>ケース</b> という。
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Bool = False | True
</pre>
</div>

<div class="results" id="orgd812580">

</div>

<div class="org-src-container">
<pre class="src src-haskell">type CardHolder = String
type CardNumber = String
type Address = [String]

:{
data BillingInfo = CreditCard CardNumber CardHolder Address
                   | CashOnDelivery
                   | Invoice CustomerID
                     deriving (Show)
:}
:info BillingInfo
</pre>
</div>

<div class="results" id="orgde6e913">
<p>

</p>

<p>
GHCi&gt; GHCi&gt; GHCi&gt; Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| GHCi&gt; data BillingInfo
  = CreditCard CardNumber CardHolder Address
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">CashOnDelivery</td>
</tr>

<tr>
<td class="org-left">Invoice CustomerID</td>
</tr>
</tbody>
</table>
<p>
  &#x2013; Defined at &lt;interactive&gt;:6340:1
instance [safe] Show BillingInfo
  &#x2013; Defined at &lt;interactive&gt;:6343:32
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type CreditCard
CreditCard "2901650221064486" "Thomas Gradgrind"  ["Dickens", "England"]
</pre>
</div>

<div class="results" id="orgd63689a">
<p>
CreditCard :: CardNumber -&gt; CardHolder -&gt; Address -&gt; BillingInfo
CreditCard &ldquo;2901650221064486&rdquo; &ldquo;Thomas Gradgrind&rdquo; [&ldquo;Dickens&rdquo;,&ldquo;England&rdquo;]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type it
</pre>
</div>

<div class="results" id="org145d2c2">
<p>
it :: [Char]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type Invoice
Invoice 2222
</pre>
</div>

<div class="results" id="org7311c6b">
<p>
Invoice :: CustomerID -&gt; BillingInfo
Invoice 2222
</p>

</div>
</div>
</div>

<div id="outline-container-orgbeab2fd" class="outline-3">
<h3 id="orgbeab2fd"><a href="#orgbeab2fd">タプルと代数データ型</a></h3>
<div class="outline-text-3" id="text-orgbeab2fd">
<div class="org-src-container">
<pre class="src src-haskell">Book 2 "The Wealth of Networks" ["Yochai Benkler"]
(2, "The Wealth of Networks", ["Yochai Benkler"])
</pre>
</div>

<div class="results" id="org50b7d48">
<p>
Book 2 &ldquo;The Wealth of Networks&rdquo; [&ldquo;Yochai Benkler&rdquo;]
(2,&ldquo;The Wealth of Networks&rdquo;,[&ldquo;Yochai Benkler&rdquo;])
</p>

</div>

<p>
↓構造的に同一なので同じ型。
</p>

<div class="org-src-container">
<pre class="src src-haskell">a = ("Porpoise", "Gray")
b = ("Table", "Oak")
</pre>
</div>

<div class="results" id="org2fb09d5">

</div>

<p>
↓別の名前なので別の型。
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Cetacean = Cetacean String String
data Furniture = Furniture String String

c = Cetacean "Porpoise" "Gray"
d = Furniture "Table" "Oak"
</pre>
</div>

<div class="results" id="org9cdc39d">

</div>

<p>
座標。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
-- x, yの座標
data Cartesian2D = Cartesian2D Double Double
                   deriving (Eq, Show)

-- 偏角と長さ
data Polar2D = Polar2D Double Double
               deriving (Eq, Show)
:}
</pre>
</div>

<div class="results" id="orge4bfdf1">

</div>

<p>
<code>==</code> 演算子は引数が同じ型でないといけないのでエラー。
</p>

<div class="org-src-container">
<pre class="src src-haskell">Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
</pre>
</div>

<div class="results" id="org82d60e4">
<p>
In an equation for ‘it’:
          it = Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
</p>

</div>

<p>
タプルの場合判断しようがないのでチェックが効かない。
</p>

<div class="org-src-container">
<pre class="src src-haskell">(1, 2) == (1, 2)
</pre>
</div>

<div class="results" id="orgcd239fd">
<p>
True
</p>

</div>

<ul class="org-ul">
<li>複合型をコードの中で広く使う場合には <code>data</code> 宣言を使う</li>
<li>規模が小さく、局所的にしか使わない場合はタプルでいい</li>
</ul>
</div>
</div>

<div id="outline-container-org6edd62c" class="outline-3">
<h3 id="org6edd62c"><a href="#org6edd62c">他の言語との類似</a></h3>
<div class="outline-text-3" id="text-org6edd62c">
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">struct</span> <span class="org-type">book_info</span> {
  <span class="org-type">int</span> <span class="org-variable-name">id</span>;
  <span class="org-type">char</span> *<span class="org-variable-name">name</span>;
  <span class="org-type">char</span> **<span class="org-variable-name">authors</span>;
};
</pre>
</div>

<div class="results" id="orge8a1b21">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
data BookInfo = Book Int String [String]
                  deriving (Show)
:}
</pre>
</div>

<div class="results" id="org30ed7dd">

</div>
</div>
</div>

<div id="outline-container-org734bfd9" class="outline-3">
<h3 id="org734bfd9"><a href="#org734bfd9">列挙型</a></h3>
<div class="outline-text-3" id="text-org734bfd9">
<p>
<a href="20210911104632-c_language.html#ID-656a0aa4-e5d3-416f-82d5-f909558d0639">C language</a>ではこう書く。
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">enum</span> <span class="org-type">roygbiv</span> {
  <span class="org-variable-name">red</span>,
  <span class="org-variable-name">orange</span>,
  <span class="org-variable-name">yellow</span>,
  <span class="org-variable-name">green</span>,
  <span class="org-variable-name">blue</span>,
  <span class="org-variable-name">indigo</span>,
  <span class="org-variable-name">violet</span>,
};
</pre>
</div>

<div class="results" id="org9aa209d">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
data Roygbiv = Red
             | Orange
             | Yellow
             | Green
             | Blue
             | Indigo
             | Violet
               deriving (Eq, Show)
:}
:type Yellow
:type Red
Red == Yellow
Green == Green
</pre>
</div>

<div class="results" id="org21b9225">
<p>

</p>

<p>
Yellow :: Roygbiv
Red :: Roygbiv
False
True
</p>

</div>

<p>
haskellのenumは型が厳密。
</p>
<div class="org-src-container">
<pre class="src src-haskell">take 3 "foobar"
take Red "foobar"
</pre>
</div>

<div class="results" id="org575efd8">
<p>
foo
&lt;interactive&gt;:6405:6-8: error:
    • Couldn&rsquo;t match expected type ‘Int’ with actual type ‘Roygbiv’
    • In the first argument of ‘take’, namely ‘Red’
      In the expression: take Red &ldquo;foobar&rdquo;
      In an equation for ‘it’: it = take Red &ldquo;foobar&rdquo;
</p>

</div>
</div>
</div>

<div id="outline-container-orgb8299ba" class="outline-3">
<h3 id="orgb8299ba"><a href="#orgb8299ba">union</a></h3>
<div class="outline-text-3" id="text-orgb8299ba">
<p>
代数データ型が複数の選択肢を持つ場合は<a href="20210911104632-c_language.html#ID-656a0aa4-e5d3-416f-82d5-f909558d0639">C language</a>の <code>union</code> と同じ。
</p>
<div class="org-src-container">
<pre class="src src-haskell">type Vector = (Double, Double)
:{
data Shape = Circle Vector Double
           | Poly [Vector]
:}
:info Shape
</pre>
</div>

<div class="results" id="orgd90e505">
<p>

</p>

<p>
GHCi&gt; data Shape = Circle Vector Double | Poly [Vector]
&#x2013; Defined at &lt;interactive&gt;:6409:1
</p>

</div>
</div>
</div>

<div id="outline-container-org168f36c" class="outline-3">
<h3 id="org168f36c"><a href="#org168f36c">パターンマッチ</a></h3>
<div class="outline-text-3" id="text-org168f36c">
<p>
↓2つの関数というわけではない。
同一関数の異なる入力パターンに対する振る舞いを定義している。
</p>

<div class="org-src-container">
<pre class="src src-haskell">myNot True = False
myNot False = True
</pre>
</div>

<div class="results" id="org19a200e">

</div>

<div class="org-src-container">
<pre class="src src-haskell">sumList (x:xs) = x + sumList xs
sumList [] = 0

sum [1,2]
</pre>
</div>

<div class="results" id="org11eb17b">
<p>

</p>

<p>
GHCi&gt; 3
</p>

</div>

<p>
タプルのパターンマッチ。
</p>

<div class="org-src-container">
<pre class="src src-haskell">complicated (True, a, x:xs, 5) = (a, xs)
complicated (True, 1, [1,2,3], 5)
</pre>
</div>

<div class="results" id="org915eae5">
<p>

</p>

<p>
(1,[2,3])
</p>

</div>

<p>
ぴったり一致しないと成功しない。
すべてのパターンマッチが失敗すると実行時エラー。
</p>

<div class="org-src-container">
<pre class="src src-haskell">complicated (False, 1, [1,2,3], 5)
</pre>
</div>

<div class="results" id="org0e5d874">
<pre class="example">
*** Exception: &lt;interactive&gt;:1963:1-40: Non-exhaustive patterns in function complicated
</pre>

</div>
</div>
</div>

<div id="outline-container-org9b3a459" class="outline-3">
<h3 id="org9b3a459"><a href="#org9b3a459">Exception: &lt;interactive&gt;:6422:1-40: Non-exhaustive patterns in function complicated</a></h3>
<div class="outline-text-3" id="text-org9b3a459">
<p>
BookInfo型の場合。
パターンマッチをセット。
</p>

<div class="org-src-container">
<pre class="src src-haskell">bookID (Book id title authors) = id
bookTitle (Book id title authors) = title
bookAuthors (Book id title authors) = authors
</pre>
</div>

<div class="results" id="org7343b45">

</div>

<p>
アクセスできる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">bookID (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
bookTitle (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
bookAuthors (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
</pre>
</div>

<div class="results" id="org0e15750">
<p>
3
Probability Theory
[&ldquo;E.T.H. Jaynes&rdquo;]
</p>

</div>

<p>
構成子に基づいて、アクセサ関数の型を推論できる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type bookID
:type bookTitle
:type bookAuthors
</pre>
</div>

<div class="results" id="org8b96103">
<p>
bookID :: BookInfo -&gt; Int
bookTitle :: BookInfo -&gt; String
bookAuthors :: BookInfo -&gt; [String]
</p>

</div>
</div>
</div>
<div id="outline-container-orga8545a4" class="outline-3">
<h3 id="orga8545a4"><a href="#orga8545a4">ワイルドカード</a></h3>
<div class="outline-text-3" id="text-orga8545a4">
<p>
この類のコードをボイラープレートという。
</p>

<div class="org-src-container">
<pre class="src src-haskell">nicerID (Book id _ _ ) = id
nicerTitle (Book _ title _) = title
nicerAuthors (Book _ _ authors) = authors
</pre>
</div>

<div class="results" id="org2cc986a">

</div>

<div class="org-src-container">
<pre class="src src-haskell">goodExample (x:xs) = x + goodExample xs
goodExample _ = 0
goodExample []
goodExample [1, 2]
</pre>
</div>

<div class="results" id="org0613cd6">
<p>

</p>

<p>
GHCi&gt; 0
0
</p>

</div>
</div>
</div>
<div id="outline-container-org18e092e" class="outline-3">
<h3 id="org18e092e"><a href="#org18e092e">レコード構文</a></h3>
<div class="outline-text-3" id="text-org18e092e">
<div class="org-src-container">
<pre class="src src-haskell">:{
  data Customer = Customer {
     customerID :: CustomerID
   , customerName :: String
   , customerAddress :: Address
     } deriving (Show)
:}
:type customerID
</pre>
</div>

<div class="results" id="orgcfe7620">
<p>

</p>

<p>
customerID :: Customer -&gt; CustomerID
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
customer2 = Customer {
    customerID = 271828
  , customerAddress = ["1048576 Disk Drive",
                      "Milpitas, CA 95134",
                      "USA"]
  , customerName = "Jane Q. Citizen"
  }
:}
customer2
cities
</pre>
</div>

<div class="results" id="org3eb41d6">
<p>

</p>

<p>
Customer {customerID = 271828, customerName = &ldquo;Jane Q. Citizen&rdquo;, customerAddress = [&ldquo;1048576 Disk Drive&rdquo;,&ldquo;Milpitas, CA 95134&rdquo;,&ldquo;USA&rdquo;]}
Book 173 &ldquo;Use of weapons&rdquo; [&ldquo;Iain M. Banks&rdquo;]
</p>

</div>

<p>
レコード構文によって使えるアクセサ関数は、通常のHaskellの関数。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type customerName
customerName customer2
</pre>
</div>

<div class="results" id="orgba3137e">
<p>
customerName :: Customer -&gt; String
Jane Q. Citizen
</p>

</div>
</div>
</div>
<div id="outline-container-org4958697" class="outline-3">
<h3 id="org4958697"><a href="#org4958697">パラメータ化された型</a></h3>
<div class="outline-text-3" id="text-org4958697">
<p>
独自に定義する型も多相型にできる。型宣言に型変数を導入する。
</p>

<p>
↓この変数は型変数。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
data Maybe a = Just a
             | Nothing
:}
:info Maybe
</pre>
</div>

<div class="results" id="org7f3281b">
<p>

</p>

<p>
data Maybe a = Just a | Nothing &#x2013; Defined at &lt;interactive&gt;:6475:1
</p>

</div>

<p>
これによって任意の型上の <code>Maybe</code> 型を使える。
</p>

<div class="org-src-container">
<pre class="src src-haskell">someBool = Just True
:type someBool
someString = Just "something"
:type someString
:type Just "Invisible bike"
</pre>
</div>

<div class="results" id="org1969c81">
<p>
someBool :: Maybe Bool
GHCi&gt; someString :: Maybe [Char]
Just &ldquo;Invisible bike&rdquo; :: Maybe [Char]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">wrapped = Just (Just "wrapped")
:type wrapped
</pre>
</div>

<div class="results" id="org7e07f39">
<p>

</p>

<p>
wrapped :: Maybe (Maybe [Char])
</p>

</div>
</div>
</div>
<div id="outline-container-orgb2dc631" class="outline-3">
<h3 id="orgb2dc631"><a href="#orgb2dc631">再帰型</a></h3>
<div class="outline-text-3" id="text-orgb2dc631">
<p>
リスト型は再帰型。定義に自身が含まれる。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
data List a = Cons a (List a)
            | Nil
              deriving (Show)
:}
</pre>
</div>

<div class="results" id="orgc850c45">

</div>

<p>
確かめる。
</p>
<div class="org-src-container">
<pre class="src src-haskell">Nil
Cons 0 Nil
Cons 1 it
Cons 2 it
Cons 3 it
</pre>
</div>

<div class="results" id="org6cf89db">
<p>
Nil
Cons 0 Nil
Cons 1 (Cons 0 Nil)
Cons 2 (Cons 1 (Cons 0 Nil))
Cons 3 (Cons 2 (Cons 1 (Cons 0 Nil)))
</p>

</div>

<p>
二分木。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
data Tree a = Node a (Tree a) (Tree a)
            | Empty
              deriving (Show)
:}
</pre>
</div>

<div class="results" id="org1e39e2a">

</div>

<p>
本と違ってなぜかエラーになる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">fromList (x:xs) = Cons x (fromList xs)
fromList [] = Nil
fromList "durian"
fromList [Just True, Nothing, Just False]
</pre>
</div>

<div class="results" id="org1570ce9">
<p>
GHCi&gt; <b>*</b> Exception: &lt;interactive&gt;:6518:1-17: Non-exhaustive patterns in function fromList
Exception: &lt;interactive&gt;:6518:1-17: Non-exhaustive patterns in function fromList
</p>

</div>

<p>
<a href="20211007104541-java.html#ID-9fa3711b-a22e-4cf5-ae97-5c057083674a">Java</a>の例(クラス定義)。
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">class</span> <span class="org-type">Tree</span>&lt;<span class="org-type">A</span>&gt;
{
    <span class="org-type">A</span> <span class="org-variable-name">value</span>;
    <span class="org-type">Tree</span>&lt;<span class="org-type">A</span>&gt; <span class="org-variable-name">left</span>;
    <span class="org-type">Tree</span>&lt;<span class="org-type">B</span>&gt; <span class="org-variable-name">right</span>;

    <span class="org-keyword">public</span> <span class="org-function-name">Tree</span>(<span class="org-type">A</span> <span class="org-variable-name">v</span>, <span class="org-type">Tree</span>&lt;<span class="org-type">A</span>&gt; <span class="org-variable-name">l</span>, <span class="org-type">Tree</span>&lt;<span class="org-type">A</span>&gt; <span class="org-variable-name">r</span>)
    {
        value = v;
        left = l;
        right = r;
    }
}
</pre>
</div>

<p>
葉を構成する関数。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-keyword">class</span> <span class="org-type">Example</span>
{
    <span class="org-keyword">static</span> <span class="org-type">Tree</span>&lt;<span class="org-type">String</span>&gt; <span class="org-function-name">simpleTree</span>()
    {
        <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">Tree</span>&lt;<span class="org-type">String</span>&gt;(
                                <span class="org-string">"parent"</span>,
                                <span class="org-keyword">new</span> <span class="org-type">Tree</span>&lt;<span class="org-type">String</span>&gt;(<span class="org-string">"left leaf"</span>, <span class="org-constant">null</span>, <span class="org-constant">null</span>),
                                <span class="org-keyword">new</span> <span class="org-type">Tree</span>&lt;<span class="org-type">String</span>&gt;(<span class="org-string">"right leaf"</span>, <span class="org-constant">null</span>, <span class="org-constant">null</span>));
    }
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
simpleTree = Node "parent" (Node "left child" Empty Empty)
                           (Node "right child" Empty Empty)
:}
:type simpleTree
</pre>
</div>

<div class="results" id="orgb431f5b">
<p>

</p>

<p>
simpleTree :: Tree [Char]
</p>

</div>
</div>
</div>
<div id="outline-container-orgdf351d5" class="outline-3">
<h3 id="orgdf351d5"><a href="#orgdf351d5">エラー報告表示</a></h3>
<div class="outline-text-3" id="text-orgdf351d5">
<p>
listの要素が1つのときはエラー表示を出す。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
mySecond :: [a] -&gt; a
mySecond xs = if null (tail xs)
              then error ("list too short")
              else head (tail xs)
:}
mySecond "xi"
mySecond [2, 3]
mySecond [2]
</pre>
</div>

<div class="results" id="org4309384">
<p>
&rsquo;i&rsquo;
3
Exception: list too short
CallStack (from HasCallStack):
  error, called at &lt;interactive&gt;:6531:20 in interactive:Ghci3189
</p>

</div>

<p>
ちゃんとエラーメッセージが出ている。
</p>
</div>
</div>
<div id="outline-container-orgd447bbd" class="outline-3">
<h3 id="orgd447bbd"><a href="#orgd447bbd">エラーの可能性, Maybe</a></h3>
<div class="outline-text-3" id="text-orgd447bbd">
<div class="org-src-container">
<pre class="src src-haskell">:{
safeSecond :: [a] -&gt; Maybe a
safeSecond [] = Nothing
safeSecond xs = if null (tail xs)
                then Nothing
                else Just (head (tail xs))
:}
safeSecond [1,2] -- なぜかできない。
</pre>
</div>

<div class="results" id="orgffa42a7">
<p>

</p>

<p>
&lt;interactive&gt;:6545:1-16: error:
    • No instance for (Show (Maybe Integer))
        arising from a use of ‘print’
      There are instances for similar types:
        instance Show a =&gt; Show (Prelude.Maybe a) &#x2013; Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
</p>

</div>

<p>
パターンマッチを使って改善。
</p>

<div class="org-src-container">
<pre class="src src-haskell">tidySecond :: [a] -&gt; Maybe a

tidySecond (_:x:_) = Just x
tidySecond _       = Nothing
</pre>
</div>

<div class="results" id="org7bd01c2">

</div>
</div>
</div>
<div id="outline-container-org2bd80f7" class="outline-3">
<h3 id="org2bd80f7"><a href="#org2bd80f7">局所変数</a></h3>
<div class="outline-text-3" id="text-org2bd80f7">
<div class="org-src-container">
<pre class="src src-haskell">:{
lend amount balance = let reserve = 100
                          newBalance = balance - amount
                      in if balance &lt; reserve
                         then Nothing
                         else Just newBalance
:}
</pre>
</div>

<div class="results" id="org1a681b9">

</div>
</div>
</div>

<div id="outline-container-org269d026" class="outline-3">
<h3 id="org269d026"><a href="#org269d026">シャドウ</a></h3>
<div class="outline-text-3" id="text-org269d026">
<p>
内側の <code>x</code> が外側の <code>x</code> を隠す。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
bar = let x = 1
      in ((let x = "foo" in x), x)
:}
bar
</pre>
</div>

<div class="results" id="orgbb73cce">
<p>

</p>

<p>
(&ldquo;foo&rdquo;,1)
</p>

</div>
</div>
</div>
<div id="outline-container-org7004e55" class="outline-3">
<h3 id="org7004e55"><a href="#org7004e55">where節</a></h3>
<div class="outline-text-3" id="text-org7004e55">
<div class="org-src-container">
<pre class="src src-haskell">:{
lend2 amount balance = if amount &lt; reserve * 0.5
                       then Just newBalance
                       else Nothing
      where reserve  = 100
            newBalance = balance - amount
:}
</pre>
</div>

<div class="results" id="org6ef2909">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
pluralise :: String -&gt; [Int] -&gt; [String]
pluralise word counts = map plural counts
    where plural 0 = "no " ++ word ++ "s"
          plural 1 = "one " ++ word
          plural n = show n ++ " " ++ word ++ "s"
:}
pluralise "car" [0]
pluralise "car" [1]
pluralise "car" [2]
</pre>
</div>

<div class="results" id="org0ac621d">
<p>

</p>

<p>
[&ldquo;no cars&rdquo;]
[&ldquo;one car&rdquo;]
[&ldquo;2 cars&rdquo;]
</p>

</div>
</div>
</div>
<div id="outline-container-orgdb36bbf" class="outline-3">
<h3 id="orgdb36bbf"><a href="#orgdb36bbf">case式</a></h3>
<div class="outline-text-3" id="text-orgdb36bbf">
<div class="org-src-container">
<pre class="src src-haskell">:{
fromMaybe defval wrapped =
  case wrapped of
    Nothing -&gt; defval
    Just value -&gt; value
:}
</pre>
</div>

<div class="results" id="org8a95d88">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
  data Fruit = Apple | Orange
  betterFruit f = case f of
                  "apple" -&gt; Apple
                  "orange" -&gt; Orange
:}
</pre>
</div>

<div class="results" id="org91a7a28">

</div>
</div>
</div>
<div id="outline-container-org9a33e57" class="outline-3">
<h3 id="org9a33e57"><a href="#org9a33e57">ガード</a></h3>
<div class="outline-text-3" id="text-org9a33e57">
<div class="org-src-container">
<pre class="src src-haskell">:{
nodesAreSame (Node a _ _) (Node b _ _)
    | a == b     = Just a
nodesAreSame _ _ = Nothing
:}
</pre>
</div>

<div class="results" id="orgd841b92">

</div>

<p>
lend関数を書き直す。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
lend3 amount balance
     | amount &lt;= 0            = Nothing
     | amount &gt; reserve * 0.5 = Nothing
     | otherwise              = Just newBalance
    where reserve    = 100
          newBalance = balance - amount
:}
</pre>
</div>

<div class="results" id="orgdf1a4a5">

</div>

<p>
myDrop関数を書き直す。
元コード。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
myDrop n xs = if n &lt;= 0 || null xs
              then xs
              else myDrop (n - 1) (tail xs)
 :}
myDrop 2 "abcd"
</pre>
</div>

<div class="results" id="org929ee51">
<p>

</p>

<p>
cd
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
niceDrop n xs | n &lt;= 0 = xs
niceDrop _ []          = []
niceDrop n (_:xs)      = niceDrop (n - 1) xs
:}
niceDrop 2 "abcd"
</pre>
</div>

<div class="results" id="org5833597">
<p>

</p>

<p>
cd
</p>

</div>
</div>
</div>
<div id="outline-container-orge7d1921" class="outline-3">
<h3 id="orge7d1921"><a href="#orge7d1921">テキスト行分割</a></h3>
<div class="outline-text-3" id="text-orge7d1921">
<div class="org-src-container">
<pre class="src src-haskell">:type lines
lines "line 1\nline 2"
lines "foo\n\nbar\n"
</pre>
</div>

<div class="results" id="orgbddfc57">
<p>
lines :: String -&gt; [String]
[&ldquo;line 1&rdquo;,&ldquo;line 2&rdquo;]
[&ldquo;foo&rdquo;,&ldquo;&rdquo;,&ldquo;bar&rdquo;]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">break odd [2,4,5,6,8]
:module +Data.Char
break isUpper "isUpper"
</pre>
</div>

<div class="results" id="org6b8d98d">
<p>
([2,4],[5,6,8])
GHCi&gt; (&ldquo;is&rdquo;,&ldquo;Upper&rdquo;)
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
  a `plus` b = a + b
  data a `Pair` b = a `Pair` b
             deriving (Show)
  foo = Pair 1 2
  bar = True `Pair` "quux"
:}
1 `plus` 2
plus 1 2
Pair "a" "a"
"a" `Pair` "a"
</pre>
</div>

<div class="results" id="orgb6c8b4b">
<p>

</p>

<p>
3
3
a&ldquo; `Pair` &rdquo;a
a&ldquo; `Pair` &rdquo;a
</p>

</div>
</div>
</div>
<div id="outline-container-org7857664" class="outline-3">
<h3 id="org7857664"><a href="#org7857664">リストの処理</a></h3>
<div class="outline-text-3" id="text-org7857664">
<div class="org-src-container">
<pre class="src src-haskell">:type length
length []
length [1,2,3]
null []
head [1,2]
tail "foo"
last "bar"
</pre>
</div>

<div class="results" id="org0400c8c">
<p>
length :: Foldable t =&gt; t a -&gt; Int
0
3
True
1
oo
&rsquo;r&rsquo;
</p>

</div>

<p>
連結関数。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type (++)
"foo" ++ "bar"
[] ++ [1,2,3]
[1] ++ []
</pre>
</div>

<div class="results" id="org9e9fe4b">
<p>
(++) :: [a] -&gt; [a] -&gt; [a]
foobar
[1,2,3]
[1]
</p>

</div>

<p>
<code>concat</code> 連結して1つのリストにする。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type concat
concat [[1,2,3], [4,5,6]]
concat [[[1,2],[3]], [[4],[5],[6]]]
concat (concat [[1,2],[3]], [[4],[5],[6]])
</pre>
</div>

<div class="results" id="org3c8fdda">
<p>
concat :: Foldable t =&gt; t [a] -&gt; [a]
[1,2,3,4,5,6]
[[1,2],[3],[4],[5],[6]]
[[4],[5],[6]]
</p>

</div>

<p>
<code>reverse</code> 逆順にする。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type reverse
reverse "foo"
</pre>
</div>

<div class="results" id="org16956b5">
<p>
reverse :: [a] -&gt; [a]
oof
</p>

</div>

<p>
便利な条件判定、 <code>all</code> と <code>any</code> 。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type all
all odd [1,3,5]
all odd [3,1,4]
all odd []
:type any
any even [3,1,4]
any even []
</pre>
</div>

<div class="results" id="orgfe9b4d3">
<p>
all :: Foldable t =&gt; (a -&gt; Prelude.Bool) -&gt; t a -&gt; Prelude.Bool
True
False
True
any :: Foldable t =&gt; (a -&gt; Prelude.Bool) -&gt; t a -&gt; Prelude.Bool
True
False
</p>

</div>

<p>
部分リスト。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type take
take 3 "foobar"
take 2 [1]
:type drop
drop 3 "xyzzy"
drop 1 []
</pre>
</div>

<div class="results" id="org5da9991">
<p>
take :: Int -&gt; [a] -&gt; [a]
foo
[1]
drop :: Int -&gt; [a] -&gt; [a]
zy
[]
</p>

</div>

<p>
<code>splitAt</code> インデックスで分割したリストのペアを返す。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:type splitAt
splitAt 3 "foobar"
</pre>
</div>

<div class="results" id="org411e8ac">
<p>
splitAt :: Int -&gt; [a] -&gt; ([a], [a])
(&ldquo;foo&rdquo;,&ldquo;bar&rdquo;)
</p>

</div>

<p>
<code>span</code> 条件に合うもの、以外でリストを返す。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type span
span even [2,4,6,7,9,10,11]
:type break
break even [1,3,5,6,8,9,10]
</pre>
</div>

<div class="results" id="orge05b481">
<p>
span :: (a -&gt; Prelude.Bool) -&gt; [a] -&gt; ([a], [a])
([2,4,6],[7,9,10,11])
break :: (a -&gt; Prelude.Bool) -&gt; [a] -&gt; ([a], [a])
([1,3,5],[6,8,9,10])
</p>

</div>

<p>
<code>elem</code> 値がリスト中に存在するか示す。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type elem
2 `elem` [5,3,2,1,1]
2 `notElem` [5,3,2,1,1]
</pre>
</div>

<div class="results" id="org5173901">
<p>
elem :: (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Prelude.Bool
True
False
</p>

</div>

<p>
<code>filter</code> 条件に合うリストを返す。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type filter
 filter odd [2,4,1,3,6,8,5,7]
</pre>
</div>

<div class="results" id="orgfc8d2de">
<p>
filter :: p -&gt; [a1] -&gt; [a2]
Exception: &lt;interactive&gt;:4825:1-16: Non-exhaustive patterns in function filter
</p>

</div>

<p>
<code>isPrefixOf</code> 部分リストがより大きなリストの中にあるか調べる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:module +Data.List
:type isPrefixOf
"foo" `isPrefixOf` "foobar"
[1,2] `isPrefixOf` []
</pre>
</div>

<div class="results" id="orgb78a622">
<p>

</p>

<p>
isPrefixOf :: Eq a =&gt; [a] -&gt; [a] -&gt; Prelude.Bool
True
False
</p>

</div>

<p>
<code>zip</code> 2つのリストをペアのリストにする。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type zip
zip [12,72,93] "zippity"
</pre>
</div>

<div class="results" id="orgf4b8c94">
<p>
zip :: [a] -&gt; [b] -&gt; [(a, b)]
[(12,&rsquo;z&rsquo;),(72,&rsquo;i&rsquo;),(93,&rsquo;p&rsquo;)]
</p>

</div>

<p>
<code>zipWith</code> 2つのリストのペアごとに関数を適用する。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type zipWith
zipWith (+) [1,2,3] [4,5,6]
</pre>
</div>

<div class="results" id="orgaf775e1">
<p>
zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
[5,7,9]
</p>

</div>

<p>
可変長引数はHaskellの型システムのうえでは難しい。
複数のリストを閉じ合わせるには <code>zip3</code> 〜 <code>zip7`</code> を使う。
</p>
</div>
</div>
<div id="outline-container-orgf7bb316" class="outline-3">
<h3 id="orgf7bb316"><a href="#orgf7bb316">リストのいけてる扱い方</a></h3>
<div class="outline-text-3" id="text-orgf7bb316">
<p>
haskellにおいてはほかの言語と同じように、扱えない部分がある。
<code>length</code> はリスト全体を辿らないといけないが、無限リストである可能性がある。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
  mySmartExample xs = if not (null xs)
                      then head xs
                      else 'Z'
  myOtherExample (x:_) = x
  myOtherExample [] = 'Z'
:}
mySmartExample "head"
mySmartExample []
</pre>
</div>

<div class="results" id="orgddc4520">
<p>

</p>

<p>
&rsquo;h&rsquo;
&rsquo;Z&rsquo;
</p>

</div>
</div>
</div>
<div id="outline-container-orgb7a1328" class="outline-3">
<h3 id="orgb7a1328"><a href="#orgb7a1328">部分関数</a></h3>
<div class="outline-text-3" id="text-orgb7a1328">
<p>
正当な入力の部分集合の値に対してのみ値を返す関数のことを部分関数という。
入力の全定義域に対して正しい結果を返す関数のことを全関数という。
</p>
</div>
</div>
<div id="outline-container-org8b2d07c" class="outline-3">
<h3 id="org8b2d07c"><a href="#org8b2d07c">文字列専用の関数</a></h3>
<div class="outline-text-3" id="text-org8b2d07c">
<div class="org-src-container">
<pre class="src src-haskell">lines "foo\nbar"
unlines ["foo", "bar"]
</pre>
</div>

<div class="results" id="org748d844">
<p>
[&ldquo;foo&rdquo;,&ldquo;bar&rdquo;]
foo\nbar\n
</p>

</div>

<p>
<code>words</code> は入力文字を任意の空白で区切る。
</p>

<div class="org-src-container">
<pre class="src src-haskell">words "the \r quick \t brown\n\n\nfox"
unwords ["jumps", "over", "the", "lazy", "dog"]
</pre>
</div>

<div class="results" id="org4a814c9">
<p>
[&ldquo;the&rdquo;,&ldquo;quick&rdquo;,&ldquo;brown&rdquo;,&ldquo;fox&rdquo;]
jumps over the lazy dog
</p>

</div>
</div>
</div>
<div id="outline-container-org1874491" class="outline-3">
<h3 id="org1874491"><a href="#org1874491">ループ</a></h3>
<div class="outline-text-3" id="text-org1874491">
<p>
Haskellには、 <code>for</code> ループ、 <code>while</code> ループはない。
</p>

<p>
<a href="20210911104632-c_language.html#ID-656a0aa4-e5d3-416f-82d5-f909558d0639">C language</a>の例。
こんなふうにはできないので末尾再帰を使う。
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">int</span> <span class="org-function-name">as_int</span>(<span class="org-type">char</span> *<span class="org-variable-name">str</span>)
{
  <span class="org-type">int</span> <span class="org-variable-name">acc</span>;
  <span class="org-keyword">for</span> (acc = 0; isdigit(*str); str++) {
    acc = acc * 10 + (*str - <span class="org-string">'0'</span>);
  }

  <span class="org-keyword">return</span> acc;
}
</pre>
</div>

<div class="results" id="org6a0c986">

</div>

<p>
配列の中のすべての要素を2乗する。
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">void</span> <span class="org-function-name">square</span>(<span class="org-type">double</span> *<span class="org-variable-name">out</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> *<span class="org-variable-name">in</span>, <span class="org-type">size_t</span> <span class="org-variable-name">length</span>)
{
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; length; i++) {
    out[i] = in[i] * in[i];
  }
}
</pre>
</div>

<div class="results" id="org83c6ac3">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
 square :: [Double] -&gt; [Double]
 square (x:xs) = x*x : square xs
 square []     = []
:}
square [1,2]
square []
</pre>
</div>

<div class="results" id="orgde17e0c">
<p>

</p>

<p>
[1.0,4.0]
[]
</p>

</div>

<p>
大文字化。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
upperCase :: String -&gt; String

upperCase (x:xs) = toUpper x : upperCase xs
upperCase []     = []
:}
upperCase "hello"
</pre>
</div>

<div class="results" id="org0771f00">
<p>

</p>

<p>
HELLO
</p>

</div>

<p>
<code>map</code> は関数を引数としてとり、リストのすべての要素に適用する。
</p>

<div class="org-src-container">
<pre class="src src-haskell">upperCase2 xs = map toUpper xs
upperCase2 "hello"
</pre>
</div>

<div class="results" id="orgd22e737">
<p>

</p>

<p>
HELLO
</p>

</div>

<p>
<code>map</code> を書き直してみる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
  myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]
  myMap f (x:xs) = f x : myMap f xs
  myMap _ _      = []
:}
  upperCase3 xs = myMap toUpper xs
  upperCase3 "hello"
</pre>
</div>

<div class="results" id="org94c4492">
<p>

</p>

<p>
GHCi&gt; &ldquo;HELLO&rdquo;
</p>

</div>
</div>
</div>
<div id="outline-container-orga571bb4" class="outline-3">
<h3 id="orga571bb4"><a href="#orga571bb4">フィルター</a></h3>
<div class="outline-text-3" id="text-orga571bb4">
<div class="org-src-container">
<pre class="src src-haskell">:{
oddList :: [Int] -&gt; [Int]

oddList (x:xs) | odd x = x : oddList xs
               | otherwise = oddList xs
oddList _                  = []
:}
oddList [1,2,3,4,5,6,7,8,9,10]
</pre>
</div>

<div class="results" id="org0c91739">
<p>

</p>

<p>
[1,3,5,7,9]
</p>

</div>

<p>
<code>helper</code> は末尾再帰の関数で、蓄積変数 <code>acc</code> を使ってリストのその時点での部分和を保持する。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
mySum xs = helper 0 xs
  where helper acc (x:xs) = helper (acc + x) xs
        helper acc _      = acc
:}
mySum [1,2,3,4]
</pre>
</div>

<div class="results" id="org150ff5a">
<p>

</p>

<p>
10
</p>

</div>
</div>
</div>
<div id="outline-container-org0c150af" class="outline-3">
<h3 id="org0c150af"><a href="#org0c150af">畳み込み</a></h3>
<div class="outline-text-3" id="text-org0c150af">
<p>
畳み込み: リストのすべての要素に何かを行い、蓄積変数を更新していって、終わったところで蓄積変数を返す。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a

foldl step zero (x:xs) = foldl step (step zero x) xs
foldl _    zero []     = zero
:}
</pre>
</div>

<div class="results" id="orgb1782e4">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
niceSum :: [Integer] -&gt; Integer
niceSum xs = foldl (+) 0 xs
:}
niceSum [1,2,3,4,5]
</pre>
</div>

<div class="results" id="org82b19bf">
<p>

</p>

<p>
15
</p>

</div>

<p>
問題を2つに単純化することで、すっきり書けるようになった。
蓄積値の初期値をどうするかと、蓄積変数の更新。
</p>

<p>
明示的再帰は綿密に読む必要があり、わかりづらい。
畳み込みを使えば再帰を理解しやすい。
</p>

<p>
右側からの畳み込み。
</p>
<div class="org-src-container">
<pre class="src src-haskell">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr step zero (x:xs) = step x (foldr step zero xs)
foldr _    zero []     = 0
</pre>
</div>

<div class="results" id="orgcb50373">

</div>
</div>
</div>
<div id="outline-container-org556a2fb" class="outline-3">
<h3 id="org556a2fb"><a href="#org556a2fb">再帰と畳み込みの比較</a></h3>
<div class="outline-text-3" id="text-org556a2fb">
<div class="org-src-container">
<pre class="src src-haskell">:{
filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter p [] = []
filter p (x:xs)
  | p x = x : filter p xs
  | otherwise = filter p xs
:}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
myFilter p xs = foldr step [] xs
  where step x ys | p x = x : ys
                  | otherwise = ys
:}
myFilter (+) [1,2]
</pre>
</div>
</div>
</div>
<div id="outline-container-org3e6df20" class="outline-3">
<h3 id="org3e6df20"><a href="#org3e6df20">無名関数</a></h3>
<div class="outline-text-3" id="text-org3e6df20">
<p>
普通に書く例。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
isInAny needle haystack = any inSequence haystack
    where inSequence s = needle `isInfixOf` s
:}
</pre>
</div>

<div class="results" id="org88c6e4c">

</div>

<p>
無名関数を使う例。
</p>

<div class="org-src-container">
<pre class="src src-haskell">isInAny2 needle haystack = any (\s -&gt; needle `isInfixOf` s) haystack
</pre>
</div>

<div class="results" id="org4be5996">

</div>
</div>
</div>
<div id="outline-container-orgb2a038f" class="outline-3">
<h3 id="orgb2a038f"><a href="#orgb2a038f">部分適用</a></h3>
<div class="outline-text-3" id="text-orgb2a038f">
<div class="org-src-container">
<pre class="src src-haskell">:type dropWhile
</pre>
</div>

<div class="results" id="org2a17254">
<p>
dropWhile :: (a -&gt; Prelude.Bool) -&gt; [a] -&gt; [a]
</p>

</div>

<p>
-&gt;の意味…左側の型を引数に取り、右側の型の値を返す関数。
</p>

<p>
Haskellにおいては、 <b>すべての関数は1つしか引数を取らない</b> 。
1つ渡すと型シグネチャから1つ削られたことがわかる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type dropWhile
:type dropWhile isSpace
map (dropWhile isSpace) [" a", "f", "    e"]
</pre>
</div>

<div class="results" id="org3e29f81">
<p>
dropWhile :: (a -&gt; Prelude.Bool) -&gt; [a] -&gt; [a]
dropWhile isSpace :: [Char] -&gt; [Char]
[&ldquo;a&rdquo;,&ldquo;f&rdquo;,&ldquo;e&rdquo;]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type zip3
zip3 "foo" "bar" "quux"
</pre>
</div>

<div class="results" id="org0fdc2ff">
<p>
zip3 :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]
[(&rsquo;f&rsquo;,&rsquo;b&rsquo;,&rsquo;q&rsquo;),(&rsquo;o&rsquo;,&rsquo;a&rsquo;,&rsquo;u&rsquo;),(&rsquo;o&rsquo;,&rsquo;r&rsquo;,&rsquo;u&rsquo;)]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type zip3 "foo"
let zip3foo = zip3 "foo"
:type zip3foo
zip3foo "aaa" "bbb"
</pre>
</div>

<div class="results" id="orgaf79a48">
<p>
zip3 &ldquo;foo&rdquo; :: [b] -&gt; [c] -&gt; [(Char, b, c)]
GHCi&gt; zip3foo :: [b] -&gt; [c] -&gt; [(Char, b, c)]
[(&rsquo;f&rsquo;,&rsquo;a&rsquo;,&rsquo;b&rsquo;),(&rsquo;o&rsquo;,&rsquo;a&rsquo;,&rsquo;b&rsquo;),(&rsquo;o&rsquo;,&rsquo;a&rsquo;,&rsquo;b&rsquo;)]
</p>

</div>

<p>
関数が受け入れ可能な数よりも少ない数の引数を渡すことを関数の部分適用という(<code>カリー化</code>)。
</p>

<div class="org-src-container">
<pre class="src src-haskell">isInAny3 needle haystack = any (isInfixOf needle) haystack
</pre>
</div>

<div class="results" id="org4adb230">

</div>

<p>
カリー化の例。
使う前。
</p>
<div class="org-src-container">
<pre class="src src-haskell">niceSum :: [Integer] -&gt; Integer
niceSum xs = foldl (+) 0 xs
</pre>
</div>

<div class="results" id="org654f29a">

</div>

<p>
完全に適用せずに、省略できる。
</p>
<div class="org-src-container">
<pre class="src src-haskell">niceSum :: [Integer] -&gt; Integer
niceSum = foldl (+) 0
</pre>
</div>

<div class="results" id="org48e52a8">

</div>
</div>
</div>
<div id="outline-container-org1b96e81" class="outline-3">
<h3 id="org1b96e81"><a href="#org1b96e81">セクション</a></h3>
<div class="outline-text-3" id="text-org1b96e81">
<p>
括弧で中置スタイルの関数の部分適用を書ける。
</p>
<div class="org-src-container">
<pre class="src src-haskell">(1+) 2
map (*3) [24,36]
map (2^) [3,5,7,9]
</pre>
</div>

<div class="results" id="org82177dd">
<p>
3
[72,108]
[8,32,128,512]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type (`elem` ['a'..'z'])
</pre>
</div>

<div class="results" id="org2c52ea8">
<p>
(`elem` [&rsquo;a&rsquo;..&rsquo;z&rsquo;]) :: Char -&gt; Prelude.Bool
</p>

</div>

<p>
引数が小文字アルファベットか調べる関数になる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">(`elem` ['a'..'z']) 'a'
(`elem` [1..9]) 1
(`elem` [1..9]) 10
</pre>
</div>

<div class="results" id="org58ddc68">
<p>
True
True
False
</p>

</div>

<p>
<code>all</code> と組み合わせる。簡潔にリスト全体か判定する関数になった。
</p>
<div class="org-src-container">
<pre class="src src-haskell">all (`elem` ['a'..'z']) "Frobozz"
</pre>
</div>

<div class="results" id="orgddf67ef">
<p>
False
</p>

</div>

<p>
<code>inInAny3</code> の改良版。
</p>

<div class="org-src-container">
<pre class="src src-haskell">isInAny4 needle haystack = any (needle `isInfixOf`) haystack
:type isInAny4

</pre>
</div>

<div class="results" id="orgbf0558a">
<p>

</p>

<p>
isInAny4 :: (Foldable t, Eq a) =&gt; [a] -&gt; t [a] -&gt; Prelude.Bool
</p>

</div>
</div>
</div>
<div id="outline-container-orgea28243" class="outline-3">
<h3 id="orgea28243"><a href="#orgea28243">アズパターン</a></h3>
<div class="outline-text-3" id="text-orgea28243">
<div class="org-src-container">
<pre class="src src-haskell">:m +Data.List
tail "foobar"
tail (tail "foobar")
tails "foobar"
tails []
</pre>
</div>

<div class="results" id="org5f1cc7d">
<p>

</p>

<p>
oobar
obar
[&ldquo;foobar&rdquo;,&ldquo;oobar&rdquo;,&ldquo;obar&rdquo;,&ldquo;bar&rdquo;,&ldquo;ar&rdquo;,&ldquo;r&rdquo;,&ldquo;&rdquo;]
[[]]
</p>

</div>

<p>
空でない接尾辞が欲しくなったとする。
</p>

<p>
<code>xs@(_:xs')</code> はアズパターンという。
変数 <code>xs</code> を、 <code>@</code> 記号の右辺とマッチした値に束縛する、という意味。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
sufixes :: [a] -&gt; [[a]]
sufixes xs@(_:xs') = xs : sufixes xs'
sufixes _          = []
:}
sufixes "foo"
</pre>
</div>

<div class="results" id="org654d896">
<p>

</p>

<p>
[&ldquo;foo&rdquo;,&ldquo;oo&rdquo;,&ldquo;o&rdquo;]
</p>

</div>

<p>
アズパターンはデータをコピーする代わりに共有する(<code>xs</code> を再利用している)。
メモリの割り当てを回避するのでパフォーマンスが良い。
</p>
</div>
</div>
<div id="outline-container-org205e38c" class="outline-3">
<h3 id="org205e38c"><a href="#org205e38c">合成</a></h3>
<div class="outline-text-3" id="text-org205e38c">
<p>
<code>init</code> 関数はリストの最期の要素を除いた残りを返す。
</p>
<div class="org-src-container">
<pre class="src src-haskell">init [1,2,3]
</pre>
</div>

<div class="results" id="orgd3034cd">
<p>
[1,2]
</p>

</div>

<p>
<code>init</code> <code>tails</code> を合成する。
</p>

<div class="org-src-container">
<pre class="src src-haskell">suffix2 xs = init (tails xs)
suffix2 [1,2,3]
</pre>
</div>

<div class="results" id="orgcddde0b">
<p>

</p>

<p>
[[1,2,3],[2,3],[3]]
</p>

</div>

<p>
ある関数を適用してから、その結果に別の関数をしている。このパターンを関数にできる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
compose f g x = f (g x)
suffixes3 xs = compose init tails xs
:}
suffixes3 [1,2,3]
</pre>
</div>

<div class="results" id="orged7c679">
<p>

</p>

<p>
[[1,2,3],[2,3],[3]]
</p>

</div>

<p>
勝手にカリー化するので変数は外せる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">suffixes4 = compose init tails
suffixes4 [1,2,3]
</pre>
</div>

<div class="results" id="org9b617c3">
<p>

</p>

<p>
[[1,2,3],[2,3],[3]]
</p>

</div>

<p>
連結はよくあることなので、 <code>.</code> 演算子として使える。
</p>

<div class="org-src-container">
<pre class="src src-haskell">suffixes5 = init . tails
suffixes5 [1,2,3]
</pre>
</div>

<div class="results" id="org4d490ab">
<p>

</p>

<p>
[[1,2,3],[2,3],[3]]
</p>

</div>

<p>
通常の演算子のひとつ。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type (.)
</pre>
</div>

<div class="results" id="org4d2fa95">
<p>
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</p>

</div>

<p>
単語の先頭が大文字か。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type isUpper . head
isUpper 'W'
</pre>
</div>

<div class="results" id="orgafe2a54">
<p>
isUpper . head :: [Char] -&gt; Prelude.Bool
True
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type filter (isUpper . head)
</pre>
</div>

<div class="results" id="org207be08">
<p>
filter (isUpper . head) :: [a1] -&gt; [a2]
</p>

</div>

<p>
関数合成の例。
</p>

<p>
<code>words</code> を使う。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:type words
words "#define DLT_CHAOS     5"
</pre>
</div>

<div class="results" id="org9853211">
<p>
words :: String -&gt; [String]
[&ldquo;#define&rdquo;,&ldquo;DLT_CHAOS&rdquo;,&ldquo;5&rdquo;]
</p>

</div>

<p>
<code>tail</code> を使う。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type tail
tail ["#define","DLT_CHAOS","5"]
</pre>
</div>

<div class="results" id="orgfb7b102">
<p>
tail :: [a] -&gt; [a]
[&ldquo;DLT_CHAOS&rdquo;,&ldquo;5&rdquo;]
</p>

</div>

<p>
合成する。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type tail . words
(tail . words) "#define DLT_CHAOS           5"
</pre>
</div>

<div class="results" id="org2448c41">
<p>
tail . words :: String -&gt; [String]
[&ldquo;DLT_CHAOS&rdquo;,&ldquo;5&rdquo;]
</p>

</div>

<p>
<code>head</code> を使う。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type head . tail . words
(head . tail . words) "#define DLT_CHAOS     5"
</pre>
</div>

<div class="results" id="orgaa93997">
<p>
head . tail . words :: String -&gt; String
DLT_CHAOS
</p>

</div>

<p>
優先順位&#x2026;ライブラリ関数の合成 &gt; 畳み込み &gt; 末尾再帰。
</p>
</div>
</div>
<div id="outline-container-org6e7e028" class="outline-3">
<h3 id="org6e7e028"><a href="#org6e7e028">スペースリーク</a></h3>
<div class="outline-text-3" id="text-org6e7e028">
<p>
遅延評価しない式のことを <code>正格な式</code> という。
<code>seq</code> は正格化する。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
foldl' _ zero []    = zero
foldl' step zero (x:xs) =
    let new = step zero x
    in new `seq` foldl' step new xs
:}
</pre>
</div>

<div class="results" id="org2d08e61">

</div>

<p>
<code>seq</code> は値を評価する方法としての存在価値しかない。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:type seq
</pre>
</div>

<div class="results" id="orge6ee2b6">
<p>
seq :: a -&gt; b -&gt; b
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">foldl' (+) 1 (2:[])
</pre>
</div>

<div class="results" id="orgf9dad12">
<p>
3
</p>

</div>

<p>
これは↓のように展開される。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
let new = 1 + 2
in new `seq` foldl' (+) new []
:}
</pre>
</div>

<div class="results" id="org4cb48ba">
<p>
3
</p>

</div>

<p>
一度↓のように展開する。
</p>

<div class="org-src-container">
<pre class="src src-haskell">fold' (+) 3 []
</pre>
</div>

<p>
<code>seq</code> によってサンクがない。
</p>
</div>
</div>
<div id="outline-container-org1b9ceba" class="outline-3">
<h3 id="org1b9ceba"><a href="#org1b9ceba">型クラス</a></h3>
<div class="outline-text-3" id="text-org1b9ceba">
<p>
同値性検査をしたい。
</p>

<p>
色の場合。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
data Color = Red | Green | Blue
colorEq :: Color -&gt; Color -&gt; Bool
colorEq Red Red = True
colorEq Green Green = True
colorEq Blue Blue = True
colorEq _ _ = False
:}
</pre>
</div>

<div class="results" id="org6e3a958">

</div>

<p>
stringの場合。
</p>
<div class="org-src-container">
<pre class="src src-haskell">stringEq :: [Char] -&gt; [Char] -&gt; Bool
stringEq [] [] = True
stringEq (x:xs) (y:ys) = x == y &amp;&amp; stringEq xs ys
stringEq _ _ = False
</pre>
</div>

<div class="results" id="org6bb7e03">

</div>

<p>
つまり…型ごとに別の名前の関数を使って比較しなければならない。
すべて <code>==</code> で比較できると便利(ジェネリック関数)。
型クラスは実際に与えられたデータの型ごとに実装を持ち得る関数の集合によって定義するもの。
</p>

<p>
型クラスを定義する。 <code>BasicEq</code> という型クラスを定義する。
インスタンスの型は <code>a</code> 。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
class BasicEq a where
    isEqual :: a -&gt; a -&gt; Bool
:}
</pre>
</div>

<div class="results" id="orgbd47d01">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:type isEqual
</pre>
</div>

<div class="results" id="org466c43c">
<p>
isEqual :: BasicEq a =&gt; a -&gt; a -&gt; Bool
</p>

</div>

<p>
→ あらゆる型 <code>a</code> に対して、 <code>a</code> が <code>BasicEq</code> のインスタンスである限り、 <code>isEqual</code> は型 <code>a</code> のパラメータを2つ取り、 <code>Bool</code> を返す。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
instance BasicEq Bool where
    isEqual True  True  = True
    isEqual False False = True
    isEqual _     _     = False
:}
</pre>
</div>

<div class="results" id="org334c23a">

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
class BasicEq2 a where
    isEqual2    :: a -&gt; a -&gt; Bool
    isNotEqual2 :: a -&gt; a -&gt; Bool
:}
</pre>
</div>

<div class="results" id="org545f300">

</div>

<p>
notを追加する。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
class BasicEq3 a where
      isEqual3 :: a -&gt; a -&gt; Bool
      -- isEqual3 x y = not (isNotEqual3 x y)

      isNotEqual3 :: a -&gt; a -&gt; Bool
      -- isNotEqual3 x y = not (isEqual3 x y)
:}
</pre>
</div>

<div class="results" id="org4998474">

</div>

<p>
組み込みの <code>Eq</code> 型を見る。
</p>
<div class="org-src-container">
<pre class="src src-haskell">class Eq a where
    (==), (/=) :: a -&gt; a -&gt; Bool

    -- 最低限の完全な定義は(==) か (/=) のどちらか
    x /= y     = not (x == y)
    x == y     = not (x /= y)
</pre>
</div>

<div class="results" id="org8e1cc75">

</div>
</div>
</div>

<div id="outline-container-org88140d7" class="outline-3">
<h3 id="org88140d7"><a href="#org88140d7">型クラスのインスタンス宣言</a></h3>
<div class="outline-text-3" id="text-org88140d7">
<p>
Color型だけでなく、BasicEq3のインスタンスとして宣言したあらゆる型に対して <code>isEqual3</code> が使える。
</p>
<div class="org-src-container">
<pre class="src src-haskell">instance BasicEq3 Color where
    isEqual3 Red   Red   = True
    isEqual3 Green Green = True
    isEqual3 Blue  Blue  = True
    isEqual3 _     _     = False
</pre>
</div>

<div class="results" id="org19d771a">

</div>
</div>
</div>
<div id="outline-container-org4f4bff0" class="outline-3">
<h3 id="org4f4bff0"><a href="#org4f4bff0">Show</a></h3>
<div class="outline-text-3" id="text-org4f4bff0">
<div class="org-src-container">
<pre class="src src-haskell">:type show
</pre>
</div>

<div class="results" id="org6cf3e08">
<p>
show :: Show a =&gt; a -&gt; String
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">show 1
show [1,2,3]
show (1,2)
</pre>
</div>

<div class="results" id="org6adfbab">
<p>
1
[1,2,3]
(1,2)
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">putStrLn (show 1)
putStrLn (show [1,2,3])
</pre>
</div>

<div class="results" id="org20d39c0">
<p>
1
[1,2,3]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">show "Hello!"
putStrLn (show "Hello!")
show ['H', 'i']
show "Hi, \"Jane\""
putStrLn (show "Hi, \"Jane\"")
</pre>
</div>

<div class="results" id="org78ca62e">
<p>
\&ldquo;Hello!\&rdquo;
Hello!
\&ldquo;Hi\&rdquo;
\&ldquo;Hi, \\\&rdquo;Jane\\\&ldquo;\&rdquo;
Hi, \&ldquo;Jane\&rdquo;
</p>

</div>

<p>
自分で定義した型に対して <code>Show</code> インスタンスを定義する。
</p>
<div class="org-src-container">
<pre class="src src-haskell">instance Show Color where
    show Red   = "Red"
    show Green = "Green"
    show Blue  = "Blue"
</pre>
</div>

<div class="results" id="orgff209a7">

</div>
</div>
</div>
<div id="outline-container-orgbcb0f83" class="outline-3">
<h3 id="orgbcb0f83"><a href="#orgbcb0f83">Read</a></h3>
<div class="outline-text-3" id="text-orgbcb0f83">
<div class="org-src-container">
<pre class="src src-haskell">:type read
</pre>
</div>

<div class="results" id="org870a4ef">
<p>
read :: Read a =&gt; String -&gt; a
</p>

</div>

<p>
エラーが出てうまくいかない&#x2026;。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
main = do
    putStrLn "Please enter a Double:"
    inpStr &lt;- getLine
    let inpDouble = (read inpStr)::Double
    putStrLn ("Twice " ++ show inpDouble ++ " is " ++ show (inpDouble * 2))
:}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">read "5"
</pre>
</div>

<div class="results" id="org5960c50">
<p>
Exception: Prelude.read: no parse
</p>

</div>

<p>
型の <code>a</code> は、それぞれのReadのインスタンスのこと。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:type (read "5")
</pre>
</div>

<div class="results" id="org31ee5a5">
<p>
(read &ldquo;5&rdquo;) :: Read a =&gt; a
</p>

</div>

<p>
実際に呼ばれる特定の関数はreadの返り値から期待される型で決まる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">(read "5")::Integer
(read "5")::Double
</pre>
</div>

<div class="results" id="org2d6ae9a">
<p>
5
5.0
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
instance Read Color where
   readsPrec _ value =
       -- ペアは文字列と欲しい返り値
       tryParse [("Red", Red), ("Green", Green), ("Blue", Blue)]
       where tryParse [] = []
             tryParse ((attempt, result):xs) =
                 if (take (length attempt) value) == attempt
                    then [(result, drop (length attempt) value)]
                    else tryParse xs
:}
</pre>
</div>

<div class="results" id="org0d48afc">

</div>

<p>
なぜかstack overflowでできない。
</p>

<div class="org-src-container">
<pre class="src src-haskell">(read "Red")::Color
(read "Green")::Color
(read "Blue")::Color
(read "[Red]")::Color
(read "[Red,Red,Blue]")::Color
</pre>
</div>

<div class="results" id="org75d1ea6">
<p>
Exception: stack overflow
</p>

</div>
</div>
</div>
<div id="outline-container-org4861c19" class="outline-3">
<h3 id="org4861c19"><a href="#org4861c19">シリアライズ</a></h3>
<div class="outline-text-3" id="text-org4861c19">
<div class="org-src-container">
<pre class="src src-haskell">let d1 = [Just 5, Nothing, Nothing, Just 8, Just 9]::[Maybe Int]
:type show
:type show d1
putStrLn (show d1)
</pre>
</div>

<div class="results" id="orgbbf6bf9">
<p>

</p>

<p>
show :: Show a =&gt; a -&gt; String
show d1 :: String
[Just 5,Nothing,Nothing,Just 8,Just 9]
</p>

</div>

<p>
ファイルに書き込み。
</p>

<div class="org-src-container">
<pre class="src src-haskell">writeFile "test" (show d1)
</pre>
</div>

<div class="results" id="orgc46d00e">

</div>

<p>
再度読み込み。
<code>d2</code> に明示的に型を与えるのがポイント。
</p>

<div class="org-src-container">
<pre class="src src-haskell">input &lt;- readFile "test"
let d2 = (read input) ::[Maybe Int]
print d1
print d2
d1 == d2
</pre>
</div>

<div class="results" id="org37cef7f">
<p>

</p>

<p>
GHCi&gt; [Just 5,Nothing,Nothing,Just 8,Just 9]
[Just 5,Nothing,Nothing,Just 8,Just 9]
True
</p>

</div>

<p>
showにほかの引数を与えてみる。
</p>

<div class="org-src-container">
<pre class="src src-haskell">putStrLn $ show [("hi", 1), ("there", 3)]
</pre>
</div>

<div class="results" id="orge228e94">
<p>
[(&ldquo;hi&rdquo;,1),(&ldquo;there&rdquo;,3)]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">putStrLn $ show [[1, 2, 3], [4, 0, 1], [], [503]]
</pre>
</div>

<div class="results" id="orgff6f91c">
<p>
[[1,2,3],[4,0,1],[],[503]]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">putStrLn $ show [Left 5, Right "there", Left 0, Right "nine"]
</pre>
</div>

<div class="results" id="org1e71b5b">
<p>
[Left 5,Right &ldquo;there&rdquo;,Left 0,Right &ldquo;nine&rdquo;]
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">putStrLn $ show [Left 0, Right [1, 2, 3], Left 5, Right []]
</pre>
</div>

<div class="results" id="org95fbe24">
<p>
[Left 0,Right [1,2,3],Left 5,Right []]
</p>

</div>
</div>
</div>
<div id="outline-container-org92c3342" class="outline-3">
<h3 id="org92c3342"><a href="#org92c3342">数値型</a></h3>
<div class="outline-text-3" id="text-org92c3342">
<p>
強力な数値型がある。
Haskellの演算子は関数にすぎない。
演算子を関数とみなす場合には括弧で囲む。
</p>

<div class="org-src-container">
<pre class="src src-haskell">:{
data Color = Red | Green | Blue
       deriving (Read, Show, Eq, Ord)
:}
show Red
(read "Red")::Color
(read "[Red,Red,Blue]")::[Color]
(read "[Red, Red, Blue]")::[Color]
Red == Red
Red == Blue
Data.List.sort [Blue,Green,Blue,Red]
Red &lt; Blue
</pre>
</div>

<div class="results" id="org4b650b5">
<p>

</p>

<p>
Red
Red
[Red,Red,Blue]
[Red,Red,Blue]
True
False
[Red,Green,Blue,Blue]
True
</p>

</div>

<p>
型が参照している型が、やはりその型クラスのインスタンスであると宣言しないといけない。
</p>

<p>
CannotShow が Show のインスタンスではないので、エラー。
</p>
<div class="org-src-container">
<pre class="src src-haskell">:{
data CannotShow = CannotShow
data CannotDeriveShow = CannotDeriveShow CannotShow
                        deriving (Show)
:}
</pre>
</div>

<div class="results" id="org8de4384">
<p>
Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char|
&lt;interactive&gt;:7599:35-38: error:
    • No instance for (Show CannotShow)
        arising from the first field of ‘CannotDeriveShow’
          (type ‘CannotShow’)
      Possible fix:
        use a standalone &rsquo;deriving instance&rsquo; declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Show CannotDeriveShow)
</p>

</div>

<div class="org-src-container">
<pre class="src src-haskell">:{
data OK = OK
instance Show OK where
    show _ = "OK"
data ThisWorks = ThisWorks OK
                 deriving (Show)
:}
</pre>
</div>

<div class="results" id="org3d9a882">

</div>

<p>
Haskell では異なる型の値を含むリストはサポートされてないので、JSONオブジェクトを直接表現できない。
代わりにデータ構成子でそれぞれの値を含む必要がある。
</p>

<div class="org-src-container">
<pre class="src src-haskell">type JSONError = String

class JSON a where
    toJValue :: a -&gt; JValue
    fromJValue :: JValue -&gt; Either JSONError a

instance JSON JValue where
    toJValue = id
    fromJValue = Right
</pre>
</div>

<div class="results" id="orgcde1da5">

</div>

<p>
よりよいエラー文。
</p>

<div class="org-src-container">
<pre class="src src-haskell">data Maybe a = Nothing
             | Just a
               deriving (Eq, Ord, Read, Show)

data Either a b = Left a
                | Right b
                  deriving (Eq, Ord, Read, Show)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">instance JSON Bool where
    toJValue = JBool
    fromJValue (JBool b) = Right b
    fromJValue _ = Left "not a JSON boolean"
</pre>
</div>

<div class="results" id="org30374cc">

</div>

<p>
特殊なコメントで制限回避。プラグマというコンパイラ指令。
</p>

<div class="org-src-container">
<pre class="src src-haskell">{-# LANGUAGE TypeSynonymInstances #-}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfa83856" class="outline-3">
<h3 id="orgfa83856"><a href="#orgfa83856">型クラスとインスタンス</a></h3>
<div class="outline-text-3" id="text-orgfa83856">
<p>
新しいインスタンスはどこででも追加できる。型クラスを定義したモジュール内のみに限定されてない。
型クラスは開世界仮説に基づいている。
</p>

<div class="org-src-container">
<pre class="src src-haskell">doubleToJValue :: (Double -&gt; a) -&gt; JValue -&gt; Either JSONError a
doubleToJValue f (JNumber v) = Right (f v)
doubleToJValue _ _ = Left "not a JSON number"

instance JSON Int where
    toJValue = JNumber . realToFrac
    fromJValue = doubleToJValue round

instance JSON Integer where
    toJValue = JNumber . realToFrac
    fromJValue = doubleToJValue round

instance JSON Double where
    toJValue = JNumber
    fromJValue = doubleToJValue id
</pre>
</div>

<div class="results" id="orga57d6d2">

</div>

<p>
インスタンスの重複。
リストをJSONの配列に変換する例。
</p>

<div class="org-src-container">
<pre class="src src-haskell">instance (JSON a) =&gt; JSON [a] where
    toJValue = undefined
    fromJValue = undefined
</pre>
</div>

<div class="results" id="org26fd660">

</div>

<div class="org-src-container">
<pre class="src src-haskell">instance (JSON a) =&gt; JSON [(String, a)] where
    toJValue = undefined
    fromJValue = undefined
</pre>
</div>

<div class="results" id="orga7195e9">

</div>

<div class="org-src-container">
<pre class="src src-haskell">{-# LANGUAGE FlexibleInstances #-}
class Borked a where
    bork :: a -&gt; String

instance Borked Int where
    bork = show

instance Borked (Int, Int) where
    bork (a, b) = bork a ++ ", " ++ bork b

instance (Borked a, Borked b) =&gt; Borked (a, b) where
    bork (a, b) = "&gt;&gt;" ++ bork a ++ " " ++ bork b ++ "&lt;&lt;"
</pre>
</div>

<p>
GHC は保守的で、使える可能性のあるインスタンスは1つだけであるべきとする。
なのでbork を使おうとするとエラーになる。
</p>
</div>
</div>
<div id="outline-container-org70910a4" class="outline-3">
<h3 id="org70910a4"><a href="#org70910a4">型クラスに関する制約の緩和</a></h3>
</div>
</div>
<div id="outline-container-org3226375" class="outline-2">
<h2 id="org3226375"><a href="#org3226375">Tasks</a></h2>
<div class="outline-text-2" id="text-org3226375">
</div>
<div id="outline-container-org73e1d3b" class="outline-3">
<h3 id="org73e1d3b"><a href="#org73e1d3b"><span class="todo TODO">TODO</span> org-babelでhaskellを実行できなくなる</a></h3>
<div class="outline-text-3" id="text-org73e1d3b">
<p>
<code>:set +t</code> を評価すると使えなくなる。
</p>
</div>
</div>
<div id="outline-container-org923e08a" class="outline-3">
<h3 id="org923e08a"><a href="#org923e08a"><span class="todo TODO">TODO</span> xmpfilterのHaskell版を探す or 作る</a></h3>
<div class="outline-text-3" id="text-org923e08a">
<p>
なければ簡易版で作る。
いちいちロード、コンパイルは学習に不便。既存のがあるはずだが、調べ方がわからない。
</p>

<p>
<code>org-babel</code> でよさそう。
</p>
</div>
</div>
<div id="outline-container-orgaa4b977" class="outline-3">
<h3 id="orgaa4b977"><a href="#orgaa4b977"><span class="todo TODO">TODO</span> <a href="https://www.oreilly.co.jp/books/9784873114231/">O&rsquo;Reilly Japan - Real World Haskell</a> <code>[14%]</code></a></h3>
<div class="outline-text-3" id="text-orgaa4b977">
<p>

</p>
</div>
<div id="outline-container-orgccb658e" class="outline-4">
<h4 id="orgccb658e"><a href="#orgccb658e"><span class="done DONE">DONE</span> 100</a></h4>
<div class="outline-text-4" id="text-orgccb658e">
</div>
</div>
<div id="outline-container-org86cb572" class="outline-4">
<h4 id="org86cb572"><a href="#org86cb572"><span class="todo TODO">TODO</span> 200</a></h4>
<div class="outline-text-4" id="text-org86cb572">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2021-10-13 水&gt;</span></span>
160pまで到達。
</p>
</div>
</div>
<div id="outline-container-org2ae7216" class="outline-4">
<h4 id="org2ae7216"><a href="#org2ae7216"><span class="todo TODO">TODO</span> 300</a></h4>
</div>
<div id="outline-container-org4cc0772" class="outline-4">
<h4 id="org4cc0772"><a href="#org4cc0772"><span class="todo TODO">TODO</span> 400</a></h4>
</div>
<div id="outline-container-org863d829" class="outline-4">
<h4 id="org863d829"><a href="#org863d829"><span class="todo TODO">TODO</span> 500</a></h4>
</div>
<div id="outline-container-orgb36630b" class="outline-4">
<h4 id="orgb36630b"><a href="#orgb36630b"><span class="todo TODO">TODO</span> 600</a></h4>
</div>
<div id="outline-container-org297d41d" class="outline-4">
<h4 id="org297d41d"><a href="#org297d41d"><span class="todo TODO">TODO</span> 700</a></h4>
</div>
</div>
</div>
<div id="outline-container-org10b3aba" class="outline-2">
<h2 id="org10b3aba"><a href="#org10b3aba">Reference</a></h2>
<div class="outline-text-2" id="text-org10b3aba">
</div>
<div id="outline-container-org101a416" class="outline-3">
<h3 id="org101a416"><a href="#org101a416"><a href="http://walk.northcol.org/haskell/">ウォークスルー Haskell - Haskell 入門</a></a></h3>
<div class="outline-text-3" id="text-org101a416">
<p>
わかりやすそうな入門。
</p>
</div>
</div>
<div id="outline-container-org7fef3ee" class="outline-3">
<h3 id="org7fef3ee"><a href="#org7fef3ee"><a href="https://www.lambdanote.com/collections/haskell">『プログラミングHaskell 第2版』 – 技術書出版と販売のラムダノート</a></a></h3>
</div>
<div id="outline-container-org1bf3628" class="outline-3">
<h3 id="org1bf3628"><a href="#org1bf3628"><a href="https://www.cs.nott.ac.uk/~pszgmh/fold.pdf">A tutorial on the universality and expressiveness of fold</a></a></h3>
<div class="outline-text-3" id="text-org1bf3628">
<p>
haskellの畳み込みのすぐれたチュートリアル。
</p>
</div>
</div>
<div id="outline-container-orgbd1af29" class="outline-3">
<h3 id="orgbd1af29"><a href="#orgbd1af29"><a href="https://www.haskell.org/onlinereport/haskell2010/haskellpa1.html#haskellch4.html">I The Haskell 2010 Language</a></a></h3>
<div class="outline-text-3" id="text-orgbd1af29">
<p>
Haskellの仕様書。
</p>
</div>
</div>
<div id="outline-container-org5ebb8f2" class="outline-3">
<h3 id="org5ebb8f2"><a href="#org5ebb8f2"><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8777">CiteSeerX — The Design of a Pretty-printing Library</a></a></h3>
<div class="outline-text-3" id="text-org5ebb8f2">
<p>
haskellのjsonプリティプリンタライブラリの設計。
</p>
</div>
</div>
<div id="outline-container-org6931d5e" class="outline-3">
<h3 id="org6931d5e"><a href="#org6931d5e"><a href="https://wiki.haskell.org/IO%E5%85%A5%E9%96%80%E7%B7%A8">IO入門編 - HaskellWiki</a></a></h3>
<div class="outline-text-3" id="text-org6931d5e">
<p>
IOの説明。
</p>
</div>
</div>
<div id="outline-container-org3fa3560" class="outline-3">
<h3 id="org3fa3560"><a href="#org3fa3560"><a href="http://www.allureofthestars.com/play/">Allure of the Stars</a></a></h3>
<div class="outline-text-3" id="text-org3fa3560">
<p>
Haskellのブラウザローグライクゲーム。
</p>
</div>
</div>
<div id="outline-container-org335e395" class="outline-3">
<h3 id="org335e395"><a href="#org335e395"><a href="https://www.infoq.com/jp/articles/Understanding-Monads-guide-for-perplexed/">モナドを理解する - 迷える者への手引き</a></a></h3>
<div class="outline-text-3" id="text-org335e395">
<p>
Haskellのモナドの解説。
</p>
</div>
</div>
<div id="outline-container-org7a04591" class="outline-3">
<h3 id="org7a04591"><a href="#org7a04591"><a href="https://ja.wikipedia.org/wiki/Haskell">Haskell - Wikipedia</a></a></h3>
</div>
</div>
<div id="outline-container-org04a7dd6" class="outline-2">
<h2 id="org04a7dd6"><a href="#org04a7dd6">Archives</a></h2>
<div class="outline-text-2" id="text-org04a7dd6">
</div>
<div id="outline-container-org035f39f" class="outline-3">
<h3 id="org035f39f"><a href="#org035f39f"><span class="done DONE">DONE</span> すごいHaskellたのしく学ぼう <code>[100%]</code></a></h3>
<div class="outline-text-3" id="text-org035f39f">
<p>
何か作る的なテーマがないので読むのがつらい。
参考になりそうなパッケージを探したけど、ピンとくるものがない。
いくつかパッケージをbuildしてみたが、依存パッケージで動かない。どうするかな。
</p>

<p>
よくわからん。
</p>
</div>
<div id="outline-container-org2121c02" class="outline-4">
<h4 id="org2121c02"><a href="#org2121c02"><span class="done DONE">DONE</span> 30%</a></h4>
<div class="outline-text-4" id="text-org2121c02">
</div>
</div>
<div id="outline-container-orgbacb332" class="outline-4">
<h4 id="orgbacb332"><a href="#orgbacb332"><span class="done DONE">DONE</span> 40%</a></h4>
<div class="outline-text-4" id="text-orgbacb332">
</div>
</div>
<div id="outline-container-org97b713f" class="outline-4">
<h4 id="org97b713f"><a href="#org97b713f"><span class="done DONE">DONE</span> 50%</a></h4>
<div class="outline-text-4" id="text-org97b713f">
<p>

</p>
</div>
</div>
<div id="outline-container-orgf978066" class="outline-4">
<h4 id="orgf978066"><a href="#orgf978066"><span class="done DONE">DONE</span> 60%</a></h4>
<div class="outline-text-4" id="text-orgf978066">
<p>

</p>
</div>
</div>
<div id="outline-container-org4ec91cf" class="outline-4">
<h4 id="org4ec91cf"><a href="#org4ec91cf"><span class="done DONE">DONE</span> 70%</a></h4>
<div class="outline-text-4" id="text-org4ec91cf">
<p>

</p>
</div>
</div>
<div id="outline-container-org0982059" class="outline-4">
<h4 id="org0982059"><a href="#org0982059"><span class="done DONE">DONE</span> 80%</a></h4>
<div class="outline-text-4" id="text-org0982059">
<p>

</p>
</div>
</div>
<div id="outline-container-org3126045" class="outline-4">
<h4 id="org3126045"><a href="#org3126045"><span class="done DONE">DONE</span> 90%</a></h4>
<div class="outline-text-4" id="text-org3126045">
<p>

</p>
</div>
</div>
<div id="outline-container-org1f3024e" class="outline-4">
<h4 id="org1f3024e"><a href="#org1f3024e"><span class="done DONE">DONE</span> 100%</a></h4>
<div class="outline-text-4" id="text-org1f3024e">
<p>

</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"/>
</div>
</body>
</html>
