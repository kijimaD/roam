:PROPERTIES:
:ID:       7cacbaa3-3995-41cf-8b72-58d6e07468b1
:header-args+: :wrap :results raw
:END:
#+title: Go

* 概要
Go言語はGoogleによって開発された[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]。[[id:1658782a-d331-464b-9fd7-1f8233b8b7f8][Docker]]はGoで書かれている。シンプルさをコンセプトにしている。シンプルすぎて必要な機能が足りてない、という批判もあるくらい。
* Memo
** WIP [[https://www.amazon.co.jp/Go%E3%81%AA%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E6%B8%8B%E5%B7%9D-%E3%82%88%E3%81%97%E3%81%8D/dp/4908686033/ref=sr_1_3?keywords=go+%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0&qid=1653145833&sprefix=go+%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%2Caps%2C206&sr=8-3][Goならわかるシステムプログラミング]]
:PROPERTIES:
:Effort:   20:00
:END:
:LOGBOOK:
CLOCK: [2024-03-17 Sun 18:40]--[2024-03-17 Sun 19:05] =>  0:25
CLOCK: [2024-03-17 Sun 17:33]--[2024-03-17 Sun 17:58] =>  0:25
CLOCK: [2024-03-17 Sun 15:50]--[2024-03-17 Sun 16:15] =>  0:25
CLOCK: [2024-03-17 Sun 15:25]--[2024-03-17 Sun 15:50] =>  0:25
CLOCK: [2024-03-17 Sun 13:23]--[2024-03-17 Sun 13:48] =>  0:25
CLOCK: [2024-03-17 Sun 12:47]--[2024-03-17 Sun 13:12] =>  0:25
CLOCK: [2024-03-17 Sun 02:07]--[2024-03-17 Sun 02:32] =>  0:25
CLOCK: [2024-03-17 Sun 01:26]--[2024-03-17 Sun 01:51] =>  0:25
CLOCK: [2024-03-16 Sat 14:50]--[2024-03-16 Sat 15:15] =>  0:25
CLOCK: [2024-03-16 Sat 14:24]--[2024-03-16 Sat 14:49] =>  0:25
CLOCK: [2024-03-16 Sat 11:35]--[2024-03-16 Sat 12:00] =>  0:25
CLOCK: [2024-03-16 Sat 11:08]--[2024-03-16 Sat 11:33] =>  0:25
CLOCK: [2024-03-16 Sat 10:15]--[2024-03-16 Sat 10:40] =>  0:25
CLOCK: [2024-03-15 Fri 00:46]--[2024-03-15 Fri 01:11] =>  0:25
CLOCK: [2024-03-14 Thu 23:59]--[2024-03-15 Fri 00:24] =>  0:25
:END:
前回途中でわからなくなったので、また読み始めた。

- システムコールで引数が数値なのはレジスタで渡せるのが数値だけだから
- 返り値もレジスタで返ってくるので数値
- ソケットが他のプロセス間通信と違うのは、アドレスとポート番号がわかればローカルのコンピュータ内だけではなく外部のコンピュータとも通信が行える点
- ソケットの3種類...TCP, UDP, Unixドメインソケット

** [[https://speakerdeck.com/akeno/oapi-codegenwoshi-tutemita?slide=24][oapi-codegenを使ってみた - Speaker Deck]]
oapi-codegenの使い方。とくにバリデーションが参考になる。
** [[https://note.crohaco.net/2020/gorp-unittest-with-db/][[Golang] gorpでDBを使ったユニットテストを書くたったひとつの冴えたやりかた - くろのて]]
factory-botを便利に使う方法。
** ポインタを渡すのにいちいち変数にしなくてよい

引数にポインタをとるとき。↓のようにしたくなる。

#+caption: 関数xxxxは*intを引数にとる
#+begin_src go
  i := 1
  xxxx(&i)
#+end_src

実際は↓のように短く書ける。

#+begin_src go
  func GetPtr[T any](x T) *T {
          return &x
  }

  xxxx(GetPtr(1))
#+end_src

** What happens with closures running as goroutines
- [[https://go.dev/doc/faq#closures_and_goroutines][Frequently Asked Questions (FAQ) - The Go Programming Language]]

#+caption: この結果はc, c, cになる
#+begin_src go
func main() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        <-done
    }
}
#+end_src

- ~v~ に入るインスタンスはループ間で共通である
- ループがまわり切ってから、goルーチンが実行される。goルーチンが実行されるときには、インスタンスは最後の ~"c"~ になっている

** delveを使う

gdbだと謎のgoroutineらしきものがたびたび挿入される( ~runtime.sigtramp~ )。直し方がよくわからないのでやめた。代わりにdelveを使うことに。構造体の表示がいい感じだ。使い方はだいたい同じ。

Emacsの ~M-x gdb~ と同等になるのが[[https://github.com/benma/go-dlv.el/][benma/go-dlv.el]]で配布されている。dap-modeよりこちらが好み。 ~(dlv-current-func)~ を使う。

** gdbで変数表示すると<optimized out>となるのを防ぐ

コンパイル時に最適化した結果、変数や式を削除することがある。その場合デバッガで表示できなくなる。コンパイルオプションで最適化を無効化すると表示できる。

#+caption: 最適化を無効化する
#+begin_src shell
  go build -gcflags="-N -l" main.go
#+end_src

** オプションパターン
オプションがたくさんある、でかいコードベースで見る表現の解説を見つけた。

- [[https://thomasnguyen.site/functional-options-pattern-in-golang][Functional Options Pattern in Golang]]

#+caption: optionsをループさせて、自在な組み合わせでオプションを設定する
#+begin_src go
package main

import "fmt"

type Config struct {
    Host     string
    Port     int
    Username string
    Password string
}

type Option func(*Config)

func WithHost(host string) Option {
    return func(c *Config) {
        c.Host = host
    }
}

func WithPort(port int) Option {
    return func(c *Config) {
        c.Port = port
    }
}

func WithCredentials(username, password string) Option {
    return func(c *Config) {
        c.Username = username
        c.Password = password
    }
}

func NewConfig(options ...Option) *Config {
    config := &Config{
        Host:     "localhost",
        Port:     8080,
        Username: "",
        Password: "",
    }

    for _, option := range options {
        option(config)
    }

    return config
}

#+end_src

** 型でラップする
型で挙動を変える書き方ができる。

#+begin_src go
  type Mover bool
  const (
          Animate = Mover(true)
          DontAnimate = Mover(false)
  )
  func (m Mover) move() { }

  Animate.move()
  DontAnimate.move()
#+end_src

** ゴルーチンはそれが作られたアドレス空間と同じ空間で実行する
Go言語による並行処理から。

ゴルーチンの中でクロージャーを実行すると、クロージャーはこれらの変数のコピーに対して操作するのか、それとも元の変数の参照に対してか。

#+caption: ゴルーチンの中でクロージャーを実行する
#+begin_src go :results output :imports '("fmt" "sync")
  var wg sync.WaitGroup
  salutation := "hello"
  wg.Add(1)
  go func() {
          defer wg.Done()
          salutation = "welcome"
  }()
  wg.Wait()
  fmt.Println(salutation)
#+end_src

#+RESULTS:
#+begin_results
welcome
#+end_results

ゴルーチンはそれが作られたアドレス空間と同じ空間で実行する、ということ。

#+caption: 同じ結果になる
#+begin_src go :results output :imports '("fmt" "sync")
  var wg sync.WaitGroup
  for _, salutation := range []string{"hello", "greetings", "good day"} {
          wg.Add(1)
          go func() {
                  defer wg.Done()
                  fmt.Println(salutation)
          }()
  }
  wg.Wait()
#+end_src

#+RESULTS:
#+begin_results
good day
good day
good day
#+end_results

- ゴルーチンが開始する前にループが終了してしまう
- salutation変数はスコープ外になる
- Goランタイムは変数salutationの参照がまだ保持されているのを知っていて、ゴルーチンがそのメモリにアクセスし続けられるようにメモリをヒープに移す
- 文字列スライスの最後の"good day"への参照を保持したままヒープに移される

ループを想定したようにただしく書くには、salutationのコピーをクロージャーに渡して、ゴルーチンが実行されるようになるまでにループの各繰り返しから渡されたデータを操作できるようにする。

#+caption: 文字列の構造体のコピーが行われる
#+begin_src go :results output :imports '("fmt" "sync")
  var wg sync.WaitGroup
  for _, salutation := range []string{"hello", "greetings", "good day"} {
          wg.Add(1)
          go func(salutation string) {
                  defer wg.Done()
                  fmt.Println(salutation)
          }(salutation)
  }
  wg.Wait()
#+end_src

#+RESULTS:
#+begin_results
good day
hello
greetings
#+end_results

** golanglint-ci のgci warningが出たとき
原因はよくわからない。ツールをインストールしてフォーマットをかける。

- [[https://stackoverflow.com/questions/75174808/meaning-of-file-is-not-gci-ed-with-skip-generated-s-standard-default-gci][main.go:24: File is not `gci`-ed with --skip-generated -s standard,default (gci)]]

#+begin_quote
main.go:24: File is not `gci`-ed with --skip-generated -s standard,default (gci)
#+end_quote

#+begin_src shell
  go install github.com/daixiang0/gci@latest
  gci write --skip-generated -s standard,default .
#+end_src
** カバレッジ計測方法
カバレッジフラグをオンにしているとコンパイル時、各ブロックにカウンタが挿入されて実行されている。
** 一部のテストを実行する

ファイル指定でテストを実行しようとすると、ほかのパッケージを読み込んでくれないため走らせられないことがある。多くの場合、ほかのファイルへの読み込みがあるので、現実的ではない。なので、読み込むファイルは全体にして、走らせる関数を指定して一部だけ実行する。

#+caption: Buildinfoとつくテストだけを実行する
#+begin_src go
go test ./... -run Buildinfo
#+end_src
** スタックとヒープ

- メモリの読み書きを行う場所は、スタックとヒープに分かれる
  - スタックはメモリの使い方や使用量がコンパイル時に決定できる場合に用いられる
    - 関数呼び出し時に確保され、関数から抜けるときに開放される。
    - あらかじめどのメモリをどれだけ使うかわかっているため、必要になる直前で確保し、いらなくなったらすぐに破棄できメモリを効率よく使える
  - ヒープはメモリの使い方や使用量が実行時にしかわからない場合に用いる
    - ヒープに確保した変数の生存期間は用途によってバラバラ
    - ガベージコレクタを用いてヒープのメモリを集中管理し、しかるべきタイミングで解放する
    - GoではGC時にSTW(Stop The World)が発生するものを採用しているので、GCが動いている間はプログラムの実行が止まる
  - なので、パフォーマンスを考慮するときはメモリを確保する先がスタックになるかヒープになるかは重要
  - 変数の型が実態で定義される場合、Goはその変数をスタック上に確保する。[[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C language]]と同じ
  - 変数の型をポインタにすると、メモリはヒープかスタックのどちらかに確保される

** 一時ファイルを作る

- os.CreateTemp が便利
- os.MkdirTemp → ディレクトリ
- (*testing.T).TempDir → テストで便利。テスト関数の終了時にディレクトリを消してくれる

** 大文字かを確認する

#+begin_src go :imports '("unicode" "fmt")
  fmt.Print(unicode.IsUpper('a'))
#+end_src

#+RESULTS:
#+begin_results
false
#+end_results

#+begin_src go :imports '("unicode" "fmt")
  fmt.Print(unicode.IsUpper('A'))
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

** goimportsが必要なパッケージを消してしまうときに確認すること
goimportsは面倒なimportを自動で書いてくれる便利なパッケージ。必要なパッケージを自動で消してしまうのでハマった。チェックリストを残す。

- 名前は合っているか。特に自分のパッケージを読み込む場合、module名と一致しているか
- 本当にその箇所から読み込めている記述になっているか。publicな呼び出しになっていないか

** copyは固定長のsliceに対してしかできない
copyはその名の通りsliceをコピーするメソッド。固定長でないとコピーされない。
** カバレッジを計測する
#+begin_src shell
$ go test -coverprofile=cover.out .
$ go tool cover -html=cover.out -o cover.html
#+end_src

Golang/goのリポジトリ全体を計測する。

#+caption: Go自体をビルドしてから、テストを実行する
#+begin_src shell
  cd ./src
  ./all.bash
  ../bin/go test -cover ./... -coverprofile=cover.out
  ../bin/go tool cover -html=cover.out -o cover.html
#+end_src
** 対象のインターフェースを満たしている関数の一覧を見る

#+begin_src shell
  godoc -http ":8000" -analysis type
  # http://localhost:6060/pkg/io/
#+end_src

** 失敗する可能性のあるときはerrorを返す
#+caption: errorを返す関数の例
#+begin_src go

func (w *Wallet) Withdraw(amount Bitcoin) error {
	if amount > w.balance {
		return ErrInsufficientFunds
	}

	w.balance -= amount
	return nil
}
#+end_src

成功したときは、errorにnilが入る。

error時の処理は呼び出し元で定義し、errorを返す可能性のある関数定義では単にerrorを返すことだけに集中する。

** named return value
返り値に名前をつける機能。最初に初期化され、returnするとそれ時点の名前のついた変数が返される。

#+caption: value1, value2は自動で初期化される。returnするとその時点でバインドされた変数が返される
#+begin_src go
  func test() (value1, value2 int) {
          value1 = 1
          value2 = 2
          return
  }
#+end_src

とすると、返り値には1, 2が返る。長い関数だとわかりづらくなるので注意。

** コールグラフを活用して関数呼び出しの全体像を把握する
どの関数がどこから呼び出されているかの図を生成する。

#+begin_src shell
  go install github.com/ofabry/go-callvis@master # なぜかlatestバージョンでは失敗した
#+end_src

そして調べたい関数を呼び出したmain.goのあるディレクトリで実行する。

#+begin_src shell
  go-callvis -group pkg,type ./ # -groupはグルーピング表示するオプション

  go-callvis -group pkg,type -focus fmt ./ # フォーカス表示
#+end_src

と、ブラウザが立ち上がって、図が表示される。図の中のライブラリをクリックすると、さらにそのライブラリの呼び出しを描画する。

** go getしたときの証明書エラー
go get したとき ~x509: certificate signed by unknown authority~ エラーになる。

証明書の更新をすればよいとのこと。

#+begin_src shell
  $ sudo apt update
  $ sudo apt install --only-upgrade -y ca-certificates #最新
  $ update-ca-certificates
#+end_src

** リクエストデータを構造体にバインドする
リクエストを使うときに通常使われる方法。値の検証と後で利用しやすくするため、定義した構造体に入れる。

- [[https://echo.labstack.com/guide/binding/][Binding Request Data | Echo - High performance, minimalist Go web framework]]
** 構造体の埋め込みの使い方
:LOGBOOK:
CLOCK: [2022-11-03 Thu 18:12]--[2022-11-03 Thu 18:37] =>  0:25
CLOCK: [2022-11-03 Thu 17:45]--[2022-11-03 Thu 18:10] =>  0:25
:END:
- [[https://qiita.com/momotaro98/items/4f6e2facc40a3f37c3c3][Go言語の埋め込みについて4つのポイントでまとめました - Qiita]]
Goの埋め込みの解説。

埋め込みはあくまでも借りているだけで、埋め込み元のオブジェクトのメソッドとして実行される。埋め込み先の構造体が埋め込み元のメソッドを実行しても埋め込み先のオブジェクトには影響を与えない。

** [[https://christina04.hatenablog.com/entry/pointers-in-golang][ポインタを図で理解する - Carpe Diem]]
:LOGBOOK:
CLOCK: [2022-11-03 Thu 12:47]--[2022-11-03 Thu 13:12] =>  0:25
CLOCK: [2022-11-03 Thu 12:14]--[2022-11-03 Thu 12:39] =>  0:25
:END:
図によるポインタのわかりやすい解説。

#+caption: 値の比較
#+begin_src go :imports "fmt"
  var x = 100
  fmt.Println("1: x address:\t", &x)

  var y *int
  fmt.Println("2: y value:\t", y)
  fmt.Println("3: y address:\t", &y)
  y = &x
  fmt.Println("4: y value:\t", y)	// yの値には、xのアドレスが入っている
  fmt.Println("5: y address:\t", &y)
#+end_src

#+RESULTS:
#+begin_results
1: x address:	 0xc00001a0c0
2: y value:	 <nil>
3: y address:	 0xc000012030
4: y value:	 0xc00001a0c0
5: y address:	 0xc000012030
#+end_results

- 型としての ~*~
  - ポインタ変数はメモリ上のアドレスを値として入れられる変数
  - 変数の中身(つまり値)はメモリアドレス
- 変数の演算子としての ~*~, ~&~
  - ~*~ ポインタの指すメモリアドレスの実データ(value)
  - ~&~ 変数がメモリ上で確保された際のアドレス(address)

~*x~ だけど ~x~ がポインタ型変数でない場合、値にアドレスがなくて辿れず当然値も取得できないのでエラー。

- メモリアドレスは変数であれば必ず存在する。なのでどの変数でも ~&~ が使える
- valueは値(1)か、メモリアドレス(0xc00001a0c0)が入っているか、nil。値にメモリアドレスが入っている場合のみ ~*~ が使える

#+caption: ポインタ変数だけどnilのとき、runtime errorになる
#+begin_src go :imports "fmt"
  var x *int
  fmt.Println("x value:\t", *x)
#+end_src

#+RESULTS:
#+begin_results
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x480f1a]
#+end_results

ポインタ変数のvalueにメモリアドレスがないのでpanicが起きる。動かしてみないとわからないのでコンパイルエラーでなくruntimeエラー。

Goはすべて値渡し(=コピー)。

#+caption: valueは同じだが、addressはすべて異なる
#+begin_src go :imports "fmt"
  func main() {
          var x = "alice"
          fmt.Println("x address:\t", &x)
          y := &x
          fmt.Println("y value:\t", y)
          fmt.Println("y address:\t", &y)

          show(y)
  }

  func show(s *string) {
          fmt.Println("f value:\t", s)
          fmt.Println("f address:\t", &s)
  }
#+end_src

#+RESULTS:
#+begin_results
x address:	 0xc000014250
y value:	 0xc000014250
y address:	 0xc000012030
f value:	 0xc000014250
f address:	 0xc000012038
#+end_results

定義された変数と、関数引数として使われた変数では、参照先アドレスは同じ(xのアドレス)。アドレスは異なる、つまりコピーされている。

ポインタレシーバ。

#+caption: main関数から、レシーバから呼ばれたときのアドレスと値を比較する
#+begin_src go :imports "fmt"
  type Person struct {
          Name string
          Age int
  }

  func main() {
          x := &Person{"alice", 20}
          fmt.Printf("x value:\t%p\n", x)
          fmt.Printf("x address:\t%p\n", &x)
          x.Greet("test")

          fmt.Printf("new x value:\t%v\n", x)
  }

  func (p *Person) Greet(msg string) {
          fmt.Printf("p value:\t%p\n", p)
          fmt.Printf("p address:\t%p\n", &p)

          // ポインタ変数を上書きするのではなく、参照先を上書きする
          p.Name = "hahaha"
  }
#+end_src

#+RESULTS:
#+begin_results
x value:	0xc000010030
x address:	0xc000012028
p value:	0xc000010030
p address:	0xc000012038
new x value:	&{hahaha 20}
#+end_results

** レシーバーを値とポインタのどちらにするか
メソッドのレシーバーを値にするかポインタにするかは、レシーバのフィールドに変更をしたいかによって決める。

#+caption: インスタンスのフィールドは変更されない(エラーにもならないので注意)
#+begin_src go
  func (s Struct) SetValue(v int {
          s.v = v
  })
#+end_src

#+caption: 値を変更できる
#+begin_src go
  func (s *Struct) SetValue(v int {
          s.v = v
  })
#+end_src
** ポインタの操作
:LOGBOOK:
CLOCK: [2022-11-03 Thu 11:49]--[2022-11-03 Thu 12:14] =>  0:25
CLOCK: [2022-11-03 Thu 11:24]--[2022-11-03 Thu 11:49] =>  0:25
:END:
- ポインタ型を示すときは ~*Person~ と宣言。これによってPerson型の変数のポインタが入ることが示される
- ポインタ型を生成するときは ~&~ を使う。これは変換関数のようなもの。 ~&変数名~ という形式。実際に変数宣言されているものに対してポインタがある。それぞれにアドレスが割り当てられるようなもの。だから、型とか関数自体はポインタにしない(意味がない)。あくまで変数をリンクさせて、変更を波及させられるのが良いところだから
- ポインタを解決実際の値を見るときは *p
- &p で*Person型を生成する、というような関係性

#+begin_src go :imports "fmt"
  var p *int // 変数pには、int型の変数のポインタが入るという宣言
  i := 1
  p = &i				// 変数iを参照するポインタ型変数p

  // p 				// -> 0xc000010000
  // *p 				// -> 1

  fmt.Println(p)
  fmt.Println(*p)
  i = 2				// あくまで変えるのは参照先の値であって、p -> i のリンク自体を変えるわけじゃない
  fmt.Println(p)			// メモリアドレスは変わらない
  fmt.Println(*p)			// 参照先のアドレスが変わった
#+end_src

#+RESULTS:
#+begin_results
0xc00001a0c0
1
0xc00001a0c0
2
#+end_results

- 「アドレスを取得(&)」という操作と「アドレスを解決(*)」という操作がある。

** TODO [[https://qiita.com/hnakamur/items/848097aad846d40ae84b][Goでファイルの存在チェック - Qiita]]
存在チェックの方法。
** ファイル埋め込み
#+caption: sample.jsonを型sampleBytesに格納する
#+begin_src go
    //go:embed sample.json
    var sampleBytes []byte
#+end_src

ファイルを直に変数に入れることができる。いちいち読み込みのコードを書かなくて良くなる。

複数ファイルの埋め込みもできる。

#+caption: embed.FS型のファイルシステムとして変数に埋め込む。あとから各々ファイルを取り出す
#+begin_src go
  //go:embed README.md version.txt
  var static embed.FS

  r, err := static.Readfile("README.md")
#+end_src

確かに短く書ける。しかしこれだけなら、従来の方法でもできる。メリットは、設定ファイルをバイナリに埋め込めること。

- [[https://future-architect.github.io/articles/20210208/][Go 1.16からリリースされたgo:embedとは | フューチャー技術ブログ]]
** 変数名のかぶりに注意する
型名と同じ変数名を宣言すると、よりローカルな変数名が優先されるため、その型が使えなくなる。それだけでなく、型指定で~は型ではありませんエラーが謎に出るため、ハマる可能性が高い。Lintで防げるだろうか。
** よく使う型の定義
- fdはファイルディスクリプタ。プログラムからファイルを操作する際、操作対象のファイルを識別・同定するために割り当てられる番号

#+caption: file型
#+begin_src git-permalink
https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file_unix.go#L54-L61
#+end_src

#+RESULTS:
#+begin_results go
type file struct {
	pfd         poll.FD
	name        string
	dirinfo     *dirInfo // nil unless directory being read
	nonblock    bool     // whether we set nonblocking mode
	stdoutOrErr bool     // whether this is stdout or stderr
	appendMode  bool     // whether file is opened for appending
}
#+end_results

- ネットワークで使うConnインターフェース

#+begin_src git-permalink
https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/net/net.go#L113-L168
#+end_src

#+RESULTS:
#+begin_results go
type Conn interface {
	// Read reads data from the connection.
	// Read can be made to time out and return an error after a fixed
	// time limit; see SetDeadline and SetReadDeadline.
	Read(b []byte) (n int, err error)

	// Write writes data to the connection.
	// Write can be made to time out and return an error after a fixed
	// time limit; see SetDeadline and SetWriteDeadline.
	Write(b []byte) (n int, err error)

	// Close closes the connection.
	// Any blocked Read or Write operations will be unblocked and return errors.
	Close() error

	// LocalAddr returns the local network address, if known.
	LocalAddr() Addr

	// RemoteAddr returns the remote network address, if known.
	RemoteAddr() Addr

	// SetDeadline sets the read and write deadlines associated
	// with the connection. It is equivalent to calling both
	// SetReadDeadline and SetWriteDeadline.
	//
	// A deadline is an absolute time after which I/O operations
	// fail instead of blocking. The deadline applies to all future
	// and pending I/O, not just the immediately following call to
	// Read or Write. After a deadline has been exceeded, the
	// connection can be refreshed by setting a deadline in the future.
	//
	// If the deadline is exceeded a call to Read or Write or to other
	// I/O methods will return an error that wraps os.ErrDeadlineExceeded.
	// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
	// The error's Timeout method will return true, but note that there
	// are other possible errors for which the Timeout method will
	// return true even if the deadline has not been exceeded.
	//
	// An idle timeout can be implemented by repeatedly extending
	// the deadline after successful Read or Write calls.
	//
	// A zero value for t means I/O operations will not time out.
	SetDeadline(t time.Time) error

	// SetReadDeadline sets the deadline for future Read calls
	// and any currently-blocked Read call.
	// A zero value for t means Read will not time out.
	SetReadDeadline(t time.Time) error

	// SetWriteDeadline sets the deadline for future Write calls
	// and any currently-blocked Write call.
	// Even if write times out, it may return n > 0, indicating that
	// some of the data was successfully written.
	// A zero value for t means Write will not time out.
	SetWriteDeadline(t time.Time) error
}
#+end_results

** ファイルを開く関数
- Open(), Create() は引数が違うだけで同じ関数OpenFile()を呼び出している
- よく使う権限の組み合わせでラップしているだけ

#+caption: Open
#+begin_src git-permalink
https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file.go#L311-L313
#+end_src

#+RESULTS:
#+begin_results
func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}
#+end_results

#+caption: Create
#+begin_src git-permalink
https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file.go#L320-L322
#+end_src

#+RESULTS:
#+begin_results
func Create(name string) (*File, error) {
	return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
#+end_results

#+caption: OpenFile
#+begin_src git-permalink
https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file.go#L330-L339
#+end_src

#+RESULTS:
#+begin_results
func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	testlog.Open(name)
	f, err := openFileNolog(name, flag, perm)
	if err != nil {
		return nil, err
	}
	f.appendMode = flag&O_APPEND != 0

	return f, nil
}
#+end_results

** 基本コマンド

#+caption: mod.goを作成する
#+begin_src shell
go mod init example
#+end_src

#+caption: 依存パッケージをインストールする。mod.goに記載される
#+begin_src shell
go install
#+end_src

#+caption: ビルド+実行
#+begin_src shell
go run hello.go
#+end_src

[[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]] dap-modeでデバッガ起動。行の横をクリックしてブレークポイントをセットしたのち、コマンド実行。

#+caption: デバッグ実行
#+begin_src emacs-lisp
M-x dap-debug
#+end_src

** [[id:7e85e3f3-a6b9-447e-9826-307a3618dac8][org-mode]]での実行方法

ob-goをインストールして ~(require "ob-go")~ する。実行方法が少し変わっていて、下のように指定する。

#+caption: babel引数で指定importを指定する。本文には書かない
#+begin_src go :imports "fmt"
  fmt.Println("hello world")
#+end_src

#+RESULTS:
#+begin_results
hello world
#+end_results

- [[https://github.com/pope/ob-go][pope/ob-go: Org-Babel support for evaluating go code.]]

** [[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]に[[id:eb807577-cd69-478c-8f82-264243c67354][LSP]]+DAPを設定する
CLOSED: [2022-08-22 Mon 12:44]
:LOGBOOK:
CLOCK: [2022-08-22 Mon 11:41]--[2022-08-22 Mon 12:06] =>  0:25
CLOCK: [2022-08-22 Mon 10:57]--[2022-08-22 Mon 11:22] =>  0:25
:END:
DAP(Debug Adapter Protocol)はデバッガー補助。エディタ関係なくIDEのようにエディタ上でブレークポイントをセットできるプロトコル。[[id:eb807577-cd69-478c-8f82-264243c67354][LSP]]のデバッガーバージョンな概念。

Go用のデバッガはemacsコマンドでインストールできず、go installでインストールする必要がある。

- [[https://emacs-lsp.github.io/dap-mode/page/configuration/#go][Configuration - DAP Mode]]
  - 外部コマンドをgo installでインストール
    - LSPのライブラリ名は ~gopls~
    - Debuggerのライブラリ名は ~delve~ (注意: VScode用のプログラムを用いる方法はdeprecatedで、現在は直接installするのが最新)
  - go installしたあと、Emacs側が認識できるように設定する

#+caption: インストールする
#+begin_src shell
  $ go install golang.org/x/tools/gopls@master            # Language Server
  $ go install github.com/go-delve/delve/cmd/dlv@master   # debugger
#+end_src

自分の環境では一瞬デバッガのボタンが表示されて Debug Adapter finished になってしまう状態になった。Warningには ~Warning (emacs): Initialize request failed: Failed to launch Disable showing Disable logging~ が表示される。理由がよくわからないため、表示させる。 ~(setq dap-print-io t)~ を評価すると、messageバッファに詳細なログを出力する。

原因は、しっかりと表示されていた。

#+begin_quote
"format": "Failed to launch: Go version 1.14.15 is too old for this version of Delve (minimum supported version 1.17, suppress this error with --check-go-version=false)",
#+end_quote

ということで、goのバージョンを上げると無事デバッガが起動するようになった。

#+caption: その他便利ライブラリ
#+begin_src shell
  $ go install github.com/uudashr/gopkgs/cmd/gopkgs       # Go パッケージ
  $ go install golang.org/x/tools/cmd/goimports@master    # import の過不足を自動で補完
#+end_src
** printの仕組み
CLOSED: [2023-02-11 Sat 17:25]
:LOGBOOK:
CLOCK: [2022-11-19 Sat 23:33]--[2022-11-19 Sat 23:58] =>  0:25
CLOCK: [2022-11-19 Sat 21:08]--[2022-11-19 Sat 21:33] =>  0:25
CLOCK: [2022-11-19 Sat 19:20]--[2022-11-19 Sat 19:45] =>  0:25
CLOCK: [2022-11-19 Sat 18:34]--[2022-11-19 Sat 18:59] =>  0:25
CLOCK: [2022-11-19 Sat 17:27]--[2022-11-19 Sat 17:52] =>  0:25
CLOCK: [2022-11-19 Sat 16:50]--[2022-11-19 Sat 17:15] =>  0:25
CLOCK: [2022-11-19 Sat 16:25]--[2022-11-19 Sat 16:50] =>  0:25
CLOCK: [2022-11-19 Sat 15:47]--[2022-11-19 Sat 16:12] =>  0:25
CLOCK: [2022-11-19 Sat 12:00]--[2022-11-19 Sat 12:25] =>  0:25
CLOCK: [2022-11-19 Sat 11:18]--[2022-11-19 Sat 11:43] =>  0:25
CLOCK: [2022-11-19 Sat 10:53]--[2022-11-19 Sat 11:18] =>  0:25
CLOCK: [2022-11-19 Sat 00:33]--[2022-11-19 Sat 00:58] =>  0:25
CLOCK: [2022-11-18 Fri 09:49]--[2022-11-18 Fri 10:14] =>  0:25
CLOCK: [2022-11-18 Fri 09:24]--[2022-11-18 Fri 09:49] =>  0:25
CLOCK: [2022-11-18 Fri 00:44]--[2022-11-18 Fri 01:09] =>  0:25
CLOCK: [2022-11-18 Fri 00:19]--[2022-11-18 Fri 00:44] =>  0:25
CLOCK: [2022-11-17 Thu 23:54]--[2022-11-18 Fri 00:19] =>  0:25
CLOCK: [2022-11-17 Thu 00:32]--[2022-11-17 Thu 00:57] =>  0:25
CLOCK: [2022-11-16 Wed 10:02]--[2022-11-16 Wed 10:27] =>  0:25
CLOCK: [2022-11-16 Wed 09:34]--[2022-11-16 Wed 09:59] =>  0:25
:END:

プリンターの状態を保存している、重要そうな構造体。

#+begin_src git-permalink
https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/fmt/print.go#L119-L120
#+end_src

#+RESULTS:
#+begin_results go
// pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.
type pp struct {
#+end_results

#+caption: フラグを実装している箇所。歴史的理由で引数はintになっているらしい
#+begin_src git-permalink
https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/fmt/print.go#L188-L202
#+end_src

#+RESULTS:
#+begin_results go
func (p *pp) Flag(b int) bool {
	switch b {
	case '-':
		return p.fmt.minus
	case '+':
		return p.fmt.plus || p.fmt.plusV
	case '#':
		return p.fmt.sharp || p.fmt.sharpV
	case ' ':
		return p.fmt.space
	case '0':
		return p.fmt.zero
	}
	return false
}
#+end_results

#+caption: Printは出力先が標準出力の、Fprintのエイリアスにすぎない
#+begin_src git-permalink
https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/fmt/print.go#L271-L273
#+end_src

#+RESULTS:
#+begin_results go
func Print(a ...any) (n int, err error) {
	return Fprint(os.Stdout, a...)
}
#+end_results

- doPrintf
  - printArg
    - printValue

- 実際画面に表示してるのはどこなんだろう
  - print系の中でbufに書き込みをしているのはよく見る
  - 関数の中に画面出力、みたいな部分は見当たらず
  - 別に「画面に出力する」という関数があるわけじゃなくて、「標準出力にあたるファイルに書き込みをする」関数があるだけ。だから、標準出力以外への書き込みとの差は一切ない
  - /dev/stdin は特殊ファイルという。画面への入出力などをファイルとして操作できるようにしたものだから、ファイル書き込みとなんら変わらずに操作できる
  - Stdoutは1と定義されている。なので、fd1つまり/dev/stdout/1を作成する

#+begin_src git-permalink
https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/os/file.go#L66
#+end_src

#+RESULTS:
#+begin_results go
	Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
#+end_results

#+begin_src git-permalink
  https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/cmd/vendor/golang.org/x/sys/unix/syscall_unix.go#L20
#+end_src

#+RESULTS:
#+begin_results
	Stdout = 1
#+end_results

- print系は、ベースになる関数がある。書き込み先とフォーマット解析の組み合わせで、いろいろ名前がついている
- 本質的に、ファイル書き込みにすぎない
- フォーマット解析でいろいろ処理があって、多くを占める。各型での文字列の取り出し方とか
** Stringerとは
CLOSED: [2023-02-11 Sat 18:15]
:LOGBOOK:
CLOCK: [2023-02-11 Sat 17:34]--[2023-02-11 Sat 17:59] =>  0:25
CLOCK: [2023-02-11 Sat 17:05]--[2023-02-11 Sat 17:30] =>  0:25
:END:
よく見るが、何か。

#+begin_src git-permalink
https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/fmt/print.go#L63-L65
#+end_src

#+RESULTS:
#+begin_results go
type Stringer interface {
	String() string
}
#+end_results

#+caption: String()を実装してるのでMyStringはStringer
#+begin_src go :imports "fmt"
type MyString string

func (s MyString) String() string {
  return "mystring"
}

func main() {
  s := MyString("hello")
  fmt.Println(s) // String()の結果が使われる
}
#+end_src

#+RESULTS:
#+begin_results
mystring
#+end_results

printするときには、先にStringerの判定が入る。Stringerを満たしていれば、String()を使う。満たさなければ、通常の、printに渡された文字列引数を使って表示する。

#+caption: fmtパッケージのhandleMethodsという関数
#+begin_src git-permalink
https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/fmt/print.go#L670-L675
#+end_src

#+RESULTS:
#+begin_results go
			case Stringer:
				handled = true
				defer p.catchPanic(p.arg, verb, "String")
				p.fmtString(v.String(), verb)
				return
			}
#+end_results

** runeとは
:LOGBOOK:
CLOCK: [2023-02-11 Sat 22:43]--[2023-02-11 Sat 23:08] =>  0:25
CLOCK: [2023-02-11 Sat 22:05]--[2023-02-11 Sat 22:30] =>  0:25
CLOCK: [2023-02-11 Sat 21:28]--[2023-02-11 Sat 21:53] =>  0:25
:END:

- [[https://qiita.com/seihmd/items/4a878e7fa340d7963fee][Goのruneを理解するためのUnicode知識 - Qiita]]
- 文字と01の並びを対応づける仕組み、それが文字コード。その1つのUnicodeは世界中のあらゆる文字列を収録されるために作られている規格
  - aはUnicodeでu+0041と表される。16進数で0041という値と対応づけられる。この値はcode point(code position)と呼ばれ、文字コード中の位置を指し示す文字のIDといえる
  - 符号化方式は41とか1F601といったcode pointの値をコンピュータが扱うデータ形式に置き換えるための規則。方式によってcode pointを何byte単位で扱うかが異なってくる
  - Goでは符号化方式としてUTF-8を使用している。UTF-8では1byteから4byteの可変長データでcode pointを置換する。数字やアルファベットのような広く使われている文字は1byteになり、Unicodeに後から追加された絵文字などは4byteになる。
  - Unicodeの符号化方式にはUTF-16やUTF-8がある
- stringにインデックスでアクセスしたときに得られるbyte値は文字コードをUTF-8で1byteごとに区切った値

#+caption: "あ"は3byteで表される
#+begin_src go :imports fmt
  s := "あ"
  for i := 0; i < len(s); i++{
    fmt.Printf("% x", s[i])
  }
#+end_src

#+RESULTS:
#+begin_results
e3 81 82
#+end_results

- ひとつの文字は複数byteで表現される可能性がある。文字を表すbyteをまとめて読まないと正しい文字として認識できなくなる
- なので文字を数える単位としてはbyteではなくcode pointのほうが都合がいい。Goではcode pointを単位として文字を扱うための仕組み、つまりruneを用意している
- runeの実体はint32のエイリアス。int32なのはUnicodeの4byte分のcode pointを表現するため

#+begin_src git-permalink
https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L90-L92
#+end_src

#+RESULTS:
#+begin_results go
// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
#+end_results

#+caption: runeはint32のエイリアス。なので単なる数字
#+begin_src go :imports fmt
  fmt.Println('あ')
  fmt.Println('a')
  fmt.Println(' ')
  fmt.Println('!')
  fmt.Println('"')
  fmt.Println('a' * 2)
  fmt.Println('a' - 'b')
#+end_src

#+RESULTS:
#+begin_results
12354
97
32
33
34
194
-1
#+end_results

#+caption: stringを[]runeと[]byteにキャストする。文字列が対応するcodepoint、byteに姿を変えているだけ
#+begin_src go :imports fmt
  s := "あいう"
  fmt.Println([]rune(s))
  fmt.Println([]byte(s))
#+end_src

#+RESULTS:
#+begin_results
[12354 12356 12358]
[227 129 130 227 129 132 227 129 134]
#+end_results
** [[https://postd.cc/performance-without-the-event-loop/][イベントループなしでのハイパフォーマンス – C10K問題へのGoの回答 | POSTD]]
:PROPERTIES:
:Effort:   1:00
:END:
:LOGBOOK:
CLOCK: [2023-10-15 Sun 14:01]--[2023-10-15 Sun 14:26] =>  0:25
CLOCK: [2023-10-15 Sun 13:34]--[2023-10-15 Sun 13:59] =>  0:25
:END:

Goルーチンの解説。ベースがないのでよく理解できなかった。

** [[https://christina04.hatenablog.com/entry/why-goroutine-is-good][goroutineはなぜ軽量なのか - Carpe Diem]]
CLOSED: [2023-10-17 Tue 01:03]
:LOGBOOK:
CLOCK: [2023-10-17 Tue 00:37]--[2023-10-17 Tue 01:02] =>  0:25
:END:

Goルーチンの解説。よくわからなかった。
** [[https://qiita.com/takc923/items/de68671ea889d8df6904][Golangのスケジューラあたりの話 - Qiita]]
** [[https://christina04.hatenablog.com/entry/2017/07/05/005944][Non-Blocking I/O, I/O Multiplexing, Asynchronous I/Oの区別 - Carpe Diem]]
:LOGBOOK:
CLOCK: [2023-10-17 Tue 08:39]--[2023-10-17 Tue 09:04] =>  0:25
:END:
非同期処理の解説。
* Tasks
** TODO [[https://github.com/dgryski/go-perfbook][dgryski/go-perfbook: Thoughts on Go performance optimization]]
Goのパフォーマンス最適の読み物。
** TODO [[https://speakerdeck.com/uji/5fen-dewan-quan-li-jie-surugofalseiota][5分で完全理解するGoのiota - Speaker Deck]]
GoのiotaのTips。
** TODO [[https://blog.lufia.org/entry/2021/03/17/113000][Goアセンブリの書き方 - Plan 9とGo言語のブログ]]
:LOGBOOK:
CLOCK: [2023-10-15 Sun 17:37]--[2023-10-15 Sun 18:02] =>  0:25
:END:
Goアセンブリの解説記事。
** TODO [[https://cmc.gitbook.io/go-internals/][go-internals - Go Internals]]
Goの内部仕様についての本。
** TODO [[https://qiita.com/Akatsuki_py/items/231350711f9ab6eba95e][Goアセンブリ入門 - Qiita]]
:LOGBOOK:
CLOCK: [2023-10-16 Mon 00:14]--[2023-10-16 Mon 00:39] =>  0:25
CLOCK: [2023-10-15 Sun 23:28]--[2023-10-15 Sun 23:53] =>  0:25
CLOCK: [2023-10-15 Sun 23:03]--[2023-10-15 Sun 23:28] =>  0:25
CLOCK: [2023-10-15 Sun 21:40]--[2023-10-15 Sun 22:05] =>  0:25
CLOCK: [2023-10-15 Sun 21:05]--[2023-10-15 Sun 21:30] =>  0:25
CLOCK: [2023-10-15 Sun 20:24]--[2023-10-15 Sun 20:49] =>  0:25
:END:
Goアセンブリの解説。

#+begin_src go-asm
package main
func add(a, b int32) (int32, bool) { return a + b, true }
func main() { add(10, 32) }
#+end_src

#+RESULTS:
#+begin_results
# command-line-arguments
main.add STEXT nosplit size=71 args=0x8 locals=0x10 funcid=0x0 align=0x0
	0x0000 00000 (/tmp/babel-ZDNznW/XkIsxn.go:2)	TEXT	main.add(SB), NOSPLIT|ABIInternal, $16-8
	0x0000 00000 (/tmp/babel-ZDNznW/XkIsxn.go:2)	SUBQ	$16, SP
	0x0004 00004 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVQ	BP, 8(SP)
	0x0009 00009 (/tmp/babel-ZDNznW/XkIsxn.go:2)	LEAQ	8(SP), BP
	0x000e 00014 (/tmp/babel-ZDNznW/XkIsxn.go:2)	FUNCDATA	$0, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)
	0x000e 00014 (/tmp/babel-ZDNznW/XkIsxn.go:2)	FUNCDATA	$1, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)
	0x000e 00014 (/tmp/babel-ZDNznW/XkIsxn.go:2)	FUNCDATA	$5, main.add.arginfo1(SB)
	0x000e 00014 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVL	AX, main.a+24(SP)
	0x0012 00018 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVL	BX, main.b+28(SP)
	0x0016 00022 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVL	$0, main.~r0+4(SP)
	0x001e 00030 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVB	$0, main.~r1+3(SP)
	0x0023 00035 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVL	main.a+24(SP), CX
	0x0027 00039 (/tmp/babel-ZDNznW/XkIsxn.go:2)	ADDL	main.b+28(SP), CX
	0x002b 00043 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVL	CX, main.~r0+4(SP)
	0x002f 00047 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVB	$1, main.~r1+3(SP)
	0x0034 00052 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVL	main.~r0+4(SP), AX
	0x0038 00056 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVL	$1, BX
	0x003d 00061 (/tmp/babel-ZDNznW/XkIsxn.go:2)	MOVQ	8(SP), BP
	0x0042 00066 (/tmp/babel-ZDNznW/XkIsxn.go:2)	ADDQ	$16, SP
	0x0046 00070 (/tmp/babel-ZDNznW/XkIsxn.go:2)	RET
	0x0000 48 83 ec 10 48 89 6c 24 08 48 8d 6c 24 08 89 44  H...H.l$.H.l$..D
	0x0010 24 18 89 5c 24 1c c7 44 24 04 00 00 00 00 c6 44  $..\$..D$......D
	0x0020 24 03 00 8b 4c 24 18 03 4c 24 1c 89 4c 24 04 c6  $...L$..L$..L$..
	0x0030 44 24 03 01 8b 44 24 04 bb 01 00 00 00 48 8b 6c  D$...D$......H.l
	0x0040 24 08 48 83 c4 10 c3                             $.H....
main.main STEXT size=54 args=0x0 locals=0x10 funcid=0x0 align=0x0
	0x0000 00000 (/tmp/babel-ZDNznW/XkIsxn.go:3)	TEXT	main.main(SB), ABIInternal, $16-0
	0x0000 00000 (/tmp/babel-ZDNznW/XkIsxn.go:3)	CMPQ	SP, 16(R14)
	0x0004 00004 (/tmp/babel-ZDNznW/XkIsxn.go:3)	PCDATA	$0, $-2
	0x0004 00004 (/tmp/babel-ZDNznW/XkIsxn.go:3)	JLS	47
	0x0006 00006 (/tmp/babel-ZDNznW/XkIsxn.go:3)	PCDATA	$0, $-1
	0x0006 00006 (/tmp/babel-ZDNznW/XkIsxn.go:3)	SUBQ	$16, SP
	0x000a 00010 (/tmp/babel-ZDNznW/XkIsxn.go:3)	MOVQ	BP, 8(SP)
	0x000f 00015 (/tmp/babel-ZDNznW/XkIsxn.go:3)	LEAQ	8(SP), BP
	0x0014 00020 (/tmp/babel-ZDNznW/XkIsxn.go:3)	FUNCDATA	$0, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)
	0x0014 00020 (/tmp/babel-ZDNznW/XkIsxn.go:3)	FUNCDATA	$1, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)
	0x0014 00020 (/tmp/babel-ZDNznW/XkIsxn.go:3)	MOVL	$10, AX
	0x0019 00025 (/tmp/babel-ZDNznW/XkIsxn.go:3)	MOVL	$32, BX
	0x001e 00030 (/tmp/babel-ZDNznW/XkIsxn.go:3)	PCDATA	$1, $0
	0x001e 00030 (/tmp/babel-ZDNznW/XkIsxn.go:3)	NOP
	0x0020 00032 (/tmp/babel-ZDNznW/XkIsxn.go:3)	CALL	main.add(SB)
	0x0025 00037 (/tmp/babel-ZDNznW/XkIsxn.go:3)	MOVQ	8(SP), BP
	0x002a 00042 (/tmp/babel-ZDNznW/XkIsxn.go:3)	ADDQ	$16, SP
	0x002e 00046 (/tmp/babel-ZDNznW/XkIsxn.go:3)	RET
	0x002f 00047 (/tmp/babel-ZDNznW/XkIsxn.go:3)	NOP
	0x002f 00047 (/tmp/babel-ZDNznW/XkIsxn.go:3)	PCDATA	$1, $-1
	0x002f 00047 (/tmp/babel-ZDNznW/XkIsxn.go:3)	PCDATA	$0, $-2
	0x002f 00047 (/tmp/babel-ZDNznW/XkIsxn.go:3)	CALL	runtime.morestack_noctxt(SB)
	0x0034 00052 (/tmp/babel-ZDNznW/XkIsxn.go:3)	PCDATA	$0, $-1
	0x0034 00052 (/tmp/babel-ZDNznW/XkIsxn.go:3)	JMP	0
	0x0000 49 3b 66 10 76 29 48 83 ec 10 48 89 6c 24 08 48  I;f.v)H...H.l$.H
	0x0010 8d 6c 24 08 b8 0a 00 00 00 bb 20 00 00 00 66 90  .l$....... ...f.
	0x0020 e8 00 00 00 00 48 8b 6c 24 08 48 83 c4 10 c3 e8  .....H.l$.H.....
	0x0030 00 00 00 00 eb ca                                ......
	rel 33+4 t=7 main.add+0
	rel 48+4 t=7 runtime.morestack_noctxt+0
go:cuinfo.producer.main SDWARFCUINFO dupok size=0
	0x0000 2d 4e 20 2d 6c 20 72 65 67 61 62 69              -N -l regabi
go:cuinfo.packagename.main SDWARFCUINFO dupok size=0
	0x0000 6d 61 69 6e                                      main
main..inittask SNOPTRDATA size=24
	0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
	0x0010 00 00 00 00 00 00 00 00                          ........
gclocals·g2BeySu+wFnoycgXfElmcg== SRODATA dupok size=8
	0x0000 01 00 00 00 00 00 00 00                          ........
main.add.arginfo1 SRODATA static dupok size=5
	0x0000 00 04 04 04 ff                                   .....
#+end_results

** TODO [[https://zenn.dev/smartshopping/articles/5df9c3717e25bd][【Go】Mapの内部構造とO(1)のメカニズム]]
Mapの中身の解説。
** TODO [[https://reproducible-builds.org/][Reproducible Builds — a set of software development practices that create an independently-verifiable path from source to binary code]]
再現可能なビルド。

** TODO [[https://zenn.dev/nobishii/articles/goquiz_20230817][[Go Quiz] 単一の型のみによる型制約を持つ型パラメータを型に持つ変数にその型の変数を代入できるか]]
型のクイズ。
** TODO [[https://zenn.dev/nobishii/articles/type_param_intro][Go言語のジェネリクス入門]]
ジェネリクスの解説。
** TODO [[https://speakerdeck.com/dqneo/go-specification-untyped-constants][入門Go言語仕様 / Go Specification Untyped Constants - Speaker Deck]]
Untyped Constantsの解説。
** TODO [[https://www.youtube.com/watch?v=TOUkp_Dxb9w][(4) 列挙型の作り方を再考する - Go Conference 2023 Online - YouTube]]
iotaで作るのがデフォルトではあるけれど。
** TODO [[https://www.oreilly.com/library/view/hands-on-software-architecture/9781788622592/][Hands-On Software Architecture with Golang [Book]]]
Golangの本。
** TODO [[https://qiita.com/tenntenn/items/45c568d43e950292bc31][Goを学びたての人が誤解しがちなtypeと構造体について #golang - Qiita]]
シンタックスの意味。
** TODO [[https://qiita.com/sonatard/items/464a9d45c689386edfe1][Better C - Goと整数 #golang - Qiita]]
Goの整数の仕様の解説。
** TODO [[https://qiita.com/sonatard/items/7b9b376f3420879a00d6][Go Binary Hacks - go buildせずにビルドする #golang - Qiita]]
go buildの仕組み解説。全然わからん。
** TODO [[https://go.dev/talks/2012/splash.article][Go at Google: Language Design in the Service of Software Engineering - The Go Programming Language]]
[[id:7cacbaa3-3995-41cf-8b72-58d6e07468b1][Go]]の言語デザインの解説。
** TODO [[https://research.swtch.com/interfaces][research!rsc: Go Data Structures: Interfaces]]
Russ Coxによるインターフェースの詳しい解説。
** TODO [[https://qiita.com/fujim2/items/493b2c8eac47a3ffe7c7][golangの並行処理のための言語要素に対応するCSPの記述を理解して形式検証の実践を開始しよう(記述編） - Qiita]]
CSPを理解する。
** TODO [[https://go.dev/blog/declaration-syntax][Go's Declaration Syntax - The Go Programming Language]]
Cのシンタックスとの違い、理由。
** TODO [[https://gist.github.com/kofuk/922bdce139e657d67baf22e053f4b548][Goアセンブラのクイックガイド]]
公式ドキュメントの翻訳。
** TODO [[https://docs.google.com/presentation/d/10ru3LdbofJqgdmD8pprZuZyWbGvOFC8rKxb6q5Q46Xc/edit#slide=id.p][Go言語低レイヤー入門 Hello world が 画面に表示されるまで (GoConforenceTokyo2021) - Google Slides]]
:LOGBOOK:
CLOCK: [2023-06-22 Thu 21:33]--[2023-06-22 Thu 21:58] =>  0:25
:END:
低レイヤーの解説。
** TODO [[https://zenn.dev/hsaki/articles/godoc-asm-ja][解説&翻訳 - A Quick Guide to Go's Assembler]]
Goアセンブラの解説。
** TODO [[https://zenn.dev/dqneo/articles/ce9459676a3303][go build を使わずにGoプログラムをビルドする]]
:LOGBOOK:
CLOCK: [2023-07-02 Sun 20:06]--[2023-07-02 Sun 20:31] =>  0:25
CLOCK: [2023-07-02 Sun 19:34]--[2023-07-02 Sun 19:59] =>  0:25
CLOCK: [2023-06-22 Thu 23:15]--[2023-06-22 Thu 23:40] =>  0:25
:END:

go buildの仕組み。実際に動かして取っ掛かりを見つけるのが面白い。そういうアプローチもあるのか。

#+begin_quote
私はソースを読むよりもリバースエンジニアリングする方が得意なので、今回もログだけを見て処理内容を推測して自作しました。
#+end_quote

ビルドタグで言及されてたページ。

-[[https://zenn.dev/team_soda/articles/golang-build-tags-history][ Goのビルドタグの書き方が// +buildから//go:buildに変わった理由]]
** TODO [[https://go.dev/doc/comment][Go Doc Comments - The Go Programming Language]]
Go Docのコメントの仕様。
** TODO [[https://github.com/golang/go/wiki/CompilerOptimizations#function-inlining][CompilerOptimizations · golang/go Wiki]]
コンパイラの最適化。
** TODO [[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview][Go Escape Analysis Flaws - Google Docs]]
Goエスケープの説明。
** TODO [[https://zenn.dev/mjhd/articles/a09cb5905b7848][Go 1.20: Profile-Guided Optimization]]
#+begin_quote
Profile-Guided Optimizationは、コンパイル時最適化のヒントとして、ランタイムのプロファイル情報を使うことでより効率よく最適化する手法です。
#+end_quote
** TODO [[https://qiita.com/ruiu/items/54f0dbdec0d48082a5b1][Goでスレッド（goroutine）セーフなプログラムを書くために必ず注意しなければいけない点 - Qiita]]
並列実行の注意点。
** TODO [[https://go.dev/ref/mem][The Go Memory Model - The Go Programming Language]]
Goのメモリモデル。
** TODO [[https://zenn.dev/sryoya/articles/b0e8e8d83032b0][sync.Onceの内部実装から学ぶ実装アイデア]]
sync.Onceの仕組み。
** TODO チェックミスに見えるところを確認する
チャネルの矢印がないときに、パッケージがないエラーになることがある。ちゃんとそっちを示してほしいのに。フォーマッタとビルドの検知が合ってないために起こるように見える。
** TODO [[https://github.com/golang/go/wiki/Articles][Articles · golang/go Wiki]]
公式の記事。
** TODO [[https://qiita.com/Akatsuki_py/items/8041fba499d54d59e0dd]["go build"した時に何が起きているのか？ - Qiita]]
コンパイル時になにが起きているか、ログから調べる。
** TODO [[https://deeeet.com/writing/2016/05/08/gogc-2016/][GolangのGCを追う | Taichi Nakashima]]
GCの解説。
** TODO [[https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/][Golang Internals, Part 5: the Runtime Bootstrap Process | Altoros]]
Goのランタイムの解説。
** TODO [[https://speakerdeck.com/rhysd/go-detukurufan-yong-yan-yu-chu-li-xi-shi-zhuang-zhan-lue][Go でつくる汎用言語処理系 実装戦略 - Speaker Deck]]
言語処理系の作り方。
** TODO [[https://go.dev/src/cmd/compile/README][Introduction to the Go compiler - The Go Programming Language]]
Goコンパイルの流れ。
** TODO [[https://maku77.github.io/p/29dgjnq/][ベンチマークを行う (testing.B) - まくまく Golang ノート]]
ベンチマークする方法。
** TODO [[https://zenn.dev/spiegel/books/error-handling-in-golang/viewer/evaluations][エラー評価のいろいろ｜Go のエラーハンドリング]]
エラーハンドリングの本。
** TODO [[https://qiita.com/hkurokawa/items/a4d402d3182dff387674][Go の定数の話 - Qiita]]
:LOGBOOK:
CLOCK: [2023-03-25 Sat 18:47]--[2023-03-25 Sat 19:12] =>  0:25
:END:
じつは複雑な定数。
** TODO [[https://zenn.dev/senk/articles/33c9dc7ea25dab][[Go] 言語仕様書の「型と値の特性」を理解する]]
値。
** TODO interfaceを満たす構造体の調べ方

どうするんだっけ。
** TODO [[https://github.com/golang/example][golang/example: Go example projects]]
例で学ぶ解説。
** TODO [[https://zenn.dev/spiegel/articles/20201010-ni-is-not-nil][nil == nil でないとき（または Go プログラマは息をするように依存を注入する）]]
直感に反する挙動からわかる、内部の仕組みの話。
** TODO [[https://gihyo.jp/book/2023/978-4-297-13419-8][Go言語プログラミングエッセンス：書籍案内｜技術評論社]]
来月発売される本。
** TODO ecspressoが本質的に何をしているか調べる                      :DontKnow:
** TODO [[https://d-tsuji.github.io/effective_go/documents/effective_go_ja.html][Effective Go — Effective Go ドキュメント]]
日本語訳。
** TODO [[https://runebook.dev/ja/docs/go/-index-][Go 1.19 日本語]]
日本語訳された公式ドキュメント。
** TODO [[https://zenn.dev/hsaki/books/golang-concurrency/viewer/intro][はじめに｜Goでの並行処理を徹底解剖！]]
:LOGBOOK:
CLOCK: [2023-02-15 Wed 21:48]--[2023-02-15 Wed 22:13] =>  0:25
CLOCK: [2023-02-14 Tue 23:43]--[2023-02-15 Wed 00:08] =>  0:25
CLOCK: [2023-02-14 Tue 23:18]--[2023-02-14 Tue 23:43] =>  0:25
CLOCK: [2023-02-14 Tue 22:53]--[2023-02-14 Tue 23:18] =>  0:25
CLOCK: [2023-02-14 Tue 22:26]--[2023-02-14 Tue 22:51] =>  0:25
CLOCK: [2023-02-14 Tue 00:25]--[2023-02-14 Tue 00:50] =>  0:25
:END:
並行処理の解説本。

並行処理と並列処理は全く異なる。

- 並行処理(Concurrency)
  - ある時点の範囲において、複数のタスクを扱うこと
  - どういう風にふたつを終わらせるかは自由
  - 複数の処理を独立に実行できる *構成* のこと
  - 「並行処理できる設備がある」
  - 一度に多くのことを扱うこと
  - 問題解決の手段としてのプログラミングパターン
  - 平行性はコードの性質
- 並列処理(Parallelism)
  - ある時点の点において、複数のタスクを扱うこと
  - 1点において、タスクAとBを同時に実行する
  - 複数の処理を同時に *実行* すること
  - 「並列処理で生産する」
  - 一度に多くのことを行うこと
  - 並行処理を可能にするハードウェアの特性のこと
  - 並列性は動作しているプログラムの性質

チャネルは送受信、実行同期のための機構。

[[file:images/20230521-parallel.drawio.svg]]

- ゴルーチンは他のコードに対して並行に実行している関数のこと(必ずしも並列ではない)

** TODO [[https://www.manning.com/books/learn-go-with-pocket-sized-projects?utm_source=donia&utm_medium=affiliate&utm_campaign=book_latour_learn_1_5_23&utm_content=linkedin&a_aid=donia&a_bid=48b0541c][Learn Go with Pocket-Sized Projects]]
Goのハンズオン集。
** TODO [[https://qiita.com/tenntenn/items/b1bb5eb4d372bd2d936f][gorenameをライブラリとして使う #golang - Qiita]]
IdをIDに変換する例。
** TODO [[https://qiita.com/lighttiger2505/items/8c1c2222d8ceb04b43fd][Go標準のflagパッケージと比べてみようサードパーティflagライブラリ - Qiita]]
読む。
** TODO [[http://go.shibu.jp/effective_go.html][Effective Go — プログラミング言語 Go ドキュメント v0.1 documentation]]
Goらしく書くためのtips。
** TODO [[https://qiita.com/mnuma/items/109458d90ce9dbdde426][Go Patternsで学ぶGo - Qiita]]
Goで役立つパターン。
** TODO [[https://www.educative.io/answers/how-to-read-and-write-with-golang-bufio][How to read and write with Golang bufio]]
bufioのわかりやすい解説。
** TODO [[https://qiita.com/tutuz/items/e875d8ea3c31450195a7][Go言語を使ったTCPクライアントの作り方 - Qiita]]
TCPの仕組み、作り方。
** TODO new()とmake()の違い                                        :DontKnow:
どちらも大まかには初期化するものだが、微妙に異なる。

- newはゼロ値で確保された値へのポインタを得る関数

#+begin_src git-permalink
https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L212
#+end_src

#+RESULTS:
#+begin_results go
func new(Type) *Type
#+end_results

- makeはマップ、スライス、チャンネル（map[type]type, []type, chan）の確保と初期化を行い型そのものを得る関数

#+begin_src git-permalink
https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L207
#+end_src

#+RESULTS:
#+begin_resultsg go
func make(t Type, size ...IntegerType) Type
#+end_results

** TODO Len()の仕組み                                            :DontKnow:
:LOGBOOK:
CLOCK: [2023-06-28 Wed 00:15]--[2023-06-28 Wed 00:40] =>  0:25
CLOCK: [2023-06-27 Tue 23:46]--[2023-06-28 Wed 00:11] =>  0:25
CLOCK: [2023-06-27 Tue 23:11]--[2023-06-27 Tue 23:36] =>  0:25
CLOCK: [2023-06-26 Mon 00:20]--[2023-06-26 Mon 00:45] =>  0:25
CLOCK: [2023-06-25 Sun 21:48]--[2023-06-25 Sun 22:13] =>  0:25
CLOCK: [2023-06-25 Sun 21:15]--[2023-06-25 Sun 21:40] =>  0:25
CLOCK: [2023-06-25 Sun 20:48]--[2023-06-25 Sun 21:13] =>  0:25
CLOCK: [2023-06-25 Sun 20:18]--[2023-06-25 Sun 20:43] =>  0:25
CLOCK: [2023-02-12 Sun 00:26]--[2023-02-12 Sun 00:51] =>  0:25
:END:
スライスなどの長さを調べるLen()はどういう実装になっているのだろうか。組み込みだから、ほかの関数とは異なりそう。

#+begin_src git-permalink
  https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L161-L173
#+end_src

#+RESULTS:
#+begin_results go
// The len built-in function returns the length of v, according to its type:
//
//	Array: the number of elements in v.
//	Pointer to array: the number of elements in *v (even if v is nil).
//	Slice, or map: the number of elements in v; if v is nil, len(v) is zero.
//	String: the number of bytes in v.
//	Channel: the number of elements queued (unread) in the channel buffer;
//	         if v is nil, len(v) is zero.
//
// For some arguments, such as a string literal or a simple array expression, the
// result can be a constant. See the Go language specification's "Length and
// capacity" section for details.
func len(v Type) int
#+end_results

** TODO [[https://zenn.dev/hsaki/books/golang-context/viewer/intro][よくわかるcontextの使い方]]
:LOGBOOK:
CLOCK: [2023-11-11 Sat 13:05]--[2023-11-11 Sat 13:30] =>  0:25
CLOCK: [2023-04-06 Thu 00:09]--[2023-04-06 Thu 00:34] =>  0:25
CLOCK: [2022-11-12 Sat 15:49]--[2022-11-12 Sat 16:14] =>  0:25
CLOCK: [2022-11-12 Sat 12:40]--[2022-11-12 Sat 13:05] =>  0:25
CLOCK: [2022-11-04 Fri 00:47]--[2022-11-04 Fri 01:12] =>  0:25
CLOCK: [2022-11-03 Thu 16:25]--[2022-11-03 Thu 16:50] =>  0:25
CLOCK: [2022-10-31 Mon 18:52]--[2022-10-31 Mon 19:17] =>  0:25
CLOCK: [2022-10-30 Sun 23:01]--[2022-10-30 Sun 23:26] =>  0:25
CLOCK: [2022-10-30 Sun 10:22]--[2022-10-30 Sun 10:47] =>  0:25
:END:
contextの詳しい解説。この人すごいなあ。

- contextのvalueに入れるのにふさわしい値はリクエストスコープな値
  - 1つのリクエストが処理されている間に共有される
  - ユーザーID
  - 認証トークン
  - トレースのためにサーバ側でつける処理ID

** TODO orgパーサを書く
:LOGBOOK:
CLOCK: [2022-10-20 Thu 17:29]--[2022-10-20 Thu 17:54] =>  0:25
CLOCK: [2022-10-20 Thu 11:38]--[2022-10-20 Thu 12:03] =>  0:25
CLOCK: [2022-10-20 Thu 10:56]--[2022-10-20 Thu 11:21] =>  0:25
CLOCK: [2022-10-20 Thu 10:31]--[2022-10-20 Thu 10:56] =>  0:25
CLOCK: [2022-10-20 Thu 10:02]--[2022-10-20 Thu 10:27] =>  0:25
CLOCK: [2022-10-20 Thu 09:37]--[2022-10-20 Thu 10:02] =>  0:25
CLOCK: [2022-10-19 Wed 23:32]--[2022-10-19 Wed 23:57] =>  0:25
CLOCK: [2022-10-19 Wed 21:53]--[2022-10-19 Wed 22:18] =>  0:25
CLOCK: [2022-10-19 Wed 21:28]--[2022-10-19 Wed 21:53] =>  0:25
CLOCK: [2022-10-19 Wed 20:59]--[2022-10-19 Wed 21:24] =>  0:25
CLOCK: [2022-10-19 Wed 20:29]--[2022-10-19 Wed 20:54] =>  0:25
CLOCK: [2022-10-19 Wed 20:04]--[2022-10-19 Wed 20:29] =>  0:25
CLOCK: [2022-10-19 Wed 19:39]--[2022-10-19 Wed 20:04] =>  0:25
CLOCK: [2022-10-19 Wed 19:06]--[2022-10-19 Wed 19:31] =>  0:25
CLOCK: [2022-10-19 Wed 14:41]--[2022-10-19 Wed 15:06] =>  0:25
CLOCK: [2022-10-19 Wed 14:08]--[2022-10-19 Wed 14:33] =>  0:25
CLOCK: [2022-10-19 Wed 13:38]--[2022-10-19 Wed 14:03] =>  0:25
CLOCK: [2022-10-19 Wed 13:09]--[2022-10-19 Wed 13:34] =>  0:25
CLOCK: [2022-10-19 Wed 12:42]--[2022-10-19 Wed 13:07] =>  0:25
CLOCK: [2022-10-19 Wed 11:00]--[2022-10-19 Wed 11:25] =>  0:25
CLOCK: [2022-10-19 Wed 10:35]--[2022-10-19 Wed 11:00] =>  0:25
CLOCK: [2022-10-19 Wed 10:09]--[2022-10-19 Wed 10:34] =>  0:25
CLOCK: [2022-10-19 Wed 09:44]--[2022-10-19 Wed 10:09] =>  0:25
CLOCK: [2022-10-19 Wed 00:43]--[2022-10-19 Wed 01:09] =>  0:26
CLOCK: [2022-10-18 Tue 23:26]--[2022-10-18 Tue 23:51] =>  0:25
CLOCK: [2022-10-18 Tue 22:38]--[2022-10-18 Tue 23:03] =>  0:25
CLOCK: [2022-10-18 Tue 21:55]--[2022-10-18 Tue 22:20] =>  0:25
CLOCK: [2022-10-18 Tue 21:20]--[2022-10-18 Tue 21:45] =>  0:25
CLOCK: [2022-10-18 Tue 20:54]--[2022-10-18 Tue 21:20] =>  0:26
CLOCK: [2022-10-18 Tue 20:29]--[2022-10-18 Tue 20:54] =>  0:25
CLOCK: [2022-10-18 Tue 20:00]--[2022-10-18 Tue 20:25] =>  0:25
CLOCK: [2022-10-18 Tue 15:56]--[2022-10-18 Tue 16:21] =>  0:25
CLOCK: [2022-10-18 Tue 15:27]--[2022-10-18 Tue 15:52] =>  0:25
CLOCK: [2022-10-18 Tue 14:52]--[2022-10-18 Tue 15:17] =>  0:25
CLOCK: [2022-10-18 Tue 14:26]--[2022-10-18 Tue 14:51] =>  0:25
CLOCK: [2022-10-18 Tue 14:01]--[2022-10-18 Tue 14:26] =>  0:25
CLOCK: [2022-10-18 Tue 13:12]--[2022-10-18 Tue 13:37] =>  0:25
CLOCK: [2022-10-18 Tue 12:27]--[2022-10-18 Tue 12:33] =>  0:06
:END:

パーサの理解を深めるためにやる。

参考。

- [[https://www.m3tech.blog/entry/2021/08/23/124000][マークダウンパーサを作ろう - エムスリーテックブログ]]

最終的にフォーマッタにしたい。

- 複数行で継続するものと、行内だけで有効化されるものがある。基本的に行内
- 先頭行で効果を発揮するものと、囲むことで有効化するものがある

** TODO [[https://compilerbook.com/][Writing A Compiler In Go | Thorsten Ball]]
Goでインタプリタを書く本の続編。
** TODO [[https://astaxie.gitbooks.io/build-web-application-with-golang/content/ja/?q=][Introduction · Build web application with Golang]]
Go Web プログラミング。
** TODO [[http://go.shibu.jp/][プログラミング言語 Go ドキュメント — プログラミング言語 Go ドキュメント v0.1 documentation]]
Goドキュメント。
** TODO [[https://knsh14.github.io/translations/go-codereview-comments/][Go Codereview Comments]]
GoのTips集。
** TODO [[https://hiwane.github.io/gospec-ja/][Go プログラミング言語仕様 | gospec-ja]]
:LOGBOOK:
CLOCK: [2022-11-19 Sat 10:18]--[2022-11-19 Sat 10:43] =>  0:25
CLOCK: [2022-11-03 Thu 17:15]--[2022-11-03 Thu 17:40] =>  0:25
:END:
言語仕様の日本語訳。
** TODO [[https://qiita.com/taigamikami/items/fc798cdd6a4eaf9a7d5e][Goのgoroutine, channelをちょっと攻略！ - Qiita]]
ゴルーチンの解説。
** TODO [[https://qiita.com/tenntenn/items/45c568d43e950292bc31][Goを学びたての人が誤解しがちなtypeと構造体について #golang - Qiita]]
typeとstructの違いの解説。
** TODO actをworkflow化する

[[id:2d35ac9e-554a-4142-bba7-3c614cbfe4c4][GitHub Actions]]ですぐに実行できるようにする。

- workflow化する
- スターターパッケージを作成する

フォークをどう扱うか問題がある。自分は運用でカバーしてるけど。自分で使うには十分だけど、他の人に利用してもらうにはまだビミョー。
** TODO actをバージョン対応する
mainを使ってるので、バージョンを固定して安全に使えるようにする。
** TODO maruをバージョン対応する
READMEのタグをmainにしてるので、バージョン番号にする。タグを切り替えると画像も変わるようにして、安全にする。安心して使えるようにする。
** TODO ローカルパッケージをimportする方法
読みたいライブラリがmoduleで、直接実行できない。実行できないと、printデバッグもできない。テストでもできるか。だが引数が面倒なのだと大変。

ローカルimportの方法も一応知っておきたい。
** TODO octocovを読む
:LOGBOOK:
CLOCK: [2022-10-05 Wed 21:12]--[2022-10-05 Wed 21:37] =>  0:25
CLOCK: [2022-10-05 Wed 20:22]--[2022-10-05 Wed 20:47] =>  0:25
CLOCK: [2022-10-05 Wed 19:46]--[2022-10-05 Wed 20:11] =>  0:25
CLOCK: [2022-10-05 Wed 00:39]--[2022-10-05 Wed 01:04] =>  0:25
CLOCK: [2022-10-04 Tue 22:37]--[2022-10-04 Tue 23:02] =>  0:25
CLOCK: [2022-10-04 Tue 22:08]--[2022-10-04 Tue 22:33] =>  0:25
:END:
- [[https://github.com/k1LoW/octocov][k1LoW/octocov]]

何か作っていて参考にするときは、よく読める。理解できる。が大雑把なスコープで「理解しよう」でやるとあまり進まない。

** TODO goclocを読む
:LOGBOOK:
CLOCK: [2022-09-27 Tue 09:51]--[2022-09-27 Tue 10:16] =>  0:25
CLOCK: [2022-09-27 Tue 09:18]--[2022-09-27 Tue 09:43] =>  0:25
CLOCK: [2022-09-26 Mon 19:40]--[2022-09-26 Mon 20:05] =>  0:25
CLOCK: [2022-09-26 Mon 19:05]--[2022-09-26 Mon 19:30] =>  0:25
CLOCK: [2022-09-26 Mon 18:32]--[2022-09-26 Mon 18:57] =>  0:25
:END:
goclocはリポジトリのコード量を調べるツール。

- [[https://github.com/hhatto/gocloc][hhatto/gocloc: A little fast cloc(Count Lines Of Code)]]

参考になるところのメモ。

- 気軽にコマンド実行できるようにdockerイメージを用意する
- オプションの取り回し方。構造体に入れておく
- 結果を構造体に入れておく
- 本体とCLIは別packageになっている

気になる部分。

- 言語判定のライブラリを使っているみたいだが、大きな、割と雑なマップがある

** TODO colorを読む
:LOGBOOK:
CLOCK: [2022-09-26 Mon 17:51]--[2022-09-26 Mon 18:16] =>  0:25
CLOCK: [2022-09-26 Mon 16:41]--[2022-09-26 Mon 17:06] =>  0:25
CLOCK: [2022-09-25 Sun 16:12]--[2022-09-25 Sun 16:37] =>  0:25
CLOCK: [2022-09-25 Sun 15:43]--[2022-09-25 Sun 16:08] =>  0:25
:END:

CLIに色をつけるライブラリ。

- [[https://github.com/fatih/color][fatih/color: Color package for Go (golang)]]

別の色関係のライブラリが出てくる。何が違うのかわからない。

- [[https://github.com/mattn/go-colorable][mattn/go-colorable]]

#+caption: 関数Set。メソッドSetを呼び出す
#+begin_src git-permalink
https://github.com/kd-collective/color/blob/dbae876e45b9c53e464d101d63f4758c9f0bd8e8/color.go#L131-L137
#+end_src

#+RESULTS:
#+begin_results go
// Set sets the given parameters immediately. It will change the color of
// output with the given SGR parameters until color.Unset() is called.
func Set(p ...Attribute) *Color {
	c := New(p...)
	c.Set()
	return c
}
#+end_results

#+caption: メソッドSet。Printfで、色指定された文字を表示している
#+begin_src git-permalink
https://github.com/kd-collective/color/blob/dbae876e45b9c53e464d101d63f4758c9f0bd8e8/color.go#L149-L157
#+end_src

#+RESULTS:
#+begin_results go
// Set sets the SGR sequence.
func (c *Color) Set() *Color {
	if c.isNoColorSet() {
		return c
	}

	fmt.Fprint(Output, c.format())
	return c
}
#+end_results

なんだか地味に長いし、よくわからない。

** TODO [[https://www.amazon.co.jp/Go%E8%A8%80%E8%AA%9Ereflect%E3%83%8F%E3%83%B3%E3%83%89%E3%83%96%E3%83%83%E3%82%AF-%E6%8A%80%E8%A1%93%E3%81%AE%E6%B3%89%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA%EF%BC%88NextPublishing%EF%BC%89-%E5%8D%83%E8%91%89-%E5%A4%A7%E4%BA%8C%E9%83%8E-ebook/dp/B08NT59MS4/ref=sr_1_16?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=1HEEXC8ONO3XN&keywords=go+%E8%A8%80%E8%AA%9E&qid=1663726078&sprefix=go+%E3%81%92n%2Caps%2C202&sr=8-16][Go言語reflectハンドブック (技術の泉シリーズ（NextPublishing）) | 千葉 大二郎 | 工学 | Kindleストア | Amazon]]
reflectの解説。
** TODO [[https://www.amazon.co.jp/Go%E3%81%A8SAM%E3%81%A7%E5%AD%A6%E3%81%B6AWS-Lambda-%E6%8A%80%E8%A1%93%E3%81%AE%E6%B3%89%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA%EF%BC%88NextPublishing%EF%BC%89-%E6%9D%89%E7%94%B0-%E5%AF%BF%E6%86%B2-ebook/dp/B07LGNGDHF/ref=sr_1_36?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=1HEEXC8ONO3XN&keywords=go+%E8%A8%80%E8%AA%9E&qid=1663726078&sprefix=go+%E3%81%92n%2Caps%2C202&sr=8-36][GoとSAMで学ぶAWS Lambda (技術の泉シリーズ（NextPublishing）) | 杉田 寿憲 | 工学 | Kindleストア | Amazon]]
:LOGBOOK:
CLOCK: [2023-01-21 Sat 18:01]--[2023-01-21 Sat 18:26] =>  0:25
CLOCK: [2023-01-21 Sat 17:36]--[2023-01-21 Sat 18:01] =>  0:25
CLOCK: [2023-01-21 Sat 17:11]--[2023-01-21 Sat 17:36] =>  0:25
:END:
Goを使ったサーバレスの解説。
** TODO [[https://www.amazon.co.jp/Go%E8%A8%80%E8%AA%9E%E3%81%AB%E3%82%88%E3%82%8B%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86-Katherine-Cox-Buday/dp/4873118468/ref=sr_1_19?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=1HEEXC8ONO3XN&keywords=go+%E8%A8%80%E8%AA%9E&qid=1663726078&sprefix=go+%E3%81%92n%2Caps%2C202&sr=8-19][Go言語による並行処理 | Katherine Cox-Buday, 山口 能迪 |本 | 通販 | Amazon]]
:LOGBOOK:
CLOCK: [2023-05-26 Fri 00:10]--[2023-05-26 Fri 00:35] =>  0:25
CLOCK: [2023-05-21 Sun 20:13]--[2023-05-21 Sun 20:38] =>  0:25
CLOCK: [2023-05-17 Wed 00:00]--[2023-05-17 Wed 00:25] =>  0:25
CLOCK: [2023-05-16 Tue 23:16]--[2023-05-16 Tue 23:41] =>  0:25
CLOCK: [2023-05-10 Wed 21:16]--[2023-05-10 Wed 21:41] =>  0:25
:END:
平行処理の解説。

- 57

- Coffman条件 :: デッドロックが発生するために存在しなければならない条件
  - 相互排他
    - ある並行プロセスがリソースに対して排他的な権利をどの時点においても保持している
  - 条件待ち
    - ある並行プロセスはリソースの保持と追加のリソース待ちを同時に行わなければならない
  - 横取り不可
    - ある並行プロセスによって保持されているリソースは、そのプロセスによってのみ解放される
  - 循環待ち
    - ある並行プロセス(P1)は、他の連なっている並行プロセス(P2)を待たなければならない。そしてP2はP1を待っている

- たいていの言語はCSPのメッセージパッシング形式よりもメモリを共有し同期するほうを好んでいる。共有メモリのモデルは正確に使うことが難しくなる
- GoでははじめからCSPを導入している
- syncパッケージは伝統的なメモリアクセス同期で並行処理を達成する。問題解決する平行処理の書き方を高水準(Goルーチン、チャネル)、低水準(sync)で選択できる
- プログラムを書く際にはある瞬間にただ1つのゴルーチンがある特定のデータの責任を持つように心がける。メモリを共有することで通信してはいけない。かわりに通信することでメモリを共有する
- Goのモットー「通信によってメモリを共有し、メモリの共有によって通信してはいけない」
- 何かしら結果を生成するコードがあり、その結果を別のコードに共有したい場合、これはデータの所有権を移動していることになる。ガベージコレクションをサポートしていない言語でのメモリの所有権と同じ考え方。データには所有権があり、平行プログラムを安全にする方法の1つとして、1度に1つの並行処理のコンテキストのみがデータの所有権を持つようにする。チャネルを使うと、この意図をチャネルの形で表現することで並行プログラムを安全にする構想を伝えることができる
  - 大きな利点は、バッファ付きチャネルを生成して、コストが低いインメモリのキューを実装し生産者(Producer)と消費者(Consumer)を切り離すことができる
- OSスレッドを使う言語では平行処理を抽象化する方法として便利なほかのパターンや実装方法がある。たとえばスレッドプール。こうした抽象化はたいていOSスレッドの補強や強化をする目的で作られていて、Goで使うことはあまりない
- 問題空間をゴルーチンに当てはめられるようにして、ワークフロー内の並行処理部分をうまく表現し、どんどんゴルーチンを起動する
- ゴルーチン :: 他のコードに対して並行に実行している関数のこと(必ずしも並列ではない)
- ゴルーチンはコルーチンとして知られる高水準の抽象化

** TODO [[https://www.amazon.co.jp/Go%E8%A8%80%E8%AA%9E%E3%81%AB%E3%82%88%E3%82%8B%E5%88%86%E6%95%A3%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9-%E2%80%95%E4%BF%A1%E9%A0%BC%E6%80%A7%E3%80%81%E6%8B%A1%E5%BC%B5%E6%80%A7%E3%80%81%E4%BF%9D%E5%AE%88%E6%80%A7%E3%81%AE%E9%AB%98%E3%81%84%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%A7%8B%E7%AF%89-Travis-Jeffery/dp/4873119979/ref=sr_1_5?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=1HEEXC8ONO3XN&keywords=go+%E8%A8%80%E8%AA%9E&qid=1663726078&sprefix=go+%E3%81%92n%2Caps%2C202&sr=8-5][Go言語による分散サービス ―信頼性、拡張性、保守性の高いシステムの構築 | Travis Jeffery, 柴田 芳樹 |本 | 通販 | Amazon]]
分散サービスの解説。
** TODO [[https://www.amazon.co.jp/%E5%AE%9F%E7%94%A8-Go%E8%A8%80%E8%AA%9E-%E2%80%95%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E9%96%8B%E7%99%BA%E3%81%AE%E7%8F%BE%E5%A0%B4%E3%81%A7%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9-%E6%B8%8B%E5%B7%9D-%E3%82%88%E3%81%97%E3%81%8D/dp/4873119693/ref=sr_1_3?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=1HEEXC8ONO3XN&keywords=go+%E8%A8%80%E8%AA%9E&qid=1663726078&sprefix=go+%E3%81%92n%2Caps%2C202&sr=8-3][実用 Go言語 ―システム開発の現場で知っておきたいアドバイス | 渋川 よしき, 辻 大志郎, 真野 隼記 |本 | 通販 | Amazon]]
:LOGBOOK:
CLOCK: [2023-11-04 Sat 23:35]--[2023-11-05 Sun 00:00] =>  0:25
CLOCK: [2022-11-12 Sat 11:51]--[2022-11-12 Sat 12:16] =>  0:25
CLOCK: [2022-10-31 Mon 23:31]--[2022-10-31 Mon 23:56] =>  0:25
CLOCK: [2022-10-31 Mon 22:37]--[2022-10-31 Mon 23:02] =>  0:25
CLOCK: [2022-10-31 Mon 19:20]--[2022-10-31 Mon 19:45] =>  0:25
CLOCK: [2022-10-29 Sat 22:48]--[2022-10-29 Sat 23:13] =>  0:25
CLOCK: [2022-10-29 Sat 21:04]--[2022-10-29 Sat 21:29] =>  0:25
CLOCK: [2022-10-28 Fri 19:37]--[2022-10-28 Fri 20:02] =>  0:25
CLOCK: [2022-10-28 Fri 19:07]--[2022-10-28 Fri 19:32] =>  0:25
CLOCK: [2022-10-28 Fri 18:07]--[2022-10-28 Fri 18:32] =>  0:25
CLOCK: [2022-10-28 Fri 17:39]--[2022-10-28 Fri 18:04] =>  0:25
CLOCK: [2022-10-28 Fri 17:06]--[2022-10-28 Fri 17:31] =>  0:25
CLOCK: [2022-10-28 Fri 16:30]--[2022-10-28 Fri 16:55] =>  0:25
CLOCK: [2022-10-28 Fri 11:42]--[2022-10-28 Fri 12:07] =>  0:25
CLOCK: [2022-10-28 Fri 10:36]--[2022-10-28 Fri 11:01] =>  0:25
CLOCK: [2022-10-28 Fri 10:11]--[2022-10-28 Fri 10:36] =>  0:25
CLOCK: [2022-10-27 Thu 22:52]--[2022-10-27 Thu 23:17] =>  0:25
CLOCK: [2022-10-27 Thu 22:18]--[2022-10-27 Thu 22:43] =>  0:25
CLOCK: [2022-10-27 Thu 19:57]--[2022-10-27 Thu 20:22] =>  0:25
CLOCK: [2022-10-27 Thu 19:27]--[2022-10-27 Thu 19:53] =>  0:26
CLOCK: [2022-10-27 Thu 16:29]--[2022-10-27 Thu 16:54] =>  0:25
CLOCK: [2022-10-27 Thu 15:32]--[2022-10-27 Thu 15:57] =>  0:25
CLOCK: [2022-10-27 Thu 14:53]--[2022-10-27 Thu 15:18] =>  0:25
CLOCK: [2022-10-27 Thu 14:28]--[2022-10-27 Thu 14:53] =>  0:25
CLOCK: [2022-10-27 Thu 13:00]--[2022-10-27 Thu 13:25] =>  0:25
CLOCK: [2022-10-27 Thu 12:35]--[2022-10-27 Thu 13:00] =>  0:25
CLOCK: [2022-10-27 Thu 11:11]--[2022-10-27 Thu 11:36] =>  0:25
CLOCK: [2022-10-26 Wed 22:55]--[2022-10-26 Wed 23:20] =>  0:25
CLOCK: [2022-10-26 Wed 16:36]--[2022-10-26 Wed 17:01] =>  0:25
CLOCK: [2022-10-26 Wed 15:59]--[2022-10-26 Wed 16:24] =>  0:25
CLOCK: [2022-10-26 Wed 15:29]--[2022-10-26 Wed 15:54] =>  0:25
CLOCK: [2022-10-26 Wed 13:41]--[2022-10-26 Wed 14:06] =>  0:25
CLOCK: [2022-10-26 Wed 09:28]--[2022-10-26 Wed 09:53] =>  0:25
:END:

- 45, 94, 102, 199, 232

業務に役立つGoの解説。

#+begin_quote
Javaの世界では、親のコントロールクラスを継承して必要なメソッドを再定義しフレームワークから利用する、といった大規模なフレームワーク風のコーディングスタイルがあります。これはmain()関数が見えない、「ハリウッドの法則」にのっとったもので、一見コード量が少なく効率も良さそうに思えますが、フレームワークの進化が進めば進むほど、ソフトウェアの構造を考えて実装するという経験が得られず、「ソフトウェアの仕組みや開発技術を学ぶ」よりも「フレームワークの作法」を学ぶことが要求されるようになります。ジュニアな開発者でもレールから外れることなく、一定の成果をあげられるという利点がありますが、プログラマーとしての成長が難しいという欠点があります。
#+end_quote

- Goでパフォーマンスに差があらわれがちなポイントはスライスとマップのメモリ確保
  - スライスはその実態として固定長の配列が確保されており、スライスはそれを参照する窓として使われメモリの読み書きが行われる
  - 長さが足りないといって好き勝手に拡張できない
  - 裏の配列に要素を追加し続けて割り当てられたサイズを使い果たした場合、Goのランタイムは新しくメモリを確保し、それに配列の内容をコピーして移動する
  - 確保しているメモリのことをキャパシティという。cap()で取得できる
- オーバーライド・継承のあるオブジェクト指向プログラミングではテンプレートメソッドパターンが一般的に用いられる
  - テンプレートメソッドパターン: フレームワーク側でロジックの大部分をにない、一部のカスタマイズ可能なポイントのロジックのみを変更する設計
- Goではテンプレートメソッドパターンを使用しない代わりにストラテジーパターンを用いる
- シンプルなインターフェースを使うAPI(Reader, Writerを引数にとる)をコアとして作り、それをラップして使いやすいAPIを別に提供するのが、Goで広く行われている設計方法
  - ユニットテストなどが行いやすい。
- 文法がシンプルだからこそ、どう使うかが重要になっている
- エラーのラップ、アンラップができる。たとえば「ファイルパスエラー」という低レベルなエラーをラップして「設定ファイルの読み込みエラー」とより抽象度の高いエラーで表現でき、必要に応じてアンラップし、詳細情報にもアクセスできる
- エラーのチェック忘れをkisielk/errcheckで確かめられる
- ~go install~ はgo.modに影響なくインストールできる。 ~go get~ はgo.modに反映する
- Goの場合、パッケージを相互依存の関係にできないことから、パッケージ連携ごとに同じような構造体を量産することになりコード量が増加する。まずはシンプルに、パッケージを細かく分割しないことを考える
- フォークしたGoプロジェクトはハッシュが異なるため、そのままでは依存関係に記述できない

** TODO [[https://zenn.dev/hokita/articles/66cc118b227ae3][はじめてのゲームプログラミング（Ebiten）]]
簡単なゲームのチュートリアル。
** TODO [[https://golangprojectstructure.com/creating-cool-games-with-ebiten-in-go/][Creating Cool Games With Ebiten | Golang Project Structure]]
ゲームのチュートリアル。
** TODO [[https://www.fatoldyeti.com/categories/roguelike-tutorial/][Roguelike Tutorial | Fat Old Yeti]]
Ebitenでローグライクを作るチュートリアル。
** TODO [[https://medium.com/@chrisandrews_76960/2d-game-development-in-golang-part-1-5e2c11a513ed][2D Game Development in Golang — Part 1 | by Chris Andrews | Medium]]
Ebitenの小さなチュートリアル。
** TODO [[https://qiita.com/bokuweb/items/1575337bef44ae82f4d3][ファミコンエミュレータの創り方 - Hello, World!編 - - Qiita]]
:LOGBOOK:
CLOCK: [2023-03-19 Sun 12:58]--[2023-03-19 Sun 13:23] =>  0:25
CLOCK: [2023-03-19 Sun 12:33]--[2023-03-19 Sun 12:58] =>  0:25
:END:
エミュレータの作り方の概要。
** TODO [[https://zenn.dev/akatsuki/articles/ec95ab95f0e89ea8c38f][ゲームボーイのエミュレータをGoで作った話]]
作り方の解説。
** TODO [[https://swet.dena.com/entry/2021/12/07/123000][「テスタビリティの高いGoのAPIサーバを開発しよう」というハンズオンを公開しました - DeNA Testing Blog]]
GoのAPIハンズオン。
** TODO [[https://wxdublin.gitbooks.io/docker-code-walk/content/client.html][Client | Docker Code Walk]]
Dockerコードの概略。
** TODO [[https://tatsu-zine.com/books/starting-grpc][スターティングgRPC【委託】 - 達人出版会]]
サーバ側Go, クライアント側Rubyと異なる言語を用いてサンプルアプリケーションを実装する。
** TODO [[https://gihyo.jp/dp/ebook/2019/978-4-297-10728-4][改訂2版 みんなのGo言語 | Gihyo Digital Publishing … 技術評論社の電子書籍]]
:LOGBOOK:
CLOCK: [2023-02-09 Thu 21:50]--[2023-02-09 Thu 22:15] =>  0:25
CLOCK: [2022-09-09 Fri 19:04]--[2022-09-09 Fri 19:29] =>  0:25
:END:
わかりやすいという入門書。
** TODO [[https://tatsu-zine.com/books/go-web-programming][Goプログラミング実践入門 標準ライブラリでゼロからWebアプリを作る【委託】 - 達人出版会]]
:LOGBOOK:
CLOCK: [2022-10-25 Tue 23:22]--[2022-10-25 Tue 23:47] =>  0:25
CLOCK: [2022-10-20 Thu 16:56]--[2022-10-20 Thu 17:21] =>  0:25
CLOCK: [2022-10-13 Thu 18:43]--[2022-10-13 Thu 19:08] =>  0:25
CLOCK: [2022-10-05 Wed 23:31]--[2022-10-05 Wed 23:56] =>  0:25
CLOCK: [2022-10-05 Wed 23:00]--[2022-10-05 Wed 23:25] =>  0:25
CLOCK: [2022-10-01 Sat 18:44]--[2022-10-01 Sat 19:09] =>  0:25
CLOCK: [2022-10-01 Sat 15:46]--[2022-10-01 Sat 16:11] =>  0:25
CLOCK: [2022-10-01 Sat 15:09]--[2022-10-01 Sat 15:34] =>  0:25
CLOCK: [2022-10-01 Sat 14:25]--[2022-10-01 Sat 14:50] =>  0:25
CLOCK: [2022-10-01 Sat 14:00]--[2022-10-01 Sat 14:25] =>  0:25
CLOCK: [2022-10-01 Sat 11:14]--[2022-10-01 Sat 11:39] =>  0:25
CLOCK: [2022-10-01 Sat 10:42]--[2022-10-01 Sat 11:07] =>  0:25
CLOCK: [2022-10-01 Sat 10:11]--[2022-10-01 Sat 10:36] =>  0:25
CLOCK: [2022-10-01 Sat 09:37]--[2022-10-01 Sat 10:02] =>  0:25
CLOCK: [2022-09-29 Thu 21:20]--[2022-09-29 Thu 21:45] =>  0:25
CLOCK: [2022-09-29 Thu 20:27]--[2022-09-29 Thu 20:52] =>  0:25
CLOCK: [2022-09-29 Thu 19:00]--[2022-09-29 Thu 19:25] =>  0:25
CLOCK: [2022-09-23 Fri 10:45]--[2022-09-23 Fri 11:10] =>  0:25
CLOCK: [2022-09-23 Fri 09:57]--[2022-09-23 Fri 10:22] =>  0:25
CLOCK: [2022-09-23 Fri 09:32]--[2022-09-23 Fri 09:57] =>  0:25
CLOCK: [2022-09-23 Fri 08:37]--[2022-09-23 Fri 09:02] =>  0:25
CLOCK: [2022-09-23 Fri 08:05]--[2022-09-23 Fri 08:30] =>  0:25
CLOCK: [2022-09-22 Thu 22:53]--[2022-09-22 Thu 23:18] =>  0:25
CLOCK: [2022-09-22 Thu 22:23]--[2022-09-22 Thu 22:48] =>  0:25
CLOCK: [2022-09-22 Thu 21:55]--[2022-09-22 Thu 22:20] =>  0:25
CLOCK: [2022-09-22 Thu 18:30]--[2022-09-22 Thu 18:55] =>  0:25
CLOCK: [2022-09-22 Thu 17:02]--[2022-09-22 Thu 17:27] =>  0:25
CLOCK: [2022-09-22 Thu 16:36]--[2022-09-22 Thu 17:01] =>  0:25
CLOCK: [2022-09-22 Thu 08:42]--[2022-09-22 Thu 09:07] =>  0:25
CLOCK: [2022-09-21 Wed 23:48]--[2022-09-22 Thu 00:13] =>  0:25
CLOCK: [2022-09-21 Wed 23:12]--[2022-09-21 Wed 23:37] =>  0:25
CLOCK: [2022-09-21 Wed 22:28]--[2022-09-21 Wed 22:53] =>  0:25
CLOCK: [2022-09-21 Wed 20:21]--[2022-09-21 Wed 20:46] =>  0:25
CLOCK: [2022-09-21 Wed 19:20]--[2022-09-21 Wed 19:45] =>  0:25
CLOCK: [2022-09-21 Wed 18:07]--[2022-09-21 Wed 18:32] =>  0:25
CLOCK: [2022-09-21 Wed 17:32]--[2022-09-21 Wed 17:57] =>  0:25
CLOCK: [2022-09-21 Wed 16:57]--[2022-09-21 Wed 17:22] =>  0:25
CLOCK: [2022-09-21 Wed 16:32]--[2022-09-21 Wed 16:32] =>  0:00
CLOCK: [2022-09-20 Tue 11:38]--[2022-09-20 Tue 12:03] =>  0:25
CLOCK: [2022-09-20 Tue 10:13]--[2022-09-20 Tue 10:38] =>  0:25
CLOCK: [2022-09-20 Tue 09:45]--[2022-09-20 Tue 10:10] =>  0:25
CLOCK: [2022-09-20 Tue 09:15]--[2022-09-20 Tue 09:40] =>  0:25
CLOCK: [2022-09-19 Mon 22:27]--[2022-09-19 Mon 22:52] =>  0:25
CLOCK: [2022-09-19 Mon 21:12]--[2022-09-19 Mon 21:37] =>  0:25
CLOCK: [2022-09-19 Mon 20:45]--[2022-09-19 Mon 21:10] =>  0:25
CLOCK: [2022-09-19 Mon 19:52]--[2022-09-19 Mon 20:17] =>  0:25
CLOCK: [2022-09-19 Mon 17:06]--[2022-09-19 Mon 17:31] =>  0:25
CLOCK: [2022-09-19 Mon 16:41]--[2022-09-19 Mon 17:06] =>  0:25
CLOCK: [2022-09-19 Mon 15:04]--[2022-09-19 Mon 15:29] =>  0:25
CLOCK: [2022-09-19 Mon 12:48]--[2022-09-19 Mon 13:13] =>  0:25
CLOCK: [2022-09-19 Mon 11:59]--[2022-09-19 Mon 12:24] =>  0:25
CLOCK: [2022-09-19 Mon 11:33]--[2022-09-19 Mon 11:59] =>  0:26
CLOCK: [2022-09-19 Mon 11:08]--[2022-09-19 Mon 11:33] =>  0:25
CLOCK: [2022-09-19 Mon 09:11]--[2022-09-19 Mon 09:36] =>  0:25
CLOCK: [2022-09-19 Mon 08:44]--[2022-09-19 Mon 09:09] =>  0:25
CLOCK: [2022-09-19 Mon 08:19]--[2022-09-19 Mon 08:44] =>  0:25
CLOCK: [2022-09-18 Sun 22:33]--[2022-09-18 Sun 22:58] =>  0:25
CLOCK: [2022-09-18 Sun 22:06]--[2022-09-18 Sun 22:31] =>  0:25
CLOCK: [2022-09-18 Sun 21:31]--[2022-09-18 Sun 21:56] =>  0:25
CLOCK: [2022-09-18 Sun 21:06]--[2022-09-18 Sun 21:31] =>  0:25
CLOCK: [2022-09-18 Sun 18:26]--[2022-09-18 Sun 18:51] =>  0:25
CLOCK: [2022-09-18 Sun 18:01]--[2022-09-18 Sun 18:26] =>  0:25
CLOCK: [2022-09-18 Sun 15:00]--[2022-09-18 Sun 15:25] =>  0:25
:END:

- 27, 68, 73, 93, 148

ゼロから実装する。あまりピンとこない。

*** フレームワークの弊害

- フレームワークを使えばすぐ構築できる。が、フレームワーク独自の約束事やパターンに従わないといけないことも多い。それがベストプラクティスであると仮定しているが、ベストプラクティスは理解していないとカーゴカルト・プログラミングに陥りどんなときでも無条件で適用してしまう
- フレームワークを構築する基盤となっている概念を理解することが重要。正しい理解があれば、ある約束事やパターンが存在する理由がわかるようになる
- たとえばクライアント側にクッキーとしてデータを保持し、サーバ側にセッションとして保持するのには理由がある。HTTPがコネクションレスのプロトコルであり、サーバの各回の呼び出しには以前の呼び出しの情報が含まれていないからである
- Go言語においてハンドラとは、ServeHttpというメソッドを持ったインターフェースのこと
- [[https://qiita.com/huji0327/items/c85affaf5b9dbf84c11e][【Go】マルチプレクサってなんやねん - Qiita]]

** TODO Go Design Patterns
** TODO Cloud Native Go
** TODO Go and Go-Moku The Oriental Board Games
** TODO Mastering Go Create Golang production applications using network libraries, concurrency, and advanced Go data structures
** TODO RESTful Go APIs Design und Implementierung leichtgewichtiger Hypermedia Services
** TODO Hands-On System Programming with Go
** TODO Powerful Command-Line Applications in Go
** TODO Build an Orchestrator in Go
** TODO The Docker Book
** TODO [[https://github.com/google/go-github][google/go-github: Go library for accessing the GitHub v3 API]]
:LOGBOOK:
CLOCK: [2022-09-26 Mon 15:31]--[2022-09-26 Mon 15:56] =>  0:25
:END:
GoのGitHubアクセスのためのライブラリ。

実際の参考になる使用例。
- https://github.com/k1LoW/octocov/blob/main/gh/gh.go
** TODO [[https://www.ebiebievidence.com/posts/2020/12/golang-compiler/][Go コンパイラのコードを読んでみよう | ebiebievidence.com]]
Goのコンパイラの解説。
** TODO [[https://zenn.dev/ytakaya/articles/ff6321bad0cbea][Goを学ぶときに参照した学習リソースまとめ]]
面白くためになる題材の紹介。
** TODO [[https://zenn.dev/hsaki/articles/gospecdictionary#%E3%81%9D%E3%81%AE%E8%A8%98%E8%BF%B0%E3%81%8C%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E4%BD%95%E3%81%8C%E5%AC%89%E3%81%97%E3%81%84%E3%81%AE%E3%81%8B%EF%BC%9F%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%82%92%E6%84%8F%E8%AD%98%E3%81%99%E3%82%8B][Goの言語仕様書精読のススメ & 英語彙集]]

読み方。より深い理解のやりかた。

#+begin_quote
GoSpecは言語仕様書であり、全ての記述には意味があるはずです。

例えばTypesの章で導入される「全ての型にはunderlying typeがある」という概念は、一見すると「なんでこんなものを導入するんだ？？」と思うかもしれません。

(略)

しかし、このunderlying typeはassignability(代入可能性)を定義するために不可欠なものです(後述)。

このように「この記述はどこで役に立つの？」という意識を持つことで、全体像の理解につながります。
#+end_quote

#+begin_quote
某書籍に「例示は理解の試金石」という言葉があります。

(略)

これは本当にそうで、読んだ内容を元に「こういうコードはこの記述を元に確かにこういう挙動をする」という例が作れるかどうかで理解の深さが段違いだという実感があります。
#+end_quote
** TODO jvm実装の続き
invoke_virtualのメソッド呼び出しで詰まっていた。

https://github.com/rodbate/jvm-on-go/blob/eb536d93317d0ef24ae9e2f298fd08b8ad4e49f8/pkg/rtda/method_ref.go#L27-L42

このへんが参考になるか。関数オブジェクトをハッシュに入れておいて、検索して呼び出せばいい。

* Go言語へのコントリビュート準備
CLOSED: [2022-10-29 Sat 11:19]
** DONE [[https://go.dev/doc/contribute][Contribution Guide - The Go Programming Language]]
CLOSED: [2022-10-29 Sat 11:19]
:LOGBOOK:
CLOCK: [2022-10-27 Thu 10:45]--[2022-10-27 Thu 11:10] =>  0:25
CLOCK: [2022-10-26 Wed 23:24]--[2022-10-26 Wed 23:49] =>  0:25
:END:
Goのコントリビューションガイド。
** DONE [[https://www.youtube.com/watch?v=DjZMKKfNVMc][justforfunc #17: contributing to the Go project - YouTube]]
CLOSED: [2022-10-29 Sat 11:38]
:LOGBOOK:
CLOCK: [2022-10-29 Sat 10:47]--[2022-10-29 Sat 11:12] =>  0:25
CLOCK: [2022-10-29 Sat 10:17]--[2022-10-29 Sat 10:42] =>  0:25
CLOCK: [2022-10-29 Sat 09:42]--[2022-10-29 Sat 10:07] =>  0:25
CLOCK: [2022-10-29 Sat 09:17]--[2022-10-29 Sat 09:42] =>  0:25
CLOCK: [2022-10-29 Sat 08:52]--[2022-10-29 Sat 09:17] =>  0:25
CLOCK: [2022-10-29 Sat 08:27]--[2022-10-29 Sat 08:52] =>  0:25
:END:

Goにコントリビュートするチュートリアル。開発環境構築、Googleの規約へのサイン、変更、レビューまでの流れを全てカバーしている。わかりやすい。
** DONE リポジトリを見てどういう開発の種類があるか把握する
CLOSED: [2022-10-25 Tue 23:56]
:LOGBOOK:
CLOCK: [2022-10-17 Mon 22:06]--[2022-10-17 Mon 22:31] =>  0:25
CLOCK: [2022-10-17 Mon 21:35]--[2022-10-17 Mon 22:00] =>  0:25
CLOCK: [2022-10-17 Mon 20:16]--[2022-10-17 Mon 20:41] =>  0:25
CLOCK: [2022-10-17 Mon 01:34]--[2022-10-17 Mon 01:59] =>  0:25
CLOCK: [2022-10-15 Sat 13:13]--[2022-10-15 Sat 13:38] =>  0:25
CLOCK: [2022-10-14 Fri 22:05]--[2022-10-14 Fri 22:30] =>  0:25
CLOCK: [2022-10-14 Fri 21:35]--[2022-10-14 Fri 22:00] =>  0:25
CLOCK: [2022-10-14 Fri 20:05]--[2022-10-14 Fri 20:30] =>  0:25
:END:
- 388fbf287c

毎日たくさんのコミットがある。どういったことをやって、より良くしているのだろうか。コードの種類、議論の進め方。ファイルを見てイチから理解していくのは難しいが、差分から少しずつ見ていけば糸口がつかめるのではないか。また、プログラミング言語の場合、ライブラリでも全然違うはずなので調べる。

開発参加に必要な段階として、コードというより周辺知識をつければいいように見える。

- 未使用コード削除
- contextオプション追加
- オーバーフローを防ぐためuint型へ
- 画像変換の高速化
- 特定の条件でvendorモードに入るのを防ぐ
- cmd.StdinPipe()を使ってテストのsleepヘルパーを消す
- 特定のテスト失敗時のデバッグ情報を増やす
- メモリ効率の良いコードに置き換える
- OSごとに異なる部分の一部を修正する
- フレーキーテストを修正する
- テストのカバーしてない部分を追加する
- エラー時の挙動
- 意味のない中間変数の削除
- エラーコードの修正
- エラーコードの共通化
- 変数名の修正
- ドキュメントの修正
- Plan9での、ファイル並列アクセス
- バージョンによって異なる挙動部分のエラーについて、メッセージにバージョン情報を追加
- テストを並列にする
- 不要になったテストの削除
- 無限ループになってタイムアウトする問題の修正
- 便利関数を使う(strings.Cut) 2e054128bf
- tarのヘッダーにファイルサイズ制限をつける 0bf7ee9977

こうやって列挙してみると、多くの領域をカバーする必要はないことがわかる。取り組みやすいところや、集中的にやる領域を決めればよさそう。

issueを見てみる。これらがうまく解ければ楽なのだが。種類。今の段階でよくわからなくても、議論を見ることは調べる取っ掛かりになりそう。何を理解することがゴールになるのか、ということだ。散漫に読むより、ある問題があることを念頭において、仕組みを知ろうとするほうが頭に入る。解くために必要だからだ。

- go fmtのバグ
- 機能リクエスト
- フレーキーテスト

メモ。
- 経験豊富なプログラマーがどうやって問題解決しているかの生の資料になる。
- 全体をふんわりではなく、特定のコマンドに絞って知識を深める、問題に取り組むのがよさそう
** DONE コンパイルする
CLOSED: [2022-10-29 Sat 11:18]
:LOGBOOK:
CLOCK: [2022-10-27 Thu 10:12]--[2022-10-27 Thu 10:37] =>  0:25
CLOCK: [2022-10-27 Thu 09:46]--[2022-10-27 Thu 10:11] =>  0:25
:END:
開発を開始するには、まずGo自体をコンパイルする必要がある。そうでないと、テストも実行できない。

src/all.bash にシェルスクリプトがあり、それでコンパイルできる。実行にはgoが必要。goを使ってgoをコンパイルする。

#+caption: コンパイルを実行する
#+begin_src shell
  $ cd src # カレントディレクトリがsrc下である必要がある
  $ ./all.bash
#+end_src

** DONE テストを実行する
CLOSED: [2022-10-27 Thu 01:22]

手元でコンパイルしてgo処理系を最新にしてない場合、↓のような状態になる。

- テストを実行するとパッケージ関連で失敗する
- 実行できるテストもあるが、ソースコード(本体、テスト)への変更が全く反映されず、すべて成功する

#+caption: パッケージ関連のエラー
#+begin_quote
$ go test -v
package std/math/big
	arith_amd64.go:10:8: use of internal package internal/cpu not allowed
#+end_quote

** DONE テストがソースコードを反映してない
CLOSED: [2022-10-29 Sat 11:19]
いじってテストを走らせたりビルドしても反映しない。通常であれば構文レベルになるものも無視される。別のソースコードを見ているぽい。本体コードについてはワーキングディレクトリではなく、マシンにインストールしてあるgoを使っている気がするな。テストが反映しないのはよくわからない。

- 手元ビルドした最新のgoへのパスが通っていないためだった。パスを通すと、テストを失敗させられるように
- どうしてテストが反映されないという結果になるのかわからない
* Library
使えそうな、参考になりそうなライブラリをまとめる。
** [[https://cli.urfave.org/][Welcome - urfave/cli]]
cliアプリを作るライブラリ。
** [[https://github.com/jroimartin/gocui][jroimartin/gocui: Minimalist Go package aimed at creating Console User Interfaces.]]
GoでCUIツールを作れるライブラリ。
** [[https://github.com/jesseduffield/lazydocker][jesseduffield/lazydocker: The lazier way to manage everything docker]]
CLIで[[id:1658782a-d331-464b-9fd7-1f8233b8b7f8][Docker]]の状態を閲覧できるライブラリ。
* Reference
** [[https://github.com/vbd/Fieldnotes/blob/main/golang.md][Fieldnotes/golang.md at main · vbd/Fieldnotes]]
Goの読み物リスト。
** [[https://www.libhunt.com/l/go][Go Open-Source Projects]]
Goのリポジトリトレンド。
** [[https://go.dev/talks/2014/names.slide#1][What's in a name?]]
Goの名前に関する解説。よく言われることがだが、標準ライブラリが参考になると書いてある。
** [[https://dave.cheney.net/2014/12/01/five-suggestions-for-setting-up-a-go-project][Five suggestions for setting up a Go project | Dave Cheney]]
Goのパッケージ構成や名前などの解説。実際のリポジトリを上げていてわかりやすい。
** [[https://techbookfest.org/product/9a3U54LBdKDE30ewPS6Ugn?productVariantID=itEzQN5gKZX8gXMmLTEXAB][Go言語で構築するクリーンアーキテクチャ設計：コードカキタイ]]
クリーンアーキテクチャの本。
** [[https://github.com/gin-gonic/gin/issues/1363][how do i get response body in after router middleware? · Issue #1363 · gin-gonic/gin]]
ミドルウェアで返したレスポンスを取得する方法。
** [[https://zenn.dev/tchssk/articles/495b49d7adaa8d][Go の HTTP サーバーで Swagger UI を提供する]]
サーバ自体でAPIドキュメントを提供する方法。
** [[https://pkg.go.dev/github.com/getkin/kin-openapi@v0.97.0/openapi3filter#example-Validator][openapi3filter package - github.com/getkin/kin-openapi/openapi3filter - Go Packages]]
openapi3filterの例。
** [[https://www.wantedly.com/companies/company_6435340/post_articles/364864][Goによるサービス開発6年のしくじり - Go Conference 2021 Autumn Sponsor Session | ミイダス株式会社]]
メモ。
** [[https://zenn.dev/jy8752/books/73769005e6afa9][古典学派的テストとGoで考える持続可能なアーキテクチャ入門]]
モックを極力しない流儀の、古典学派のテスト本。
** [[https://go.dev/talks/2015/how-go-was-made.slide#1][How Go was made]]
Goの歴史。
** [[https://qiita.com/Jxck/items/8717a5982547cfa54ebc][Go の Test に対する考え方 #Go - Qiita]]
理由が書かれている。
** [[https://research.swtch.com/telemetry-intro][research!rsc: Transparent Telemetry for Open-Source Projects (Transparent Telemetry, Part 1)]]
MacOSでの Go1.14のコンパイルにX Codeが必要なのは意図的でなかった。しばらくの間、誰もそれをバグとして気づかなかった。
** [[https://zenn.dev/keishi_lcc/articles/c40fcb9d2c589d][Golang(echo)のAPIをrenderでデプロイする方法]]
タダのバックエンドサーバ。
** [[https://zenn.dev/kou_pg_0131/articles/goreleaser-usage][GoReleaser で Go 製 CLI のリリースを自動化＆ Homebrew でインストールできるようにする]]
goreleaserの使い方。
** [[https://astaxie.gitbooks.io/build-web-application-with-golang/content/ja/11.2.html][GDBを使用したデバッグ · Build web application with Golang]]
デバッグ方法の解説。
** [[https://go.dev/blog/comparable][All your comparable types - The Go Programming Language]]
1.20の変更。比較可能な型。
** [[https://go.dev/doc/toolchain][Go Toolchains - The Go Programming Language]]
Goツールチェイン。
** [[https://github.com/golang/go/issues/57001][extended forwards compatibility for Go · Issue #57001 · golang/go]]
go.modで指定するバージョンでは、Goツールチェーンを指定するわけではない。それを変えようという提案。
** [[https://github.com/golang/go/issues/60686][cmd/go: "loadPackageData called with empty package path" build panic · Issue #60686 · golang/go]]
比較的わかりやすい、小さなバグ。
** [[https://github.com/golang/go/issues/21835][proposal: use PCG Source in math/rand for Go 2 · Issue #21835 · golang/go]]
randの実装を効率が良いものに変える提案。
** [[https://github.com/hashicorp/go-plugin][hashicorp/go-plugin: Golang plugin system over RPC.]]
go pluginの例。
** [[https://go-review.googlesource.com/c/go/+/101457][doc: remove non-prime from list of primes in spec (101457) · Gerrit Code Review]]
素数に9が含まれているのはタイポではなく、そういうジョークとのこと。
** [[https://appliedgo.net/][Applied Go · Applied Go]]
高品質なGoのチュートリアル。
** [[https://go.dev/talks/2015/simplicity-is-complicated.slide#1][Simplicity is Complicated]]
ロブ・パイクによるGoのスライド。
** [[https://speakerdeck.com/retervision/go-runtime-scheduler][Go Runtime Scheduler - Speaker Deck]]
Goのスケジューラを実装する。
** [[https://zenn.dev/tmk616/articles/383fc3fbb0ec4b][【Go】go getは不要？go installとは？]]
わかりやすい説明。

- go get はgo.modに変更を加える
- go install はバイナリをインストールする

** [[https://qiita.com/sueken/items/30b6da9259e94c1ede71][golangのio.Readerは使い回しできない - Qiita]]
知らなかったな。
** [[https://engineering.mercari.com/blog/entry/2018-08-08-080000/][Go Fridayこぼれ話：非公開（unexported）な機能を使ったテスト #golang | メルカリエンジニアリング]]
- プロダクトコードとテストは別パッケージしたほうがいい
  - はじめてのユーザになり、インターフェースや公開の状態を考えられるから
- 非公開な関数や変数をテストしたときは、テスト用にエクスポートすればいい
** [[https://go.dev/blog/survey2022-q2-results][Go Developer Survey 2022 Q2 Results - The Go Programming Language]]
サーベイ結果。
** [[https://go.googlesource.com/proposal/+/master/design][design - proposal - Git at Google]]
proposal一覧。
** [[https://github.com/golang/proposal#proposal-review][golang/proposal: Go Project Design Documents]]
Go言語のproposal。
** [[https://zenn.dev/tenntenn/books/d168faebb1a739/viewer/22e4d4][はじめに｜逆引き Goによる静的解析]]
Goで静的解析をする入門本。
** [[https://yuroyoro.github.io/goast-viewer/][yuroyoro.github.io/goast-viewer/]]
GoのASTビューワー。
** [[https://divan.dev/posts/visual_programming_go/][Rethinking Visual Programming with Go · divan's blog]]
ソースコードの呼び出し関係をグラフィカルに表示する。
** [[https://www.onlinetool.io/xmltogo/][XML to Go]]
XMLからGoの構造体に変換するツール。
** [[https://www.campoy.cat/][Francesc Campoy Flores]]
Goプログラマー、Youtuber。チャンネルは更新止まってるぽい。
** [[https://go.dev/blog/][The Go Blog - The Go Programming Language]]
Goの公式ブログ。
** [[https://go.dev/doc/][Documentation - The Go Programming Language]]
公式ドキュメント。
** [[https://github.com/golang/go/issues/54968][debug/buildinfo: timeout in Read · Issue #54968 · golang/go]]
参考になるissue。バグ報告のうまいやり方。playgroundを使う。タイムアウトになるバグの原因。
** [[https://unknownplace.org/archives/golang-editing-with-emacs/][EmacsでのGo言語編集環境 - unknownplace.org]]
[[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]のgo-modeでのフォーマット、定義ジャンプ、便利なさまざまな機能。

- C-c C-a でimportを追加できる
** [[https://zenn.dev/hsaki/books/golang-concurrency/viewer/goelement][ゴールーチンとチャネル｜Goでの並行処理を徹底解剖！]]
Goルーチンの解説。
** [[https://qiita.com/Yaruki00/items/7edc04720a24e71abfa2][Goでflagを使ってコマンドライン引数を扱う - Qiita]]
手軽に使える。
** [[https://ebiten.org/][Ebitengine - A dead simple 2D game library for Go]]
Goのゲームライブラリ。
** [[https://www.techscore.com/tech/Go/Lang/Basic15/][15. スライスのハマりどころ | TECHSCORE(テックスコア)]]
:LOGBOOK:
CLOCK: [2022-11-12 Sat 11:19]--[2022-11-12 Sat 11:45] =>  0:26
:END:
スライスの詳しい解説。

キャパシティは参照するメモリ配列の範囲。
* Archives
** DONE [[https://tatsu-zine.com/books/go-five-recipes][Go言語を楽しむ5つのレシピ コタツと蜜柑とゴーファーとわたし【委託】 - 達人出版会]]
CLOSED: [2022-09-09 Fri 19:04]
:LOGBOOK:
CLOCK: [2022-09-09 Fri 18:29]--[2022-09-09 Fri 18:54] =>  0:25
CLOCK: [2022-09-09 Fri 17:24]--[2022-09-09 Fri 17:49] =>  0:25
CLOCK: [2022-09-09 Fri 16:51]--[2022-09-09 Fri 17:16] =>  0:25
:END:
画像処理やWebAssemblyなど。

ざっと読んだだけ。コードの中は読んでないので必要になったら確認する。
** DONE [[https://go-tour-jp.appspot.com/list][A Tour of Go]]
CLOSED: [2022-09-13 Tue 09:23]
:LOGBOOK:
CLOCK: [2022-09-13 Tue 08:41]--[2022-09-13 Tue 09:06] =>  0:25
CLOCK: [2022-09-13 Tue 08:13]--[2022-09-13 Tue 08:38] =>  0:25
CLOCK: [2022-09-11 Sun 15:02]--[2022-09-11 Sun 15:27] =>  0:25
CLOCK: [2022-09-11 Sun 14:33]--[2022-09-11 Sun 14:58] =>  0:25
CLOCK: [2022-09-11 Sun 10:03]--[2022-09-11 Sun 10:28] =>  0:25
CLOCK: [2022-09-10 Sat 21:18]--[2022-09-10 Sat 21:43] =>  0:25
CLOCK: [2022-09-10 Sat 20:50]--[2022-09-10 Sat 21:15] =>  0:25
CLOCK: [2022-09-10 Sat 20:24]--[2022-09-10 Sat 20:49] =>  0:25
CLOCK: [2022-09-10 Sat 18:48]--[2022-09-10 Sat 19:13] =>  0:25
CLOCK: [2022-09-10 Sat 18:16]--[2022-09-10 Sat 18:41] =>  0:25
CLOCK: [2022-09-10 Sat 17:51]--[2022-09-10 Sat 18:16] =>  0:25
CLOCK: [2022-09-10 Sat 16:44]--[2022-09-10 Sat 17:09] =>  0:25
:END:
最初のチュートリアル。
** DONE [[https://dev.classmethod.jp/articles/list-containers-by-docker-sdk-go/][Docker Engine SDKでコンテナ一覧を取得する | DevelopersIO]]
CLOSED: [2022-09-16 Fri 12:16]
:LOGBOOK:
CLOCK: [2022-09-16 Fri 11:11]--[2022-09-16 Fri 11:36] =>  0:25
:END:

小さなコマンドラインツールの例。
** DONE [[https://haibara-works.hatenablog.com/entry/2020/12/05/235227][GoでDockerを操る [Docker Engine SDK] - はいばらのブログ]]
CLOSED: [2022-09-17 Sat 10:19]
:LOGBOOK:
CLOCK: [2022-09-17 Sat 09:42]--[2022-09-17 Sat 10:07] =>  0:25
CLOCK: [2022-09-17 Sat 09:13]--[2022-09-17 Sat 09:38] =>  0:25
CLOCK: [2022-09-17 Sat 08:48]--[2022-09-17 Sat 09:13] =>  0:25
CLOCK: [2022-09-16 Fri 23:13]--[2022-09-16 Fri 23:38] =>  0:25
CLOCK: [2022-09-16 Fri 22:48]--[2022-09-16 Fri 23:13] =>  0:25
CLOCK: [2022-09-16 Fri 19:19]--[2022-09-16 Fri 19:44] =>  0:25
CLOCK: [2022-09-16 Fri 18:54]--[2022-09-16 Fri 19:19] =>  0:25
CLOCK: [2022-09-16 Fri 18:27]--[2022-09-16 Fri 18:52] =>  0:25
CLOCK: [2022-09-16 Fri 18:01]--[2022-09-16 Fri 18:27] =>  0:26
CLOCK: [2022-09-16 Fri 13:57]--[2022-09-16 Fri 14:22] =>  0:25
CLOCK: [2022-09-16 Fri 13:23]--[2022-09-16 Fri 13:48] =>  0:25
CLOCK: [2022-09-16 Fri 12:17]--[2022-09-16 Fri 12:42] =>  0:25
:END:
goとdockerの解説。
** DONE [[https://zenn.dev/kenny/articles/b9dd668bf09efe][Goで作成したAPIをDockerで動かす]]
CLOSED: [2022-09-17 Sat 11:54]
:LOGBOOK:
CLOCK: [2022-09-17 Sat 11:36]--[2022-09-17 Sat 11:54] =>  0:18
CLOCK: [2022-09-17 Sat 11:10]--[2022-09-17 Sat 11:35] =>  0:25
CLOCK: [2022-09-17 Sat 10:44]--[2022-09-17 Sat 11:09] =>  0:25
CLOCK: [2022-09-17 Sat 10:19]--[2022-09-17 Sat 10:44] =>  0:25
:END:
APIのサンプルコード。
** DONE [[https://www.amazon.co.jp/%E6%94%B9%E8%A8%822%E7%89%88-%E5%9F%BA%E7%A4%8E%E3%81%8B%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8B-Go%E8%A8%80%E8%AA%9E-%E5%8F%A4%E5%B7%9D%E6%98%87-ebook/dp/B06WP6S2QT/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=1GPYX46MK3OK&keywords=%E5%9F%BA%E7%A4%8E%E3%81%8B%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8B+go%E8%A8%80%E8%AA%9E&qid=1663028634&sprefix=%E5%9F%BA%E7%A4%8E%E3%81%8B%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8Bgo%E8%A8%80%E8%AA%9E%2Caps%2C2056&sr=8-1][改訂2版 基礎からわかる Go言語 | 古川昇 | 工学 | Kindleストア | Amazon]]
CLOSED: [2022-09-18 Sun 14:59]
:LOGBOOK:
CLOCK: [2022-09-17 Sat 20:58]--[2022-09-17 Sat 21:23] =>  0:25
CLOCK: [2022-09-17 Sat 18:01]--[2022-09-17 Sat 18:26] =>  0:25
CLOCK: [2022-09-15 Thu 11:51]--[2022-09-15 Thu 12:16] =>  0:25
CLOCK: [2022-09-15 Thu 08:47]--[2022-09-15 Thu 09:12] =>  0:25
CLOCK: [2022-09-15 Thu 08:21]--[2022-09-15 Thu 08:46] =>  0:25
CLOCK: [2022-09-15 Thu 07:56]--[2022-09-15 Thu 08:21] =>  0:25
CLOCK: [2022-09-14 Wed 17:40]--[2022-09-14 Wed 18:05] =>  0:25
CLOCK: [2022-09-14 Wed 17:05]--[2022-09-14 Wed 17:30] =>  0:25
CLOCK: [2022-09-14 Wed 16:38]--[2022-09-14 Wed 17:03] =>  0:25
CLOCK: [2022-09-14 Wed 14:20]--[2022-09-14 Wed 14:45] =>  0:25
CLOCK: [2022-09-14 Wed 10:09]--[2022-09-14 Wed 10:34] =>  0:25
CLOCK: [2022-09-14 Wed 09:39]--[2022-09-14 Wed 10:04] =>  0:25
CLOCK: [2022-09-14 Wed 08:00]--[2022-09-14 Wed 08:25] =>  0:25
CLOCK: [2022-09-14 Wed 07:34]--[2022-09-14 Wed 07:59] =>  0:25
CLOCK: [2022-09-13 Tue 11:44]--[2022-09-13 Tue 12:09] =>  0:25
CLOCK: [2022-09-13 Tue 10:47]--[2022-09-13 Tue 11:12] =>  0:25
CLOCK: [2022-09-13 Tue 10:10]--[2022-09-13 Tue 10:35] =>  0:25
CLOCK: [2022-09-13 Tue 09:24]--[2022-09-13 Tue 09:49] =>  0:25
:END:

- 117, 133, 141, 155

Go言語の入門本。

- Goでは、最初の文字が大文字で始まる名前は、外部のパッケージから参照できるエクスポートされた名前。例えばPiはmathパッケージでエクスポートされる

#+begin_src go
  package main
  import (
          "fmt"
          "math"
  )
  func main() {
          fmt.println(Math.pi)
  }
#+end_src

- 変数が存在するメモリ上の位置を「アドレス」といい、そのアドレスを格納可能な変数を「ポインタ」という
- ~int~ 型変数のアドレスを格納できるポインタの型は ~*int~ 型というように、アスタリスクをつける

#+caption: ポインタ
#+begin_src go :imports "fmt"
  var ptr *int
  var i int = 12345
  ptr = &i

  fmt.Println("iのアドレス:", &i)
  fmt.Println("ptrの値(変数iのアドレス):", ptr)

  fmt.Println("iの値:", i)
  fmt.Println("ポインタ経由のiの値:", *ptr)

  ,*ptr = 999
  fmt.Println("ポインタ経由で変更したiの値:", i)
#+end_src

#+RESULTS:
#+begin_results
iのアドレス: 0xc0000b6010
ptrの値(変数iのアドレス): 0xc0000b6010
iの値: 12345
ポインタ経由のiの値: 12345
ポインタ経由で変更したiの値: 999
#+end_results

#+begin_src go :imports "fmt"
  func main() {
          a, b := 1, 1

          double(a, &b)
          fmt.Println("値渡し:", a)
          fmt.Println("ポインタ渡し:", b)
  }

  func double(x int, y *int) {
          x = x * 2
          ,*y = *y * 2
  }
#+end_src

#+RESULTS:
#+begin_results
値渡し: 1
ポインタ渡し: 2
#+end_results

関数リテラル。

#+caption: 関数リテラル = 無名関数
#+begin_src go :imports "fmt"
  func main() {
          val := 123

          // 関数リテラルの記述と呼び出しを同時に行う
          func(i int) {
                  // 関数リテラル外の変数valにアクセス可能
                  fmt.Println(i * val)
          }(10)

          // 関数リテラルを変数に代入
          f := func(s string) {
                  fmt.Println(s)
          }

          f("hoge")
  }
#+end_src

#+RESULTS:
#+begin_results
1230
hoge
#+end_results

関数型。

#+caption: 代入して呼び出す
#+begin_src go :imports "fmt"
  func main() {
          // 関数型の変数宣言
          var f func(int, int) int

          // 関数リテラルの値を代入
          f = func(a int, b int) int {
                  return a + b
          }

          // 関数型の変数経由で関数を呼び出す
          fmt.Println(f(1, 2))


          // 関数型の変数に値を代入
          f = multiply

          // 関数型の変数経由で関数を呼び出す
          fmt.Println(f(1, 2))
  }

  func multiply(x int, y int) int {
          return x * y
  }
#+end_src

#+RESULTS:
#+begin_results
3
2
#+end_results

メソッドの宣言。

#+caption: 型に実装する
#+begin_src go :imports "fmt"
  type myType int

  // myType型をレシーバに持つ関数、すなわちmyType型のメソッドを宣言。レシーバは一番最初に書く
  func (value myType) println() {
          fmt.Println(value)
  }

  func main() {
          // myType型の変数を宣言する
          var z myType = 1234

          // myType型のメソッドを呼び出す
          z.println()
  }
#+end_src

#+RESULTS:
#+begin_results
1234
#+end_results

メソッドのレシーバをポインタにする。

#+begin_src go :imports "fmt"
  // int型
  type myType int

  func (value myType) setByValue(newValue myType) {
          // ここで値を代入しても無意味。Valueはコピーされるので
          value = newValue
  }

  func(value *myType) setByPointer(newValue myType) {
          // 代入した値が反映される
          ,*value = newValue
  }
  func main() {
          var x myType = 0

          // レシーバは値。値は変更できない
          x.setByValue(1)
          fmt.Println("値: 0 ->", x)

          // レシーバはポインタ。値は変更できる
          x.setByPointer(2)
          fmt.Println("ポインタ: 0 ->", x)
  }

#+end_src

#+RESULTS:
#+begin_results
値: 0 -> 0
ポインタ: 0 -> 2
#+end_results

構造体型に名前をつける。

#+caption: 構造体にMyDataという新しい型名を与える
#+begin_src go
  type MyData struct {
        s string
        b byte
  }
#+end_src

#+RESULTS:
#+begin_results
#+end_results

- メソッドの宣言には値レシーバ、ポインタレシーバの2つがある。混在させるべきではない
  - 変数レシーバではメソッドの操作は元の変数のコピーを操作する
  - ポインタレシーバでは、ポインタを使うので元の変数を変更できる
- ポインタレシーバを使う2つの理由
  - メソッドがレシーバが指す先の変数を変更するため
  - メソッドの呼び出しごとに変数のコピーを避けるため

匿名フィールド。匿名フィールドが持つフィールドとメソッドが、埋め込み先の構造体型にも実装されているかのように扱われる。Go言語には型の実装はないが、構造体に他の型を埋め込むことで継承似たようなことを実現できる。

#+caption: 埋め込み
#+begin_src go :imports "fmt"
  // 埋め込まれる型の構造体
  type embedded struct {
          i int
  }

  // embedded型のメソッド
  func (x embedded) doSomething() {
          fmt.Println("test.doSomething()")
  }

  // 埋め込み先の構造体
  type test struct {
          embedded // embedded型の埋め込み
  }

  func main() {
          var x test

          // embedded型に実装されているメソッドに、test型の値でアクセス
          x.doSomething()

          // embedded型のフィールドに、test型の値でアクセス
          fmt.Println(x.i)
  }
#+end_src

#+RESULTS:
#+begin_results
test.doSomething()
0
#+end_results

構造体の初期化。

#+caption: 2つの方法がある
#+begin_src go :imports "fmt"
  type Person struct {
          name string
          age int
  }

  func main() {
          // 構造体リテラルを使用せず、フィールドを個別に初期化
          var p1 Person
          p1.name = "Jhon"
          p1.age = 23

          // 構造体リテラルで初期化
          p2 := Person{age: 31, name: "Tom"}
          p3 := Person{"Jane", 42}
          p4 := &Person{"Mike", 36}
          fmt.Println(p1, p2, p3, p4)
  }
#+end_src

#+RESULTS:
#+begin_results
{Jhon 23} {Tom 31} {Jane 42} &{Mike 36}
#+end_results

埋め込みを行った構造体を構造体リテラルで初期化する。

#+caption: 埋め込み
#+begin_src go :imports "fmt"
  type Person struct {
          name string
          age int
  }

  type Employee struct {
          id int
          Person // 埋め込み
  }

  func main() {
          e := Employee{1, Person{"jack", 28}}
          fmt.Println(e)
  }
#+end_src

#+RESULTS:
#+begin_results
{1 {jack 28}}
#+end_results

Go言語のインターフェースの役割は「振る舞い」を規定すること。Go言語のインターフェースは「インターフェース」と「それを実装した型」との関係性を明示的に記述する必要がない。インターフェースに定義されている関数をメソッドとして実装している型は、自動的にそのインターフェースを実装していることになる。

#+caption: インターフェースと型は自動で関連付けられる
#+begin_src go :imports "fmt"
  type Calculator interface {
          // 関数の定義
          Calculate(a int, b int) int
  }

  type Add struct {
          // フィールドは持たない
  }

  // Add型にCalculatorインターフェースのCalculator関数を実装
  func (x Add) Calculate(a int, b int) int {
          return a + b
  }

  type Sub struct { }

  func (x Sub) Calculate(a int, b int) int {
          return a - b
  }

  func main() {
          var add Add
          var sub Sub

          var cal Calculator // interface

          cal = add // interfaceを満たす関数を持っているので、自動的にインターフェースを実装していることになり、代入できる
          fmt.Println("和:", cal.Calculate(1, 2))

          cal = sub
          fmt.Println("差:", cal.Calculate(1, 2))
  }
#+end_src

#+RESULTS:
#+begin_results
和: 3
差: -1
#+end_results

空インターフェース。関数を持たない空のインターフェース。定義関数をすべて実装している型はインターフェースを実装したことになるので、すべての型は空インターフェースを実装していることになる。

#+caption: 空インターフェース。どんな値でも代入できる。_ は未使用エラーを防ぐため
#+begin_src go
  var empty interface {}

  empty = "abc"
  empty = 12345
  empty = 3.14

  _ = empty
  #+end_src

#+RESULTS:
#+begin_results
#+end_results

関数を1つしか持たないインターフェースの場合、そのインターフェース名は「関数名+er」とするのが慣わし。

#+caption: 関数名がReadであれば、インターフェース名はReader
#+begin_src go
  type Reader interface {
          Read(p []byte) (n int, err error)
  }
#+end_src

型アサーションはインターフェース型の値を他の型へ変換するとき、または変換できるか確認するときに使う。

#+caption: 型アサーション
#+begin_src go :imports "fmt"
  func main() {
          // 空インターフェースにstring型の値を格納
          var i interface{} = "test"
          // 型アサーションを使いstring型へ
          var s string = i.(string) // 型アサーション
          fmt.Printf("i: %T\n", i)
          fmt.Printf("s: %T\n", s)
  }
#+end_src

#+RESULTS:
#+begin_results
i: string
s: string
#+end_results

型アサーション失敗時にランタイムパニックを発生させない。チェックに使う。

#+caption: 型アサーションから2番目の値を受け取るときは、変換できなくてもランタイムパニックは起きない
#+begin_src go :imports "fmt"
  func main() {
          // 空インターフェースにstring型の値を格納
          var i interface{} = "test"

          // 型アサーションに成功する例
          s1, ok := i.(string)
          fmt.Println(s1, ok)

          // 型アサーションに失敗する例
          // string型はdummyメソッドを持たないので変換できない
          s2, ok := i.(interface {
                  dummy()
          })
          fmt.Println(s2, ok)
  }
#+end_src

#+RESULTS:
#+begin_results
test true
<nil> false
#+end_results

型switch文。通常のswitch文とは異なる。式switchが値によって分岐するのに対し、型switch文は値が持つ型によって分岐する。

#+caption: 型switch
#+begin_src go :imports "fmt"
  func main() {
          showType(nil)
          showType(12345)
          showType("abcdef")
          showType(3.14)
  }

  func showType(x interface{}) {
          switch x.(type) {

          case nil:
                  fmt.Println("nil")

          case int, int32, int64:
                  fmt.Println("整数")

          case string:
                  fmt.Println("文字列")

          default:
                  fmt.Println("不明")
          }
  }
  #+end_src

#+RESULTS:
#+begin_results
nil
整数
文字列
不明
#+end_results

配列アクセス。

#+caption: 配列にアクセスする
#+begin_src go :imports "fmt"
  func main() {
          var date [7]string

          date[0] = "日曜日"
          date[1] = "月曜日"
          date[2] = "火曜日"
          date[3] = "水曜日"
          date[4] = "木曜日"
          date[5] = "金曜日"
          date[6] = "土曜日"

          // indexバージョン
          for i := 0; i < len(date); i++ {
                  fmt.Print(date[i], " ")
          }

          // rangeバージョン
          // 改行
          fmt.Println()

          for _, value := range date {
                  fmt.Print(value, " ")
          }

          fmt.Println()
  }
#+end_src

#+RESULTS:
#+begin_results
日曜日 月曜日 火曜日 水曜日 木曜日 金曜日 土曜日
日曜日 月曜日 火曜日 水曜日 木曜日 金曜日 土曜日
#+end_results

- スライス → 可変長
- 配列 → 非可変長

スライス式。

#+caption: スライスにアクセスする
#+begin_src go :imports "fmt"
  func main() {
          // 配列を宣言
          x := [5]string{"a", "b", "c", "d", "e"}
          // スライス型の変数を宣言
          var s1 []string

          // 配列全体をスライス
          s1 = x[:]
          fmt.Println(s1)

          // インデックス1~3までをスライス
          s2 := x[1:4]
          fmt.Println(s2)

          // インデックス3~をスライス
          s3 := x[3:]
          fmt.Println(s3)

          // インデックス1~3をスライス
          s4 := x[:4]
          fmt.Println(s4)
  }
#+end_src

#+RESULTS:
#+begin_results
[a b c d e]
[b c d]
[d e]
[a b c d]
#+end_results

スライスは「参照型」の1つ。Go言語にはスライス、マップ、チャネルという3つの参照型がある。データの実体を持たず、データへの参照情報しか持たない。

スライスを可変長パラメータに直接受け渡す。

#+caption: スライス...で展開して渡す
#+begin_src go :imports "fmt"
  func main() {
          s := []string{"a", "b", "c"}

          // 以下2つの結果は同じ
          test(s...)
          test("a", "b", "c")
  }
  func test(s ...string) {
          fmt.Println(len(s), s)
  }
#+end_src

#+RESULTS:
#+begin_results
3 [a b c]
3 [a b c]
#+end_results

エラーハンドリング。

#+caption: 存在しないファイルを参照して失敗させて検証する
#+begin_src go :imports '("fmt" "os")
  func main() {
          file, err := os.Open("test.txt")

          if err != nil {
                  fmt.Println(err.Error())
                  // os.Exit(1)
          }

          file.Close()
          fmt.Println("finish")
  }
#+end_src

#+RESULTS:
#+begin_results
open test.txt: no such file or directory
finish
#+end_results

独自のエラー処理。

#+begin_src go :imports "fmt"
          type MyError struct {
                  message string
          }

          func (err MyError) Error() string {
                  return err.message
          }

        func main() {
            val, err := hex2int("1")
            fmt.Println(val, err)

            val, err = hex2int("00000f")
            fmt.Println(val, err)

            val, err = hex2int("abcd")
            fmt.Println(val, err)

            val, err = hex2int("z")
            fmt.Println(val, err)
      }

  // 16進数文字列をint型に変換する
    func hex2int(hex string) (val int, err error) {
          // 1文字づつ取り出す
        for _, r := range hex {
              val *= 16
              switch {
                    case '0' <= r && r <= '9':
                    val += int(r - '0')
                    case 'a' <= r && r <= 'f':
                    val += int(r-'a') + 10
                    default:
                    return 0, MyError{"不正な文字列です。" + string(r)}
              }
        }

        // 戻り値errには初期値であるnilが返る
        return
  }

#+end_src

#+RESULTS:
#+begin_results
1 <nil>
15 <nil>
43981 <nil>
0 不正な文字列です。z
#+end_results

処理終了。

#+caption: panic関数
#+begin_src go
  func main() {
          f1()
  }

  func f1() {
          panic("パニック発生 ")
  }
#+end_src

#+RESULTS:
#+begin_results
#+end_results

チャネルはGoプログラムの中の通信機構で、ゴルーチン間における通信、同期、値の同期に使用する。

#+begin_src go :imports "fmt"
  func main() {
          c := make(chan int, 10)
          c <- 0

          fmt.Println("cap:", cap(c))
          fmt.Println("len:", len(c))
  }
#+end_src

#+RESULTS:
#+begin_results
cap: 10
len: 1
#+end_results

selectは複数のチャネルに対して同時に送受信待ちを行うときに使用する。
** DONE [[https://future-architect.github.io/articles/20210427b/][GoでDockerのAPIを叩いてみる | フューチャー技術ブログ]]
CLOSED: [2022-09-18 Sun 15:00]
goとdocker。
** DONE [[https://blog.zaim.co.jp/n/nc05117f6dffd][Go でコマンドラインツールを作るときに便利なパッケージ｜@hira]]
CLOSED: [2022-09-23 Fri 12:07]
:LOGBOOK:
CLOCK: [2022-09-23 Fri 11:37]--[2022-09-23 Fri 12:02] =>  0:25
:END:
環境変数、カラー、インジケータ。
** DONE cloneツール作成
CLOSED: [2022-09-24 Sat 09:20]
:LOGBOOK:
CLOCK: [2022-09-24 Sat 10:21]--[2022-09-24 Sat 10:46] =>  0:25
CLOCK: [2022-09-23 Fri 23:13]--[2022-09-23 Fri 23:38] =>  0:25
CLOCK: [2022-09-23 Fri 22:28]--[2022-09-23 Fri 22:53] =>  0:25
CLOCK: [2022-09-23 Fri 21:54]--[2022-09-23 Fri 22:19] =>  0:25
CLOCK: [2022-09-23 Fri 21:19]--[2022-09-23 Fri 21:44] =>  0:25
CLOCK: [2022-09-23 Fri 20:51]--[2022-09-23 Fri 21:16] =>  0:25
CLOCK: [2022-09-23 Fri 18:49]--[2022-09-23 Fri 19:14] =>  0:25
CLOCK: [2022-09-23 Fri 18:16]--[2022-09-23 Fri 18:41] =>  0:25
CLOCK: [2022-09-23 Fri 17:08]--[2022-09-23 Fri 17:33] =>  0:25
CLOCK: [2022-09-23 Fri 16:40]--[2022-09-23 Fri 17:05] =>  0:25
CLOCK: [2022-09-23 Fri 16:15]--[2022-09-23 Fri 16:40] =>  0:25
CLOCK: [2022-09-23 Fri 15:31]--[2022-09-23 Fri 15:56] =>  0:25
CLOCK: [2022-09-23 Fri 13:24]--[2022-09-23 Fri 13:49] =>  0:25
CLOCK: [2022-09-23 Fri 12:59]--[2022-09-23 Fri 13:24] =>  0:25
:END:

clonerのgoバージョンを作成する。
** DONE gcloneをリファクタする
CLOSED: [2022-09-28 Wed 17:23]
:LOGBOOK:
CLOCK: [2022-09-28 Wed 16:52]--[2022-09-28 Wed 17:17] =>  0:25
CLOCK: [2022-09-28 Wed 16:27]--[2022-09-28 Wed 16:52] =>  0:25
CLOCK: [2022-09-28 Wed 15:47]--[2022-09-28 Wed 16:12] =>  0:25
CLOCK: [2022-09-28 Wed 12:46]--[2022-09-28 Wed 13:11] =>  0:25
CLOCK: [2022-09-28 Wed 12:21]--[2022-09-28 Wed 12:46] =>  0:25
CLOCK: [2022-09-28 Wed 11:56]--[2022-09-28 Wed 12:21] =>  0:25
CLOCK: [2022-09-28 Wed 10:13]--[2022-09-28 Wed 10:38] =>  0:25
CLOCK: [2022-09-28 Wed 09:48]--[2022-09-28 Wed 10:13] =>  0:25
CLOCK: [2022-09-28 Wed 09:22]--[2022-09-28 Wed 09:47] =>  0:25
CLOCK: [2022-09-28 Wed 08:43]--[2022-09-28 Wed 09:08] =>  0:25
CLOCK: [2022-09-27 Tue 23:55]--[2022-09-28 Wed 00:20] =>  0:25
CLOCK: [2022-09-27 Tue 23:23]--[2022-09-27 Tue 23:48] =>  0:25
CLOCK: [2022-09-27 Tue 22:11]--[2022-09-27 Tue 22:36] =>  0:25
CLOCK: [2022-09-27 Tue 21:41]--[2022-09-27 Tue 22:06] =>  0:25
CLOCK: [2022-09-27 Tue 21:16]--[2022-09-27 Tue 21:41] =>  0:25
CLOCK: [2022-09-27 Tue 20:49]--[2022-09-27 Tue 21:14] =>  0:25
CLOCK: [2022-09-27 Tue 20:23]--[2022-09-27 Tue 20:48] =>  0:25
CLOCK: [2022-09-27 Tue 11:17]--[2022-09-27 Tue 11:42] =>  0:25
CLOCK: [2022-09-27 Tue 10:52]--[2022-09-27 Tue 11:17] =>  0:25
CLOCK: [2022-09-27 Tue 10:26]--[2022-09-27 Tue 10:51] =>  0:25
:END:

goclocを読んでいると、gcloneのひどい書き方が目につく。型、構造体の使い方、ファイルやモジュール分割。一通り完了。非常に勉強になった。
** DONE [[https://zenn.dev/hsaki/books/golang-io-package][Goから学ぶI/O]]
CLOSED: [2022-09-28 Wed 21:30]
:LOGBOOK:
CLOCK: [2022-09-28 Wed 20:35]--[2022-09-28 Wed 21:00] =>  0:25
CLOCK: [2022-09-28 Wed 19:59]--[2022-09-28 Wed 20:24] =>  0:25
CLOCK: [2022-09-28 Wed 17:24]--[2022-09-28 Wed 17:49] =>  0:25
CLOCK: [2022-09-27 Tue 08:48]--[2022-09-27 Tue 09:13] =>  0:25
CLOCK: [2022-09-27 Tue 08:17]--[2022-09-27 Tue 08:42] =>  0:25
CLOCK: [2022-09-27 Tue 00:18]--[2022-09-27 Tue 00:43] =>  0:25
CLOCK: [2022-09-26 Mon 23:01]--[2022-09-26 Mon 23:26] =>  0:25
CLOCK: [2022-09-26 Mon 22:35]--[2022-09-26 Mon 23:00] =>  0:25
CLOCK: [2022-09-26 Mon 22:10]--[2022-09-26 Mon 22:35] =>  0:25
:END:
GoのIOの解説。

#+begin_quote
os.File型のReadメソッドは以下のような実装となっています。

1. os.file型のReadメソッドを呼ぶ
2. 1の中でos.file型のreadメソッドを呼ぶ
3. 2の中でpoll.FD型のReadメソッドを呼ぶ
4. 3の中でsyscall.Readメソッドを呼ぶ
5. OSカーネルのシステムコールで読み込み処理
#+end_quote

- [[id:c5102c82-3146-4710-a826-85a802997929][network]]もI/Oと捉えられる。コネクションからデータを読み取る・書き込むといえるから
- [[id:7a81eb7c-8e2b-400a-b01a-8fa597ea527a][Linux]]の設計思想として"everything-is-a-file philosophy"というものがある。キーボードからの入力も、プリンターへの出力も、ハードディスクやネットワークからのI/Oもありとあらゆるものをすべて「OSのファイルシステムにあるファイルへのI/Oとして捉える」という思想。ネットワークからのデータ読み取り・書き込みも、OS内部的には通常のファイルI/Oと変わらない。そのため、ネットワークコネクションに対しても、通常ファイルと同様にfdが与えられる
- ファイル読み込みでもネットワークコネクションでも、システムコールsocket()を呼んで、fdを取得し、fdを内部フィールドに含んだ型を生成するところは共通
- リスナーからコネクションを得る = リスナーからfdを取り出して、それをTCPConnにラップする
** DONE gclone拡張
CLOSED: [2022-10-01 Sat 09:36]
:LOGBOOK:
CLOCK: [2022-09-30 Fri 23:26]--[2022-09-30 Fri 23:51] =>  0:25
CLOCK: [2022-09-30 Fri 23:00]--[2022-09-30 Fri 23:25] =>  0:25
CLOCK: [2022-09-30 Fri 22:35]--[2022-09-30 Fri 23:00] =>  0:25
CLOCK: [2022-09-30 Fri 09:15]--[2022-09-30 Fri 09:40] =>  0:25
CLOCK: [2022-09-30 Fri 00:32]--[2022-09-30 Fri 00:57] =>  0:25
CLOCK: [2022-09-29 Thu 23:25]--[2022-09-29 Thu 23:50] =>  0:25
CLOCK: [2022-09-29 Thu 22:58]--[2022-09-29 Thu 23:23] =>  0:25
:END:
ファイルサイズの増分、各所要時間を表示する。

ダウンロードしているとき先にリポジトリ名を表示して、あとから結果に応じて記号をつける。

#+begin_src shell
  github@gclone... ✔ (10s)
  github@go............ ✗ (0.6s)
  ...
  40.4s
  10.1G
#+end_src

インラインに表示するのがむずかしい。spinnerとコンフリクトしてるのか。
** DONE GitHub APIで統計を取る
CLOSED: [2022-10-04 Tue 09:21] DEADLINE: <2022-10-03 Mon>
:LOGBOOK:
CLOCK: [2022-10-04 Tue 11:48]--[2022-10-04 Tue 12:13] =>  0:25
CLOCK: [2022-10-03 Mon 23:17]--[2022-10-03 Mon 23:42] =>  0:25
CLOCK: [2022-10-03 Mon 22:50]--[2022-10-03 Mon 23:15] =>  0:25
CLOCK: [2022-10-03 Mon 22:07]--[2022-10-03 Mon 22:32] =>  0:25
CLOCK: [2022-10-03 Mon 21:42]--[2022-10-03 Mon 22:07] =>  0:25
CLOCK: [2022-10-03 Mon 21:13]--[2022-10-03 Mon 21:38] =>  0:25
CLOCK: [2022-10-03 Mon 20:42]--[2022-10-03 Mon 21:07] =>  0:25
CLOCK: [2022-10-03 Mon 19:10]--[2022-10-03 Mon 19:35] =>  0:25
CLOCK: [2022-10-03 Mon 18:45]--[2022-10-03 Mon 19:10] =>  0:25
CLOCK: [2022-10-03 Mon 18:19]--[2022-10-03 Mon 18:44] =>  0:25
CLOCK: [2022-10-03 Mon 17:54]--[2022-10-03 Mon 18:19] =>  0:25
CLOCK: [2022-10-03 Mon 15:38]--[2022-10-03 Mon 16:03] =>  0:25
CLOCK: [2022-10-03 Mon 13:32]--[2022-10-03 Mon 13:57] =>  0:25
CLOCK: [2022-10-03 Mon 13:06]--[2022-10-03 Mon 13:32] =>  0:26
CLOCK: [2022-10-03 Mon 12:41]--[2022-10-03 Mon 13:06] =>  0:25
CLOCK: [2022-10-03 Mon 11:12]--[2022-10-03 Mon 11:37] =>  0:25
CLOCK: [2022-10-03 Mon 10:46]--[2022-10-03 Mon 11:11] =>  0:25
CLOCK: [2022-10-03 Mon 10:21]--[2022-10-03 Mon 10:46] =>  0:25
CLOCK: [2022-10-03 Mon 09:50]--[2022-10-03 Mon 10:15] =>  0:25
CLOCK: [2022-10-03 Mon 09:13]--[2022-10-03 Mon 09:38] =>  0:25
CLOCK: [2022-10-03 Mon 08:47]--[2022-10-03 Mon 09:12] =>  0:25
CLOCK: [2022-10-03 Mon 08:22]--[2022-10-03 Mon 08:47] =>  0:25
CLOCK: [2022-10-03 Mon 07:57]--[2022-10-03 Mon 08:22] =>  0:25
CLOCK: [2022-10-02 Sun 23:33]--[2022-10-02 Sun 23:58] =>  0:25
CLOCK: [2022-10-02 Sun 22:59]--[2022-10-02 Sun 23:24] =>  0:25
CLOCK: [2022-10-02 Sun 22:16]--[2022-10-02 Sun 22:41] =>  0:25
CLOCK: [2022-10-02 Sun 21:48]--[2022-10-02 Sun 22:13] =>  0:25
CLOCK: [2022-10-02 Sun 21:23]--[2022-10-02 Sun 21:48] =>  0:25
CLOCK: [2022-10-02 Sun 19:39]--[2022-10-02 Sun 20:04] =>  0:25
CLOCK: [2022-10-02 Sun 18:15]--[2022-10-02 Sun 18:41] =>  0:26
CLOCK: [2022-10-02 Sun 17:49]--[2022-10-02 Sun 18:14] =>  0:25
CLOCK: [2022-10-02 Sun 17:24]--[2022-10-02 Sun 17:49] =>  0:25
CLOCK: [2022-10-02 Sun 16:59]--[2022-10-02 Sun 17:24] =>  0:25
CLOCK: [2022-10-02 Sun 16:20]--[2022-10-02 Sun 16:45] =>  0:25
CLOCK: [2022-10-02 Sun 15:55]--[2022-10-02 Sun 16:20] =>  0:25
CLOCK: [2022-10-02 Sun 15:19]--[2022-10-02 Sun 15:44] =>  0:25
CLOCK: [2022-10-02 Sun 14:52]--[2022-10-02 Sun 15:17] =>  0:25
CLOCK: [2022-10-02 Sun 14:27]--[2022-10-02 Sun 14:52] =>  0:25
CLOCK: [2022-10-02 Sun 14:02]--[2022-10-02 Sun 14:27] =>  0:25
CLOCK: [2022-10-02 Sun 13:33]--[2022-10-02 Sun 13:58] =>  0:25
CLOCK: [2022-10-02 Sun 12:23]--[2022-10-02 Sun 12:48] =>  0:25
CLOCK: [2022-10-02 Sun 11:40]--[2022-10-02 Sun 12:05] =>  0:25
CLOCK: [2022-10-02 Sun 11:15]--[2022-10-02 Sun 11:40] =>  0:25
CLOCK: [2022-10-02 Sun 10:50]--[2022-10-02 Sun 11:15] =>  0:25
CLOCK: [2022-10-02 Sun 10:25]--[2022-10-02 Sun 10:50] =>  0:25
CLOCK: [2022-10-02 Sun 09:35]--[2022-10-02 Sun 10:00] =>  0:25
CLOCK: [2022-10-02 Sun 09:10]--[2022-10-02 Sun 09:35] =>  0:25
CLOCK: [2022-10-02 Sun 08:45]--[2022-10-02 Sun 09:10] =>  0:25
CLOCK: [2022-10-02 Sun 08:20]--[2022-10-02 Sun 08:45] =>  0:25
CLOCK: [2022-10-02 Sun 00:07]--[2022-10-02 Sun 00:32] =>  0:25
CLOCK: [2022-10-01 Sat 23:34]--[2022-10-01 Sat 23:59] =>  0:25
CLOCK: [2022-10-01 Sat 22:16]--[2022-10-01 Sat 22:41] =>  0:25
CLOCK: [2022-10-01 Sat 21:50]--[2022-10-01 Sat 22:15] =>  0:25
CLOCK: [2022-10-01 Sat 21:16]--[2022-10-01 Sat 21:41] =>  0:25
CLOCK: [2022-10-01 Sat 20:51]--[2022-10-01 Sat 21:16] =>  0:25
CLOCK: [2022-10-01 Sat 20:11]--[2022-10-01 Sat 20:36] =>  0:25
CLOCK: [2022-10-01 Sat 19:46]--[2022-10-01 Sat 20:11] =>  0:25
CLOCK: [2022-10-01 Sat 19:17]--[2022-10-01 Sat 19:42] =>  0:25
CLOCK: [2022-09-29 Thu 22:18]--[2022-09-29 Thu 22:43] =>  0:25
CLOCK: [2022-09-29 Thu 21:46]--[2022-09-29 Thu 22:11] =>  0:25
:END:

アイデア。

- 言語別のリポジトリ数、行数、コミット数
- シールド
  - 定期的にGitHub Actionsでビルドすることで、数値を画像に反映させる
- データストア用リポジトリという考え方を深める(octcovやupptime的な)
  - 汎用的なデータストアとして用いる
  - 別リポジトリから簡単に扱えるworkflowを作成する
  - データストアリポジトリのURLと、キーによって、保存する
  - データを元に画像なり生成して、時系列を見られるようにする
- リポジトリ一覧を作る。コミット数、言語情報を一覧する
- データストアに保存、加工しやすい形にする
- 画像/jsonで出力する
- 他サイトに貼れるようにする

#+begin_src
総コミット: 5000

| 名前     | 概要           | 言語       |
|----------+----------------+------------|
| .emacs.d | emacs dotfiles | Emacs Lisp |
| dotfiles | system config  | Shell      |
| gclone   | git clone tool | Go         |

| 言語         | リポジトリ数 | コミット数 |
|------------+--------------+------------|
| Go         |            4 |        100 |
| Ruby       |            5 |        200 |
| Emacs Lisp |            2 |        100 |
#+end_src

- 汎用的なデータストアリポジトリ(配信用)。ツールを実行して更新する
- CLIツール
  - 情報取得
  - json出力
  - 画像出力
  - README.md出力
  - コミット機能
- フロントエンド

*** 作業ログ
コミット数を取るのが難しい。[[id:b4f456cf-d250-4877-ac4c-4b03144392f0][GraphQL]]で取るようにした。
** DONE 丸画像を生成する
CLOSED: [2022-10-04 Tue 15:39]
:LOGBOOK:
CLOCK: [2022-10-04 Tue 14:44]--[2022-10-04 Tue 15:09] =>  0:25
CLOCK: [2022-10-04 Tue 14:15]--[2022-10-04 Tue 14:40] =>  0:25
CLOCK: [2022-10-04 Tue 13:01]--[2022-10-04 Tue 13:26] =>  0:25
CLOCK: [2022-10-04 Tue 12:13]--[2022-10-04 Tue 12:38] =>  0:25
CLOCK: [2022-10-04 Tue 11:13]--[2022-10-04 Tue 11:38] =>  0:25
CLOCK: [2022-10-04 Tue 10:37]--[2022-10-04 Tue 11:02] =>  0:25
CLOCK: [2022-10-04 Tue 10:12]--[2022-10-04 Tue 10:37] =>  0:25
CLOCK: [2022-10-04 Tue 09:47]--[2022-10-04 Tue 10:12] =>  0:25
CLOCK: [2022-10-04 Tue 09:21]--[2022-10-04 Tue 09:46] =>  0:25
:END:
言語別の色の丸画像を生成するパッケージ。
** DONE act出力の順番固定
CLOSED: [2022-10-05 Wed 19:31]
:LOGBOOK:
CLOCK: [2022-10-05 Wed 17:50]--[2022-10-05 Wed 18:15] =>  0:25
CLOCK: [2022-10-05 Wed 17:24]--[2022-10-05 Wed 17:49] =>  0:25
:END:

1. keyだけを別のスライスにして、ソートする。
2. keyをイテレートして、mapの中身を取り出す
** DONE バナー生成
CLOSED: [2022-10-05 Wed 19:42]
:LOGBOOK:
CLOCK: [2022-10-04 Tue 18:30]--[2022-10-04 Tue 18:55] =>  0:25
CLOCK: [2022-10-04 Tue 18:00]--[2022-10-04 Tue 18:25] =>  0:25
CLOCK: [2022-10-04 Tue 17:33]--[2022-10-04 Tue 17:58] =>  0:25
CLOCK: [2022-10-04 Tue 17:08]--[2022-10-04 Tue 17:33] =>  0:25
:END:
ほかの形も追加する。
** DONE 誤字修正PRを送る
CLOSED: [2022-10-18 Tue 11:47]
+ [[https://github.com/golang/go][golang/go: The Go programming language]]

- TestStdErrorHander
- hexdecimal
** DONE [[https://www.oreilly.co.jp/books/9784873118222/][O'Reilly Japan - Go言語でつくるインタプリタ]]
CLOSED: [2022-10-18 Tue 12:22]
:LOGBOOK:
CLOCK: [2022-10-18 Tue 11:48]--[2022-10-18 Tue 12:13] =>  0:25
CLOCK: [2022-10-18 Tue 11:21]--[2022-10-18 Tue 11:46] =>  0:25
CLOCK: [2022-10-18 Tue 10:30]--[2022-10-18 Tue 10:55] =>  0:25
CLOCK: [2022-10-17 Mon 22:34]--[2022-10-17 Mon 22:59] =>  0:25
CLOCK: [2022-10-17 Mon 17:12]--[2022-10-17 Mon 17:37] =>  0:25
CLOCK: [2022-10-17 Mon 16:38]--[2022-10-17 Mon 17:03] =>  0:25
CLOCK: [2022-10-17 Mon 15:27]--[2022-10-17 Mon 15:52] =>  0:25
CLOCK: [2022-10-17 Mon 14:36]--[2022-10-17 Mon 15:01] =>  0:25
CLOCK: [2022-10-17 Mon 14:08]--[2022-10-17 Mon 14:33] =>  0:25
CLOCK: [2022-10-17 Mon 13:43]--[2022-10-17 Mon 14:08] =>  0:25
CLOCK: [2022-10-17 Mon 11:53]--[2022-10-17 Mon 12:18] =>  0:25
CLOCK: [2022-10-17 Mon 11:08]--[2022-10-17 Mon 11:33] =>  0:25
CLOCK: [2022-10-17 Mon 10:43]--[2022-10-17 Mon 11:08] =>  0:25
CLOCK: [2022-10-17 Mon 10:18]--[2022-10-17 Mon 10:43] =>  0:25
CLOCK: [2022-10-17 Mon 09:52]--[2022-10-17 Mon 10:17] =>  0:25
CLOCK: [2022-10-16 Sun 23:22]--[2022-10-16 Sun 23:47] =>  0:25
CLOCK: [2022-10-16 Sun 22:46]--[2022-10-16 Sun 23:11] =>  0:25
CLOCK: [2022-10-16 Sun 22:20]--[2022-10-16 Sun 22:45] =>  0:25
CLOCK: [2022-10-16 Sun 21:30]--[2022-10-16 Sun 21:55] =>  0:25
CLOCK: [2022-10-16 Sun 18:37]--[2022-10-16 Sun 19:02] =>  0:25
CLOCK: [2022-10-16 Sun 17:59]--[2022-10-16 Sun 18:24] =>  0:25
CLOCK: [2022-10-16 Sun 17:24]--[2022-10-16 Sun 17:49] =>  0:25
CLOCK: [2022-10-16 Sun 16:59]--[2022-10-16 Sun 17:24] =>  0:25
CLOCK: [2022-10-16 Sun 16:33]--[2022-10-16 Sun 16:58] =>  0:25
CLOCK: [2022-10-16 Sun 14:20]--[2022-10-16 Sun 14:45] =>  0:25
CLOCK: [2022-10-16 Sun 13:51]--[2022-10-16 Sun 14:16] =>  0:25
CLOCK: [2022-10-16 Sun 11:55]--[2022-10-16 Sun 12:21] =>  0:26
CLOCK: [2022-10-16 Sun 11:18]--[2022-10-16 Sun 11:43] =>  0:25
CLOCK: [2022-10-16 Sun 10:48]--[2022-10-16 Sun 11:14] =>  0:26
CLOCK: [2022-10-16 Sun 10:16]--[2022-10-16 Sun 10:41] =>  0:25
CLOCK: [2022-10-16 Sun 09:48]--[2022-10-16 Sun 10:13] =>  0:25
CLOCK: [2022-10-16 Sun 00:45]--[2022-10-16 Sun 01:10] =>  0:25
CLOCK: [2022-10-15 Sat 22:30]--[2022-10-15 Sat 22:55] =>  0:25
CLOCK: [2022-10-15 Sat 22:00]--[2022-10-15 Sat 22:25] =>  0:25
CLOCK: [2022-10-15 Sat 21:27]--[2022-10-15 Sat 21:52] =>  0:25
CLOCK: [2022-10-15 Sat 20:50]--[2022-10-15 Sat 21:15] =>  0:25
CLOCK: [2022-10-15 Sat 20:18]--[2022-10-15 Sat 20:43] =>  0:25
CLOCK: [2022-10-15 Sat 19:00]--[2022-10-15 Sat 19:25] =>  0:25
CLOCK: [2022-10-15 Sat 16:09]--[2022-10-15 Sat 16:34] =>  0:25
CLOCK: [2022-10-15 Sat 15:18]--[2022-10-15 Sat 15:43] =>  0:25
CLOCK: [2022-10-15 Sat 14:47]--[2022-10-15 Sat 15:12] =>  0:25
CLOCK: [2022-10-15 Sat 12:30]--[2022-10-15 Sat 12:56] =>  0:26
CLOCK: [2022-10-15 Sat 11:38]--[2022-10-15 Sat 12:03] =>  0:25
CLOCK: [2022-10-15 Sat 11:12]--[2022-10-15 Sat 11:37] =>  0:25
CLOCK: [2022-10-15 Sat 10:40]--[2022-10-15 Sat 11:05] =>  0:25
CLOCK: [2022-10-14 Fri 23:31]--[2022-10-14 Fri 23:56] =>  0:25
CLOCK: [2022-10-14 Fri 22:52]--[2022-10-14 Fri 23:17] =>  0:25
CLOCK: [2022-10-14 Fri 19:24]--[2022-10-14 Fri 19:49] =>  0:25
CLOCK: [2022-10-14 Fri 17:34]--[2022-10-14 Fri 17:59] =>  0:25
CLOCK: [2022-10-14 Fri 17:09]--[2022-10-14 Fri 17:34] =>  0:25
CLOCK: [2022-10-14 Fri 16:44]--[2022-10-14 Fri 17:09] =>  0:25
CLOCK: [2022-10-14 Fri 15:52]--[2022-10-14 Fri 16:17] =>  0:25
CLOCK: [2022-10-14 Fri 13:49]--[2022-10-14 Fri 14:14] =>  0:25
CLOCK: [2022-10-14 Fri 13:21]--[2022-10-14 Fri 13:46] =>  0:25
CLOCK: [2022-10-14 Fri 12:43]--[2022-10-14 Fri 13:08] =>  0:25
CLOCK: [2022-10-14 Fri 11:57]--[2022-10-14 Fri 12:22] =>  0:25
CLOCK: [2022-10-14 Fri 11:24]--[2022-10-14 Fri 11:49] =>  0:25
CLOCK: [2022-10-14 Fri 10:59]--[2022-10-14 Fri 11:24] =>  0:25
CLOCK: [2022-10-14 Fri 10:12]--[2022-10-14 Fri 10:37] =>  0:25
CLOCK: [2022-10-14 Fri 09:44]--[2022-10-14 Fri 10:09] =>  0:25
CLOCK: [2022-10-14 Fri 09:19]--[2022-10-14 Fri 09:44] =>  0:25
CLOCK: [2022-10-14 Fri 08:54]--[2022-10-14 Fri 09:19] =>  0:25
CLOCK: [2022-10-14 Fri 00:52]--[2022-10-14 Fri 01:17] =>  0:25
CLOCK: [2022-10-13 Thu 23:32]--[2022-10-13 Thu 23:57] =>  0:25
CLOCK: [2022-10-13 Thu 22:59]--[2022-10-13 Thu 23:24] =>  0:25
CLOCK: [2022-10-13 Thu 21:01]--[2022-10-13 Thu 21:26] =>  0:25
CLOCK: [2022-10-13 Thu 20:10]--[2022-10-13 Thu 20:35] =>  0:25
CLOCK: [2022-10-13 Thu 19:26]--[2022-10-13 Thu 19:51] =>  0:25
CLOCK: [2022-10-13 Thu 18:09]--[2022-10-13 Thu 18:34] =>  0:25
CLOCK: [2022-10-13 Thu 17:20]--[2022-10-13 Thu 17:45] =>  0:25
CLOCK: [2022-10-13 Thu 16:54]--[2022-10-13 Thu 17:19] =>  0:25
CLOCK: [2022-10-13 Thu 15:21]--[2022-10-13 Thu 15:46] =>  0:25
CLOCK: [2022-10-13 Thu 14:13]--[2022-10-13 Thu 14:38] =>  0:25
CLOCK: [2022-10-13 Thu 13:16]--[2022-10-13 Thu 13:42] =>  0:26
CLOCK: [2022-10-13 Thu 10:29]--[2022-10-13 Thu 10:54] =>  0:25
CLOCK: [2022-10-12 Wed 23:48]--[2022-10-13 Thu 00:13] =>  0:25
CLOCK: [2022-10-12 Wed 22:18]--[2022-10-12 Wed 22:43] =>  0:25
CLOCK: [2022-10-12 Wed 21:47]--[2022-10-12 Wed 22:12] =>  0:25
CLOCK: [2022-10-12 Wed 21:22]--[2022-10-12 Wed 21:47] =>  0:25
CLOCK: [2022-10-12 Wed 20:56]--[2022-10-12 Wed 21:21] =>  0:25
CLOCK: [2022-10-12 Wed 20:18]--[2022-10-12 Wed 20:43] =>  0:25
CLOCK: [2022-10-12 Wed 17:42]--[2022-10-12 Wed 18:07] =>  0:25
CLOCK: [2022-10-12 Wed 17:11]--[2022-10-12 Wed 17:36] =>  0:25
CLOCK: [2022-10-12 Wed 16:37]--[2022-10-12 Wed 17:02] =>  0:25
CLOCK: [2022-10-12 Wed 16:10]--[2022-10-12 Wed 16:35] =>  0:25
CLOCK: [2022-10-12 Wed 15:34]--[2022-10-12 Wed 15:59] =>  0:25
CLOCK: [2022-10-12 Wed 13:38]--[2022-10-12 Wed 14:03] =>  0:25
CLOCK: [2022-10-12 Wed 11:53]--[2022-10-12 Wed 12:18] =>  0:25
CLOCK: [2022-10-12 Wed 11:27]--[2022-10-12 Wed 11:52] =>  0:25
CLOCK: [2022-10-12 Wed 10:45]--[2022-10-12 Wed 11:10] =>  0:25
CLOCK: [2022-10-12 Wed 10:08]--[2022-10-12 Wed 10:33] =>  0:25
CLOCK: [2022-10-12 Wed 09:43]--[2022-10-12 Wed 10:08] =>  0:25
CLOCK: [2022-10-12 Wed 09:16]--[2022-10-12 Wed 09:41] =>  0:25
CLOCK: [2022-10-11 Tue 23:31]--[2022-10-11 Tue 23:56] =>  0:25
CLOCK: [2022-10-11 Tue 23:06]--[2022-10-11 Tue 23:31] =>  0:25
CLOCK: [2022-10-11 Tue 22:33]--[2022-10-11 Tue 22:58] =>  0:25
CLOCK: [2022-10-11 Tue 21:57]--[2022-10-11 Tue 22:22] =>  0:25
CLOCK: [2022-10-11 Tue 20:15]--[2022-10-11 Tue 20:40] =>  0:25
CLOCK: [2022-10-11 Tue 09:13]--[2022-10-11 Tue 09:38] =>  0:25
CLOCK: [2022-10-10 Mon 23:12]--[2022-10-10 Mon 23:37] =>  0:25
CLOCK: [2022-10-10 Mon 22:42]--[2022-10-10 Mon 23:07] =>  0:25
CLOCK: [2022-10-10 Mon 22:11]--[2022-10-10 Mon 22:36] =>  0:25
CLOCK: [2022-10-10 Mon 21:41]--[2022-10-10 Mon 22:06] =>  0:25
CLOCK: [2022-10-10 Mon 21:08]--[2022-10-10 Mon 21:33] =>  0:25
CLOCK: [2022-10-10 Mon 20:34]--[2022-10-10 Mon 20:59] =>  0:25
CLOCK: [2022-10-10 Mon 19:42]--[2022-10-10 Mon 20:07] =>  0:25
CLOCK: [2022-10-10 Mon 19:02]--[2022-10-10 Mon 19:27] =>  0:25
CLOCK: [2022-10-10 Mon 18:11]--[2022-10-10 Mon 18:36] =>  0:25
CLOCK: [2022-10-10 Mon 17:44]--[2022-10-10 Mon 18:09] =>  0:25
CLOCK: [2022-10-10 Mon 16:20]--[2022-10-10 Mon 16:45] =>  0:25
CLOCK: [2022-10-10 Mon 13:34]--[2022-10-10 Mon 13:59] =>  0:25
CLOCK: [2022-10-09 Sun 22:08]--[2022-10-09 Sun 22:33] =>  0:25
CLOCK: [2022-10-09 Sun 21:41]--[2022-10-09 Sun 22:06] =>  0:25
CLOCK: [2022-10-09 Sun 21:11]--[2022-10-09 Sun 21:36] =>  0:25
CLOCK: [2022-10-09 Sun 20:04]--[2022-10-09 Sun 20:29] =>  0:25
CLOCK: [2022-10-09 Sun 19:34]--[2022-10-09 Sun 19:59] =>  0:25
CLOCK: [2022-10-09 Sun 18:59]--[2022-10-09 Sun 19:24] =>  0:25
CLOCK: [2022-10-09 Sun 17:27]--[2022-10-09 Sun 17:52] =>  0:25
CLOCK: [2022-10-09 Sun 16:44]--[2022-10-09 Sun 17:09] =>  0:25
CLOCK: [2022-10-09 Sun 16:01]--[2022-10-09 Sun 16:26] =>  0:25
CLOCK: [2022-10-09 Sun 15:36]--[2022-10-09 Sun 16:01] =>  0:25
CLOCK: [2022-10-09 Sun 13:33]--[2022-10-09 Sun 13:58] =>  0:25
CLOCK: [2022-10-09 Sun 13:08]--[2022-10-09 Sun 13:33] =>  0:25
CLOCK: [2022-10-09 Sun 12:40]--[2022-10-09 Sun 13:05] =>  0:25
CLOCK: [2022-10-09 Sun 12:15]--[2022-10-09 Sun 12:40] =>  0:25
CLOCK: [2022-10-09 Sun 00:14]--[2022-10-09 Sun 00:39] =>  0:25
:END:

- 31, 42, 45, 52, 75, 86, 105, 115, 162, 184, 238, 252, 297

インタプリタを実装する。

- 字句解析フェーズが文字列をトークン列に変換
- 構文解析フェーズがトークン列をASTに変換
- マクロ展開フェーズがASTを受け取り、修正して、返却
- 評価

一通りやったが、あまり腑に落ちてない。部分的なコードの多くは読んで理解できたが、自分で別のことに利用したり、拡張は全くできそうにない。
** DONE [[https://tatsu-zine.com/books/nuxt-go-web-app-development][NuxtとGoではじめるWebアプリ開発【委託】 - 達人出版会]]
CLOSED: [2022-10-25 Tue 23:00]
:LOGBOOK:
CLOCK: [2022-10-25 Tue 22:07]--[2022-10-25 Tue 22:32] =>  0:25
CLOCK: [2022-10-25 Tue 21:42]--[2022-10-25 Tue 22:07] =>  0:25
CLOCK: [2022-10-24 Mon 19:45]--[2022-10-24 Mon 20:10] =>  0:25
CLOCK: [2022-10-24 Mon 19:10]--[2022-10-24 Mon 19:35] =>  0:25
CLOCK: [2022-10-24 Mon 18:45]--[2022-10-24 Mon 19:10] =>  0:25
CLOCK: [2022-10-24 Mon 18:20]--[2022-10-24 Mon 18:45] =>  0:25
CLOCK: [2022-10-24 Mon 17:28]--[2022-10-24 Mon 17:53] =>  0:25
CLOCK: [2022-10-24 Mon 17:02]--[2022-10-24 Mon 17:27] =>  0:25
CLOCK: [2022-10-24 Mon 16:37]--[2022-10-24 Mon 17:02] =>  0:25
CLOCK: [2022-10-24 Mon 16:12]--[2022-10-24 Mon 16:37] =>  0:25
CLOCK: [2022-10-24 Mon 15:23]--[2022-10-24 Mon 15:48] =>  0:25
CLOCK: [2022-10-24 Mon 14:58]--[2022-10-24 Mon 15:23] =>  0:25
CLOCK: [2022-10-24 Mon 14:32]--[2022-10-24 Mon 14:57] =>  0:25
CLOCK: [2022-10-24 Mon 14:07]--[2022-10-24 Mon 14:32] =>  0:25
CLOCK: [2022-10-23 Sun 22:05]--[2022-10-23 Sun 22:30] =>  0:25
CLOCK: [2022-10-23 Sun 21:30]--[2022-10-23 Sun 21:55] =>  0:25
CLOCK: [2022-10-23 Sun 21:05]--[2022-10-23 Sun 21:30] =>  0:25
CLOCK: [2022-10-23 Sun 20:40]--[2022-10-23 Sun 21:05] =>  0:25
CLOCK: [2022-10-23 Sun 18:05]--[2022-10-23 Sun 18:30] =>  0:25
CLOCK: [2022-10-23 Sun 17:40]--[2022-10-23 Sun 18:05] =>  0:25
CLOCK: [2022-10-23 Sun 17:15]--[2022-10-23 Sun 17:40] =>  0:25
CLOCK: [2022-10-23 Sun 16:43]--[2022-10-23 Sun 17:08] =>  0:25
CLOCK: [2022-10-23 Sun 13:54]--[2022-10-23 Sun 14:19] =>  0:25
CLOCK: [2022-10-23 Sun 13:26]--[2022-10-23 Sun 13:51] =>  0:25
CLOCK: [2022-10-23 Sun 13:00]--[2022-10-23 Sun 13:25] =>  0:25
CLOCK: [2022-10-23 Sun 06:54]--[2022-10-23 Sun 07:19] =>  0:25
CLOCK: [2022-10-22 Sat 23:29]--[2022-10-22 Sat 23:54] =>  0:25
CLOCK: [2022-10-22 Sat 23:04]--[2022-10-22 Sat 23:29] =>  0:25
CLOCK: [2022-10-22 Sat 22:39]--[2022-10-22 Sat 23:04] =>  0:25
CLOCK: [2022-10-22 Sat 22:14]--[2022-10-22 Sat 22:39] =>  0:25
CLOCK: [2022-10-22 Sat 21:39]--[2022-10-22 Sat 22:04] =>  0:25
CLOCK: [2022-10-22 Sat 20:24]--[2022-10-22 Sat 20:49] =>  0:25
CLOCK: [2022-10-22 Sat 19:59]--[2022-10-22 Sat 20:24] =>  0:25
CLOCK: [2022-10-22 Sat 19:32]--[2022-10-22 Sat 19:57] =>  0:25
CLOCK: [2022-10-22 Sat 19:00]--[2022-10-22 Sat 19:25] =>  0:25
CLOCK: [2022-10-22 Sat 18:35]--[2022-10-22 Sat 19:00] =>  0:25
CLOCK: [2022-10-22 Sat 18:08]--[2022-10-22 Sat 18:33] =>  0:25
CLOCK: [2022-10-22 Sat 17:42]--[2022-10-22 Sat 18:07] =>  0:25
CLOCK: [2022-10-22 Sat 11:40]--[2022-10-22 Sat 12:05] =>  0:25
CLOCK: [2022-10-22 Sat 11:15]--[2022-10-22 Sat 11:40] =>  0:25
CLOCK: [2022-10-22 Sat 10:50]--[2022-10-22 Sat 11:15] =>  0:25
CLOCK: [2022-10-22 Sat 10:25]--[2022-10-22 Sat 10:50] =>  0:25
CLOCK: [2022-10-21 Fri 21:46]--[2022-10-21 Fri 22:11] =>  0:25
CLOCK: [2022-10-15 Sat 14:02]--[2022-10-15 Sat 14:27] =>  0:25
:END:

動画検索アプリを題材に、NuxtとGoを使ったアプリ開発をやる本。

ところどころSDKのバージョンの違いで本の記述では動かないところがある。どこか間違ったらしく、jsonトークンを受け取る箇所がうまくできない。Firebaseへのログイン状態を判断する箇所がうまくいってないので、データベースの動きも確かめられていない。
** DONE ライフゲーム作成
CLOSED: [2022-11-12 Sat 21:38]
:LOGBOOK:
CLOCK: [2022-11-06 Sun 23:49]--[2022-11-07 Mon 00:14] =>  0:25
CLOCK: [2022-11-06 Sun 22:42]--[2022-11-06 Sun 23:07] =>  0:25
CLOCK: [2022-11-06 Sun 22:08]--[2022-11-06 Sun 22:33] =>  0:25
CLOCK: [2022-11-06 Sun 21:42]--[2022-11-06 Sun 22:07] =>  0:25
CLOCK: [2022-11-06 Sun 21:17]--[2022-11-06 Sun 21:42] =>  0:25
CLOCK: [2022-11-06 Sun 19:24]--[2022-11-06 Sun 19:49] =>  0:25
CLOCK: [2022-11-06 Sun 18:52]--[2022-11-06 Sun 19:17] =>  0:25
CLOCK: [2022-11-06 Sun 18:27]--[2022-11-06 Sun 18:52] =>  0:25
CLOCK: [2022-11-06 Sun 18:02]--[2022-11-06 Sun 18:27] =>  0:25
CLOCK: [2022-11-06 Sun 16:35]--[2022-11-06 Sun 17:00] =>  0:25
CLOCK: [2022-11-06 Sun 16:10]--[2022-11-06 Sun 16:35] =>  0:25
CLOCK: [2022-11-06 Sun 12:17]--[2022-11-06 Sun 12:42] =>  0:25
CLOCK: [2022-11-06 Sun 11:52]--[2022-11-06 Sun 12:17] =>  0:25
CLOCK: [2022-11-06 Sun 11:26]--[2022-11-06 Sun 11:51] =>  0:25
CLOCK: [2022-11-06 Sun 10:49]--[2022-11-06 Sun 11:14] =>  0:25
CLOCK: [2022-11-05 Sat 22:20]--[2022-11-05 Sat 22:45] =>  0:25
CLOCK: [2022-11-05 Sat 21:55]--[2022-11-05 Sat 22:20] =>  0:25
CLOCK: [2022-11-05 Sat 21:30]--[2022-11-05 Sat 21:55] =>  0:25
CLOCK: [2022-11-05 Sat 20:56]--[2022-11-05 Sat 21:21] =>  0:25
CLOCK: [2022-11-05 Sat 20:31]--[2022-11-05 Sat 20:56] =>  0:25
CLOCK: [2022-11-05 Sat 17:02]--[2022-11-05 Sat 17:27] =>  0:25
CLOCK: [2022-11-05 Sat 16:35]--[2022-11-05 Sat 17:00] =>  0:25
CLOCK: [2022-11-05 Sat 15:54]--[2022-11-05 Sat 16:19] =>  0:25
CLOCK: [2022-11-05 Sat 15:28]--[2022-11-05 Sat 15:53] =>  0:25
CLOCK: [2022-11-05 Sat 14:39]--[2022-11-05 Sat 15:04] =>  0:25
CLOCK: [2022-11-05 Sat 13:38]--[2022-11-05 Sat 14:03] =>  0:25
CLOCK: [2022-11-05 Sat 13:12]--[2022-11-05 Sat 13:37] =>  0:25
CLOCK: [2022-11-05 Sat 12:35]--[2022-11-05 Sat 13:00] =>  0:25
CLOCK: [2022-11-05 Sat 12:10]--[2022-11-05 Sat 12:35] =>  0:25
CLOCK: [2022-11-05 Sat 11:45]--[2022-11-05 Sat 12:10] =>  0:25
CLOCK: [2022-11-05 Sat 11:05]--[2022-11-05 Sat 11:30] =>  0:25
CLOCK: [2022-11-04 Fri 23:30]--[2022-11-04 Fri 23:56] =>  0:26
CLOCK: [2022-11-04 Fri 23:03]--[2022-11-04 Fri 23:28] =>  0:25
CLOCK: [2022-11-03 Thu 21:13]--[2022-11-03 Thu 21:38] =>  0:25
CLOCK: [2022-11-03 Thu 20:25]--[2022-11-03 Thu 20:50] =>  0:25
CLOCK: [2022-11-03 Thu 20:00]--[2022-11-03 Thu 20:25] =>  0:25
CLOCK: [2022-11-03 Thu 19:33]--[2022-11-03 Thu 19:58] =>  0:25
CLOCK: [2022-11-03 Thu 19:07]--[2022-11-03 Thu 19:32] =>  0:25
:END:
バックエンドGo, フロントReactで作る。

- [[https://github.com/kijimaD/golife][kijimaD/golife: implement Conway's Game of Life]]
** DONE gofmtを読む
CLOSED: [2022-11-12 Sat 21:51]
:LOGBOOK:
CLOCK: [2022-11-12 Sat 20:59]--[2022-11-12 Sat 21:25] =>  0:26
CLOCK: [2022-11-12 Sat 20:24]--[2022-11-12 Sat 20:49] =>  0:25
CLOCK: [2022-11-12 Sat 19:38]--[2022-11-12 Sat 20:03] =>  0:25
CLOCK: [2022-11-12 Sat 19:02]--[2022-11-12 Sat 19:27] =>  0:25
CLOCK: [2022-11-12 Sat 17:33]--[2022-11-12 Sat 17:58] =>  0:25
CLOCK: [2022-10-29 Sat 20:38]--[2022-10-29 Sat 21:03] =>  0:25
CLOCK: [2022-10-29 Sat 19:47]--[2022-10-29 Sat 20:12] =>  0:25
CLOCK: [2022-10-29 Sat 19:21]--[2022-10-29 Sat 19:46] =>  0:25
CLOCK: [2022-10-29 Sat 18:47]--[2022-10-29 Sat 19:12] =>  0:25
CLOCK: [2022-10-29 Sat 18:05]--[2022-10-29 Sat 18:30] =>  0:25
CLOCK: [2022-10-29 Sat 11:51]--[2022-10-29 Sat 12:16] =>  0:25
CLOCK: [2022-10-29 Sat 11:19]--[2022-10-29 Sat 11:44] =>  0:25
CLOCK: [2022-10-28 Fri 18:38]--[2022-10-28 Fri 19:03] =>  0:25
CLOCK: [2022-10-28 Fri 15:14]--[2022-10-28 Fri 15:39] =>  0:25
CLOCK: [2022-10-28 Fri 14:44]--[2022-10-28 Fri 15:09] =>  0:25
CLOCK: [2022-10-28 Fri 12:50]--[2022-10-28 Fri 13:15] =>  0:25
CLOCK: [2022-10-28 Fri 11:09]--[2022-10-28 Fri 11:34] =>  0:25
CLOCK: [2022-10-27 Thu 18:42]--[2022-10-27 Thu 19:07] =>  0:25
CLOCK: [2022-10-27 Thu 18:17]--[2022-10-27 Thu 18:42] =>  0:25
CLOCK: [2022-10-27 Thu 17:27]--[2022-10-27 Thu 17:52] =>  0:25
CLOCK: [2022-10-27 Thu 17:01]--[2022-10-27 Thu 17:26] =>  0:25
:END:
整形の方法を読む。

主要な関数を見ていく。

#+caption: 各ファイルにフォーマットを実行する関数
#+begin_src git-permalink
https://github.com/golang/go/blob/51af90445696772703ed88d967e8c23c8e9e992d/src/cmd/gofmt/gofmt.go#L229
#+end_src

#+RESULTS:
#+begin_results go
func processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter) error {
#+end_results

1. ファイル読み込み
2. ast取り出し
3. フォーマット
4. 差分があれば、結果に対する各種処理
  - 複数ファイルオプションがあれば、ファイル名をプリント
  -  書き込みオプションがあれば、ファイルに書き込み。最初にバックアップを別ファイルに保存し、目標ファイルへの上書きにエラーがあれば戻せるようにする。エラーがなかった場合は完了
  - 差分表示オプションがあれば、差分をプリント

#+caption: 実行の全体像
#+begin_src git-permalink
https://github.com/golang/go/blob/51af90445696772703ed88d967e8c23c8e9e992d/src/cmd/gofmt/gofmt.go#L387
#+end_src

#+RESULTS:
#+begin_results go
func gofmtMain(s *sequencer) {
#+end_results

疑問。

- ~fdSem~ とは
  - fdSem guards the number of concurrently-open file descriptors.
  - file descriptor semaphore か。セマフォとは、同時実行を制御する仕組み
  - 定義の make(chan bool, 200) はバッファ作成。チャネルに一時データを保存する
  - ~fdsem <- true~ は入れる
  - ~<-fdSem~ は取り出し
  - ファイル関係の処理が入るときにfdSemをコントロールして、file descriptorの上限を超えないようにしている
- ~weight~ とは
  - maxWeightはコア数の環境変数から計算した値を使う
  - maxWeightは最大の同時接続数のことで、weightはその接続数のカウントのこと。接続が増えるとカウントが減り、0になるとほかのゴルーチンは並列実行できない
  - weightはファイルサイズから計算する
  - ファイルサイズによって同時実行数を制御する…ということか。あまりピンとこない
- ~sequencer~ とは
  - スライス等ではないが、prevフィールドで辿れるグループピング構造に見える
  - weight, ファイル処理を含む無名関数が入っている
  - エラーを出す無名関数を入れることもある
** DONE bufioを読む
CLOSED: [2022-11-16 Wed 09:32]
:LOGBOOK:
CLOCK: [2022-11-13 Sun 22:46]--[2022-11-13 Sun 23:11] =>  0:25
CLOCK: [2022-11-13 Sun 22:07]--[2022-11-13 Sun 22:32] =>  0:25
CLOCK: [2022-11-13 Sun 21:28]--[2022-11-13 Sun 21:53] =>  0:25
CLOCK: [2022-11-13 Sun 20:09]--[2022-11-13 Sun 20:34] =>  0:25
CLOCK: [2022-11-13 Sun 19:35]--[2022-11-13 Sun 20:00] =>  0:25
CLOCK: [2022-11-13 Sun 18:55]--[2022-11-13 Sun 19:20] =>  0:25
CLOCK: [2022-11-13 Sun 17:47]--[2022-11-13 Sun 18:12] =>  0:25
CLOCK: [2022-11-13 Sun 17:21]--[2022-11-13 Sun 17:46] =>  0:25
CLOCK: [2022-11-13 Sun 16:54]--[2022-11-13 Sun 17:19] =>  0:25
CLOCK: [2022-11-13 Sun 16:29]--[2022-11-13 Sun 16:54] =>  0:25
CLOCK: [2022-11-13 Sun 12:28]--[2022-11-13 Sun 12:53] =>  0:25
CLOCK: [2022-11-13 Sun 11:53]--[2022-11-13 Sun 12:18] =>  0:25
CLOCK: [2022-11-13 Sun 11:21]--[2022-11-13 Sun 11:46] =>  0:25
CLOCK: [2022-11-13 Sun 10:55]--[2022-11-13 Sun 11:20] =>  0:25
CLOCK: [2022-11-13 Sun 10:27]--[2022-11-13 Sun 10:52] =>  0:25
CLOCK: [2022-11-13 Sun 00:59]--[2022-11-13 Sun 01:24] =>  0:25
CLOCK: [2022-11-12 Sat 21:52]--[2022-11-12 Sat 22:17] =>  0:25
:END:

結局全然ピンと来てない。

まずバッファの概念を理解することが必要そう。解説してあった。こういうのを自分でコードから調査できるようになりたい。
- [[https://zenn.dev/hsaki/books/golang-io-package/viewer/bufio][bufioパッケージによるbuffered I/O｜Goから学ぶI/O]]

あるバイト数に達するまでbufioの内部バッファにためておく処理がある。それが普通のbufioとioの違い。

#+caption: 重要そうな部分。余りバッファがあればコピーし、余りバッファがないときはコピーせず直接write
#+begin_src git-permalink
https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/bufio/bufio.go#L662-L685
#+end_src

#+RESULTS:
#+begin_results go
func (b *Writer) Write(p []byte) (nn int, err error) {
	for len(p) > b.Available() && b.err == nil {
		var n int
		if b.Buffered() == 0 {
			// Large write, empty buffer.
			// Write directly from p to avoid copy.
			n, b.err = b.wr.Write(p)
		} else {
			n = copy(b.buf[b.n:], p)
			b.n += n
			b.Flush()
		}
		nn += n
		p = p[n:]
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], p)
	b.n += n
	nn += n
	return nn, nil
}
#+end_results
** DONE [[https://gihyo.jp/dp/ebook/2021/978-4-297-12520-2][エキスパートたちのGo言語 一流のコードから応用力を学ぶ | Gihyo Digital Publishing … 技術評論社の電子書籍]]
CLOSED: [2023-02-11 Sat 16:35]
:PROPERTIES:
:Effort:   5:00
:END:
:LOGBOOK:
CLOCK: [2024-03-13 Wed 23:03]--[2024-03-13 Wed 23:28] =>  0:25
CLOCK: [2023-02-11 Sat 15:58]--[2023-02-11 Sat 16:23] =>  0:25
CLOCK: [2023-02-11 Sat 14:37]--[2023-02-11 Sat 15:02] =>  0:25
CLOCK: [2023-02-11 Sat 10:44]--[2023-02-11 Sat 11:09] =>  0:25
CLOCK: [2023-02-11 Sat 10:16]--[2023-02-11 Sat 10:41] =>  0:25
CLOCK: [2023-02-10 Fri 21:40]--[2023-02-10 Fri 22:05] =>  0:25
CLOCK: [2023-02-10 Fri 21:15]--[2023-02-10 Fri 21:40] =>  0:25
CLOCK: [2023-02-10 Fri 20:19]--[2023-02-10 Fri 20:44] =>  0:25
:END:
ノウハウ集。通読するものというよりは、好きな箇所をつまみ食いする本。
** DONE [[https://zenn.dev/empenguin/articles/09c1b50ebeb8e7][Golang による Strategy パターン]]
CLOSED: [2023-02-11 Sat 20:59]
:LOGBOOK:
CLOCK: [2023-02-11 Sat 20:53]--[2023-02-11 Sat 20:59] =>  0:06
:END:
必要になったので参考にする。
** DONE [[https://selfnote.work/20210516/programming/golang-design-pattern-prototype/][[Go言語]Prototypeパターンを学ぼう | セルフノート]]
CLOSED: [2023-02-11 Sat 20:59]
:LOGBOOK:
CLOCK: [2023-02-11 Sat 20:18]--[2023-02-11 Sat 20:43] =>  0:25
:END:
デザインパターンの紹介。
** DONE [[https://andmorefine.gitbook.io/learn-go-with-tests/][テスト駆動開発でGO言語を学びましょう - テスト駆動開発でGO言語を学びましょう]]
:PROPERTIES:
:Effort:   5:00
:END:
:LOGBOOK:
CLOCK: [2023-01-21 Sat 18:27]--[2023-01-21 Sat 18:52] =>  0:25
CLOCK: [2023-01-21 Sat 16:06]--[2023-01-21 Sat 16:31] =>  0:25
CLOCK: [2023-01-21 Sat 15:34]--[2023-01-21 Sat 15:59] =>  0:25
CLOCK: [2023-01-09 Mon 11:37]--[2023-01-09 Mon 12:02] =>  0:25
CLOCK: [2022-12-26 Mon 23:26]--[2022-12-26 Mon 23:51] =>  0:25
CLOCK: [2022-12-25 Sun 21:57]--[2022-12-25 Sun 22:22] =>  0:25
CLOCK: [2022-12-25 Sun 21:28]--[2022-12-25 Sun 21:53] =>  0:25
CLOCK: [2022-12-25 Sun 20:49]--[2022-12-25 Sun 21:14] =>  0:25
CLOCK: [2022-12-25 Sun 20:23]--[2022-12-25 Sun 20:48] =>  0:25
CLOCK: [2022-12-25 Sun 19:58]--[2022-12-25 Sun 20:23] =>  0:25
CLOCK: [2022-12-25 Sun 18:19]--[2022-12-25 Sun 18:44] =>  0:25
CLOCK: [2022-12-25 Sun 17:50]--[2022-12-25 Sun 18:15] =>  0:25
CLOCK: [2022-12-25 Sun 17:22]--[2022-12-25 Sun 17:47] =>  0:25
CLOCK: [2022-12-25 Sun 16:57]--[2022-12-25 Sun 17:22] =>  0:25
CLOCK: [2022-12-20 Tue 22:49]--[2022-12-20 Tue 23:14] =>  0:25
CLOCK: [2022-12-20 Tue 22:24]--[2022-12-20 Tue 22:49] =>  0:25
CLOCK: [2022-12-20 Tue 21:59]--[2022-12-20 Tue 22:24] =>  0:25
CLOCK: [2022-12-20 Tue 21:34]--[2022-12-20 Tue 21:59] =>  0:25
CLOCK: [2022-12-11 Sun 17:36]--[2022-12-11 Sun 18:01] =>  0:25
CLOCK: [2022-12-11 Sun 17:00]--[2022-12-11 Sun 17:25] =>  0:25
CLOCK: [2022-12-11 Sun 12:38]--[2022-12-11 Sun 13:03] =>  0:25
CLOCK: [2022-12-11 Sun 12:04]--[2022-12-11 Sun 12:29] =>  0:25
CLOCK: [2022-12-11 Sun 09:47]--[2022-12-11 Sun 10:12] =>  0:25
CLOCK: [2022-12-10 Sat 22:41]--[2022-12-10 Sat 23:06] =>  0:25
CLOCK: [2022-12-10 Sat 22:16]--[2022-12-10 Sat 22:41] =>  0:25
CLOCK: [2022-12-10 Sat 21:51]--[2022-12-10 Sat 22:16] =>  0:25
CLOCK: [2022-12-10 Sat 21:23]--[2022-12-10 Sat 21:48] =>  0:25
CLOCK: [2022-12-10 Sat 19:40]--[2022-12-10 Sat 20:05] =>  0:25
CLOCK: [2022-12-10 Sat 19:06]--[2022-12-10 Sat 19:31] =>  0:25
CLOCK: [2022-12-10 Sat 18:41]--[2022-12-10 Sat 19:06] =>  0:25
CLOCK: [2022-12-10 Sat 17:50]--[2022-12-10 Sat 18:15] =>  0:25
CLOCK: [2022-12-10 Sat 17:21]--[2022-12-10 Sat 17:46] =>  0:25
CLOCK: [2022-12-10 Sat 16:40]--[2022-12-10 Sat 17:05] =>  0:25
CLOCK: [2022-11-30 Wed 10:07]--[2022-11-30 Wed 10:32] =>  0:25
CLOCK: [2022-11-30 Wed 09:32]--[2022-11-30 Wed 09:57] =>  0:25
CLOCK: [2022-11-30 Wed 00:22]--[2022-11-30 Wed 00:47] =>  0:25
CLOCK: [2022-11-29 Tue 23:56]--[2022-11-30 Wed 00:21] =>  0:25
CLOCK: [2022-11-29 Tue 23:20]--[2022-11-29 Tue 23:45] =>  0:25
CLOCK: [2022-11-29 Tue 10:06]--[2022-11-29 Tue 10:31] =>  0:25
CLOCK: [2022-11-29 Tue 09:41]--[2022-11-29 Tue 10:06] =>  0:25
CLOCK: [2022-11-27 Sun 23:21]--[2022-11-27 Sun 23:46] =>  0:25
CLOCK: [2022-11-27 Sun 21:54]--[2022-11-27 Sun 22:19] =>  0:25
CLOCK: [2022-11-27 Sun 21:21]--[2022-11-27 Sun 21:46] =>  0:25
CLOCK: [2022-11-27 Sun 20:56]--[2022-11-27 Sun 21:21] =>  0:25
CLOCK: [2022-11-27 Sun 20:14]--[2022-11-27 Sun 20:39] =>  0:25
CLOCK: [2022-11-27 Sun 19:37]--[2022-11-27 Sun 20:02] =>  0:25
CLOCK: [2022-11-27 Sun 19:12]--[2022-11-27 Sun 19:37] =>  0:25
CLOCK: [2022-11-27 Sun 13:16]--[2022-11-27 Sun 13:41] =>  0:25
CLOCK: [2022-11-27 Sun 12:50]--[2022-11-27 Sun 13:15] =>  0:25
CLOCK: [2022-11-27 Sun 11:58]--[2022-11-27 Sun 12:23] =>  0:25
CLOCK: [2022-11-27 Sun 11:24]--[2022-11-27 Sun 11:49] =>  0:25
CLOCK: [2022-11-27 Sun 10:59]--[2022-11-27 Sun 11:24] =>  0:25
CLOCK: [2022-11-27 Sun 10:34]--[2022-11-27 Sun 10:59] =>  0:25
CLOCK: [2022-11-26 Sat 23:55]--[2022-11-27 Sun 00:20] =>  0:25
CLOCK: [2022-11-24 Thu 09:19]--[2022-11-24 Thu 09:45] =>  0:26
CLOCK: [2022-11-24 Thu 00:40]--[2022-11-24 Thu 01:05] =>  0:25
CLOCK: [2022-11-23 Wed 22:46]--[2022-11-23 Wed 23:11] =>  0:25
CLOCK: [2022-11-23 Wed 22:11]--[2022-11-23 Wed 22:36] =>  0:25
CLOCK: [2022-11-23 Wed 21:42]--[2022-11-23 Wed 22:07] =>  0:25
CLOCK: [2022-11-23 Wed 21:16]--[2022-11-23 Wed 21:41] =>  0:25
CLOCK: [2022-11-23 Wed 20:35]--[2022-11-23 Wed 21:00] =>  0:25
CLOCK: [2022-11-22 Tue 09:29]--[2022-11-22 Tue 09:54] =>  0:25
CLOCK: [2022-11-22 Tue 09:00]--[2022-11-22 Tue 09:25] =>  0:25
CLOCK: [2022-11-22 Tue 08:09]--[2022-11-22 Tue 08:34] =>  0:25
CLOCK: [2022-11-22 Tue 01:15]--[2022-11-22 Tue 01:27] =>  0:12
CLOCK: [2022-11-22 Tue 00:47]--[2022-11-22 Tue 01:12] =>  0:25
CLOCK: [2022-11-21 Mon 09:25]--[2022-11-21 Mon 09:50] =>  0:25
CLOCK: [2022-11-21 Mon 00:35]--[2022-11-21 Mon 01:00] =>  0:25
CLOCK: [2022-11-20 Sun 22:45]--[2022-11-20 Sun 23:10] =>  0:25
CLOCK: [2022-11-20 Sun 22:20]--[2022-11-20 Sun 22:45] =>  0:25
CLOCK: [2022-11-20 Sun 21:36]--[2022-11-20 Sun 22:01] =>  0:25
CLOCK: [2022-11-20 Sun 21:00]--[2022-11-20 Sun 21:25] =>  0:25
CLOCK: [2022-11-20 Sun 20:13]--[2022-11-20 Sun 20:39] =>  0:26
CLOCK: [2022-11-20 Sun 19:47]--[2022-11-20 Sun 20:12] =>  0:25
CLOCK: [2022-11-20 Sun 17:59]--[2022-11-20 Sun 18:24] =>  0:25
:END:
テスト駆動開発によるGo入門。動かしてわかりやすいだけでなく、後の学習に役に立ちそうな言葉も多い。

- 標準ライブラリを使ってみるときにテストで動作チェックしてみると、勉強になる

#+begin_quote
Go標準ライブラリは本当に良いです。時間をかけて勉強してください。
このようにio.Writerインターフェースにある程度慣れていることで、テストでbytes.Bufferを Writerとして使うことができ、標準ライブラリの他のWriterを使ってコマンドラインアプリやウェブサーバで関数を使うことができます。
標準ライブラリに慣れるほど、これらの汎用インターフェイスが表示され、独自のコードで再利用して、ソフトウェアをさまざまなコンテキストで再利用可能にすることができます。
#+end_quote

#+begin_quote
システムの実行にとって実装が本当に重要でない限り、テストが有用な動作をチェックするようにしてください。
#+end_quote

#+begin_quote
- リファクタリングの定義では、コードは変更されますが、動作は同じです。理論的にリファクタリングを行うことに決めた場合は、テストを変更せずにコミットを実行できるはずです。だからテストを書くときは自問してください

  - 必要な動作や実装の詳細をテストしていますか？
  - このコードをリファクタリングする場合、テストに多くの変更を加える必要がありますか？
- テストが3つ以上のモックで動作している場合、それは危険信号であるように感じます（デザインを再検討する時間）
#+end_quote

#+begin_quote
TDDアプローチの詳細
- ささいな例に直面した場合は、問題を「薄いスライス」に分解してください。ウサギの穴に入り込み、「ビッグバン」アプローチをとらないように、できるだけ早く_testsで動作するソフトウェアを使用できるようにしてください。
- 動作するソフトウェアを入手したら、必要なソフトウェアにたどり着くまで小さなステップで繰り返すのが簡単です。
#+end_quote
** DONE 実行結果をいい感じに保持するにはどうするか
CLOSED: [2023-02-18 Sat 17:05]
:LOGBOOK:
CLOCK: [2023-02-18 Sat 16:39]--[2023-02-18 Sat 17:04] =>  0:25
CLOCK: [2023-02-18 Sat 10:50]--[2023-02-18 Sat 11:15] =>  0:25
CLOCK: [2023-02-18 Sat 10:19]--[2023-02-18 Sat 10:44] =>  0:25
CLOCK: [2023-02-18 Sat 09:53]--[2023-02-18 Sat 10:18] =>  0:25
CLOCK: [2023-02-18 Sat 01:28]--[2023-02-18 Sat 01:53] =>  0:25
:END:

都度printするのではなく、貯めておいて、表示する箇所で整形して表示したい。表示部分と処理が分離される効果もある。何か公開されているツールを参考にすればできそう。

- 単純に1階層の結果であれば、構造体に入れて普通に返せばいい
- 複数階層であれば、工夫が必要そう

#+caption: docker build形式でもよさそう
#+begin_src
[python 2/4]RUN pip3 install
[build  2/13] COPY . .
#+end_src
** DONE [[https://qiita.com/tenntenn/items/ac5940dfbca703183fdf][Goのスコープについて考えてみよう #golang - Qiita]]
CLOSED: [2023-03-05 Sun 20:14]
:LOGBOOK:
CLOCK: [2023-03-05 Sun 19:04]--[2023-03-05 Sun 19:29] =>  0:25
CLOCK: [2023-03-05 Sun 18:18]--[2023-03-05 Sun 18:43] =>  0:25
CLOCK: [2023-03-05 Sun 17:26]--[2023-03-05 Sun 18:01] =>  0:35
CLOCK: [2023-03-05 Sun 16:50]--[2023-03-05 Sun 17:15] =>  0:25
CLOCK: [2023-03-05 Sun 16:15]--[2023-03-05 Sun 16:40] =>  0:25
CLOCK: [2023-03-05 Sun 15:49]--[2023-03-05 Sun 16:14] =>  0:25
CLOCK: [2023-03-05 Sun 15:24]--[2023-03-05 Sun 15:49] =>  0:25
:END:
スコープの解説。

スコープには4つの種類がある。

- ユニバース
- ファイル
- パッケージ
- ローカル

それぞれの種類のスコープでは以下のオブジェクトが定義できる。

|                             | ユニバース | ファイル | パッケージ | ローカル |
|-----------------------------+------------+----------+------------+----------|
| 組み込み関数(types.Builtin) | ✔          |          |            |          |
| nil(types.nil)              | ✔          |          |            |          |
| 定数(types.Const)           | ✔          |          | ✔          | ✔        |
| 型名(types.TypeName)        | ✔          |          | ✔          | ✔        |
| 関数(types.Func)            |            |          | ✔          |          |
| 変数(types.Var)             |            |          | ✔          | ✔        |
| パッケージ名(types.PkgName) |            | ✔        |            |          |
| ラベル(Label)               |            |          |            | ✔        |
** DONE [[https://qiita.com/tenntenn/items/e15cc0c54b3bbfddb04e][Goの比較可能性（comparable） - Qiita]]
CLOSED: [2023-03-12 Sun 23:26]
:LOGBOOK:
CLOCK: [2023-03-12 Sun 23:09]--[2023-03-12 Sun 23:26] =>  0:17
:END:

比較可能な型の説明。

- 比較可能
  - 真偽値
  - 整数値
  - 浮動小数点値
  - 複素数値
  - 文字列
  - ポインタ
  - チャネル
  - インタフェース
    - 動的型と動的値の2つから構成される
    - 動的型が ~%T~ verbで表示できる
  - 構造体(条件あり)
  - 配列(条件あり)
    - 構成するフィールドや要素に比較できない型がある場合は比較できない
- 比較可能の場合、 ~==~ 演算子、 ~!=~ 演算子で比較できる。
- 順序付け可能な場合はさらに ~<~ , ~<=~ , ~>~ , ~>=~ が使用できる

#+caption: falseになる。動的型はint型で同じだが、動的値が同じなため
#+begin_src go :imports "fmt"
var x, y any = 100, 200
fmt.Println(x == y)
#+end_src

#+RESULTS:
#+begin_results
false
#+end_results

#+caption: falseになる。動的型が違うので
#+begin_src go :imports "fmt"
var x, y any = int(100), int32(100)
fmt.Println(x == y)
#+end_src

#+RESULTS:
#+begin_results
false
#+end_results

まとめ。

- 動的型が違う場合は必ずfalse
- 動的型が同じでどちらかの動的型が比較不可能な場合はパニック
- 動的型が同じでcomparableでかつ動的値が同じ場合はtrue
- 動的型が同じでcomparableでかつ動的値が違う場合はfalse
** DONE ネストしたときのoavの挙動を確認する
CLOSED: [2023-03-15 Wed 21:08]
:LOGBOOK:
CLOCK: [2023-03-14 Tue 22:51]--[2023-03-14 Tue 23:16] =>  0:25
CLOCK: [2023-03-14 Tue 22:26]--[2023-03-14 Tue 22:51] =>  0:25
CLOCK: [2023-03-14 Tue 22:01]--[2023-03-14 Tue 22:26] =>  0:25
:END:

- [[https://github.com/kijimaD/oav][kijimaD/oav]]

検知してない疑惑。問題なかった。

- type: objectをつけてない項目があった
- その項目はarrayだけを子に持っていた。そのため、自身のtypeもarrayになっていた
- おそらく、子の項目で自身のtypeが決定する。ほとんどは複合型で、objectに自動で決定して問題ないが、今回のように問題があるケースがある
** DONE [[https://www.amazon.co.jp/Go%E3%81%AA%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E6%B8%8B%E5%B7%9D-%E3%82%88%E3%81%97%E3%81%8D/dp/4908686033/ref=sr_1_3?keywords=go+%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0&qid=1653145833&sprefix=go+%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%2Caps%2C206&sr=8-3][Goならわかるシステムプログラミング | 渋川 よしき, ごっちん |本 | 通販 - Amazon.co.jp]]
CLOSED: [2023-04-30 Sun 22:14]
:PROPERTIES:
:Effort:   30:00
:END:
:LOGBOOK:
CLOCK: [2024-03-14 Thu 23:00]--[2024-03-14 Thu 23:25] =>  0:25
CLOCK: [2023-04-30 Sun 21:46]--[2023-04-30 Sun 22:11] =>  0:25
CLOCK: [2023-04-30 Sun 20:05]--[2023-04-30 Sun 20:30] =>  0:25
CLOCK: [2023-04-30 Sun 19:38]--[2023-04-30 Sun 20:03] =>  0:25
CLOCK: [2023-04-30 Sun 19:09]--[2023-04-30 Sun 19:34] =>  0:25
CLOCK: [2023-04-30 Sun 18:35]--[2023-04-30 Sun 19:00] =>  0:25
CLOCK: [2023-04-30 Sun 17:29]--[2023-04-30 Sun 17:54] =>  0:25
CLOCK: [2023-04-30 Sun 12:01]--[2023-04-30 Sun 12:26] =>  0:25
CLOCK: [2023-04-30 Sun 11:33]--[2023-04-30 Sun 11:58] =>  0:25
CLOCK: [2023-04-30 Sun 10:54]--[2023-04-30 Sun 11:19] =>  0:25
CLOCK: [2023-04-30 Sun 10:29]--[2023-04-30 Sun 10:54] =>  0:25
CLOCK: [2023-04-29 Sat 22:37]--[2023-04-29 Sat 23:02] =>  0:25
CLOCK: [2023-04-29 Sat 22:11]--[2023-04-29 Sat 22:36] =>  0:25
CLOCK: [2023-04-29 Sat 21:13]--[2023-04-29 Sat 21:38] =>  0:25
CLOCK: [2023-04-29 Sat 20:36]--[2023-04-29 Sat 21:01] =>  0:25
CLOCK: [2023-04-29 Sat 20:09]--[2023-04-29 Sat 20:34] =>  0:25
CLOCK: [2023-04-29 Sat 18:37]--[2023-04-29 Sat 19:02] =>  0:25
CLOCK: [2023-04-29 Sat 18:09]--[2023-04-29 Sat 18:34] =>  0:25
CLOCK: [2023-04-29 Sat 17:27]--[2023-04-29 Sat 17:52] =>  0:25
CLOCK: [2023-04-29 Sat 16:42]--[2023-04-29 Sat 17:07] =>  0:25
CLOCK: [2023-04-29 Sat 00:26]--[2023-04-29 Sat 00:51] =>  0:25
CLOCK: [2023-04-26 Wed 20:26]--[2023-04-26 Wed 20:51] =>  0:25
CLOCK: [2023-04-25 Tue 00:34]--[2023-04-25 Tue 00:59] =>  0:25
CLOCK: [2023-04-24 Mon 00:11]--[2023-04-24 Mon 00:36] =>  0:25
CLOCK: [2023-04-23 Sun 23:26]--[2023-04-23 Sun 23:52] =>  0:26
CLOCK: [2023-04-23 Sun 17:37]--[2023-04-23 Sun 18:02] =>  0:25
CLOCK: [2023-04-23 Sun 17:12]--[2023-04-23 Sun 17:37] =>  0:25
CLOCK: [2023-04-23 Sun 16:42]--[2023-04-23 Sun 17:07] =>  0:25
CLOCK: [2023-04-23 Sun 16:16]--[2023-04-23 Sun 16:41] =>  0:25
CLOCK: [2023-04-23 Sun 15:37]--[2023-04-23 Sun 16:02] =>  0:25
CLOCK: [2023-04-23 Sun 15:07]--[2023-04-23 Sun 15:32] =>  0:25
CLOCK: [2023-04-23 Sun 14:30]--[2023-04-23 Sun 14:55] =>  0:25
CLOCK: [2023-04-23 Sun 13:55]--[2023-04-23 Sun 14:20] =>  0:25
CLOCK: [2023-04-23 Sun 12:47]--[2023-04-23 Sun 13:12] =>  0:25
CLOCK: [2023-04-23 Sun 12:22]--[2023-04-23 Sun 12:47] =>  0:25
CLOCK: [2023-04-22 Sat 23:32]--[2023-04-22 Sat 23:57] =>  0:25
CLOCK: [2023-04-22 Sat 23:04]--[2023-04-22 Sat 23:29] =>  0:25
CLOCK: [2023-04-22 Sat 22:37]--[2023-04-22 Sat 23:02] =>  0:25
CLOCK: [2023-04-22 Sat 20:52]--[2023-04-22 Sat 21:17] =>  0:25
CLOCK: [2023-04-05 Wed 00:40]--[2023-04-05 Wed 01:05] =>  0:25
CLOCK: [2023-03-29 Wed 22:15]--[2023-03-29 Wed 22:40] =>  0:25
CLOCK: [2022-09-09 Fri 12:43]--[2022-09-09 Fri 13:08] =>  0:25
CLOCK: [2022-09-09 Fri 12:03]--[2022-09-09 Fri 12:28] =>  0:25
CLOCK: [2022-09-04 Sun 19:07]--[2022-09-04 Sun 19:32] =>  0:25
CLOCK: [2022-09-04 Sun 10:24]--[2022-09-04 Sun 10:49] =>  0:25
CLOCK: [2022-09-04 Sun 09:53]--[2022-09-04 Sun 10:18] =>  0:25
CLOCK: [2022-08-25 Thu 12:17]--[2022-08-25 Thu 12:42] =>  0:25
CLOCK: [2022-08-23 Tue 10:55]--[2022-08-23 Tue 11:20] =>  0:25
CLOCK: [2022-08-22 Mon 09:00]--[2022-08-22 Mon 09:25] =>  0:25
CLOCK: [2022-08-22 Mon 08:35]--[2022-08-22 Mon 09:00] =>  0:25
CLOCK: [2022-08-22 Mon 08:10]--[2022-08-22 Mon 08:35] =>  0:25
:END:

途中まで読んだが、あまりおもしろくないので後回しにする。

システムプログラミングをGoで学ぶ本。

- まずデバッガ環境を整えることから
- ファイルディスクリプタに対応するものは、通常のファイルに限らない。標準入出力/ソケット/OS/CPUに内蔵されている乱数生成の仕組みなど、ファイルではないものにもファイルディスクリプタが割り当てられ、どれもファイルと同じようにアクセスできる
- OSは、プロセスが起動されるとまず3つの疑似ファイルを作成し、それぞれにファイルディスクリプタを割り当てる。0が標準入力、1が標準出力、2が標準エラー出力
- 可能な限りすべてのものがファイルとして抽象化されている
- go言語ではファイルディスクリプタのような共通化の仕組みを言語レベルで持ってOSによる差異を吸収している。io.Writer
- インターフェースは、構造体と違って何かしら実体を持つものを表すのではなく、「どんなことができるか」を宣言しているだけ
- リクエストではスロースタートによって、最適な速度を決定している。大きなファイル転送するときに徐々に速度が上がっていくのはこのためか
- Linuxのファイルの管理情報を格納している領域を、inodeという
- Linuxでファイルを読み書きする場合には、まずバッファにデータが格納される。すでにバッファに載っていて、そのファイルに対する書き込みが行われていないならバッファだけにしかアクセスしない
- .envファイルを利用するアイデアは、[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]での発明らしい
- OSが実行ファイルを読み込んで実行するには、そのためのリソースを用意しなければならない。そのようなリソースをまとめたプログラムの実行単位がプロセス
  - カーネルは新しいプロセスを作るたびに各プロセスでどういった入出力が行われるかの管理テーブルをつくる。そのインデックス値がファイルディスクリプタ
- プロセスを束ねたグループというものもある。プロセスグループ(別名ジョブ)。パイプを使うと同じプロセスグループになる
- シグナルはプロセスに対して送られる
- システムコール :: プロセス → OSカーネル
- シグナル :: OSカーネル → プロセス
- スレッドがCPUコアに対してマッピングされるのに対し、goroutineはOSのスレッドにマッピングされる
- goroutineはOSのスレッドと比較してタスク切り替えのコストが低い
  - スイッチには前の処理が使っていたレジスタの退避が必要になるが、退避が最小限が済むコード位置にスイッチのためのコードが埋め込める
  - 初期スタックメモリのサイズが小さい。メモリ確保は処理時間がかかるので、起動時間では小さいほうが有利
  - などによって、goroutineは起動時間、切り替え時間がOSのスレッドより1000倍のオーダーで高速
  - Goが提供する並行・並列処理の3要素
    - goroutine: 実行
    - チャネル・コミュニケーション
    - select: 調停
  - 並行・並列処理の実現手法
    - マルチプロセス
    - イベント駆動
    - マルチスレッド
    - ストリーミング・プロセッシング
  - スライスの裏には配列がある。実際には配列を参照するウィンドウ(対象の配列のスタート位置，終了位置、確保済みのサイズの3つの情報を持つ)で構成されている
  - バックエンドの配列に対し、使いやすいフロントエンドとして提供されているのがスライス
  - スライスの実態は3つの数値とポインタを持った24バイトのデータ
    - スライスの先頭の要素へのポインタ
    - スライスの長さ
    - スライスが確保している要素数
** DONE [[https://go.dev/ref/spec][The Go Programming Language Specification - The Go Programming Language]]
CLOSED: [2023-03-19 Sun 12:23]
:LOGBOOK:
CLOCK: [2023-03-19 Sun 12:08]--[2023-03-19 Sun 12:23] =>  0:15
CLOCK: [2023-03-19 Sun 00:32]--[2023-03-19 Sun 00:57] =>  0:25
CLOCK: [2023-03-18 Sat 23:26]--[2023-03-18 Sat 23:51] =>  0:25
CLOCK: [2023-03-18 Sat 22:59]--[2023-03-18 Sat 23:24] =>  0:25
CLOCK: [2023-03-18 Sat 22:25]--[2023-03-18 Sat 22:50] =>  0:25
CLOCK: [2023-03-18 Sat 17:01]--[2023-03-18 Sat 17:26] =>  0:25
CLOCK: [2023-03-18 Sat 16:25]--[2023-03-18 Sat 16:50] =>  0:25
CLOCK: [2023-03-18 Sat 14:40]--[2023-03-18 Sat 15:05] =>  0:25
CLOCK: [2023-03-18 Sat 13:32]--[2023-03-18 Sat 13:57] =>  0:25
CLOCK: [2023-03-18 Sat 13:03]--[2023-03-18 Sat 13:28] =>  0:25
CLOCK: [2023-03-18 Sat 11:37]--[2023-03-18 Sat 12:02] =>  0:25
CLOCK: [2023-03-18 Sat 11:03]--[2023-03-18 Sat 11:28] =>  0:25
CLOCK: [2023-03-18 Sat 10:34]--[2023-03-18 Sat 10:59] =>  0:25
CLOCK: [2023-03-17 Fri 23:09]--[2023-03-17 Fri 23:34] =>  0:25
CLOCK: [2023-03-17 Fri 21:22]--[2023-03-17 Fri 21:47] =>  0:25
CLOCK: [2023-03-14 Tue 00:36]--[2023-03-14 Tue 01:01] =>  0:25
CLOCK: [2023-03-13 Mon 23:12]--[2023-03-13 Mon 23:37] =>  0:25
CLOCK: [2023-03-13 Mon 22:34]--[2023-03-13 Mon 22:59] =>  0:25
CLOCK: [2023-03-13 Mon 21:58]--[2023-03-13 Mon 22:23] =>  0:25
CLOCK: [2023-03-13 Mon 21:17]--[2023-03-13 Mon 21:42] =>  0:25
:END:
言語の仕様書。

- リテラルってなんだ
  - [[https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB][リテラル - Wikipedia]]
  - ソースコード内に値を直接表記したもの
    - ~int x = 7;~ だと7
    - ~double pi = 3.14;~ だと3.14
    - ~string s = "hello";~ だと"hello"
  - トークンとは違うのかな。トークンは値だけでなく識別子や予約語も含む
  - [[https://e-words.jp/w/%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB.html][リテラル（直値）とは - 意味をわかりやすく - IT用語辞典 e-Words]]
  - リテラルとは、コンピュータプログラムのソースコードなどの中に、特定のデータ型の値を直に記載したもの。また、そのように値をコードに書き入れるために定められている書式。
- セレクタってなんだ
  - ~x.f~ は値 ~x~ のフィールド ~f~ 、またはメソッド ~f~ を示す
- 定義型(defined type)ってなんだ
  - 事前定義された型か、独自に定義された型
  - ~type S []int~ の ~S~
  - ~type T int~ の ~T~ と ~int~
  - defined typeでない型は複合型
- 型リテラルってなんだ
  - [[https://zenn.dev/syumai/articles/77bc12aca9b654][Goの型同一性を理解する]]
  - 他の型を利用して構成される型
  - ~var a [5]int~ における[5]int
  - ~type B int~ (Bは型名)
  - ~var b []B~ における[]B
  - リテラル中に他の型が使われない、func()や、struct{}といった型リテラルも存在する
  - 型リテラルを使って示される型は、型定義が行われていないためdefined typeではない
  - 型リテラルの種類
    - 要素型を持つ
      - 配列型
      - スライス型
      - マップ型
      - チャンネル型
    - キー型を持つ
      - マップ型
    - フィールド型を持つ
      - 構造体型
    - ベースの型を持つ
      - ポインタ型
    - 仮引数型、結果型を持つ
      - 関数型
  - 型リテラルによって示される型同士が同一かどうかを判定するには、型リテラルの構造が同一かつ、型リテラル中に現れる型が同一であることを確認する必要がある
  - 型リテラルごとに、同一性の条件がある
  - インターフェース型は任意の型を使って構成されるわけではない。インターフェース型はメソッドを持ち、それぞれのメソッドは関数型を持つ
- underlying type(基底型)ってなんだ
  - すべての型はunderlying typeを持つ
  - 事前に定義された型や、型リテラルによって示される型のunderlying typeはその型自身
    - ~int~ -> 基底型: int
    - ~string~ -> 基底型: string
    - ~[]int~ -> 基底型: []int
    - ~struct{}~ -> 基底型: struct{}
  - それ以外の型のunderlying typeは型宣言の対象によって決まる
  - 2つの型宣言
    - ~type A string~ -> 型宣言
      - ~type A string~ -> Aの基底型: string
      - ~type B A~ -> Bの基底型: string
      - ~type C []int~ -> Cの基底型: []int
    - ~type B = int~ -> エイリアス宣言
      - ~type A string~ -> defined type
      - ~type B = A~ -> Bの基底型: string
      - ~type C = []int~ -> Cの基底型: []int
  - 2つの型のいずれもdefined typeでない場合、それぞれの型のunderlying typeの型リテラルが構造的に等しい場合に同一となる
    - defined typeでない型とは、型リテラルと型エイリアス
    - 型リテラルのunderlying typeはその型リテラル自身
    - 型同一性においてunderlying typeの考慮が必要なのは型エイリアスのみ
    - ~type NamedMap = map[string][]int~
      - NamedMapの基底型はmap[string][]int
      - m1とm2はunderlying typeの型リテラルの構造が同一なので同一
      - ~var m1 map[string][]int~
      - ~var m2 NamedMap~
- 参考になる用語 [[https://zenn.dev/senk/articles/91fa080844bb12][[Go] 言語仕様書に出てくる型関連の用語まとめ]]
- [[https://zenn.dev/nobishii/articles/defined_types][Go言語のdefined typeとは何か]]
- 修飾識別子
  - パッケージ名をつけて修飾された識別子
  - PackageName "." identifier .
  - 修飾識別子は、インポートされなければならない
- runeの例で白鵬が出てきて笑う
  - https://github.com/golang/go/blob/20e9b7f1b53d49fd66e0344b1d0d42d3cf5e47b6/doc/go_spec.html#L5624
- 終端文
  - return, goto, panic...
- 式文(expression statements)
  - 関数呼び出しとメソッド呼び出しと受信演算は、文コンテキストに現れる。そのような文は、丸括弧で囲まれている必要がある
- アドレス演算子
- ポインター間接参照
- 誤字
  - 自薦宣言
  - 関数内え
  - キーを全く含まないは要素リスト
  - ある要素がキーをもつならば，すべて要素が
  - 関数はリテラルは
  - ようそが要素が
  - 定数インデック
  - インデックは
  - 次の関係を満足する
  - 連続した要素がその文字列のバイトたち
  - であるスライスを生成される
  - 結合性を上書して
  - fStmt =
  - 仕様できる
  - 文囲む親関数
  - じたがって
  - を満足する
  - を基準としたの
** DONE [[https://github.com/golang/go/blob/release-branch.go1.13/src/cmd/compile/README.md][go/README.md at release-branch.go1.13 · golang/go · GitHub]]
CLOSED: [2023-05-27 Sat 18:35]
:LOGBOOK:
CLOCK: [2023-05-27 Sat 17:55]--[2023-05-27 Sat 18:20] =>  0:25
:END:
Go コンパイラについての公式ドキュメント。
** DONE [[https://www.oreilly.co.jp/books/9784873117522/][O'Reilly Japan - Go言語によるWebアプリケーション開発]]
CLOSED: [2023-06-10 Sat 11:57]
:PROPERTIES:
:Effort:   20:00
:END:
:LOGBOOK:
CLOCK: [2023-05-25 Thu 23:33]--[2023-05-25 Thu 23:58] =>  0:25
CLOCK: [2023-05-25 Thu 23:02]--[2023-05-25 Thu 23:27] =>  0:25
CLOCK: [2023-05-25 Thu 21:55]--[2023-05-25 Thu 22:20] =>  0:25
CLOCK: [2023-05-24 Wed 23:31]--[2023-05-24 Wed 23:56] =>  0:25
CLOCK: [2023-05-24 Wed 23:06]--[2023-05-24 Wed 23:31] =>  0:25
CLOCK: [2023-05-24 Wed 00:31]--[2023-05-24 Wed 00:56] =>  0:25
CLOCK: [2023-05-21 Sun 21:36]--[2023-05-21 Sun 22:01] =>  0:25
CLOCK: [2023-05-21 Sun 21:10]--[2023-05-21 Sun 21:35] =>  0:25
CLOCK: [2023-05-21 Sun 19:23]--[2023-05-21 Sun 19:48] =>  0:25
CLOCK: [2023-05-21 Sun 18:05]--[2023-05-21 Sun 18:30] =>  0:25
CLOCK: [2023-05-21 Sun 17:35]--[2023-05-21 Sun 18:00] =>  0:25
CLOCK: [2023-05-21 Sun 16:48]--[2023-05-21 Sun 17:13] =>  0:25
CLOCK: [2023-05-21 Sun 16:18]--[2023-05-21 Sun 16:43] =>  0:25
CLOCK: [2023-05-21 Sun 12:42]--[2023-05-21 Sun 13:07] =>  0:25
CLOCK: [2023-05-21 Sun 12:08]--[2023-05-21 Sun 12:33] =>  0:25
CLOCK: [2023-05-21 Sun 11:32]--[2023-05-21 Sun 11:58] =>  0:26
CLOCK: [2023-05-21 Sun 11:00]--[2023-05-21 Sun 11:25] =>  0:25
CLOCK: [2023-05-21 Sun 09:43]--[2023-05-21 Sun 10:08] =>  0:25
CLOCK: [2023-05-21 Sun 09:12]--[2023-05-21 Sun 09:37] =>  0:25
CLOCK: [2023-05-21 Sun 08:45]--[2023-05-21 Sun 09:10] =>  0:25
CLOCK: [2023-05-21 Sun 00:17]--[2023-05-21 Sun 00:42] =>  0:25
CLOCK: [2023-05-20 Sat 21:35]--[2023-05-20 Sat 22:00] =>  0:25
CLOCK: [2023-05-20 Sat 20:45]--[2023-05-20 Sat 21:10] =>  0:25
CLOCK: [2023-05-20 Sat 19:59]--[2023-05-20 Sat 20:24] =>  0:25
CLOCK: [2023-05-20 Sat 19:33]--[2023-05-20 Sat 19:58] =>  0:25
CLOCK: [2023-05-20 Sat 18:40]--[2023-05-20 Sat 19:05] =>  0:25
CLOCK: [2023-05-20 Sat 18:11]--[2023-05-20 Sat 18:36] =>  0:25
CLOCK: [2023-05-20 Sat 15:02]--[2023-05-20 Sat 15:27] =>  0:25
CLOCK: [2023-05-20 Sat 14:34]--[2023-05-20 Sat 14:59] =>  0:25
CLOCK: [2023-05-20 Sat 13:36]--[2023-05-20 Sat 14:01] =>  0:25
CLOCK: [2023-05-20 Sat 13:09]--[2023-05-20 Sat 13:34] =>  0:25
CLOCK: [2023-05-20 Sat 12:21]--[2023-05-20 Sat 12:46] =>  0:25
CLOCK: [2023-05-20 Sat 11:55]--[2023-05-20 Sat 12:20] =>  0:25
CLOCK: [2023-05-20 Sat 11:15]--[2023-05-20 Sat 11:40] =>  0:25
CLOCK: [2023-05-20 Sat 10:43]--[2023-05-20 Sat 11:08] =>  0:25
CLOCK: [2023-05-20 Sat 01:46]--[2023-05-20 Sat 02:11] =>  0:25
CLOCK: [2023-05-20 Sat 01:13]--[2023-05-20 Sat 01:38] =>  0:25
CLOCK: [2023-05-19 Fri 00:37]--[2023-05-19 Fri 01:02] =>  0:25
CLOCK: [2023-05-19 Fri 00:04]--[2023-05-19 Fri 00:29] =>  0:25
CLOCK: [2023-05-18 Thu 23:39]--[2023-05-19 Fri 00:04] =>  0:25
CLOCK: [2023-05-18 Thu 23:13]--[2023-05-18 Thu 23:38] =>  0:25
:END:

いろんなWebアプリの紹介。

- sync.Once型を使うと関数が1回しか実行しないことを保証できる
- Newメソッド, Offメソッド, Tracerインターフェース

[[file:images/20230520-web.drawio.svg]]

#+begin_quote
呼び出される時点ではまだ利用できない値に依存しているということがわかりました。そこで、何らかの対策が必要になります。例えば、必要なフィールドを個別に引数として渡すという変更が考えられます。しかし、こうするとインタフェースが不安定なものになってしまいます。いずれかのAvatarの実装で新しい種類の情報が必要になるたびに、メソッドのシグネチャーを変更しなければならなくなるためです。代わりに、Avatarの実装が必要とする情報をカプセル化した新しい型を定義することにします。
#+end_quote

- メッセージが送信されるたびにアバター画像URLを生成するとスケールしない。アバターURLはクッキーの中にキャッシュすることにする
** DONE [[https://zenn.dev/hsaki/articles/go-convert-json-struct][Goにおけるjsonの扱い方を整理・考察してみた ~ データスキーマを添えて]]
CLOSED: [2023-06-23 Fri 23:28]
:LOGBOOK:
CLOCK: [2023-06-23 Fri 22:53]--[2023-06-23 Fri 23:18] =>  0:25
CLOCK: [2022-11-06 Sun 17:37]--[2022-11-06 Sun 18:02] =>  0:25
CLOCK: [2022-11-06 Sun 17:12]--[2022-11-06 Sun 17:37] =>  0:25
:END:
エンコードの解説。

- インメモリ表現
  - 何らかの構造を持つことを前提とした扱い方
    - リスト
    - 配列
    - 構造体
- バイト列表現
  - ただのバイト列として扱い。データそのものに何が書いてあるかを気にする必要がない
  - ファイルへの書き込み
  - ネットワークへの受信

エンコードはインメモリ表現からバイト列表現への変換のこと。

- Go構造体からjsonを生成する
- 平文から暗号文を生成する

デコーディングはバイト列表現からインメモリ表現への変換のこと。

- jsonからGo構造体を生成する
- 暗号文から平文を生成する

Unmarshalは、対応してないjsonのフィールドがあると取りこぼす。そしてゼロ値を入れる。この挙動を防ぎたいときは、Unmarshalで書き込む先の変数をinterface{}型にして入れ、それから型アサーションで確かめればよい。
** DONE [[https://techbookfest.org/product/vJdm4hcCDab9xE5Yjshyv8?productVariantID=6CzemppiY937uDD4bXT6nE][詳解Go標準パッケージ：web-apps.tech]]
CLOSED: [2023-06-24 Sat 14:36]
:PROPERTIES:
:Effort:   3:00
:END:
:LOGBOOK:
CLOCK: [2023-06-24 Sat 12:50]--[2023-06-24 Sat 13:15] =>  0:25
CLOCK: [2023-06-24 Sat 11:24]--[2023-06-24 Sat 11:49] =>  0:25
CLOCK: [2023-06-24 Sat 10:58]--[2023-06-24 Sat 11:23] =>  0:25
CLOCK: [2023-06-24 Sat 03:47]--[2023-06-24 Sat 04:12] =>  0:25
CLOCK: [2023-06-24 Sat 00:34]--[2023-06-24 Sat 00:59] =>  0:25
CLOCK: [2023-06-23 Fri 09:07]--[2023-06-23 Fri 09:32] =>  0:25
:END:
Goの標準パッケージを詳解する本。
** DONE [[https://techbookfest.org/product/5127270203129856?productVariantID=5036058678919168][Goでちょっとひといき：Women Who Go Tokyo]]
CLOSED: [2023-06-25 Sun 20:18]
:PROPERTIES:
:Effort:   10:00
:END:
:LOGBOOK:
CLOCK: [2023-06-25 Sun 19:42]--[2023-06-25 Sun 20:07] =>  0:25
CLOCK: [2023-06-25 Sun 18:56]--[2023-06-25 Sun 19:21] =>  0:25
CLOCK: [2023-06-25 Sun 18:31]--[2023-06-25 Sun 18:56] =>  0:25
CLOCK: [2023-06-25 Sun 18:06]--[2023-06-25 Sun 18:31] =>  0:25
CLOCK: [2023-06-25 Sun 15:09]--[2023-06-25 Sun 15:34] =>  0:25
CLOCK: [2023-06-25 Sun 14:44]--[2023-06-25 Sun 15:09] =>  0:25
CLOCK: [2023-06-25 Sun 14:17]--[2023-06-25 Sun 14:42] =>  0:25
CLOCK: [2023-06-25 Sun 13:42]--[2023-06-25 Sun 14:07] =>  0:25
CLOCK: [2023-06-25 Sun 12:59]--[2023-06-25 Sun 13:24] =>  0:25
CLOCK: [2023-06-25 Sun 11:16]--[2023-06-25 Sun 11:41] =>  0:25
CLOCK: [2023-06-25 Sun 10:48]--[2023-06-25 Sun 11:13] =>  0:25
CLOCK: [2023-06-24 Sat 23:32]--[2023-06-24 Sat 23:57] =>  0:25
CLOCK: [2023-06-24 Sat 22:57]--[2023-06-24 Sat 23:22] =>  0:25
CLOCK: [2023-06-24 Sat 22:17]--[2023-06-24 Sat 22:42] =>  0:25
CLOCK: [2023-06-24 Sat 21:46]--[2023-06-24 Sat 22:11] =>  0:25
CLOCK: [2023-06-24 Sat 20:41]--[2023-06-24 Sat 21:06] =>  0:25
CLOCK: [2023-06-24 Sat 19:52]--[2023-06-24 Sat 20:17] =>  0:25
CLOCK: [2023-06-24 Sat 19:22]--[2023-06-24 Sat 19:47] =>  0:25
CLOCK: [2023-06-24 Sat 18:50]--[2023-06-24 Sat 19:15] =>  0:25
CLOCK: [2023-06-24 Sat 16:16]--[2023-06-24 Sat 16:41] =>  0:25
CLOCK: [2023-06-24 Sat 15:51]--[2023-06-24 Sat 16:16] =>  0:25
:END:
Goの解説集。

#+caption: エントリポイントから呼ばれる
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/rt0_linux_amd64.s#L7-L8
#+end_src

#+RESULTS:
#+begin_results asm
TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB)
#+end_results

#+caption: ジャンプ先
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/asm_amd64.s#L15-L18
#+end_src

#+RESULTS:
#+begin_results asm
TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime rt0_go(SB)
#+end_results

#+caption: g0とはproc.goで定義されている変数のこと
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/proc.go#L115
#+end_src

#+RESULTS:
#+begin_results go
	g0           g
#+end_results

#+caption: g型の定義
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/runtime2.go#L414
#+end_src

#+RESULTS:
#+begin_results go
type g struct {
#+end_results

#+caption: どのプロセッサが使われているか確認する
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/asm_amd64.s#L183-L187
#+end_src

#+RESULTS:
#+begin_results asm
	CMPL	BX, $0x756E6547  // "Genu"
	JNE	notintel
	CMPL	DX, $0x49656E69  // "ineI"
	JNE	notintel
	CMPL	CX, $0x6C65746E  // "ntel"
#+end_results

- TLS :: Thread Local Storage
- runtimeまわりでは ~g~ はgoroutine、 ~m~ はワーカースレッドをさす

#+caption: 初期化する。CPU数、ページサイズをセットする
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/os_linux.go#L346-L368
#+end_src

#+RESULTS:
#+begin_results go
func osinit() {
	ncpu = getproccount()
	physHugePageSize = getHugePageSize()
	if iscgo {
		// #42494 glibc and musl reserve some signals for
		// internal use and require they not be blocked by
		// the rest of a normal C runtime. When the go runtime
		// blocks...unblocks signals, temporarily, the blocked
		// interval of time is generally very short. As such,
		// these expectations of *libc code are mostly met by
		// the combined go+cgo system of threads. However,
		// when go causes a thread to exit, via a return from
		// mstart(), the combined runtime can deadlock if
		// these signals are blocked. Thus, don't block these
		// signals when exiting threads.
		// - glibc: SIGCANCEL (32), SIGSETXID (33)
		// - musl: SIGTIMER (32), SIGCANCEL (33), SIGSYNCCALL (34)
		sigdelset(&sigsetAllExiting, 32)
		sigdelset(&sigsetAllExiting, 33)
		sigdelset(&sigsetAllExiting, 34)
	}
	osArchInit()
}
#+end_results

#+caption: スケジューラの初期化
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/proc.go#L694-L779
#+end_src

#+RESULTS:
#+begin_results go
func schedinit() {
	lockInit(&sched.lock, lockRankSched)
	lockInit(&sched.sysmonlock, lockRankSysmon)
	lockInit(&sched.deferlock, lockRankDefer)
(略)
#+end_results

#+caption: ここでmainパッケージのmain関数にリンクする
#+begin_src git-permalink
https://github.com/golang/go/blob/a031f4ef83edc132d5f49382bfef491161de2476/src/runtime/proc.go#L131-L132
#+end_src

- デバッガでステップインしたあとパブリックな関数を見つけて、それを呼び出すようにすると再度デバッガを実行するときに素早く目的の関数までたどり着きやすくなる。変数まわりを調べて同じ引数で渡せるようにする
** DONE gcloneをリファクタする
CLOSED: [2023-08-07 Mon 01:12]
:LOGBOOK:
CLOCK: [2023-08-06 Sun 21:39]--[2023-08-06 Sun 22:04] =>  0:25
CLOCK: [2023-08-06 Sun 21:13]--[2023-08-06 Sun 21:38] =>  0:25
CLOCK: [2023-08-06 Sun 20:41]--[2023-08-06 Sun 21:06] =>  0:25
CLOCK: [2023-08-06 Sun 20:15]--[2023-08-06 Sun 20:40] =>  0:25
CLOCK: [2023-08-06 Sun 19:50]--[2023-08-06 Sun 20:15] =>  0:25
:END:

Goを学んだ初期に書いた。わかりにくいコードになっているのを直す。
** DONE [[https://zenn.dev/hsaki/books/golang-httpserver-internal][Deep Dive into The Go's Web Server]]
CLOSED: [2023-11-19 Sun 15:35]
:LOGBOOK:
CLOCK: [2023-11-19 Sun 15:09]--[2023-11-19 Sun 15:34] =>  0:25
CLOCK: [2023-11-19 Sun 14:43]--[2023-11-19 Sun 15:08] =>  0:25
CLOCK: [2023-11-19 Sun 13:07]--[2023-11-19 Sun 13:32] =>  0:25
:END:
Goのサーバーの解説。

#+begin_src git-permalink
https://github.com/kd-collective/go/blob/2eca0b1e1663d826893b6b1fd8bd89da98e65d1e/src/net/http/server.go#L2503-L2515
#+end_src

#+RESULTS:
#+begin_results go
// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == "*" {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set("Connection", "close")
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r)
}
#+end_results
