:properties:
:ID: 20240214T224307
:end:
#+title:      KDOC 95: なぜjson.Unmarshalの引数はバイト列なのか
#+date:       [2024-02-14 Wed 22:43]
#+filetags:   :code:
#+identifier: 20240214T224307

* この文書のステータス
:LOGBOOK:
CLOCK: [2024-02-15 Thu 23:55]--[2024-02-16 Fri 00:20] =>  0:25
CLOCK: [2024-02-15 Thu 23:02]--[2024-02-15 Thu 23:27] =>  0:25
:END:
- 作成
  - [X] 2024-02-16 貴島
- レビュー
  - [X] 2024-02-25 貴島
* 概要
[[id:7cacbaa3-3995-41cf-8b72-58d6e07468b1][Go]]でJSONをデシリアライズするときに使う関数のシグネチャはこうだ。

#+caption: JSONを構造体とかに格納する関数
#+begin_src go
func Unmarshal(data []byte, v any) error {}
#+end_src

引数は[]byteで、バイトスライスだ。どうして文字列ではないのか、違いは何かを考えた。が、なぜそうなったのかは見つけられず、自分の持っている知識ではよくわからなかった。

* 違い

stringと[]byteの違いは何か。本質的にはどちらもバイト列だ。文字列はイミュータブルで、バイトスライスはミュータブルという点は違う。したがってデータが変わるときはバイトスライスのほうがコストを低くできる。文字列だとメモリをアローケーションして作り直すしかないから。文字列だと特定のケースで遅くなる可能性があるから、バイトスライスにしている、などどうだろう。

コンピュータ内部やネットワーク間ではバイト列で処理してるだろうから、[]byteのほうが低レイヤで汎用的ではある。標準ライブラリなどではバイト列を受け渡しする関数は多いので、互換性を保ちやすそうだ。また、Goは書く量がやや増えるのを許容して汎用性を求める、ようなデザインをしているように見えるので自然に見える。が、確かめる方法はわからない。

* Footnotes
[fn:1] 文字エンコードまわりの理解があやふやなので、この表現は正確さに欠けている可能性が高い。
