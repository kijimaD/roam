:properties:
:ID: 20251016T010331
:end:
#+title:      KDOC 474: 『Go言語による並行処理』
#+date:       [2025-10-16 Thu 01:03]
#+filetags:   :draft:book:
#+identifier: 20251016T010331

#+begin_comment
(kd/denote-kdoc-rename)
(kd/denote-format)

====ポリシー。
1ファイル1アイデア。
1ファイルで内容を完結させる。
常にほかのエントリとリンクする。
自分の言葉を使う。
参考文献を残しておく。
文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
ツェッテルカステンの議論に寄与するか。それで本を書けと言われて書けるか
頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。
個人の感想・意思表明ではない。事実や書籍情報に基づいている

====永久保存メモのルール。
自分の言葉で書く。
後から読み返して理解できる。
他のメモと関連付ける。
ひとつのメモにひとつのことだけを書く。
メモの内容は1枚で完結させる。
論文の中に組み込み、公表できるレベルである。

====水準を満たす価値があるか。
その情報がどういった文脈で使えるか。
どの程度重要な情報か。
そのページのどこが本当に必要な部分なのか。
公表できるレベルの洞察を得られるか

====フロー。
1. 「走り書きメモ」「文献メモ」を書く
2. 1日1回既存のメモを見て、自分自身の研究、思考、興味にどのように関係してくるかを見る
3. 追加すべきものだけ追加する

#+end_comment

* この文書のステータス
:LOGBOOK:
CLOCK: [2025-11-03 Mon 11:51]--[2025-11-03 Mon 12:16] =>  0:25
CLOCK: [2025-11-03 Mon 11:24]--[2025-11-03 Mon 11:49] =>  0:25
CLOCK: [2025-11-03 Mon 10:51]--[2025-11-03 Mon 11:16] =>  0:25
CLOCK: [2025-11-02 Sun 20:55]--[2025-11-02 Sun 21:20] =>  0:25
CLOCK: [2025-11-02 Sun 20:25]--[2025-11-02 Sun 20:50] =>  0:25
CLOCK: [2025-11-02 Sun 19:58]--[2025-11-02 Sun 20:23] =>  0:25
CLOCK: [2025-11-02 Sun 18:46]--[2025-11-02 Sun 19:11] =>  0:25
CLOCK: [2025-11-02 Sun 17:39]--[2025-11-02 Sun 18:04] =>  0:25
CLOCK: [2025-11-02 Sun 17:14]--[2025-11-02 Sun 17:39] =>  0:25
CLOCK: [2025-11-02 Sun 16:48]--[2025-11-02 Sun 17:13] =>  0:25
CLOCK: [2025-11-02 Sun 15:07]--[2025-11-02 Sun 15:32] =>  0:25
CLOCK: [2025-11-01 Sat 21:19]--[2025-11-01 Sat 21:44] =>  0:25
CLOCK: [2025-11-01 Sat 20:52]--[2025-11-01 Sat 21:17] =>  0:25
CLOCK: [2025-11-01 Sat 20:27]--[2025-11-01 Sat 20:52] =>  0:25
CLOCK: [2025-11-01 Sat 19:57]--[2025-11-01 Sat 20:22] =>  0:25
CLOCK: [2025-11-01 Sat 19:09]--[2025-11-01 Sat 19:34] =>  0:25
CLOCK: [2025-11-01 Sat 17:18]--[2025-11-01 Sat 17:43] =>  0:25
CLOCK: [2025-11-01 Sat 16:10]--[2025-11-01 Sat 16:35] =>  0:25
CLOCK: [2025-11-01 Sat 15:43]--[2025-11-01 Sat 16:08] =>  0:25
CLOCK: [2025-11-01 Sat 15:08]--[2025-11-01 Sat 15:33] =>  0:25
CLOCK: [2025-11-01 Sat 14:36]--[2025-11-01 Sat 15:01] =>  0:25
CLOCK: [2025-11-01 Sat 14:11]--[2025-11-01 Sat 14:36] =>  0:25
:END:
- 作成
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# チェックリスト ================
# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
# 本文(見出しも設定する)
『Go言語による並行処理』は、並行処理を解説する本である。

* メモ

- 並列性はランタイムの性質であって、コードの性質ではない(p24)
  - 並列で走ってほしいと考えて並行なコードを書いている
- コードの結果を別のコードに共有したい場合、これはデータの所有権を移動していることになる。並行プログラムを安全にするには、一度に1つの並行処理のコンテキストのみがデータの所有権を持つようにする(p33)
- 構造体の内部の状態を保護している場合はメモリアクセス同期を使うべきで、チャネルを使うべきではない(p34)
- メモリアクセスするべきか、チャネルを使うべきかの判断基準がある
- ゴルーチンは一時停止や再エントリーのポイントを定義していない。Goのランタイムはゴルーチンの実行時の振る舞いを観察して自動的に一時停止したり再開する(p38)
- Goがゴルーチンを管理する機構はM:Nスケジューラという実装になっている。M個のグリーンスレッドをN個のOSスレッドに対応させる。ゴルーチンはグリーンスレッドにスケジュールされる(p39)
- ゴルーチンは未来の任意のタイミングにスケジュールされる。ループ内でゴルーチンを発行していたら、順番に実行される保証はない
- WaitGroupの使い方。
  - Add カウンタを増やす -- 監視対象のゴルーチンの外で行う。いつゴルーチンが実行されるかはわからない。競合する可能性があるから
  - Done カウンタを減らす
  - Wait ゼロになるまでメインゴルーチンをブロック
- Sync, Cond, WaitGroup, Once, Pool
- オブジェクトプールデザインパターンはオブジェクトを要求するがインスタンス化のあとすぐにオブジェクトを捨てる並行処理のプロセスがある場合あるいはオブジェクトの生成がメモリに悪影響を与える場合に最適である(p64)
- 一方向チャネルを宣言するには ~<-~ 演算子を使う(p66)
  - 読み込み専用チャネル: chan<-
  - 書き込み専用チャネル: <-chan
- Goは双方向チャネルを必要に応じて暗黙的に一方向チャネルに変換してくれる(p66)
- チャネルをrange処理すると、チャネルが閉じたときに自動的にループを終了する(p69)
- チャネルを閉じるとチャネルの読み込みブロックが解除される。閉じたチャネルは無限に読み込める(p70)
- チャネルが満杯のときはチャネルへの書き込みによってブロックし、チャネルが空のときはチャネルからの読み込みによってブロックする(p71)
- nilチャネルの扱い。nilチャネルからの読み込み、書き込み、close。チャネルを扱うときは常に、確実に初期化する(p75)
- 読み込み
  - nil -> ブロック
  - Openで空ではない -> 値を取得
  - Openで空 -> ブロック
  - Closed -> デフォルト値、false
  - 書き込み専用 -> コンパイルエラー
- 書き込み
  - nil -> ブロック
  - Openで満杯 -> ブロック
  - Openで満杯ではない -> 値を書き込み
  - Closed -> panic
  - 読み込み専用 -> コンパイルエラー
- Close
  - nil -> panic
  - Openで空ではない -> チャネルを閉じる。読み込みはチャネルの中身がなくなるまで成功する。その後読み込みはデフォルト値を読み込む
  - Openで空 -> チャネルを閉じる。デフォルト値を読み込む
  - Closed -> panic
  - 読み込み専用 -> コンパイルエラー
- どのゴルーチンがチャネルを所有しているかはっきりさせることが重要である。所有しているゴルーチンにはチャネルに対する書き込み権限がある。利用しているだけのゴルーチンには読み込み専用権限しかない(p77)

selectでタイムアウトを実現する簡潔な方法。

#+caption: time.After は送信チャネルを返す
#+begin_src go
  package main

  import (
   	"time"
   	"fmt"
  )

  func main() {
  	var c <- chan int
  	select {
  	case <-c: // 決してブロックは解放されない
  	case <-time.After(1 * time.Second):
  		fmt.Println("Timed out.")
  	}
  }
#+end_src

#+RESULTS:
#+begin_src
Timed out.
#+end_src

- もしあるゴルーチンがゴルーチンの生成の責任を負っているのであれば、そのゴルーチンを停止できるようにする責任もある(p96)
- 外部から終了させるためのチャネルを返させるパターン
- チャネルの合成パターン(p98)
- パイプライン構築のベストプラクティス(p106)
- パイプライン全体を割り込み可能にする(p111)
- キューの真の実用性は、あるステージの実行時間が他のステージの実行時間に影響を与えないようにステージを分離することにある(p129)
- Contextパッケージの2つの目的(p135)
  - コールグラフの各枝をキャンセルするAPIを提供する
  - コールグラフを通じてリクエストに関するデータを渡すデータの置き場所を提供する
- Contextに保存するガイドライン(p147)
- エラーで表示する必要のあること(p150)
  - 何が起きたか
  - いつどこでエラーが発生したか
  - 1行程度のわかりやすいメッセージ
  - さらに情報を得るにはどうすればよいか(スタックトレースなど)
- エラーを包む必要があるのは自分のコードが有益なエラーコンテキストを追加しうるときだけである。たいていのコードでエラーを包む必要はない(p152)
- きちんとした形式のエラーが持つべき情報をすべて含む独自のエラー型を作る(p153)
- 並行処理のプロセスを設計するときには、タイムアウトとキャンセル処理を考慮する(p164)
- トークンバケットアルゴリズムによる流量制限(p180)
- 複数の流量制限ルール(時間、日、...)を適用する実装例(p187)
- ゴルーチンの健全性を監視する実装例(p192)
- 継続とは、プログラム中のある計算処理の途中からその処理を終わらせるまでに行われる処理のまとまりをさす。継続を関数に渡せるオブジェクトして扱えるプログラミング言語にはその性質を使って並行処理を実現しているものがある(p206)

感想。

- デススパイラルの話がよくわからない(p132)
- ハートビートの話がよくわからない(p171)
- 抽象パーツの分け方が参考になる。bridge, or, ...
- あまり並行処理コードを読むのに慣れていないが、ずっと読んでいると少し改善した
- ワークスティーリングの話が何を言っているのか全然わからない(p207)

* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# - この事実は自分のこのアイデアとどう整合するか。
# - この現象はあの理論でどう説明できるか。
# - ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# - いま聞いた内容は以前に聞いたことがなかったか。
# - メモ y についてメモ x はどういう意味か。
# - 対立する
# - 修正する
# - 補足する
# - 付け加えるもの
# - アイデア同士を組み合わせて新しいものを生み出せないか
# - どんな疑問が浮かんだか
なし。
