:PROPERTIES:
:ID:       2337587f-0d95-484f-922a-f4cca1ace49e
:header-args+: :wrap :results raw
:END:
#+title: Common Lisp
* 概要
Common Lispは[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]、[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]の方言の1つ。
Lispファミリーでは最もメジャー。
* Memo
* WIP [[https://www.oreilly.co.jp/books/9784873115870/][O'Reilly Japan - Land of Lisp]]                                    :Read:
:LOGBOOK:
CLOCK: [2022-02-18 Fri 23:28]--[2022-02-18 Fri 23:53] =>  0:25
CLOCK: [2022-02-18 Fri 22:53]--[2022-02-18 Fri 23:18] =>  0:25
CLOCK: [2022-02-17 Thu 10:28]--[2022-02-17 Thu 10:53] =>  0:25
CLOCK: [2022-02-17 Thu 09:27]--[2022-02-17 Thu 09:52] =>  0:25
CLOCK: [2022-02-17 Thu 09:53]--[2022-02-17 Thu 10:18] =>  0:25
:END:
- (全) 46, 48
** Progress
*** DONE 50
CLOSED: [2022-02-17 Thu 23:42] DEADLINE: <2022-02-17 Thu 23:59>
*** TODO 100
DEADLINE: <2022-02-18 Fri 23:59>
** 数あてゲーム
#+caption: defparameterはグローバル変数
#+begin_src lisp
  (defparameter *small* 1)
  *small*
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

#+caption: 元の値は上書きされる
#+begin_src lisp
  (defparameter *foo* 5)
  ,*foo*
  (defparameter *foo* 6)
  ,*foo*
#+end_src

#+RESULTS:
#+begin_results
6
#+end_results

#+caption: ashはバイナリサーチを書くのに使う
#+begin_src lisp
  (defun guess-my-number ()
    (ash (+ *small* *big*) -1))
#+end_src

#+RESULTS:
#+begin_results
GUESS-MY-NUMBER
#+end_results

#+caption: 実行してみる
#+begin_src lisp
  (guess-my-number)
#+end_src

#+RESULTS:
#+begin_results
50
#+end_results

#+caption: smallerとbigger関数の定義
#+begin_src lisp
  (defun smaller ()
    (setf *big* (1- (guess-my-number)))
    (guess-my-number))
  (defun bigger ()
    (setf *small* (1+ (guess-my-number)))
    (guess-my-number))
#+end_src

#+RESULTS:
#+begin_results
BIGGER
#+end_results

#+caption: 使ってみる
#+begin_src lisp
  (bigger)
#+end_src

#+RESULTS:
#+begin_results
75
#+end_results

#+caption: 初期化関数の定義
#+begin_src lisp
  (defun start-over ()
    (defparameter *small* 1)
    (defparameter *big* 100)
    (guess-my-number))
  (start-over)
#+end_src

#+RESULTS:
#+begin_results
50
#+end_results
** 基本関数
#+caption: 53の53乗
#+begin_src lisp
(expt 53 53)
#+end_src

#+RESULTS:
#+begin_results
24356848165022712132477606520104725518533453128685640844505130879576720609150223301256150373
#+end_results

#+caption: 除算関数は有理数を返す
#+begin_src lisp
(/ 4 6)
#+end_src

#+RESULTS:
#+begin_results
2/3
#+end_results

#+caption: 文字を表示するprinc
#+begin_src lisp
(princ "aaaa")
#+end_src

#+RESULTS:
#+begin_results
aaaa
#+end_results

Lispには、コードモードとデータモードがある。
通常はコードモード、シングルクォートがつくとデータモード。

#+caption: cadrで短くかける
#+begin_src lisp
  (car (cdr '(pork beef chicken)))
  (cadr '(pork beef chicken))
#+end_src
名前はリストにしたときの順番になっている。
つまり評価するときの意味としては逆になる。
cadrはcdr+carである。

andやorは真偽値演算だけでなく、条件判断としても使える。
#+caption: 条件を満たさないときは、以降は評価されない
#+begin_src lisp
  (and *file-modified* (ask-user-about-saving) (save-file))
#+end_src

member関数の返り値は部分リストになっている。もしマッチしたものを返すだったらnilを探すとき偽になってしまうから。
#+caption:
#+begin_src lisp
  (if (member nil '(3 4 nil 5))
      'nil-is-in-the-list
      'nil-is-not-in-the-list)
#+end_src

- シンボル同士は常に ~eq~ で比較する
- シンボル同士の比較でなければ ~equal~ で比較する
** ゲームエンジン
- ゲームに限らずほとんどの実用プログラムでは、出力される情報は単なるテキストよりもはるかに複雑な構造をとる。HTML, PDF, グラフィック
- 元となるデータ構造を出力形式に縛られない形で最初から持っておけば、プログラミング言語の得意な点を活かしたコーディングができる。[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]の場合操作がしやすいのはシンボルとリストだから、可能な限り、プログラムを設計する際にこれらのデータ型で処理できないかを考える

#+caption: 連想リストを使って景色を描写する
#+begin_src lisp
  (defparameter *nodes* '((living-room (you are in the living-room.
                                        a wizard is snoring loudly on the couch.))
                          (garden (your are in a beautiful garden.
                                   there is a well in front of you.))
                          (attic (you are in the attic.
                                  there is a giant welding torch in the corner.))))
#+end_src

#+RESULTS:
#+begin_results
*NODES*
#+end_results

#+caption: alistからキーを取り出す
#+begin_src lisp
  (assoc 'garden *nodes*)
#+end_src

#+RESULTS:
#+begin_results
(GARDEN (YOUR ARE IN A BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU.))
#+end_results

#+caption: 場所を描写する関数
#+begin_src lisp
  (defun describe-location (location nodes)
    (cadr (assoc location nodes)))
  (describe-location 'living-room *nodes*)
#+end_src

#+RESULTS:
#+begin_results
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH.)
#+end_results

通り道を描写する。
#+caption: ゲームのマップ上でプレーヤーが場所間を移動可能な通り道を格納する
#+begin_src lisp
  (defparameter *edges* '((living-room (garden west door)
                                       (attic upstairs ladder))
                          (garden (living-room east door))
                          (attic (living-room downstairs ladder))))
#+end_src

#+RESULTS:
#+begin_results
*EDGES*
#+end_results

テキストをシンボルのリストとして表現しておいたおかげで、準クォートを使って文を構築するコードを簡潔に書ける。

#+caption: 必要なエッジの名前からテキストによる説明を得る関数
#+begin_src lisp
  (defun describe-path (edge)
    `(there is a ,(caddr edge) going ,(cadr edge) from here.))
  (describe-path '(garden west door))
#+end_src

#+RESULTS:
#+begin_results
(THERE IS A DOOR GOING WEST FROM HERE.)
#+end_results

1つの場所からはいくつもの通り道が出ている可能性がある。
与えられた場所から出ているすべての*edges*データから探して描写する関数が必要。

#+caption: 描写する
#+begin_src lisp
  (defun describe-paths (location edges)
    (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))
  (describe-paths 'living-room *edges*)
#+end_src

#+RESULTS:
#+begin_results
(THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
 HERE.)
#+end_results

mapcarはよく使われる。引数に他の関数とリストを受け取って、リストの要素それぞれを引数として受け取った関数を呼び出す。
#+caption: sqrtは平方根を求める関数
#+begin_src lisp
(mapcar #'sqrt '(1 2 3 4))
#+end_src

#+RESULTS:
#+begin_results
(1 1.4142135 1.7320508 2)
#+end_results

#+caption: 2つのリストの最初を返す
#+begin_src lisp
  (mapcar #'car '((foo bar) (baz qux)))
#+end_src

#+RESULTS:
#+begin_results
(FOO BAZ)
#+end_results

#'はfunctionオペレータの略記。この記号を含む式は、内部的に変換される。
#+caption: ↑の関数の内部的な形
#+begin_src lisp
  (mapcar (function car) '((foo bar) (baz qux)))
#+end_src

#+RESULTS:
#+begin_results
(FOO BAZ)
#+end_results

Common Lispでは関数を値として扱うときにfunctionオペレータを使ってそのことを明示しなければならない。
関数と変数で名前が衝突した場合にエラーを起こす可能性があるから。

#+caption: 別々の名前空間。組み込みの関数carとローカル変数carは区別できる
#+begin_src lisp
  (let ((car "Honda Civic"))
    (mapcar #'car '((foo bar) (baz qux))))
#+end_src

#+RESULTS:
#+begin_results
(FOO BAZ)
#+end_results

[[id:53a7a781-8398-4069-8735-6ac5b8c3bc05][Scheme]]では、変数と関数と名前空間が共通なので関数を値として渡す場合にfunctionオペレータで明示する必要はない。

applyとappendでリストを合体する。
#+caption: apply
#+begin_src lisp
  (apply #'append '((mary had) (a) (little lamb)))
#+end_src

#+RESULTS:
#+begin_results
(MARY HAD A LITTLE LAMB)
#+end_results
* Tasks
** [[https://www.cs.cmu.edu/~dst/LispBook/book.pdf][COMMONLISP: A Gentle Introduction to Symbolic Computation]]
わかりやすい入門。
** TODO [[http://lyrical.bugyo.tk/][魔法言語 リリカル☆Lisp]]
nscripterと萌えキャラでLispが学べる…。
** [[https://lispcookbook.github.io/cl-cookbook/][Common Lisp Cookbook Home]]
** [[https://gigamonkeys.com/book/][Practical Common Lisp]]
** TODO 実用 Common Lisp
- [[https://www.amazon.co.jp/Common-Lisp-Architects%E2%80%99Archive-CLASSIC-MODER/dp/4798118907/][実用 Common Lisp (IT Architects’Archive CLASSIC MODER)]]
- [[https://github.com/norvig/paip-lisp][norvig/paip-lisp]] - サンプルスクリプト
** TODO Common Lisp Quick Reference
* Reference
** [[https://lisphub.jp/common-lisp/cookbook/index.cgi][逆引き Common Lisp クックブック:逆引きCommon Lisp]]
リファレンス。
* Archives
** DONE Road to Common Lisp
CLOSED: [2021-09-13 Mon 21:22]

Lispの学び方、おすすめ本の紹介。
- [[https://gist.github.com/y2q-actionman/49d7587912b2786eb68643afde6ca192][A Road to Common Lisp 翻訳]]
