:PROPERTIES:
:ID:       2337587f-0d95-484f-922a-f4cca1ace49e
:header-args+: :wrap :results raw
:END:
#+title: Common Lisp
* 概要
Common Lispは[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]、[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]の方言の1つ。
Lispファミリーでは最もメジャー。
* Memo
* WIP [[https://www.oreilly.co.jp/books/9784873115870/][O'Reilly Japan - Land of Lisp]]                                    :Read:
:LOGBOOK:
CLOCK: [2022-02-23 Wed 19:12]--[2022-02-23 Wed 19:37] =>  0:25
CLOCK: [2022-02-22 Tue 23:05]--[2022-02-22 Tue 23:30] =>  0:25
CLOCK: [2022-02-21 Mon 10:33]--[2022-02-21 Mon 10:59] =>  0:26
CLOCK: [2022-02-20 Sun 22:35]--[2022-02-20 Sun 23:00] =>  0:25
CLOCK: [2022-02-20 Sun 22:08]--[2022-02-20 Sun 22:33] =>  0:25
CLOCK: [2022-02-20 Sun 21:33]--[2022-02-20 Sun 21:58] =>  0:25
CLOCK: [2022-02-20 Sun 21:05]--[2022-02-20 Sun 21:31] =>  0:26
CLOCK: [2022-02-18 Fri 23:28]--[2022-02-18 Fri 23:53] =>  0:25
CLOCK: [2022-02-18 Fri 22:53]--[2022-02-18 Fri 23:18] =>  0:25
CLOCK: [2022-02-17 Thu 10:28]--[2022-02-17 Thu 10:53] =>  0:25
CLOCK: [2022-02-17 Thu 09:27]--[2022-02-17 Thu 09:52] =>  0:25
CLOCK: [2022-02-17 Thu 09:53]--[2022-02-17 Thu 10:18] =>  0:25
CLOCK: [2022-02-23 Wed 19:42]--[2022-02-23 Wed 20:07] =>  0:25
CLOCK: [2022-02-23 Wed 18:04]--[2022-02-23 Wed 18:29] =>  0:25
CLOCK: [2022-02-23 Wed 12:55]--[2022-02-23 Wed 13:20] =>  0:25
CLOCK: [2022-02-23 Wed 12:05]--[2022-02-23 Wed 12:30] =>  0:25
CLOCK: [2022-02-23 Wed 11:21]--[2022-02-23 Wed 11:46] =>  0:25
CLOCK: [2022-02-23 Wed 10:54]--[2022-02-23 Wed 11:19] =>  0:25
:END:
** _
- 46, 48, 96, 103, 106, 132
** Progress
*** DONE 50
CLOSED: [2022-02-17 Thu 23:42] DEADLINE: <2022-02-17 Thu 23:59>
*** DONE 100
CLOSED: [2022-02-22 Tue 23:25] DEADLINE: <2022-02-18 Fri 23:59>
*** TODO 150
DEADLINE: <2022-02-27 Sun 23:59>
** 数あてゲーム
#+caption: defparameterはグローバル変数
#+begin_src lisp
  (defparameter *small* 1)
  *small*
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

#+caption: 元の値は上書きされる
#+begin_src lisp
  (defparameter *foo* 5)
  ,*foo*
  (defparameter *foo* 6)
  ,*foo*
#+end_src

#+RESULTS:
#+begin_results
6
#+end_results

#+caption: ashはバイナリサーチを書くのに使う
#+begin_src lisp
  (defun guess-my-number ()
    (ash (+ *small* *big*) -1))
#+end_src

#+RESULTS:
#+begin_results
GUESS-MY-NUMBER
#+end_results

#+caption: 実行してみる
#+begin_src lisp
  (guess-my-number)
#+end_src

#+RESULTS:
#+begin_results
50
#+end_results

#+caption: smallerとbigger関数の定義
#+begin_src lisp
  (defun smaller ()
    (setf *big* (1- (guess-my-number)))
    (guess-my-number))
  (defun bigger ()
    (setf *small* (1+ (guess-my-number)))
    (guess-my-number))
#+end_src

#+RESULTS:
#+begin_results
BIGGER
#+end_results

#+caption: 使ってみる
#+begin_src lisp
  (bigger)
#+end_src

#+RESULTS:
#+begin_results
75
#+end_results

#+caption: 初期化関数の定義
#+begin_src lisp
  (defun start-over ()
    (defparameter *small* 1)
    (defparameter *big* 100)
    (guess-my-number))
  (start-over)
#+end_src

#+RESULTS:
#+begin_results
50
#+end_results
** 基本関数
#+caption: 53の53乗
#+begin_src lisp
(expt 53 53)
#+end_src

#+RESULTS:
#+begin_results
24356848165022712132477606520104725518533453128685640844505130879576720609150223301256150373
#+end_results

#+caption: 除算関数は有理数を返す
#+begin_src lisp
(/ 4 6)
#+end_src

#+RESULTS:
#+begin_results
2/3
#+end_results

#+caption: 文字を表示するprinc
#+begin_src lisp
(princ "aaaa")
#+end_src

#+RESULTS:
#+begin_results
aaaa
#+end_results

Lispには、コードモードとデータモードがある。
通常はコードモード、シングルクォートがつくとデータモード。

#+caption: cadrで短くかける
#+begin_src lisp
  (car (cdr '(pork beef chicken)))
  (cadr '(pork beef chicken))
#+end_src
名前はリストにしたときの順番になっている。
つまり評価するときの意味としては逆になる。
cadrはcdr+carである。

andやorは真偽値演算だけでなく、条件判断としても使える。
#+caption: 条件を満たさないときは、以降は評価されない
#+begin_src lisp
  (and *file-modified* (ask-user-about-saving) (save-file))
#+end_src

member関数の返り値は部分リストになっている。もしマッチしたものを返すだったらnilを探すとき偽になってしまうから。
#+caption:
#+begin_src lisp
  (if (member nil '(3 4 nil 5))
      'nil-is-in-the-list
      'nil-is-not-in-the-list)
#+end_src

- シンボル同士は常に ~eq~ で比較する
- シンボル同士の比較でなければ ~equal~ で比較する
** 描写する
- ゲームに限らずほとんどの実用プログラムでは、出力される情報は単なるテキストよりもはるかに複雑な構造をとる。HTML, PDF, グラフィック
- 元となるデータ構造を出力形式に縛られない形で最初から持っておけば、プログラミング言語の得意な点を活かしたコーディングができる。[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]の場合操作がしやすいのはシンボルとリストだから、可能な限り、プログラムを設計する際にこれらのデータ型で処理できないかを考える

#+caption: 連想リストを使って景色を描写する
#+begin_src lisp
  (defparameter *nodes* '((living-room (you are in the living-room.
                                        a wizard is snoring loudly on the couch.))
                          (garden (your are in a beautiful garden.
                                   there is a well in front of you.))
                          (attic (you are in the attic.
                                  there is a giant welding torch in the corner.))))
#+end_src

#+RESULTS:
#+begin_results
*NODES*
#+end_results

#+caption: alistからキーを取り出す
#+begin_src lisp
  (assoc 'garden *nodes*)
#+end_src

#+RESULTS:
#+begin_results
(GARDEN (YOUR ARE IN A BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU.))
#+end_results

#+caption: 場所を描写する関数
#+begin_src lisp
  (defun describe-location (location nodes)
    (cadr (assoc location nodes)))
  (describe-location 'living-room *nodes*)
#+end_src

#+RESULTS:
#+begin_results
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH.)
#+end_results

通り道を描写する。
#+caption: ゲームのマップ上でプレーヤーが場所間を移動可能な通り道を格納する
#+begin_src lisp
  (defparameter *edges* '((living-room (garden west door)
                                       (attic upstairs ladder))
                          (garden (living-room east door))
                          (attic (living-room downstairs ladder))))
#+end_src

#+RESULTS:
#+begin_results
*EDGES*
#+end_results

テキストをシンボルのリストとして表現しておいたおかげで、準クォートを使って文を構築するコードを簡潔に書ける。

#+caption: 必要なエッジの名前からテキストによる説明を得る関数
#+begin_src lisp
  (defun describe-path (edge)
    `(there is a ,(caddr edge) going ,(cadr edge) from here.))
  (describe-path '(garden west door))
#+end_src

#+RESULTS:
#+begin_results
(THERE IS A DOOR GOING WEST FROM HERE.)
#+end_results

1つの場所からはいくつもの通り道が出ている可能性がある。
与えられた場所から出ているすべての*edges*データから探して描写する関数が必要。

#+caption: 描写する
#+begin_src lisp
  (defun describe-paths (location edges)
    (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))
  (describe-paths 'living-room *edges*)
#+end_src

#+RESULTS:
#+begin_results
(THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
 HERE.)
#+end_results

mapcarはよく使われる。引数に他の関数とリストを受け取って、リストの要素それぞれを引数として受け取った関数を呼び出す。
#+caption: sqrtは平方根を求める関数
#+begin_src lisp
(mapcar #'sqrt '(1 2 3 4))
#+end_src

#+RESULTS:
#+begin_results
(1 1.4142135 1.7320508 2)
#+end_results

#+caption: 2つのリストの最初を返す
#+begin_src lisp
  (mapcar #'car '((foo bar) (baz qux)))
#+end_src

#+RESULTS:
#+begin_results
(FOO BAZ)
#+end_results

#'はfunctionオペレータの略記。この記号を含む式は、内部的に変換される。
#+caption: ↑の関数の内部的な形
#+begin_src lisp
  (mapcar (function car) '((foo bar) (baz qux)))
#+end_src

#+RESULTS:
#+begin_results
(FOO BAZ)
#+end_results

Common Lispでは関数を値として扱うときにfunctionオペレータを使ってそのことを明示しなければならない。
関数と変数で名前が衝突した場合にエラーを起こす可能性があるから。

#+caption: 別々の名前空間。組み込みの関数carとローカル変数carは区別できる。mapcarはそれぞれのapply結果のリストを返す
#+begin_src lisp
  (let ((car "Honda Civic"))
    (mapcar #'car '((foo bar) (baz qux))))
#+end_src

#+RESULTS:
#+begin_results
(FOO BAZ)
#+end_results

[[id:53a7a781-8398-4069-8735-6ac5b8c3bc05][Scheme]]では、変数と関数と名前空間が共通なので関数を値として渡す場合にfunctionオペレータで明示する必要はない。

#+caption: applyとappendでリストを合体する
#+begin_src lisp
  (apply #'append '((mary had) (a) (little lamb)))
#+end_src

#+RESULTS:
#+begin_results
(MARY HAD A LITTLE LAMB)
#+end_results

#+caption:
#+begin_src lisp
  (apply #'append '((THERE IS A DOOR GOING WEST FROM HERE.)
                    (THERE IS A LADDER GOING UPSTAIRS FROM HERE.)))
#+end_src

#+RESULTS:
#+begin_results
(THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
 HERE.)
#+end_results

** 目に見えるオブジェクトをリストする
ゲーム世界に存在するオブジェクトのリストを作る。

#+caption:
#+begin_src lisp
(defparameter *objects* '(whiskey bucket frog chain))
#+end_src

#+RESULTS:
#+begin_results
*OBJECTS*
#+end_results

オブジェクトとその場所をalistで表現する。
#+caption: alist
#+begin_src lisp
  (defparameter *object-locations* '((whiskey living-room)
                                     (bucket living-room)
                                     (chain garden)
                                     (frog garden)))
  *object-locations*
#+end_src

#+RESULTS:
#+begin_results
((WHISKEY LIVING-ROOM) (BUCKET LIVING-ROOM) (CHAIN GARDEN) (FROG GARDEN))
#+end_results

与えられた場所から見るオブジェクトのリスト。
#+caption: labelsでローカル関数が定義できる
#+begin_src lisp
  (defun objects-at (loc objs obj-locs)
    (labels ((at-loc-p (obj)
               (eq (cadr (assoc obj obj-locs)) loc)))
      (remove-if-not #'at-loc-p objs)))
#+end_src

#+RESULTS:
#+begin_results
OBJECTS-AT
#+end_results

objects-atを使ってみる。

#+caption: living-roomにあるobjectを描写する
#+begin_src lisp
(objects-at 'living-room *objects* *object-locations*)
#+end_src

#+RESULTS:
#+begin_results
(WHISKEY BUCKET)
#+end_results

ある場所で見えるオブジェクトの一覧。

#+caption: オブジェクト一覧
#+begin_src lisp
  (defun describe-objects (loc objs obj-loc)
    (labels ((describe-obj (obj)
               `(you see a ,obj on the floor.)))
      (apply #'append (mapcar #'describe-obj (objects-at loc objs obj-loc)))))
#+end_src

#+RESULTS:
#+begin_results
DESCRIBE-OBJECTS
#+end_results

使ってみる。

#+caption:
#+begin_src lisp
  (describe-objects 'living-room *objects* *object-locations*)
#+end_src

#+RESULTS:
#+begin_results
(YOU SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
#+end_results

** 現在地を保持する
現在値を保持する変数を作る。

#+caption: 現在地を保持する
#+begin_src lisp
  (defparameter *location* 'living-room)
  *location*
#+end_src

#+RESULTS:
#+begin_results
LIVING-ROOM
#+end_results

プレイヤーがタイプするlook関数を作る。見えるものすべてを描写する。

#+caption: 見えるものすべてを描写する
#+begin_src lisp
  (defun look ()
  (append (describe-location *location* *nodes*)
        (describe-paths *location* *edges*)
        (describe-objects *location* *objects* *object-locations*)))
  (look)
#+end_src

#+RESULTS:
#+begin_results
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
 A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
 SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
#+end_results

look関数はグローバル変数を読むから、関数的ではない。
** 動き回る
#+caption: 歩き回るwalk関数。find関数はリストから与えた要素を探す関数
#+begin_src lisp
  (defun walk (direction)
    (let ((next (find direction
                      (cdr (assoc *location* *edges*))
                      :key #'cadr)))
      (if next
          (progn (setf *location* (car next))
                 (look))
          '(you cannot go that way.))))
#+end_src

#+RESULTS:
#+begin_results
WALK
#+end_results

#+caption: findの例: シンボルyをcadrに持つような最初の要素をリストから探し出す
#+begin_src lisp
  (find 'y '((5 x) (3 y) (7 z)) :key #'cadr)
#+end_src

#+RESULTS:
#+begin_results
(3 Y)
#+end_results

#+caption: findの例2: シンボルyをcarに持つような最初の要素をリストから探し出す
#+begin_src lisp
  (find '3 '((5 x) (3 y) (7 z)) :key #'car)
#+end_src

#+RESULTS:
#+begin_results
(3 Y)
#+end_results

:key #'carはキーワード引数。
コロンで始まる名前、続く値で構成されている。

#+caption: walkを使ってみる
#+begin_src lisp
(walk 'west)
#+end_src

#+RESULTS:
#+begin_results
(YOUR ARE IN A BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU. THERE IS A
 DOOR GOING EAST FROM HERE. YOU SEE A FROG ON THE FLOOR. YOU SEE A CHAIN ON THE
 FLOOR.)
#+end_results

** オブジェクトを手に取る
pushとassocを使うことで、alistの値が変更されたかのように見せることができる。

#+caption: オブジェクトの場所を管理している変数 *object-locations*を変更する
#+begin_src lisp
  (defun pickup (object)
    (cond ((member object
                   (objects-at *location* *objects* *object-locations*))
           (push (list object 'body) *object-locations*)
           `(you are now carrying the ,object))
          (t '(you cannot get that.))))
#+end_src

#+RESULTS:
#+begin_results
PICKUP
#+end_results

#+caption: リビングに戻る
#+begin_src lisp
(walk 'east)
#+end_src

#+RESULTS:
#+begin_results
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
 A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
 SEE A WHISKEY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
#+end_results

#+caption: ウィスキーを取る
#+begin_src lisp
  (pickup 'whiskey)
#+end_src

#+RESULTS:
#+begin_results
(YOU CANNOT GET THAT.)
#+end_results

alist中の値を置き換えたければ、新しい要素をリストにpushするだけでいい。
assocは最も新しい値だけを返すから。

#+caption: 持っているものを調べる
#+begin_src lisp
  (defun inventory ()
      (cons 'items- (objects-at 'body *objects* *object-locations*)))
  (inventory)
#+end_src

#+RESULTS:
#+begin_results
(ITEMS-)
#+end_results

#+caption: pushは先頭に新しいリストを追加する
#+begin_src lisp
  (defparameter *foo* '(1 2 3))
  (push 7 *foo*)
#+end_src

#+RESULTS:
#+begin_results
(7 1 2 3)
#+end_results

#+caption: ↑と同じことをsetfで表現する
#+begin_src lisp
(setf *foo* (cons 7 '(1 2 3)))
#+end_src

#+RESULTS:
#+begin_results
(7 1 2 3)
#+end_results

動作を試す。
居間に戻ってウィスキーを取る。

#+caption: 歩く
#+begin_src lisp
(walk 'east)
#+end_src

#+RESULTS:
#+begin_results
(YOU CANNOT GO THAT WAY.)
#+end_results

#+caption: ウィスキーを取る
#+begin_src lisp
(pickup 'whiskey)
#+end_src

#+RESULTS:
#+begin_results
(YOU ARE NOW CARRYING THE WHISKEY)
#+end_results

** テキストの表示と読み込み
#+caption: 表示する
#+begin_src lisp
(print "foo")
#+end_src

#+RESULTS:
#+begin_results
foo
#+end_results

#+caption: printは改行する
#+begin_src lisp :results output
  (progn (print "this")
         (print "is")
         (print "a")
         (print "test"))
#+end_src

#+RESULTS:
#+begin_results

"this"
"is"
"a"
"test"
#+end_results

#+caption: prin1は改行しない
#+begin_src lisp :results output
  (progn (prin1 "this")
         (prin1 "is")
         (prin1 "a")
         (prin1 "test"))
#+end_src

#+RESULTS:
#+begin_results
this""is""a""test
#+end_results

prin1の方がやってることは少ないので、より基本的な関数であると言える。組み合わせの自由度も高く、したがって大規模なコードの中でよく見られる。

入力させて挨拶を返す関数。
#+caption: プロンプトから呼び出して、入力を待つ。入力はダブルクォートで囲む必要がある
#+begin_src lisp
  (defun say-hello ()
    (print "Please type your name:")
    (let ((name (read)))
      (print "Nice to meet you, ")
      (print name)))
#+end_src

printはコンピュータ向け、princは人間向け。
printは元のデータを表示する。printcは文字列にして表示する。

ダブルクォートをつけなくていい改良版。

#+caption: princ, read-lineを使う
#+begin_src lisp
  (defun say-hello()
    (princ "Please type your name:")
    (let ((name (read-line)))
      (princ "Nice to meet you, ")
      (princ name)))
#+end_src

#+RESULTS:
#+begin_results
SAY-HELLO
#+end_results

** データの対称性
プログラムコードとデータを同じデータ構造を使って扱うプログラミング言語は、同図象性を持つ、と呼ばれる。

- '(+ 1 2) → データモード
- (+ 1 2) → コードモード

evalは強力で、自己書き換えのプログラムを書くには役立つ。が、普段はほとんど使わない。

** 専用のインターフェースを追加する
専用のREPLを作るのは簡単にできる。
#+caption:
#+begin_src lisp
  (defun game-repl ()
    (loop (print (eval (read)))))
  (game-repl)
#+end_src

REPLでの実行。

#+begin_src lisp
CL-USER> (look)
(YOU ARE IN THE LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
 A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
 SEE A BUCKET ON THE FLOOR.)
#+end_src

quit呼び出しを検知して、replを抜けられるようにする。

#+caption: ローカル変数cmdにコマンドを保存しておいて、判断する
#+begin_src lisp
  (defun game-repl ()
    (let ((cmd (game-read)))
      (unless (eq (car cmd) 'quit)
        (game-print (game-eval cmd))
        (game-repl))))
#+end_src

#+RESULTS:
#+begin_results
GAME-REPL
#+end_results

カッコをつけなくてもコマンド入力できるようにする。
walk east とタイプしたなら、(walk east) になる。
#+caption: カッコを付け足して評価する
#+begin_src lisp
  (defun game-read ()
    (let ((cmd (read-from-string
                (concatenate 'string "(" (read-line) ")"))))
      (flet ((quote-it (x)
               (list 'quote x)))
        (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))
#+end_src

#+RESULTS:
#+begin_results
GAME-READ
#+end_results

game-evalではあらかじめ決めたコマンドだけを呼べるようにする。
#+caption: 変数に入れておいたコマンドだけ実行できる
#+begin_src lisp
  (defparameter *allowed-commands* '(look walk pickup inventory))

  (defun game-eval (sexp)
    (if (member (car sexp) *allowed-commands*)
        (eval sexp)
        '(i do not know that command.)))
#+end_src

#+RESULTS:
#+begin_results
GAME-EVAL
#+end_results

テキストをいい感じに変換する関数が必要。
#+caption: 内部表現にすぎないシンボルのリストを文字列に変換する。coerce関数を使って文字列を文字のリストに変換することで、解くべき問題をリスト処理へと落とし込んでいる
#+begin_src lisp
  (defun tweak-text (lst caps lit)
    (when lst
      (let ((item (car lst))
            (rest (cdr lst)))
        (cond ((eql item #\space) (cons item (tweak-text rest caps lit)))
              ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit))) ;; 文章の先頭は、!,?,.,のあとに現れる
              ((eql item #\") (tweak-text rest caps (not lit)))
              (lit (cons  item (tweak-text rest nil lit)))
              (caps (cons (char-upcase item) (tweak-text rest nil lit)))
              (t (cons (char-downcase item) (tweak-text rest nil nil))))))) ;; どの条件も満たさなければ、小文字になる

  (defun game-print (lst)
    (princ (coerce (tweak-text (coerce (string-trim "() "
                                                    (prin1-to-string lst))
                                       'list)
                               t
                               nil)
                   'string)
           (fresh-line)))
#+end_src

#+RESULTS:
#+begin_results
GAME-PRINT
#+end_results

途中で大文字が出てくる場合に対応している。
#+caption: "がでてきた場合は無視して、残りの処理を続行する
#+begin_src lisp
(game-print '(not only does this sentence have a "comma," it also mentions the "iPad."))
#+end_src

#+RESULTS:
#+begin_results
Not only does this sentence have a comma, it also mentions the iPad.
#+end_results

** Lambda
そもそもLispが産まれたのは、lambdaコマンドのためだった。

lambdaを使えば、名前を与えずに関数を作れる。

#+caption: 関数引数に渡すことができる
#+begin_src lisp
  (mapcar (lambda (n) (/ n 2)) '(2 4 6))
#+end_src

#+RESULTS:
#+begin_results
(1 2 3)
#+end_results

#+caption: 関数引数に渡すことができる
#+begin_src lisp
  (funcall (lambda (n) (/ n 2)) 2)
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

lambdaの引数は評価されずlambdaに渡される。つまり、lambdaは本物の関数ではない。これはマクロとよばれる。[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]の関数の引数は、関数自体が評価される前にすべて評価される。
lambdaが返す値は通常のLisp関数である。
多くの言語では、関数と値の世界を分けようとしている。Lispでは、この2つの世界をつなぐことができる。

関数を普通のデータのように受け渡しできるという機能は、とても便利である。純粋に数学的な意味では、lambdaが唯一のLispコマンドといえる。(ラムダ算法…lambdaを唯一のコマンドする理論的なプログラミング言語のようなもの。)

- lambda形式はLispシステムの中で最も根源的なコマンドである
- Lispの他の関数はlambdaの概念を元に導かれている
- lambdaはLispのアイディアそのものが産まれた中心にある概念
** 奇妙なリスト
#+caption: 通常のリスト
#+begin_src lisp
(cons 1 (cons 2 (cons 3 nil)))
#+end_src

#+RESULTS:
#+begin_results
(1 2 3)
#+end_results

#+caption: リストの最後のnilが見つからなかったとき、3の前に . をつけて表示する
#+begin_src lisp
(cons 1 (cons 2 3))
#+end_src

#+RESULTS:
#+begin_results
(1 2 . 3)
#+end_results

最後がnilではないことを明示するために.をつけている。
ドットリストは、対を表現するのによく使う。

リストの最後がリストの最初を指すような、循環しているリストもある。
遊ぶ前に準備する。
#+caption: ループで止まるのを防ぐ設定
#+begin_src lisp
(setf *print-circle* t)
#+end_src

#+RESULTS:
#+begin_results
T
#+end_results

#+caption: 循環リストを作る
#+begin_src lisp
  (defparameter foo (list 1 2 3))
  (setf (cdddr foo) foo)
#+end_src

#+RESULTS:
#+begin_results
#1=(1 2 3 . #1#)
#+end_results
** 連想リスト
コンスセルから作られるデータ構造の中でも特に便利なのは、連想リスト。
#+caption: 連想リストと、assocによるアクセス
#+begin_src lisp
  (defparameter *drink-order* '((bill . double-espresso)
                                (lisa . small-drip-coffee)
                                (john . medium-latter)))
  (assoc 'lisa *drink-order*)
#+end_src

#+RESULTS:
#+begin_results
(LISA . SMALL-DRIP-COFFEE)
#+end_results

追加。
#+caption: 追加。lisaが2つあることがわかる
#+begin_src lisp
(push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
#+end_src

#+RESULTS:
#+begin_results
((LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM) (BILL . DOUBLE-ESPRESSO)
 (LISA . SMALL-DRIP-COFFEE) (JOHN . MEDIUM-LATTER))
#+end_results

#+caption: assocで優先されるのは先にあるほうだから、新しい値に入れ替わったことになる
#+begin_src lisp
(assoc 'lisa *drink-order*)
#+end_src

#+RESULTS:
#+begin_results
(LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
#+end_results

そのため、データの変更履歴をたどることも可能。
** ノードの変換
グラフ構造を視覚的に表現するために、graphvizを使う。
フォーマットを出力するための関数を書く。

#+caption: DOTフォーマットが受け付けない文字(アルファベットでも数字でもない)をすべてアンダースコアに変更する
#+begin_src lisp
  (defun dot-name (exp)
      (substitute-if #\_ (complement #'alphanumericp) (prin1-to-string exp)))
  (dot-name 'foo!)
#+end_src

#+RESULTS:
#+begin_results
FOO_
#+end_results

substitute-ifは、与えられたテスト関数の結果によって値を置き換える関数。
#+caption: 数字をeに変換する
#+begin_src lisp
(substitute-if #\e #'digit-char-p "I'm a l33t hack3r!")
#+end_src

#+RESULTS:
#+begin_results
I'm a leet hacker!
#+end_results

substitute-ifは、リストも処理できる。
#+caption: 奇数を0に置き換える
#+begin_src lisp
(substitute-if 0 #'oddp '(1 2 3 4 5 6 7 8 9))
#+end_src

#+RESULTS:
#+begin_results
(0 2 0 4 0 6 0 8 0)
#+end_results

グラフのノードにラベルをつける。
#+caption: write-to-string のキーワード引数prettyは、人間用に改行などを整形してくれるのをオフにするため
#+begin_src lisp
  (defparameter *max-label-length* 30)

  (defun dot-label (exp)
    (if exp
        (let ((s (write-to-string exp :pretty nil)))
          (if (> (length s) *max-label-length*)
              (concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
              s))
        ""))
#+end_src

#+RESULTS:
#+begin_results
DOT-LABEL
#+end_results

ノードのalistを取ってその情報をDOTの形で生成する関数を書く。
#+caption: mapcはmapcarの変種で、結果のリストを返さない。ここではREPLで出力される情報だけが重要(副作用だけを使う)なため
#+begin_src lisp
  (defun nodes->dot (nodes)
    (mapc (lambda (node)
            (fresh-line)
            (princ (dot-name (car node)))
            (princ "[label=\"")
            (princ (dot-label node))
            (princ "\"];"))
          nodes))
#+end_src

#+RESULTS:
#+begin_results
NODES->DOT
#+end_results

#+caption: 変換したいalistを再定義しておく
#+begin_src lisp
  (defparameter *wizard-edges* '((living-room (garden west door)
                           (attic upstairs ladder))
                          (garden (living-room east door))
                          (attic (living-room downstairs ladder))))

  (defparameter *wizard-nodes* '((living-room (you are in the living-room.
                                        a wizard is snoring loudly on the couch.))
                          (garden (your are in a beautiful garden.
                                   there is a well in front of you.))
                          (attic (you are in the attic.
                                  there is a giant welding torch in the corner.))))
#+end_src

#+RESULTS:
#+begin_results
*WIZARD-NODES*
#+end_results

#+caption:
#+begin_src lisp :results output
  (nodes->dot *wizard-nodes*)
#+end_src

#+RESULTS:
#+begin_results
LIVING_ROOM[label="(LIVING-ROOM (YOU ARE IN TH..."];
GARDEN[label="(GARDEN (YOUR ARE IN A BEAU..."];
ATTIC[label="(ATTIC (YOU ARE IN THE ATTI..."];
#+end_results

次は、エッジをDOTの情報として書き出す。
#+caption:
#+begin_src lisp
  (defun edges->dot (edges)
    (mapc (lambda (node)
            (mapc (lambda (edge)
                    (fresh-line)
                    (princ (dot-name (car node)))
                    (princ "->")
                    (princ (dot-name (car edge)))
                    (princ "[label=\"")
                    (princ (dot-label (cdr edge)))
                    (princ "\"];"))
                  (cdr node)))
          edges))
#+end_src

#+RESULTS:
#+begin_results
EDGES->DOT
#+end_results

* DONE [[https://www.amazon.co.jp/%E5%88%9D%E3%82%81%E3%81%A6%E3%81%AE%E4%BA%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AELISP-%E5%A2%97%E8%A3%9C%E6%94%B9%E8%A8%82%E7%89%88-%E7%AB%B9%E5%86%85-%E9%83%81%E9%9B%84/dp/4798119415/ref=pd_vtp_3/356-6212978-4622712][初めての人のためのLISP]]                                          :Read:
CLOSED: [2022-03-03 Thu 12:17] DEADLINE: <2022-02-25 Fri>
:LOGBOOK:
CLOCK: [2022-03-03 Thu 11:31]--[2022-03-03 Thu 11:56] =>  0:25
CLOCK: [2022-03-02 Wed 22:59]--[2022-03-02 Wed 23:24] =>  0:25
CLOCK: [2022-03-02 Wed 21:50]--[2022-03-02 Wed 22:15] =>  0:25
CLOCK: [2022-03-01 Tue 10:19]--[2022-03-01 Tue 10:44] =>  0:25
CLOCK: [2022-02-27 Sun 17:54]--[2022-02-27 Sun 18:19] =>  0:25
CLOCK: [2022-02-27 Sun 14:44]--[2022-02-27 Sun 15:09] =>  0:25
CLOCK: [2022-02-27 Sun 13:40]--[2022-02-27 Sun 14:05] =>  0:25
CLOCK: [2022-02-27 Sun 12:44]--[2022-02-27 Sun 13:09] =>  0:25
CLOCK: [2022-02-19 Sat 20:00]--[2022-02-19 Sat 20:25] =>  0:25
CLOCK: [2022-02-18 Fri 22:02]--[2022-02-18 Fri 22:27] =>  0:25
CLOCK: [2022-02-18 Fri 21:36]--[2022-02-18 Fri 22:01] =>  0:25
CLOCK: [2022-02-18 Fri 00:09]--[2022-02-18 Fri 00:34] =>  0:25
CLOCK: [2021-12-13 Mon 22:58]--[2021-12-13 Mon 23:07] =>  0:09
CLOCK: [2021-12-13 Mon 09:15]--[2021-12-13 Mon 09:55] =>  0:40
CLOCK: [2021-12-13 Mon 00:03]--[2021-12-13 Mon 00:54] =>  0:51
:END:
** _
Lispの考え方に焦点を当てた入門本。
解説で使われているのは[[id:2337587f-0d95-484f-922a-f4cca1ace49e][Common Lisp]]。

- 128, 162, 175, 191, 201, 210, 220, 304
** Progress
*** DONE 200
CLOSED: [2022-02-18 Fri 10:57] DEADLINE: <2022-02-18 Fri 23:59>
*** DONE 220
CLOSED: [2022-02-20 Sun 00:29] DEADLINE: <2022-02-18 Fri 23:59>
*** DONE 240
CLOSED: [2022-02-27 Sun 14:48] DEADLINE: <2022-02-27 Sun 23:59>
*** DONE 260
CLOSED: [2022-03-02 Wed 22:38]
*** DONE 280
CLOSED: [2022-03-02 Wed 22:38]
*** DONE 300
CLOSED: [2022-03-02 Wed 22:38]
** cond
#+caption: condは条件式の処理に使う。
#+begin_src lisp
  (cond ((>= 1 1) (print 0))
        ((= 0 0) (print 1)))
#+end_src

#+RESULTS:
: 0
** member
#+caption: member関数は、リストのトップレベルに望むものがあるか調べる
#+begin_src lisp
  (defun my-member (x y)
    (cond ((null y) nil)
          ((eq x (car y)) t)
          (t (member x (cdr y)))))
  (my-member 'a '(a b))
#+end_src

#+RESULTS:
#+begin_results
T
#+end_results

#+caption: 無い場合はnilを返す
#+begin_src lisp
  (my-member 'c '(a b))
#+end_src

#+RESULTS:
#+begin_results
NIL
#+end_results
** assoc
#+caption: assoc関数は辞書を検索する
#+begin_src lisp
  (setq dict '((unum . 1) (duo . 2) (tria . 3)))
  (assoc 'unum dict)
#+end_src

#+RESULTS:
#+begin_results
(UNUM . 1)
#+end_results

#+caption: assocの定義
#+begin_src lisp
  (defun my-assoc (x y)
    (cond ((null y) nil)
          ((eq x (caar y)) (car y))
          (t (assoc x (cdr y)))))
  (my-assoc 'unum dict)
#+end_src

#+RESULTS: assocの定義
#+begin_results
(UNUM . 1)
#+end_results

** rassoc
#+caption: rassocは逆引き関数。辞書からcdrを検索する
#+begin_src lisp
  (defun my-rassoc (x y)
    (cond ((null y) nil)
          ((eq x (cdar y)) (car y))
          (t (rassoc x (cdr y)))))
  (my-rassoc 1 dict)
#+end_src

#+RESULTS:
#+begin_results
(UNUM . 1)
#+end_results

ドット記法で ~(reiko . (3 712 5648))~ は、
~(reiko 3 712 5678)~ と同じ。後ろの方がリストになっているとドットは書かない慣習。

Lispにおける式は、題付きリストといえる。
(関数 引数1 引数2 ...)
は、関数と引数のリストとのドット対、
(関数 . 引数のリスト)
と考えることができる。
** replaca
#+caption: rplacaはxが指しているセルのcarをyに置き換える
#+begin_src lisp
(rplaca '(1 1) 2)
#+end_src

#+RESULTS:
#+begin_results
(2 1)
#+end_results

#+caption: rplacdはcdrバージョン
#+begin_src lisp
(rplacd '(1 1) 2)
#+end_src

#+RESULTS:
#+begin_results
(1 . 2)
#+end_results

#+caption: alistを書き換える関数
#+begin_src lisp
  (defun update-phone (p x y)
      (rplacd (assoc x p) y)
      p  )

  (setq dict '((unum . 1) (duo . 2) (tria . 3)))
  (update-phone dict 'unum 111)
#+end_src

#+RESULTS:
#+begin_results
((UNUM . 111) (DUO . 2) (TRIA . 3))
#+end_results

** remove
#+caption: xと等しいトップレベルの要素をすべて削除してみる
#+begin_src lisp
  (defun my-remove (x y)
    (cond ((null y) nil)
          ((eq (car y) x) (remove x (cdr y)))
          (t (cons (car y) (remove x (cdr y))))))
(my-remove 'mo '(to mo do mo mo to mo to mo))
#+end_src

#+RESULTS:
#+begin_results
(TO DO TO TO)
#+end_results

#+caption: マッチした最初のリストを取り除く。書き換えるべきセルは、1つ前のセル。
#+begin_src lisp
  (defun my-delete-1 (x y)
    (setq y (cons 'dummy y))
    (my-del2 x (cdr y) y)
    (cdr y))

  (defun my-del2 (x y z)
    (cond ((null y) nil)
          ((eq (car y) x) (rplacd z (cdr y)))
          (t (my-del2 x (cdr y) y))))
  (my-delete-1 'mo '(mo mo mo to to to))
#+end_src

#+RESULTS:
#+begin_results
(MO MO TO TO TO)
#+end_results

#+caption: 再帰関数が取る変数を少なくしたバージョン
#+begin_src lisp
  (defun my-delete (x y)
    (setq y (cons 'dummy y))
    (my-dela x y)
    (cdr y))

  (defun my-dela (x y)
    (cond ((null (cdr y)) nil)
          ((eq (cadr y) x)
           (rplacd y (cddr y))
           (my-dela x (cdr y)))
    (t (my-dela x (cdr y)))))

  (my-delete 'mo '(mo to mo to))
#+end_src

#+RESULTS:
#+begin_results
(TO TO TO)
#+end_results
** nreverse
#+caption: nreverseはリストを逆にする関数
#+begin_src lisp
(nreverse '(A B C))
#+end_src

#+RESULTS:
#+begin_results
(C B A)
#+end_results

#+caption: nreverseを定義する(バグ)
#+begin_src lisp
  (defun my-nreverse (x)
    (nrev2 x nil))

  (defun nrev2 (x r)
    (cond ((null x) r)
          (t (rplacd x r)
             (nrev2 (cdr x) x))))
  (my-nreverse '(A B C))
#+end_src

#+RESULTS:
#+begin_results
(A)
#+end_results

特殊形式prog1。
(prog1 式1 式2 式3 ...)
は返す値が式1の値。これを使って修正する。

#+caption: nrev2の修正版。prog1を使う
#+begin_src lisp
  (defun nrev2 (x r)
    (cond ((null x) r)
          (t (prog1 (nrev2 (cdr x) x)
               (rplacd x r)))))
  (my-nreverse '(A B C))
#+end_src

#+RESULTS:
#+begin_results
(C B A)
#+end_results
** 破壊的関数
nreverseは破壊的。

#+caption: 返される値は逆になる
#+begin_src lisp
  (setq numl '(1 2 3))
  (nreverse numl)
#+end_src

#+RESULTS:
#+begin_results
(3 2 1)
#+end_results

#+caption: 元のリストは破壊される
#+begin_src lisp
  numl
#+end_src

#+RESULTS:
#+begin_results
(1)
#+end_results

破壊的関数にはsetqを使うとよい。
#+caption: numlにnreverseした後の値が入っている
#+begin_src lisp
  (setq numl '(1 2 3))
  (setq numl (nreverse numl))
  numl
#+end_src

#+RESULTS:
#+begin_results
(3 2 1)
#+end_results

** append, nconc
appendの破壊版がnconc。
#+caption: appendは非破壊
#+begin_src lisp
  (setq numl '(1 2 3))
  (append numl 1)
  numl
#+end_src

#+RESULTS:
#+begin_results
(1 2 3)
#+end_results

#+caption: nconcは破壊的
#+begin_src lisp
  (setq numl '(1 2 3))
  (nconc numl 1)
  numl
#+end_src

#+RESULTS:
#+begin_results
(1 2 3 . 1)
#+end_results

#+caption: nconcを定義する。xに破壊的変更して、xを最後に返す
#+begin_src lisp
  (defun my-nconc (x y)
    (cond ((null x) y)
          (t (rplacd (last x) y) x)))
  (my-nconc '(1 2 3) 1)
#+end_src

#+RESULTS:
#+begin_results
(1 2 3 . 1)
#+end_results
** last
#+caption:
#+begin_src lisp
  (defun my-last (x)
    (cond ((null x) nil)
          (t (my-last2 x))))

  (defun my-last2 (x)
    (cond ((null (cdr x)) x)
          (t (my-last2 (cdr x)))))

  (my-last '(1 2 3))
#+end_src

#+RESULTS:
#+begin_results
(3)
#+end_results

** subst
#+caption: substはaをbに置き換える関数
#+begin_src lisp
  (subst 'a 'b '(a b (a b (b ba) nil a)))
#+end_src

#+RESULTS:
#+begin_results
(A A (A A (A BA) NIL A))
#+end_results

#+caption: substの定義
#+begin_src lisp
  (defun my-subst (new old tree)
    (cond ((eq old Tree) new)
          ((atom tree) tree)
          (t (cons (subst new old (car tree))
                   (subst new old (cdr tree))))))
  (my-subst 'a 'b '(a b a b))
#+end_src

#+RESULTS:
#+begin_results
(A A A A)
#+end_results

#+caption: substではcarもcdrも平等に扱われているので、ドット記法が見える。
#+begin_src lisp
(subst 'kk nil '(a b (b ba) nil a))
#+end_src

#+RESULTS:
#+begin_results
(A B (B BA . KK) KK A . KK)
#+end_results

consを使っているので、新しいリストを作っていることになる。
#+caption: 置き換える対象がなければ単にリストコピーになる
#+begin_src lisp
(subst 'a 'b '(a a a))
#+end_src

#+RESULTS:
#+begin_results
(A A A)
#+end_results

何もやらないときはcopy関数の定義と同じ。
#+caption: cons部分に注目すると同じことがわかる
#+begin_src lisp
  (defun my-copy (tree)
    (cond ((atom tree) tree)
          (t (cons (my-copy (car tree))
                   (my-copy (cdr tree))))))
  (my-copy '(a a a))
#+end_src

#+RESULTS:
#+begin_results
(A A A)
#+end_results

今風スタイルなsubst。
#+caption: letと、同じであればコピーせずtreeをそのまま返すのが違い
#+begin_src lisp
  (defun my-subst (new old tree)
    (cond ((eq old tree) new)
          ((atom tree) tree)
          (t (let ((a (my-subst new old (car tree)))
                   (d (my-subst new old (cdr tree))))
               (cond ((and (eq a (car tree))
                           (eq d (cdr tree)))
                      tree)
                     (t (cons a d)))))))
  (my-subst 'a 'b '(a b))
#+end_src

#+RESULTS:
#+begin_results
(A A)
#+end_results

複数種類の置き換えをしたい。
#+caption: sublistは置き換えのための辞書をalistでもらう
#+begin_src lisp
  (defun my-sublis (alist tree)
    (let ((pair (assoc tree alist)))
      (cond (pair (cdr pair))
            ((atom tree) tree)
            (t (let ((a (my-sublis alist (car tree)))
                     (d (my-sublis alist (cdr tree))))
                 (cond ((and (eq a (car tree))
                             (eq d (cdr Tree)))
                        tree)
                       (t (cons a d))))))))
  (my-sublis '((unum . 1) (duo . 2) (tria . 3)) '(unum duo tria unum (unum tria)))
#+end_src

#+RESULTS:
#+begin_results
(1 2 3 1 (1 3))
#+end_results
** defsubst
defsubstが使われるとき。

まずifを定義してみる(これはうまくいかない)。
#+caption: 返る値とxの値の違いに注目する。ifを呼ぶ時に引数を評価してしまう。なので副作用が実行されてxの値は7になる
#+begin_src lisp
  (defun my-if (p x y)
    (cond (p x)
          (t y)))

  (setq x 4)
  (setq flag t)
  (my-if flag (setq x (+ x 1)) (setq x (+ x 2))) ;; => 5
  x ;; => 7
#+end_src

#+RESULTS:
#+begin_results
7
#+end_results

#+caption: defsubst。setqのように副作用のある式が引数に来ても、評価しない
#+begin_src lisp
  (defsubst my-if (p x y)
    (cond (p x)
          (t y)))

  ;; (setq x 4)
  ;; (setq flag t)
  ;; (my-if flag (setq x (+ x 1)) (setq x (+ x 2)))
#+end_src

余剰変数: 変数が不定個の引数をリストに束ねて受け取ること。
#+caption: &restでlistが簡単に定義できる
#+begin_src lisp
  (defun my-list (&rest x) x)
  (my-list 1 1)
#+end_src

#+RESULTS:
#+begin_results
(1 1)
#+end_results
** defmacro
#+caption: マクロは引数を評価しない
#+begin_src lisp
  (defmacro my-first (x)
    (list 'car x))
  (my-first (list 1 2 3))
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

~(my-first (list 1 2 3))~ は、
~(car (list 1 2 3))~ に置き換わるように見える。

試しにdefunでやってみると、できない。
#+caption: carが単なるシンボルになり(関数として評価されない)、リストになる
#+begin_src lisp
  (defun my-first (x)
    (list 'car x))
  (my-first '(1 2 3)) ;; '(car (1 2 3)) と同じ
#+end_src

#+RESULTS:
#+begin_results
(CAR (1 2 3))
#+end_results

condをマクロ定義してみる。
#+caption:
#+begin_src lisp
  (defmacro my-cond (&rest clauses)
    (expand-cond clauses))

  (defun expand-cond (clauses)
    (my-cond ((null clauses) nil)
          ((eq (caar clauses) 't)
           (cons 'progn (cdar clauses)))
          (t (list 'if
                   (caar clauses)
                   (cons 'progn (cdar clauses))
                   (expand-cond (cdr clauses))))))
  (my-cond (1 '(1))
           (t '(t)))
#+end_src

#+RESULTS:
#+begin_results
(1)
#+end_results

backquoteをつけると、quoteと違ってS式がコピーされる。
コピーの途中で、コンマのついた部分S式があるとそれを評価する。
これを用いてfirstの定義を書き直す。

#+caption: バッククォートを使ったバージョンのfirst
#+begin_src lisp
  (defmacro my-first (x)
    `(car ,x))
  (my-first '(1 2 3))
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

よく見るパターンをマクロ化する。
#+caption: よく見るやつ
#+begin_src lisp :eval never
  (cond ((null なんとか) どうする1)
        (t どうする2))
#+end_src

#+caption:
#+begin_src lisp
  (defmacro if-null (nan dos1 dos2)
    `(cond ((null ,nan) ,dos1)
           (t ,dos2)))
  (defun my-even (x)
    (if-null (= (mod x 2) 1) t nil))
  (my-even 2)
#+end_src

#+RESULTS:
#+begin_results
T
#+end_results
** pop
よく使うマクロ2つ。
#+caption: 定義する
#+begin_src lisp
  (defmacro my-pop (x)
    `(prog1 (car ,x) (setq ,x (cdr ,x))))
  (defmacro my-push (y x)
    `(setq ,x (cons ,y ,x)))
#+end_src

#+caption: popを使ってみる
#+begin_src lisp
  (setq pop-test '(1 2 3))
  (my-pop pop-test)
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

#+caption: 破壊的
#+begin_src lisp
  pop-test
#+end_src

#+RESULTS:
#+begin_results
(2 3)
#+end_results

#+begin_src lisp
  (defmacro image (var list &rest forms)
    `(let (($list$ ,list)
           ($r$ nil)
           (,var nil))
      (while ($list$ (nreverse $r$))
       (setq ,var (pop $list$))
       (push (progn ,@forms) $r$))))
  (image i (list 1 2 3 4) (* i i)) ;; => (1 4 9 16)になるはずだが動かない
  ;; i をrubyでいうブロック引数とするように定義するマクロ
  ;; このようにもともとの特殊形式と同じように自由に定義できるのがLispらしさ
#+end_src

** 文字列
#+caption: 実体が異なるのでnilになる
#+begin_src lisp
(eq "tide" "tide")
#+end_src

#+RESULTS:
#+begin_results
NIL
#+end_results

#+caption: equalを使うと文字列で比較する
#+begin_src lisp
(equal "tide" "tide")
#+end_src

#+RESULTS:
#+begin_results
T
#+end_results

** alist
#+caption: alistにアクセスするgetの実装
#+begin_src lisp
  (defun my-get (symbol property)
    (let ((plist (symbol-plist symbol)))
      (loop (until (null plist) nil)
         (until (eq (car plist) property) (cadr plist))
         (setq plist (cddr plist)))))
#+end_src

#+RESULTS:
#+begin_results
MY-GET
#+end_results

#+caption: putpropの実装
#+begin_src lisp
  (putprop 'foo
           (cons (symbol-function 'foo)
                 (get 'foo 'old-definition))
           'old-definition)
#+end_src

lambdaはdefunのように関数を定義する特殊形式ではない。
lambdaはcarにあるリストが関数実体を示す単なる標識。
defunとは、関数実体に名前をつける関数といえる。

#+begin_export latex
(defun fn args . body)
;; ↑は、
(cons 'lambda (cons args body))
;; ↑と表すことができる
#+end_export

#+caption: applyは関数(ラムダ式でも名前付きでもよい)に引数を与えて評価する
#+begin_src lisp
  (apply (lambda (x y) (+ (* x x) (* y y))) (list 3 4))
#+end_src

#+RESULTS:
#+begin_results
25
#+end_results

簡単な例。
#+caption: リストの合計を求める。第2引数はリスト
#+begin_src lisp
  (apply '+ '(1 2 3 4))
#+end_src

#+RESULTS:
#+begin_results
10
#+end_results

funcallで書く。
#+caption: リストの合計を求める。第2引数は任意の数
#+begin_src lisp
  (funcall '+ 1 2 3 4)
#+end_src

#+RESULTS:
#+begin_results
10
#+end_results
** mapcar
#+caption: mapcarの定義
#+begin_src lisp
  (defun my-mapcar (fn mlist)
    (cond ((null mlist) nil)
          (t (cons (funcall fn (car mlist))
                   (mapcar fn (cdr mlist))))))
  (my-mapcar #'sqrt '(1 2 3))
#+end_src

#+RESULTS:
#+begin_results
(1 1.4142135 1.7320508)
#+end_results

#+caption: maplistの定義
#+begin_src lisp
  (defun my-maplist (fn mlist)
    (cond ((null mlist) nil)
          (t (cons (funcall fn mlist) ;; mapcar との違いはここだけ。carではなくリストに対してfnをapplyする
                   (maplist fn (cdr mlist))))))
  (my-maplist #'append '(1 2 3))
#+end_src

#+RESULTS:
#+begin_results
((1 2 3) (2 3) (3))
#+end_results

#+caption: maplistの例。各要素の累計を得るとき
#+begin_src lisp
  (reverse
   (my-maplist (lambda (x) (apply #'+ x))
               (reverse '(10 5 6 12 3 5 9 7 0 4 2 15))))
#+end_src

#+RESULTS:
#+begin_results
(10 15 21 33 36 41 50 57 57 61 63 78)
#+end_results
** sort
#+caption: 無名関数で順序を指定してソートする
#+begin_src lisp
  (setq monthly-sales
        '((Jan . 10) (Feb . 5) (Mar . 6) (Apr . 12) (May . 3)(Jun . 5) (Jul . 9) (Aug . 7) (Sep . 0) (Oct . 4)(Nov . 2) (Dec . 15)))
  (sort monthly-sales #'(lambda (x y) (> (cdr x) (cdr y))))
#+end_src

#+RESULTS:
#+begin_results
((DEC . 15) (APR . 12) (JAN . 10) (JUL . 9) (AUG . 7) (MAR . 6) (FEB . 5)
 (JUN . 5) (OCT . 4) (MAY . 3) (NOV . 2) (SEP . 0))
#+end_results
** eval
evalを実装することで理解する。
スコープあたりの核となる部分を実装しているのだが、よくわからない。

#+caption: eval
#+begin_src lisp
  (defun eval (form)
    (cond
      ((or (null form) (numberp form) (stringp form)) form) ; nil, 数, 文字列の値はそれ自身
      ((symbolp form) (variable-value form)) ; シンボルは変数と解釈される
      ((member (car form)
               '(quote cond setq prog progn prog1 prog2 go let let* if do do* defun defmacro function ...))
       (eval-special-form form)) ; 特殊形式の処理(ここから先はセルとわかっている)
      ((and (consp (car Form)) ; ラムダ式
            (eq (caar form) 'lambda))
       (apply (car form) (evlis (cdr form))))
      ((function-symbol-p (car form)  ; 関数シンボル
                          (evlis (cdr form))))
      ((macro-symbol-p (car form)) ; マクロ呼び出し。ただしbackquoteには未対応
       (eval (apply (macro-function (car form)) (cdr form))))
      (t (error 'concat-evaluate form))))
#+end_src

#+caption: evlis
#+begin_src lisp
  ;; 引数を順次評価してリストにする(実際はリストを作らずスタックに積む ??)
  (defun evlis (args)
    (cond ((null args) nil)
          (t (cons (eval (car args)) (evlis (cdr args))))))
#+end_src

#+caption: 特殊形式の評価
#+begin_src lisp
  (defun eval-special-form (form)
    (cond ((eq (car form) 'quote) (cadr form))
          ((eq (car form 'cond) (evcon (cdr form))))
          ((eq (car form) 'setq') ...)
          ((eq (car form) 'progn) (evprogn (cdr form)))))
#+end_src

#+caption: cond式の評価
#+begin_src lisp
  (defun evcon (clauses)
    (cond
      ;; もうcond節が残ってなければnilを返す
      ((null clauses) nil)
      ;; 述語が真であれば、帰結の暗黙のprognを順次評価する
      ((eval (caar clauses))
       (evprogn (cdr clauses)))
      ;; 次のcond節を調べる
      (t (evcon (cdr clauses)))))
#+end_src

#+caption: prognの評価
#+begin_src lisp
  (defun evprogn (forms)
    (cond
      ((null forms) nil)
      ((null (cdr forms)) (eval (car forms)))
      (t (eval (car forms)) (evprogn (cdr forms)))))
#+end_src
** キーワード
Common Lispでは名前空間のことをシンボル・パッケージあるいは単にパッケージと呼ぶ。シンボルはどれかのパッケージに属する。
Common Lispで標準的に用意されているのはlisp, user, keyword, systemの4つ。

carと使うときは、実際にはlisp:carとしている。文脈によって自動で決定されるので毎回lisp:を打つ必要はない。

キーワード引数は名前空間のうち、keywordを使う。特別扱いされ、keyword: が :だけに省略できる。
なので keyword:direction と:direction は同じ意味である。キーワードを評価すると、つねにそれ自身を値として返すので、quoteする必要がない。
* Tasks
** [[https://www.cs.cmu.edu/~dst/LispBook/book.pdf][COMMONLISP: A Gentle Introduction to Symbolic Computation]]
わかりやすい入門。
** TODO [[http://lyrical.bugyo.tk/][魔法言語 リリカル☆Lisp]]
nscripterと萌えキャラでLispが学べる…。
** [[https://lispcookbook.github.io/cl-cookbook/][Common Lisp Cookbook Home]]
** [[https://gigamonkeys.com/book/][Practical Common Lisp]]
** TODO 実用 Common Lisp
- [[https://www.amazon.co.jp/Common-Lisp-Architects%E2%80%99Archive-CLASSIC-MODER/dp/4798118907/][実用 Common Lisp (IT Architects’Archive CLASSIC MODER)]]
- [[https://github.com/norvig/paip-lisp][norvig/paip-lisp]] - サンプルスクリプト
** TODO Common Lisp Quick Reference
* Reference
** [[https://lisphub.jp/common-lisp/cookbook/index.cgi][逆引き Common Lisp クックブック:逆引きCommon Lisp]]
リファレンス。
* Archives
** DONE Road to Common Lisp
CLOSED: [2021-09-13 Mon 21:22]

Lispの学び方、おすすめ本の紹介。
- [[https://gist.github.com/y2q-actionman/49d7587912b2786eb68643afde6ca192][A Road to Common Lisp 翻訳]]
