:PROPERTIES:
:ID:       6218deb2-43df-473a-8cdf-910c47edd801
:header-args+: :wrap
:END:
#+title: Clojure
* 概要
Clojureは[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]、[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]の方言の1つ。
プログラムは[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]仮想マシン、.NETで動作する。

* Memo
** インストール
- Javaのランタイム
- Leiningen...依存関係管理。
#+begin_src shell
  sudo apt-get install leiningen
  lein repl
#+end_src
** Hello, world
#+begin_src clojure :results output
  (println "hello world")
#+end_src

#+RESULTS:
#+begin_results
hello world
#+end_results

#+begin_src clojure
  (defn hello [name] (str "Hello, " name))
#+end_src

#+RESULTS:
#+begin_results
#'user/hello
#+end_results

#+begin_src clojure
  (defn hello-world [username]
    (println (format "Hello, %s" username)))
#+end_src

#+RESULTS:
#+begin_results
#'user/hello-world
#+end_results

状態を共有する。
セットに要素を1つ追加する。
#+begin_src clojure
  (conj coll item)
  (conj #{} "Stu")
#+end_src

#+RESULTS:
#+begin_results
| class clojure.lang.Compiler$CompilerException |
| #{"Stu"}                                      |
#+end_results

セットを知る。
~conj~ を ~update~-fn として渡す。
#+begin_src clojure
  (def visitors (atom #{}))
  (swap! visitors conj "Stu")
#+end_src

#+RESULTS:
#+begin_results
| #'user/visitors |
| #{"Stu"}        |
#+end_results

~atom~ はClojureが持つリファレンスタイプのひとつ。
~ref~ の中身は ~deref~ で見ることができる。略記として ~@~ を使える。

#+begin_src clojure
  (deref visitors)
  @visitors
#+end_src

#+RESULTS:
#+begin_results
| #{"Stu"} |
| #{"Stu"} |
#+end_results

#+begin_src clojure
  (defn hello
    "Writes hello message to *out*. Calls you by username.
  Knows if you have been here before."
    [username]
    (swap! visitors conj username)
    (str "Hello, " username))
#+end_src

#+RESULTS:
#+begin_results
#'user/hello
#+end_results

#+begin_src clojure
  (hello "Rich")
  @visitors
#+end_src

#+RESULTS:
#+begin_results
| "Hello, Rich"   |
| #{"Stu" "Rich"} |
#+end_results

状態の問題。それまでにどういう動作をしたかによって、結果が異なってくる。
純粋な関数なら、局所的な知識だけで動作を理解できるが、状態が絡むとそこに至るすべての履歴を理解しなければならない。
** ライブラリ
~use~ は ~require~ と ~refer~ を一度にやってくれる。
#+begin_src clojure
  (require 'clojure.java.io)
  (use 'clojure.java.io)
#+end_src

#+RESULTS:
#+begin_results
#+end_results

再読込。

#+begin_src clojure
  (use :reload 'clojure.java.io)
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** ドキュメント検索
#+begin_src clojure :results output
  (doc str)
#+end_src

#+RESULTS:
#+begin_results
-------------------------
clojure.core/str
([] [x] [x & ys])
  With no args, returns the empty string. With one arg x, returns
  x.toString().  (str ) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.
#+end_results

#+begin_src clojure  :results output
(find-doc "reduce")
#+end_src

#+RESULTS:
#+begin_results
-------------------------
cider.nrepl.middleware.track-state/fast-reduce
([f coll])
  Like (reduce f {} coll), but faster.
  Inside f, use `assoc!` and `conj!` instead of `assoc` and `conj`.
-------------------------
clojure.core/areduce
([a idx ret init expr])
Macro
  Reduces an expression across an array a, using an index named idx,
  and return value named ret, initialized to init, setting ret to the
  evaluation of expr at each step, returning ret.
-------------------------
clojure.core/eduction
([xform* coll])
  Returns a reducible/iterable application of the transducers
  to the items in coll. Transducers are applied in order as if
  combined with comp. Note that these applications will be
  performed every time reduce/iterator is called.
-------------------------
clojure.core/ensure-reduced
([x])
  If x is already reduced?, returns it, else returns (reduced x)
-------------------------
clojure.core/reduce
([f coll] [f val coll])
  f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.
-------------------------
clojure.core/reduce-kv
([f init coll])
  Reduces an associative collection. f should be a function of 3
  arguments. Returns the result of applying f to init, the first key
  and the first value in coll, then applying f to that result and the
  2nd key and value, etc. If coll contains no entries, returns init
  and f is not called. Note that reduce-kv is supported on vectors,
  where the keys will be the ordinals.
-------------------------
clojure.core/reduced
([x])
  Wraps x in a way such that a reduce will terminate with the value x
-------------------------
clojure.core/reduced?
([x])
  Returns true if x is the result of a call to reduced
-------------------------
clojure.core/reductions
([f coll] [f init coll])
  Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init.
-------------------------
clojure.core/require
([& args])
  Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A 'lib' is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib's
  name also locates its root directory within classpath using Java's
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  'require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol 'x.y.z; it has the root directory
  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or
  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The
  root resource should contain code to create the lib's
  namespace (usually by using the ns macro) and load any additional
  lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib's namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It's common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as 's'.

  (require '(clojure zip [set :as s]))
-------------------------
clojure.core/run!
([proc coll])
  Runs the supplied procedure (via reduce), for purposes of side
  effects, on successive items in the collection. Returns
-------------------------
clojure.core/transduce
([xform f coll] [xform f init coll])
  reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with 'completing'. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.
-------------------------
clojure.core/unreduced
([x])
  If x is reduced?, returns (deref x), else returns x
-------------------------
clojure.core.protocols/CollReduce
  Protocol for collection types that can implement reduce faster than
  first/next recursion. Called by clojure.core/reduce. Baseline
  implementation defined in terms of Iterable.
-------------------------
clojure.core.protocols/IKVReduce
  Protocol for concrete associative types that can reduce themselves
   via a function of key and val faster than first/next recursion over map
   entries. Called by clojure.core/reduce-kv, and has same
   semantics (just different arg order).
-------------------------
clojure.core.protocols/InternalReduce
  Protocol for concrete seq types that can reduce themselves
   faster than first/next recursion. Called by clojure.core/reduce.
-------------------------
clojure.core.protocols/interface-or-naive-reduce
([coll f val])
  Reduces via IReduceInit if possible, else naively.
-------------------------
clojure.core.protocols/naive-seq-reduce
([s f val])
  Reduces a seq, ignoring any opportunities to switch to a more
  specialized implementation.
-------------------------
cider.nrepl.middleware.util.instrument/strip-instrumentation-meta
([form])
  Remove all tags in order to reduce java bytecode size and enjoy cleaner code
  printouts. We keep ::breakfunction for def symbols because that is how we
  identify currently instrumented vars in list-instrumented-defs.
#+end_results
** clojure関数のソースを見る
~repl~ ライブラリを使う。
#+begin_src clojure
  (use 'clojure.repl)
  (source identity)
#+end_src

#+RESULTS:
#+begin_results
#+end_results

Clojureのコレクションが[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]のコレクションであることを確かめる。
#+begin_src clojure
  (ancestors (class [1 2 3]))
#+end_src

#+RESULTS:
#+begin_results
#{clojure.lang.IPersistentVector clojure.lang.Indexed clojure.lang.IMeta clojure.lang.ILookup java.lang.Runnable java.lang.Iterable java.util.List clojure.lang.IPersistentCollection java.io.Serializable clojure.lang.IEditableCollection java.util.Collection clojure.lang.Seqable java.util.concurrent.Callable clojure.lang.IHashEq clojure.lang.Counted java.util.RandomAccess clojure.lang.Associative clojure.lang.IFn clojure.lang.Reversible clojure.lang.IObj clojure.lang.IReduceInit clojure.lang.AFn java.lang.Object clojure.lang.IReduce clojure.lang.Sequential clojure.lang.IPersistentStack clojure.lang.IKVReduce clojure.lang.APersistentVector java.lang.Comparable}
#+end_results

** フォーム
- Clojureは同図像性を持つ。
- ClojureのコードはClojureのデータによって組み立てられる。
- Clojureのプログラムを走らせるときには、まずClojureの中の ~リーダ~ と呼ばれる部分がプログラムを ~フォーム~ と呼ばれる単位ごとに読み込んで、それをClojureのデータ構造へと変換する。そしてデータ構造をコンパイルして実行する。

フォームにはブール値、文字、キーワード、リスト、マップ…などがある。
** シンボル
シンボルは、Clojure内のあらゆる種類のものの名前として使う。

ドットで[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]メソッドの呼び出しであると判断する。
#+begin_src clojure
  (.toUpperCase "hello")
  (str "hello")
#+end_src

#+RESULTS:
#+begin_results
| "HELLO" |
| "hello" |
#+end_results


リテラル表記は ~\{letter}~ 。
#+begin_src clojure
(str \h \e \y \space \y \o \u)
#+end_src

#+RESULTS:
#+begin_results
hey you
#+end_results

文字を交互に結合。
#+begin_src clojure
(interleave "Attack at midnight" "The purple elephant chortled")
#+end_src

#+RESULTS:
#+begin_results
(\A \T \t \h \t \e \a \space \c \p \k \u \space \r \a \p \t \l \space \e \m \space \i \e \d \l \n \e \i \p \g \h \h \a \t \n)
#+end_results

文字列に戻す。
#+begin_src clojure
(apply str (interleave "Attack at midnight" "The purple elephant chortled"))
#+end_src

#+RESULTS:
#+begin_results
ATthtea cpku raptl em iedlneipghhatn
#+end_results

復元する。
#+begin_src clojure
  (apply str (take-nth 2 "ATthtea cpku raptl em iedlneipghhatn"))
#+end_src

#+RESULTS:
#+begin_results
| "clojure.lang.LazySeq@c855d426" |
| "Attack at midnight"            |
#+end_results

Clojureでは空リストは偽ではない。
#+begin_src clojure
(if () "We are in Clojure!" "We are in Common Lisp!")
#+end_src

#+RESULTS:
#+begin_results
We are in Clojure!
#+end_results

~true?~ は値が ~true~ そのものであるかを調べる。
#+begin_src clojure
  (true? true)
  (true? "foo")
#+end_src

#+RESULTS:
#+begin_results
| true  |
| false |
#+end_results

#+begin_src clojure
  (zero? 0.0)
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

述語一覧。
#+begin_src clojure :results output :evel never
(find-doc #"\?$")
#+end_src

#+RESULTS:
#+begin_results
-------------------------
nrepl.middleware.interruptible-eval/interrupted?
([e])
  Returns true if the given throwable was ultimately caused by an interrupt.
-------------------------
leiningen.core.classpath/ext-dependency?
([dep])
  Should the given dependency be loaded in the extensions classloader?
-------------------------
leiningen.core.pedantic/range?
([{:keys [node]}])
  Does the path point to a DependencyNode asking for a version range?
-------------------------
leiningen.core.pedantic/top-level?
([{:keys [parents]}])
  Is the path a top level dependency in the project?
-------------------------
clojure.test/function?
([x])
  Returns true if argument is a function or a symbol that resolves to
  a function (not a macro).
-------------------------
clojure.test/successful?
([summary])
  Returns true if the given test summary indicates all tests
  were successful, false otherwise.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader/garg
([n])
  Get a symbol for an anonymous ?argument?
-------------------------
dynapath.util/addable-classpath?
([cl])
  Returns true if the given ClassLoader provides add-claspath-url.
-------------------------
dynapath.util/readable-classpath?
([cl])
  Returns true if the given ClassLoader provides classpath-urls.
-------------------------
cider.nrepl.middleware.debug/looks-step-innable?
([form])
  Decide whether a form looks like a call to a function that we could
  instrument and step into.
-------------------------
cider.nrepl.middleware.debug/safe-to-debug?
([ns])
  Some namespaces are not safe to debug, because doing so can cause a stack
  overflow that crashes the nrepl process.
-------------------------
cider.nrepl.middleware.debug/skip-breaks?
([coor STATE__])
  True if the breakpoint at coordinates should be skipped.

  The `*skip-breaks*` map stores a `mode`, `coordinates`, the `code` that it
  applies to, and a `force?` flag.

  Behaviour depends on the `mode`:
   - :all - return true, skipping all breaks
   - :trace - return false, skip nothing
   - :deeper - return true if the given coordinates are deeper than the
               coordinates stored in `*skip-breaks*`, in the same code
   - :before - return true if the given coordinates represent a place before
               the coordinates in `*skip-breaks*`, in the same code

  For :deeper and :before, if we are not in the same code (i.e. we have stepped
  into another instrumented function and code argument doesn't match old code in
  *skip-breaks*), then return the value of `force?`.
-------------------------
cider.nrepl.middleware.debug/step-in?
([v coor code])
  Return true if we can and should step in to the function in the var `v`.
  The "should" part is determined by the value in `step-in-to-next?`, which
  gets set to true by the user sending the "step in" command.
-------------------------
clojure.core.specs.alpha/even-number-of-forms?
([forms])
  Returns true if there are an even number of forms in a binding vector
-------------------------
nrepl.middleware.session/interrupted?
([e])
  Returns true if the given throwable was ultimately caused by an interrupt.
-------------------------
cider.nrepl.inlined-deps.javaclasspath.v1v0v0.clojure.java.classpath/jar-file?
([f])
  Returns true if file is a normal file with a .jar or .JAR extension.
-------------------------
cider.nrepl.middleware.util.error-handling/shallow-bencodable?
([item])
  Returns false if `item`'s type can't be bencoded as defined by the
  algorithm in `nrepl.bencode/write-bencode`. Does not
  examine the elements of a collection to ensure that the enclosed
  elements are also bencodable, and so you probably actually want to
  use `deep-bencodable-or-fail` or write something similar.
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.dynamic-classpath/can-add?
([cl])
  Must return true if add-classpath-url is implemented.
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.dynamic-classpath/can-read?
([cl])
  Must return true if classpath-urls is implemented.
-------------------------
clojure.spec.alpha/?
([pred-form])
Macro
  Returns a regex op that matches zero or one value matching
  pred. Produces a single value (not a collection) if matched.
-------------------------
clojure.spec.alpha/check-asserts?
([])
  Returns the value set by check-asserts.
-------------------------
clojure.spec.alpha/inst-in-range?
([start end inst])
  Return true if inst at or after start and before end
-------------------------
clojure.spec.alpha/int-in-range?
([start end val])
  Return true if start <= val, val < end and val is a fixed
  precision integer.
-------------------------
clojure.spec.alpha/invalid?
([ret])
  tests the validity of a conform return value
-------------------------
clojure.spec.alpha/pvalid?
([pred x] [pred x form])
  internal helper function that returns true when x is valid for spec.
-------------------------
clojure.spec.alpha/regex?
([x])
  returns x if x is a (clojure.spec) regex op, else logical false
-------------------------
clojure.spec.alpha/spec?
([x])
  returns x if x is a spec object, else logical false
-------------------------
clojure.spec.alpha/valid?
([spec x] [spec x form])
  Helper function that returns true when x is valid for spec.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.dependency/dependent?
([graph x y])
  True if y is a dependent of x.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.dependency/depends?
([graph x y])
  True if x is directly or transitively dependent on y.
-------------------------
leiningen.core.project/composite-profile?
([profile])
  Returns true if the profile is composite, false otherwise.
-------------------------
leiningen.core.project/different-priority?
([left right])
  Returns true if either left has a higher priority than right or vice versa.
-------------------------
leiningen.core.project/displace?
([obj])
  Returns true if the object is marked as displaceable
-------------------------
leiningen.core.project/replace?
([obj])
  Returns true if the object is marked as replaceable
-------------------------
leiningen.core.project/top-displace?
([obj])
  Returns true if the object is marked as top-displaceable
-------------------------
clojure.set/subset?
([set1 set2])
  Is set1 a subset of set2?
-------------------------
clojure.set/superset?
([set1 set2])
  Is set1 a superset of set2?
-------------------------
cemerick.pomegranate.aether/within?
([[dep version & opts :as coord] [sdep sversion & sopts :as scoord]])
  Determines if the first coordinate would be a version in the second
   coordinate. The first coordinate is not allowed to contain a
   version range.
-------------------------
clojure.string/blank?
([s])
  True if s is , empty, or contains only whitespace.
-------------------------
clojure.string/ends-with?
([s substr])
  True if s ends with substr.
-------------------------
clojure.string/includes?
([s substr])
  True if s includes substr.
-------------------------
clojure.string/starts-with?
([s substr])
  True if s starts with substr.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/boot-project?
([])
  Check whether we're dealing with a Boot project.
  We figure this by checking for the presence of Boot's fake classpath.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/directory?
([f])
  Whether the argument is a directory or an url that points to a directory
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/file-ext?
([f & exts])
  Whether the argument's path ends in one of the specified case-insensitive
  file extensions
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/ns-obj?
([ns])
  Return true if n is a namespace object
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/url?
([u])
  Check whether the argument is an url
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.java/add-java-sources-via-dynapath?
  Should orchard use the dynapath library to use "fetch Java sources" functionality?

  Note that using dynapath currently implies some bugs, so you might want to disable this option.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.java/immutable-source-file?
([info])
  Return true if the source file is effectively immutable. Specifically, this
  returns true if no source file is available, or if the source file is in a
  jar/zip archive.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.java/initialize-cache-silently?
  Should `#'cache-initializer` refrain from printing to `System/out`?
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.util/addable-classpath?
([cl])
  Returns true if the given ClassLoader provides add-claspath-url.
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.util/readable-classpath?
([cl])
  Returns true if the given ClassLoader provides classpath-urls.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.reader-types/indexing-reader?
([rdr])
  Returns true if the reader satisfies IndexingReader
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.reader-types/line-start?
([rdr])
  Returns true if rdr is an IndexingReader and the current char starts a new line
-------------------------
clojure.core/any?
([x])
  Returns true given any argument.
-------------------------
clojure.core/associative?
([coll])
  Returns true if coll implements Associative
-------------------------
clojure.core/boolean?
([x])
  Return true if x is a Boolean
-------------------------
clojure.core/bound?
([& vars])
  Returns true if all of the vars provided as arguments have any bound value, root or thread-local.
   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.
-------------------------
clojure.core/bytes?
([x])
  Return true if x is a byte array
-------------------------
clojure.core/char?
([x])
  Return true if x is a Character
-------------------------
clojure.core/class?
([x])
  Returns true if x is an instance of Class
-------------------------
clojure.core/coll?
([x])
  Returns true if x implements IPersistentCollection
-------------------------
clojure.core/contains?
([coll key])
  Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. 'contains?' operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also 'some'.
-------------------------
clojure.core/counted?
([coll])
  Returns true if coll implements count in constant time
-------------------------
clojure.core/decimal?
([n])
  Returns true if n is a BigDecimal
-------------------------
clojure.core/delay
([& body])
Macro
  Takes a body of expressions and yields a Delay object that will
  invoke the body only the first time it is forced (with force or deref/@), and
  will cache the result and return it on all subsequent force
  calls. See also - realized?
-------------------------
clojure.core/delay?
([x])
  returns true if x is a Delay created with delay
-------------------------
clojure.core/distinct?
([x] [x y] [x y & more])
  Returns true if no two of the arguments are =
-------------------------
clojure.core/double?
([x])
  Return true if x is a Double
-------------------------
clojure.core/empty?
([coll])
  Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))
-------------------------
clojure.core/even?
([n])
  Returns true if n is even, throws an exception if n is not an integer
-------------------------
clojure.core/every?
([pred coll])
  Returns true if (pred x) is logical true for every x in coll, else
  false.
-------------------------
clojure.core/extends?
([protocol atype])
  Returns true if atype extends protocol
-------------------------
clojure.core/false?
([x])
  Returns true if x is the value false, false otherwise.
-------------------------
clojure.core/fits-table?
([ints])
  Returns true if the collection of ints can fit within the
  max-table-switch-size, false otherwise.
-------------------------
clojure.core/float?
([n])
  Returns true if n is a floating point number
-------------------------
clojure.core/fn?
([x])
  Returns true if x implements Fn, i.e. is an object created via fn.
-------------------------
clojure.core/future-cancelled?
([f])
  Returns true if future f is cancelled
-------------------------
clojure.core/future-done?
([f])
  Returns true if future f is done
-------------------------
clojure.core/future?
([x])
  Returns true if x is a future
-------------------------
clojure.core/ident?
([x])
  Return true if x is a symbol or keyword
-------------------------
clojure.core/identical?
([x y])
  Tests if 2 arguments are the same object
-------------------------
clojure.core/ifn?
([x])
  Returns true if x implements IFn. Note that many data structures
  (e.g. sets and maps) implement IFn
-------------------------
clojure.core/indexed?
([coll])
  Return true if coll implements Indexed, indicating efficient lookup by index
-------------------------
clojure.core/inst?
([x])
  Return true if x satisfies Inst
-------------------------
clojure.core/instance?
([c x])
  Evaluates x and tests if it is an instance of the class
    c. Returns true or false
-------------------------
clojure.core/int?
([x])
  Return true if x is a fixed precision integer
-------------------------
clojure.core/integer?
([n])
  Returns true if n is an integer
-------------------------
clojure.core/isa?
([child parent] [h child parent])
  Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy
-------------------------
clojure.core/keyword?
([x])
  Return true if x is a Keyword
-------------------------
clojure.core/lazy-seq
([& body])
Macro
  Takes a body of expressions that returns an ISeq or , and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?
-------------------------
clojure.core/libspec?
([x])
  Returns true if x is a libspec
-------------------------
clojure.core/list?
([x])
  Returns true if x implements IPersistentList
-------------------------
clojure.core/map-entry?
([x])
  Return true if x is a map entry
-------------------------
clojure.core/map?
([x])
  Return true if x implements IPersistentMap
-------------------------
clojure.core/nat-int?
([x])
  Return true if x is a non-negative fixed precision integer
-------------------------
clojure.core/neg-int?
([x])
  Return true if x is a negative fixed precision integer
-------------------------
clojure.core/neg?
([num])
  Returns true if num is less than zero, else false
-------------------------
clojure.core/?
([x])
  Returns true if x is , false otherwise.
-------------------------
clojure.core/not-any?
([pred coll])
  Returns false if (pred x) is logical true for any x in coll,
  else true.
-------------------------
clojure.core/not-every?
([pred coll])
  Returns false if (pred x) is logical true for every x in
  coll, else true.
-------------------------
clojure.core/number?
([x])
  Returns true if x is a Number
-------------------------
clojure.core/odd?
([n])
  Returns true if n is odd, throws an exception if n is not an integer
-------------------------
clojure.core/pos-int?
([x])
  Return true if x is a positive fixed precision integer
-------------------------
clojure.core/pos?
([num])
  Returns true if num is greater than zero, else false
-------------------------
clojure.core/qualified-ident?
([x])
  Return true if x is a symbol or keyword with a namespace
-------------------------
clojure.core/qualified-keyword?
([x])
  Return true if x is a keyword with a namespace
-------------------------
clojure.core/qualified-symbol?
([x])
  Return true if x is a symbol with a namespace
-------------------------
clojure.core/ratio?
([n])
  Returns true if n is a Ratio
-------------------------
clojure.core/rational?
([n])
  Returns true if n is a rational number
-------------------------
clojure.core/reader-conditional?
([value])
  Return true if the value is the data representation of a reader conditional
-------------------------
clojure.core/realized?
([x])
  Returns true if a value has been produced for a promise, delay, future or lazy sequence.
-------------------------
clojure.core/record?
([x])
  Returns true if x is a record
-------------------------
clojure.core/reduced?
([x])
  Returns true if x is the result of a call to reduced
-------------------------
clojure.core/reversible?
([coll])
  Returns true if coll implements Reversible
-------------------------
clojure.core/satisfies?
([protocol x])
  Returns true if x satisfies the protocol
-------------------------
clojure.core/seq?
([x])
  Return true if x implements ISeq
-------------------------
clojure.core/seqable?
([x])
  Return true if the seq function is supported for x
-------------------------
clojure.core/sequential?
([coll])
  Returns true if coll implements Sequential
-------------------------
clojure.core/set?
([x])
  Returns true if x implements IPersistentSet
-------------------------
clojure.core/simple-ident?
([x])
  Return true if x is a symbol or keyword without a namespace
-------------------------
clojure.core/simple-keyword?
([x])
  Return true if x is a keyword without a namespace
-------------------------
clojure.core/simple-symbol?
([x])
  Return true if x is a symbol without a namespace
-------------------------
clojure.core/some?
([x])
  Returns true if x is not , false otherwise.
-------------------------
clojure.core/sorted?
([coll])
  Returns true if coll implements Sorted
-------------------------
clojure.core/special-symbol?
([s])
  Returns true if s names a special form
-------------------------
clojure.core/string?
([x])
  Return true if x is a String
-------------------------
clojure.core/symbol?
([x])
  Return true if x is a Symbol
-------------------------
clojure.core/tagged-literal?
([value])
  Return true if the value is the data representation of a tagged literal
-------------------------
clojure.core/thread-bound?
([& vars])
  Returns true if all of the vars provided as arguments have thread-local bindings.
   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.
-------------------------
clojure.core/true?
([x])
  Returns true if x is the value true, false otherwise.
-------------------------
clojure.core/uri?
([x])
  Return true if x is a java.net.URI
-------------------------
clojure.core/uuid?
([x])
  Return true if x is a java.util.UUID
-------------------------
clojure.core/var?
([v])
  Returns true if v is of type clojure.lang.Var
-------------------------
clojure.core/vector?
([x])
  Return true if x implements IPersistentVector
-------------------------
clojure.core/volatile?
([x])
  Returns true if x is a volatile.
-------------------------
clojure.core/zero?
([num])
  Returns true if num is zero, else false
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.utils/newline?
([c])
  Checks whether the character is a newline
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.utils/numeric?
([ch])
  Checks whether a given character is numeric
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.utils/whitespace?
([ch])
  Checks whether a given character is whitespace
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.commons/number-literal?
([reader initch])
  Checks whether the reader is at the start of a number literal
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.info/qualified-symbol?
([x])
  Return true if `x` is a symbol with a namespace

  This is only available from Clojure 1.9 so we backport it until we
  drop support for Clojure 1.8.
-------------------------
dynapath.dynamic-classpath/can-add?
([cl])
  Must return true if add-classpath-url is implemented.
-------------------------
dynapath.dynamic-classpath/can-read?
([cl])
  Must return true if classpath-urls is implemented.
-------------------------
cemerick.pomegranate/modifiable-classloader?
([cl])
  Returns true iff the given ClassLoader is of a type that satisfies
   the dynapath.dynamic-classpath/DynamicClasspath protocol, and it can
   be modified.
-------------------------
clojure.pprint/integral?
([x])
  returns true if a number is actually an integer (that is, has no fractional part)
-------------------------
clojure.pprint/pretty-writer?
([x])
  Return true iff x is a PrettyWriter
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/comment?
([form])
  Returns true if form is a (comment ...)
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/ns-decl?
([form])
  Returns true if form is a (ns ...) declaration.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/option-spec?
([form])
  Returns true if form represents a libspec vector containing optional
  keyword arguments like [namespace :as alias] or
  [namespace :refer (x y)] or just [namespace]
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/prefix-spec?
([form])
  Returns true if form represents a libspec prefix list like
  (prefix name1 name1) or [com.example.prefix [name1 :as name1]]
-------------------------
leiningen.core.utils/ancestor?
([a b])
  Is a an ancestor of b?
-------------------------
leiningen.core.utils/symlink?
([file])
  Checks if a File is a symbolic link or points to another file.
-------------------------
leiningen.core.user/gpg-available?
([])
  Verifies (gpg-program) exists
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/has-tests?
([ns])
  Returns a truthy value if the namespace has any vars with `:test` metadata.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/in-project?
([url])
  Whether the URL is in the current project's directory.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/inlined-dependency?
([namespace])
  Returns true if the namespace matches one of our, or eastwood's,
   inlined dependencies.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/internal-namespace?
([namespace & [prefixes]])
  Returns true if the namespace matches the given prefixes.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.file/clojure-file?
([file])
  Returns true if the java.io.File represents a file which will be
  read by the Clojure (JVM) compiler.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.file/clojurescript-file?
([file])
  Returns true if the java.io.File represents a file which will be
  read by the ClojureScript compiler.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.file/file-with-extension?
([file extensions])
  Returns true if the java.io.File represents a file whose name ends
  with one of the Strings in extensions.
-------------------------
cider.nrepl.middleware.util.instrument/contains-recur?
([form])
  Return true if form is not a `loop` or a `fn` and a `recur` is found in it.
-------------------------
cider.nrepl.middleware.util.instrument/dont-break?
(~[[name :as form]]~)
  Return true if it's NOT ok to wrap form in a breakpoint.
  Expressions we don't want to wrap are those listed in
  `dont-break-forms` and anything containing a `recur`
  form (unless it's inside a `loop`).
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.inspect
  Clojure data structure inspection functionality.
  This code has a long history and at various points of
  time it lived in different projects. Originally
  it was part of swank-clojure, afterwards it was moved to
  javert, then forked to another project from which it
  was contributed to cider-nrepl. Finally cider-nrepl
  was split into two libraries and the code ended up here.

  Pretty wild, right?
#+end_results
** マップ/キーワード/レコード
マップ。
#+begin_src clojure
(def inventors {"Lisp" "McCarthy" "Clojure" "Hickey"})
#+end_src

#+RESULTS:
#+begin_results
#'user/inventors
#+end_results

みやすさのためにコロンを置くこともできる。
#+begin_src clojure
(def inventors {"Lisp" "McCarthy", "Clojure" "Hickey"})
#+end_src

#+RESULTS:
#+begin_results
#'user/inventors
#+end_results

マップは関数としても動作する。
#+begin_src clojure
  (inventors "Lisp")
#+end_src

#+RESULTS:
#+begin_results
McCarthy
#+end_results

~get~ 関数も使える。存在しない場合の値を指定できる。
#+begin_src clojure
  (get inventors "Lisp" "not find")
  (get inventors "Foo" "not find")
#+end_src

#+RESULTS:
#+begin_results
| "McCarthy" |
| "not find" |
#+end_results

~キーワード~ はシンボルに似ているが、コロンで始まる。評価されると自分自身を返す。
#+begin_src clojure
:foo
#+end_src

#+RESULTS:
#+begin_results
:foo
#+end_results

シンボルとは異なる。シンボルは評価されるとそれに結び付けられた何かを返そうとする。
#+begin_src clojure
foo
#+end_src

#+RESULTS:
#+begin_results
class clojure.lang.Compiler$CompilerException
#+end_results

キーワードをキーにして書き直す。
#+begin_src clojure
(def inventors {:Lisp "McCarthy" :Clojure "Hickey"})
#+end_src

#+RESULTS:
#+begin_results
#'user/inventors
#+end_results

~defrecord~ を使って構造体を定義することで、各マップがどういうキーを取りうるか明示し、強制できる。
#+begin_src clojure
  (defrecord Book [title author])
  (->Book "title" "author")
#+end_src

#+RESULTS:
#+begin_results
| user.Book                                    |
| #user.Book{:title "title", :author "author"} |
#+end_results

マップと同じように扱える。
#+begin_src clojure
  (def b (->Book "Anathem" "Neal Stephenson"))
  (:title b)
#+end_src

#+RESULTS:
#+begin_results
| #'user/b  |
| "Anathem" |
#+end_results
** リーダマクロ
Clojureのフォームはリーダによって読まれて、テキストからClojureのデータに変換される。
リーダマクロは前置される特定のマクロ文字によって起動される、リーダの特殊な動作。
コメントのセミコロンや、評価抑制のクォートもリーダマクロ。
** 関数
関数呼び出しは単に最初の要素が関数を指すようなリストである。
自分で関数を定義するには ~defn~ を使う( ~def~ ではない)。

#+begin_src clojure
  (defn greeting
    "Returns a greeting of the form 'Hello, username.'"
    [username]
    (str "Hello, " username))
  (greeting "world")
#+end_src

#+RESULTS:
#+begin_results
| #'user/greeting |
| "Hello, world"  |
#+end_results

同名の関数で受け取る引数が違うものを呼び出す。
ゼロ引数の ~greeting~ は1引数の ~greeting~ に渡して移譲できる。
 #+begin_src clojure
   (defn greeting
     "Returns a greeting of the form 'Hello, username.'
        Default username is 'world'."
     ([] (greeting "world"))
     ([username] (str "Hello, " username)))

   (greeting)
#+end_src

#+RESULTS:
#+begin_results
| #'user/greeting |
| "Hello, world"  |
#+end_results

フィルタ。
まず述語を定義する。
#+begin_src clojure
  (defn indexable-word? [word]
    (> (count word) 2))
#+end_src

#+RESULTS:
#+begin_results
#'user/indexable-word?
#+end_results

適用する。
#+begin_src clojure
  (require '[clojure.string :as str])
  (filter indexable-word? (str/split "A fine day it is" #"\W+"))
#+end_src

#+RESULTS:
#+begin_results
| fine | day |
#+end_results

無名関数バージョン。
#+begin_src clojure
  (filter (fn [w] (> (count w) 2)) (str/split "A fine day" #"\W+"))
#+end_src

#+RESULTS:
#+begin_results
| fine | day |
#+end_results

#+begin_src clojure
  (defn make-greeter [greeting-prefix]
    (fn [username] (str greeting-prefix ", " username)))

  (def hello-greeting (make-greeter "Hello"))
  (hello-greeting "world")

  (def aloha-greeting (make-greeter "Aloha"))
  (aloha-greeting "Hawaii")
#+end_src

#+RESULTS:
#+begin_results
| #'user/make-greeter   |
| #'user/hello-greeting |
| "Hello, world"        |
| #'user/aloha-greeting |
| "Aloha, Hawaii"       |
#+end_results

名前を与えなくてもいい。

#+begin_src clojure
((make-greeter "Howdy") "pardner")
#+end_src

#+RESULTS:
#+begin_results
Howdy, pardner
#+end_results
** var、束縛、名前空間
オブジェクトを ~def~ ~defn~ で定義すると、オブジェクトはClojureの ~var~ に格納される。

リーダマクロで user/foo に結び付けられた ~var~ を見る。
#+begin_src clojure
  (def foo 10)
  #'foo
#+end_src

#+RESULTS:
#+begin_results
| #'user/foo |
| #'user/foo |
#+end_results

実引数と仮引数のnumberが束縛される。
#+begin_src clojure
  (defn triple [number] (* 3 number))
  (triple 10)
#+end_src

#+RESULTS:
#+begin_results
| #'user/triple |
|            30 |
#+end_results

関数の引数束縛はレキシカルスコープ…関数本体の中だけから見える。

コレクション全体を変数に束縛する。
姓と名を両方とも保存するけど、名だけが必要な場合。
↓引数authorを取るが、必要なのは名だけで、ちょっとわかりにくい。
#+begin_src clojure
  (defn greet-author-1 [author]
    (println "Hello," (:first-name author)))
#+end_src

#+RESULTS:
#+begin_results
#'user/greet-author-1
#+end_results

必要な部分だけを束縛する。
#+begin_src clojure
  (defn greet-author-2 [{fname :first-name}]
    (println "Hello," fname))
#+end_src

アンダースコアは慣用的に値を気にしない束縛を示すのに使う。
#+begin_src clojure
(let [[_ _ z] [1 2 3]] z)
#+end_src

#+RESULTS:
#+begin_results
3
#+end_results

~as~ でコレクション自体に名前をつけることもできる。
#+begin_src clojure
  (let [[x y :as coords] [1 2 3 4 5 6]]
    (str "x: " x ", y: " y ", total dimensions " (count coords)))
#+end_src

#+RESULTS:
#+begin_results
x: 1, y: 2, total dimensions 6
#+end_results

分配束縛を使う。
[w1 w2 w3] への分配束縛によって最初の3つの単語が取り出される。
#+begin_src clojure
  (require '[clojure.string :as str])
  (defn ellipsize [words]
    (let [[w1 w2 w3] (str/split words #"\s+")]
      (str/join " " [w1 w2 w3 "..."])))

  (ellipsize "The quick brown fox jumps over the lazy dogs.")
#+end_src

#+RESULTS:
#+begin_results
| #'user/ellipsize      |
| "The quick brown ..." |
#+end_results

#+begin_src clojure
  (resolve 'foo)
  (in-ns 'myapp)
#+end_src

#+RESULTS:
#+begin_results
| #'user/foo        |
| #namespace[myapp] |
#+end_results

#+begin_src clojure
  (clojure.core/use 'clojure.core)
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** [[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]を呼び出す
#+begin_src clojure
(new java.util.Random)
#+end_src

#+RESULTS:
#+begin_results
#object[java.util.Random 0x499982f7 "java.util.Random@499982f7"]
#+end_results

#+begin_src clojure
  (def rnd (new java.util.Random))
#+end_src

#+RESULTS:
#+begin_results
#'user/rnd
#+end_results

#+begin_src clojure
  (. rnd nextInt)
#+end_src

#+RESULTS:
#+begin_results
1468370734
#+end_results

#+begin_src clojure
(. rnd nextInt 10)
#+end_src

#+RESULTS:
#+begin_results
9
#+end_results

~.~ はインスタンスのメソッドだけでなく、クラスメンバへのアクセスにも使える。
#+begin_src clojure
(. Math PI)
#+end_src

#+RESULTS:
#+begin_results
3.141592653589793
#+end_results

ブラウザで該当ドキュメントに移動する。
#+begin_src clojure
(javadoc java.net.URL)
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results
** フロー制御
#+begin_src clojure
  (defn is-small? [number]
    (if (< number 100) "yes" "no"))

  (is-small? 50)
  (is-small? 101)
#+end_src

#+RESULTS:
#+begin_results
| #'user/is-small? |
| "yes"            |
| "no"             |
#+end_results

分岐後に複数のアクションを起こす、には ~do~ を使う。
~do~ は副作用をもたらすという明示になる。
#+begin_src clojure
  (defn is-small? [number]
    (if (< number 100)
      "yes"
      (do
        (println "Saw a big number" number)
        "no")))
  (is-small? 200)
#+end_src

~loop~ を使っての再帰。
#+begin_src clojure
  (loop [result [] x 5]
    (if (zero? x)
      result
      (recur (conj result x) (dec x))))
#+end_src

#+RESULTS:
#+begin_results
| 5 | 4 | 3 | 2 | 1 |
#+end_results

#+begin_src clojure
  (defn countdown [result x]
    (if (zero? x)
      result
      (recur (conj result x) (dec x))))

  (countdown [] 5)
#+end_src

#+RESULTS:
#+begin_results
| #'user/countdown |
| [5 4 3 2 1]      |
#+end_results

さまざまなカウントダウン。
#+begin_src clojure
(into [] (take 5 (iterate dec 5)))
#+end_src

#+RESULTS:
#+begin_results
| 5 | 4 | 3 | 2 | 1 |
#+end_results

#+begin_src clojure
(into [] (drop-last (reverse (range 6))))
#+end_src

#+RESULTS:
#+begin_results
| 5 | 4 | 3 | 2 | 1 |
#+end_results

#+begin_src clojure
(vec (reverse (rest (range 6))))
#+end_src

#+RESULTS:
#+begin_results
| 5 | 4 | 3 | 2 | 1 |
#+end_results

#+begin_src clojure
  (defn indexed [coll] (map-indexed vector coll))
  (indexed "abcde")
#+end_src

#+RESULTS:
#+begin_results
| #'user/indexed                       |
| ([0 \a] [1 \b] [2 \c] [3 \d] [4 \e]) |
#+end_results

#+begin_src clojure
(indexed "abcde")
#+end_src

clojureの ~for~ はループではなく、シーケンスの内包表記である。
#+begin_src clojure
  (defn index-filter [pred coll]
    (when pred
      (for [[idx elt] (indexed coll) :when (pred elt)] idx)))
  (index-filter #{\a \b} "abcdbbb")
  (index-filter #{\a \b} "xyz")
#+end_src

#+RESULTS:
#+begin_results
| #'user/index-filter |
| (0 1 4 5 6)         |
| ()                  |
#+end_results

#+begin_src clojure
  (defn index-of-any [pred coll]
    (first (index-filter pred coll)))
  (index-of-any #{\z \a} "zzabyycdxx")
  (index-of-any #{\b \y} "zzabyycdxx")
#+end_src

#+RESULTS:
#+begin_results
| #'user/index-of-any |
|                   0 |
|                   3 |
#+end_results
** メタデータ
#+begin_src clojure
(meta #'str)
#+end_src

#+RESULTS:
#+begin_results
'(:added "1.0"  :ns #namespace(clojure.core)  :name str  :file "clojure/core.clj"  :static true  :column 1  :line 544  :tag java.lang.String  :arglists (() (x) (x & ys))  :doc "With no args, returns the empty string. With one arg x, returns\\n  x.toString().  (str ) returns the empty string. With more than\\n  one arg, returns the concatenation of the str values of the args.")
#+end_results

#+begin_src clojure
  (defn ^{:tag String} shout [^{:tag String} s] (.toUpperCase s))
  (meta #'shout)
#+end_src

#+RESULTS:
#+begin_results
| #'user/shout                                                                                                                                    |
| {:tag java.lang.String, :arglists ([s]), :line 1, :column 1, :file "*cider-repl ~/roam:localhost:40825(clj)*", :name shout, :ns #namespace[user]} |
#+end_results

あるいは略記法で書ける。
#+begin_src clojure
  (defn ^String shout [^String s] (.toUpperCase s))
#+end_src

#+RESULTS:
#+begin_results
#'user/shout
#+end_results
** シーケンス
シーケンスはいろんなデータ構造の抽象。

#+begin_src clojure
(class (rest [1 2 3]))
#+end_src

#+RESULTS:
#+begin_results
clojure.lang.PersistentVector$ChunkedSeq
#+end_results

#+begin_src clojure
  (first ["a" "b"])
  (rest ["a" "b"])
  (cons "a" "b")
#+end_src

#+RESULTS:
#+begin_results
| "a"      |
| ("b")    |
| ("a" \b) |
#+end_results

マップはキー/値のペアを要素とするシーケンスとして扱える。
#+begin_src clojure
  (first {:fname "Aaron" :lname "Bedra"})
  (rest {:fname "Aaron" :lname "Bedra"})
  (cons [:mname "James"] {:fname "Aaron" :lname "Bedra"})
#+end_src

#+RESULTS:
#+begin_results
| [:fname "Aaron"]                                     |
| ([:lname "Bedra"])                                   |
| ([:mname "James"] [:fname "Aaron"] [:lname "Bedra"]) |
#+end_results

~conj~ と ~info~ は効率的に追加できる位置に要素を加える。
対象となるデータ構造について一番効率の良い操作をしてくれるので、具体的な実装に結び付けなくても効率的なコードが書ける。
#+begin_src clojure
(conj '(1 2 3) :a)
#+end_src

#+RESULTS:
#+begin_results
| :a | 1 | 2 | 3 |
#+end_results

#+begin_src clojure
(into '(1 2 3) '(:a :b :c))
#+end_src

#+RESULTS:
#+begin_results
| :c | :b | :a | 1 | 2 | 3 |
#+end_results
** シーケンスライブラリ
*** シーケンスを生成する関数
#+begin_src clojure
  (range 10)
  (range 10 20)
  (range 10 20 2)
#+end_src

#+RESULTS:
#+begin_results
| (0 1 2 3 4 5 6 7 8 9)           |
| (10 11 12 13 14 15 16 17 18 19) |
| (10 12 14 16 18)                |
#+end_results

↓なぜか実行できない。
#+begin_src clojure
(repeat 5 "x")
#+end_src

シーケンスは無限に続くので取り出しが必要。
#+begin_src clojure
(take 10 (iterate inc 1))
#+end_src

#+RESULTS:
#+begin_results
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
#+end_results

#+begin_src clojure
(defn whole-numbers [] (iterate inc 1))
#+end_src

#+RESULTS:
#+begin_results
#'user/whole-numbers
#+end_results

#+begin_src clojure
(take 4 (repeat 1))
#+end_src

#+RESULTS:
#+begin_results
| 1 | 1 | 1 | 1 |
#+end_results

#+begin_src clojure
(take 10 (cycle (range 3)))
#+end_src

#+RESULTS:
#+begin_results
| 0 | 1 | 2 | 0 | 1 | 2 | 0 | 1 | 2 | 0 |
#+end_results

#+begin_src clojure
(interpose "," ["apple" "banana" "grapes"])
#+end_src

#+RESULTS:
#+begin_results
| apple | , | banana | , | grapes |
#+end_results

#+begin_src clojure
  (use '[clojure.string :only (join)])
  (join \, ["apples" "banana", "grapes"])
#+end_src

#+RESULTS:
#+begin_results
apples,banana,grapes
#+end_results
*** シーケンスをフィルタする関数
#+begin_src clojure
(take 10 (filter even? (whole-numbers)))
#+end_src

#+RESULTS:
#+begin_results
| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |
#+end_results

#+begin_src clojure
(take 10 (filter odd? (whole-numbers)))
#+end_src

#+RESULTS:
#+begin_results
| 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 |
#+end_results

最初の母音に出会うまで文字列から文字を取り出す操作。
#+begin_src clojure
(take-while (complement #{\a\e\i\o\u}) "the-quick-brown-fox")
#+end_src

#+RESULTS:
#+begin_results
(\t \h)
#+end_results

#+begin_src clojure
(drop-while (complement #{\a\e\i\o\u}) "the-quick-brown-fox")
#+end_src

#+RESULTS:
#+begin_results
(\e \- \q \u \i \c \k \- \b \r \o \w \n \- \f \o \x)
#+end_results

#+begin_src clojure
(split-at 5 (range 10))
#+end_src

#+RESULTS:
#+begin_results
| 0 | 1 | 2 | 3 | 4 |
| 5 | 6 | 7 | 8 | 9 |
#+end_results

#+begin_src clojure
(split-with #(<= % 10) (range 0 20 2))
#+end_src

#+RESULTS:
#+begin_results
|  0 |  2 |  4 |  6 | 8 | 10 |
| 12 | 14 | 16 | 18 |   |    |
#+end_results
*** シーケンスに対する述語
述語をそれぞれ適応して真偽値を返す。
#+begin_src clojure
  (every? odd? [1 3 5])
  (every? odd? [1 3 8])
#+end_src

#+RESULTS:
#+begin_results
| true  |
| false |
#+end_results

いずれかが条件に合わない時はnilを返す。
#+begin_src clojure
  (some even? [1 2 3])
  (some even? [1 3 5])
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

#+begin_src clojure
(some identity [nil false 1 nil 2])
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

#+begin_src clojure
(not-every? even? (whole-numbers))
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

#+begin_src clojure
(not-any? even? (take 10 (whole-numbers)))
#+end_src

#+RESULTS:
#+begin_results
false
#+end_results
*** シーケンスを変換する関数
各リストに関数を適用する。
#+begin_src clojure
(map #(format "<p>%s</p>" %) ["the" "quick" "brown" "fox"])
#+end_src

#+RESULTS:
#+begin_results
| <p>the</p> | <p>quick</p> | <p>brown</p> | <p>fox</p> |
#+end_results

シーケンスの中身をまとめ上げる。
#+begin_src clojure
(reduce + (range 1 11))
#+end_src

#+RESULTS:
#+begin_results
55
#+end_results

#+begin_src clojure
(reduce * (range 1 11))
#+end_src

#+RESULTS:
#+begin_results
3628800
#+end_results

#+begin_src clojure
(sort [42 1 7 11])
#+end_src

#+RESULTS:
#+begin_results
| 1 | 7 | 11 | 42 |
#+end_results

#+begin_src clojure
(sort-by #(.toString %) [42 1 7 11])
#+end_src

#+RESULTS:
#+begin_results
| 1 | 11 | 42 | 7 |
#+end_results

ソートの順番を変えられる。
#+begin_src clojure
  (sort > [42 1 7 11])
  (sort < [42 1 7 11])
#+end_src

#+RESULTS:
#+begin_results
| (42 11 7 1) |
| (1 7 11 42) |
#+end_results

リスト内包表記バージョン。
#+begin_src clojure
  (for [word ["the" "quick" "brown" "fox"]]
    (format "<p>%s</p>" word))
#+end_src

#+RESULTS:
#+begin_results
| <p>the</p> | <p>quick</p> | <p>brown</p> | <p>fox</p> |
#+end_results

~:when~ 節を使うと ~filter~ をエミュレートできる。
#+begin_src clojure
(take 10 (for [n (whole-numbers) :when (even? n)] n))
#+end_src

#+RESULTS:
#+begin_results
| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |
#+end_results

1番右側の束縛を最初に繰り返し、1度繰り返すたびにその左側の操作を1つ進める。
なのでrankの繰り返しが先に行われる。
#+begin_src clojure
(for [file "ABCDEFGH" rank (range 1 9)] (format "%c%d" file rank))
#+end_src

#+RESULTS:
#+begin_results
| A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | G1 | G2 | G3 | G4 | G5 | G6 | G7 | G8 | H1 | H2 | H3 | H4 | H5 | H6 | H7 | H8 |
#+end_results
** 遅延シーケンスと無限シーケンス
リストは必要なときに作られる。
#+begin_src clojure
  (use 'examples.primes)
  (def ordinals-and-primes (map vector (iterate inc 1) primes))
  (take 5 (drop 1000 ordinals-and-primes))
#+end_src

#+RESULTS:
#+begin_results
| #'examples.primes/ordinals-and-primes                         |
| ([1001 7927] [1002 7933] [1003 7937] [1004 7949] [1005 7951]) |
#+end_results

遅延なので、副作用が動かないように見える。
#+begin_src clojure
  (def x (for [i (range 1 3)] (do (println i) i)))
  x ;; 標準入力に出ない
#+end_src

#+RESULTS:
#+begin_results
| #'user/x |
| (1 2)    |
#+end_results

シーケンスの要素をすべて計算する。
#+begin_src clojure
(doall x)
#+end_src

#+RESULTS:
#+begin_results
| 1 | 2 |
#+end_results

#+begin_src clojure
  (def x (for [i (range 1 3)] (do (println i) i)))
  x
#+end_src

#+RESULTS:
#+begin_results
| #'user/x |
| (1 2)    |
#+end_results
** シーカブル
シーケンス関数に渡されると、[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]のコレクションは自動的にシーケンスとして振る舞う。
シーケンスとして振る舞えるコレクションをシーカブルであるという。

配列はシーカブル。
#+begin_src clojure
  (first (.getBytes "hello"))
  (rest (.getBytes "hello"))
  (cons (int \h) (.getBytes "ello"))
#+end_src

#+RESULTS:
#+begin_results
| 104                   |
| (101 108 108 111)     |
| (104 101 108 108 111) |
#+end_results

文字列もシーカブル。
#+begin_src clojure
  (first "Hello")
  (rest "Hello")
  (cons \H "ello")
#+end_src

#+RESULTS:
#+begin_results
| \H               |
| (\e \l \l \o)    |
| (\H \e \l \l \o) |
#+end_results

逆にして、戻す。
#+begin_src clojure
  (reverse "hello")
  (apply str (reverse "hello"))
#+end_src

#+RESULTS:
#+begin_results
| (\o \l \l \e \h) |
| "olleh"          |
#+end_results

[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]のコレクションを使うのは、[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]のAPIを扱うときだけ(Clojure組み込みのコレクションの方が便利)。
** 正規表現
マッチした文字列からなる変更不可なシーケンスを作り出す。
シーケンスライブラリの関数群がただで正規表現にも使えるようになる。
#+begin_src clojure
  (re-seq #"\w+" "the quick brown fox")
  (sort (re-seq #"\w+" "the quick brown fox"))
  (drop 2 (re-seq #"\w+" "the quick brown fox"))
  (map #(.toUpperCase %) (re-seq #"\w+" "the quick brown fox"))
#+end_src

#+RESULTS:
#+begin_results
| ("the" "quick" "brown" "fox") |
| ("brown" "fox" "quick" "the") |
| ("brown" "fox")               |
| ("THE" "QUICK" "BROWN" "FOX") |
#+end_results

#+begin_src clojure
  (import '(java.io File))
  (map #(.getName %) (.listFiles (File. "./public/css")))
#+end_src

#+RESULTS:
#+begin_results
| java.io.File            |
| ("site.css" "code.css") |
#+end_results

ディレクトリを深さ優先で辿る。
#+begin_src clojure
(count (file-seq (File. "./public")))
#+end_src

#+RESULTS:
#+begin_results
101
#+end_results

最近更新されたファイルだけを調べる。
#+begin_src clojure
  (defn minutes-to-millis [mins]
    (* mins 1000 60))
  (defn recently-modified? [file]
    (> (.lastModified file)
       (- (System/currentTimeMillis) (minutes-to-millis 30))))
  (filter recently-modified? (file-seq (File. ".")))
#+end_src

#+RESULTS:
#+begin_results
| #'user/minutes-to-millis                                                                                    |
| #'user/recently-modified?                                                                                   |
| (#object[java.io.File 0x6bf2183f "./20210926143813-clojure.org"] #object[java.io.File 0x70ca1df7 "./.git"]) |
#+end_results

読み込む(readerをオープンしたまま)。
#+begin_src clojure
  (use '[clojure.java.io :only (reader)])
  (take 2 (line-seq (reader "public/index.html")))
#+end_src

#+RESULTS:
#+begin_results
| <!DOCTYPE html> | <html lang="en"> |
#+end_results

リーダーをちゃんと閉じる。
#+begin_src clojure
  (with-open [rdr (reader "./public/index.html")]
    (count (line-seq rdr)))
#+end_src

#+RESULTS:
#+begin_results
107
#+end_results

空行を除いた行数。
#+begin_src clojure
  (with-open [rdr (reader "./public/index.html")]
    (count (filter #(re-find #"\S" %) (line-seq rdr))))
#+end_src

#+RESULTS:
#+begin_results
98
#+end_results

orgコードの行数を数え上げる。
#+begin_src clojure
  (use '[clojure.java.io :only (reader)])
  (defn non-blank? [line] (if (re-find #"\S" line) true false))
  (defn non-svn? [file] (not (.contains (.toString file) ".svn")))
  (defn org-source? [file] (.endsWith (.toString file) ".org"))
  (defn org-loc [base-file]
    (reduce
     +
     (for [file (file-seq base-file)
           :when (and (org-source? file) (non-svn? file))]
       (with-open [rdr (reader file)]
         (count (filter non-blank? (line-seq rdr)))))))
  (org-loc (java.io.File. "./"))
#+end_src

#+RESULTS:
#+begin_results
| #'user/non-blank?  |
| #'user/non-svn?    |
| #'user/org-source? |
| #'user/org-loc     |
| 12299              |
#+end_results
** 特定の構造に特化した関数
シーケンス関数を使うと汎用性の高いコードが書ける。
リスト、ベクタ、マップ、セットに特化した関数もある。
#+begin_src clojure
  (peek '(1 2 3))
  (pop '(1 2 3))
#+end_src

#+RESULTS:
#+begin_results
|     1 |
| (2 3) |
#+end_results

#+begin_src clojure
  (get [:a :b :c] 1)
  (get [:a :b :c] 5) ;; nil
#+end_src

#+RESULTS:
#+begin_results
:b
#+end_results

指定のインデックスに新しい値を入れる。
#+begin_src clojure
  (assoc [0 1 2 3 4] 2 :two)
  (subvec [1 2 3 4 5] 3)
  (take 2 (drop 3 [1 2 3 4 5]))
#+end_src

#+RESULTS:
#+begin_results
| [0 1 :two 3 4] |
| [4 5]          |
| (4 5)          |
#+end_results

特定の構造向けの関数がある場合、それは性能のためであることがほとんど。
#+begin_src clojure
  (keys {:sundance "spaniel", :darwin "beagle"})
  (vals {:sundance "spaniel", :darwin "beagle"})
#+end_src

#+RESULTS:
#+begin_results
| (:sundance :darwin)  |
| ("spaniel" "beagle") |
#+end_results

#+begin_src clojure
  (get {:sundance "spaniel", :darwin "beagle"} :darwin)
  ({:sundance "spaniel", :darwin "beagle"} :darwin)
  (:darwin {:sundance "spaniel", :darwin "beagle"})
#+end_src

#+RESULTS:
#+begin_results
| "beagle" |
| "beagle" |
| "beagle" |
#+end_results

キーとして持っていれば値に関わらずtrueを返す。
#+begin_src clojure
  (def score {:stu nil :joey 100})
  (contains? score :stu)
#+end_src

#+RESULTS:
#+begin_results
| #'user/score |
| true         |
#+end_results

#+begin_src clojure
  (def song {:name "Agnus Dei"
             :artist "Kryzysztof Penderecki"
             :album "Polish Requiem"
             :genre "Classical"})

  song
  (assoc song :kind "MPEG Audio File")
  (dissoc song :genre)
  (select-keys song [:name :artist])
  (merge song {:size 8118166, :time 507245})
#+end_src

#+RESULTS:
#+begin_results
| #'user/song                                                                                                                    |
| {:name "Agnus Dei", :artist "Kryzysztof Penderecki", :album "Polish Requiem", :genre "Classical"}                              |
| {:name "Agnus Dei", :artist "Kryzysztof Penderecki", :album "Polish Requiem", :genre "Classical", :kind "MPEG Audio File"}     |
| {:name "Agnus Dei", :artist "Kryzysztof Penderecki", :album "Polish Requiem"}                                                  |
| {:name "Agnus Dei", :artist "Kryzysztof Penderecki"}                                                                           |
| {:name "Agnus Dei", :artist "Kryzysztof Penderecki", :album "Polish Requiem", :genre "Classical", :size 8118166, :time 507245} |
#+end_results

同じキーを持っていた場合、どうやって値を組み合わせるかを指定する関数を与える。
#+begin_src clojure
  (merge-with
   concat
   {:rubble ["Barney"], :flintstone ["Fred"]}
   {:rubble ["Betty"], :flintstone ["Wilma"]}
   {:rubble ["Bam-Bam"], :flintstone ["Pebbles"]})
#+end_src

#+RESULTS:
#+begin_results
| :rubble | (Barney Betty Bam-Bam) | :flintstone | (Fred Wilma Pebbles) |
#+end_results

* Tasks
** TODO プログラミングClojure
:LOGBOOK:
CLOCK: [2021-10-18 Mon 23:03]--[2021-10-18 Mon 23:54] =>  0:51
CLOCK: [2021-10-17 Sun 19:47]--[2021-10-17 Sun 21:16] =>  1:29
CLOCK: [2021-10-17 Sun 15:04]--[2021-10-17 Sun 16:00] =>  0:56
CLOCK: [2021-10-17 Sun 13:06]--[2021-10-17 Sun 13:24] =>  0:18
CLOCK: [2021-10-17 Sun 10:43]--[2021-10-17 Sun 11:24] =>  0:41
CLOCK: [2021-10-17 Sun 09:49]--[2021-10-17 Sun 10:14] =>  0:25
CLOCK: [2021-10-16 Sat 23:02]--[2021-10-16 Sat 23:42] =>  0:40
CLOCK: [2021-10-16 Sat 17:28]--[2021-10-16 Sat 17:53] =>  0:25
:END:

- 37, 39, 44, 56, 67, 74
* Reference
** [[https://www.infoq.com/presentations/Simple-Made-Easy/][Simple Made Easy]]
clojure開発者リッチ・ヒッキーのプレゼン。
** [[https://boxofpapers.hatenablog.com/entry/simple_made_easy][Clojureと「Simple Made Easy」 - 紙箱]]
リッチ・ヒッキーのプレゼンの解説。
簡単とシンプルさを分ける。抽象化によってシンプルさを保つ。
** [[https://github.com/stuarthalloway/programming-clojure][stuarthalloway/programming-clojure: Sample code for the book]]
clojureの本のサンプルコード。
** [[https://github.com/technomancy/leiningen][technomancy/leiningen: Automate Clojure projects without setting your hair on fire.]]
clojureの依存解決ライブラリ。
** [[http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html][「名詞の王国での実行」Stevey's Blog Rants: Execution in the Kingdom of Nouns]]
オブジェクト指向では名詞が重要な地位を占めている。
**  [[https://www.geidai.ac.jp/~marui/clojure/rationale/][Clojureをつくったわけ]]
clojureの特徴がわかる。
* Archive
