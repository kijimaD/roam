:PROPERTIES:
:ID:       6218deb2-43df-473a-8cdf-910c47edd801
:header-args+: :wrap
:END:
#+title: Clojure
* 概要
Clojureは[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]、[[id:18fbe00f-4ec8-4ca0-adfa-2d1381669642][LISP]]の方言の1つ。
プログラムは[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]仮想マシン、.NETで動作する。

* Memo
** インストール
- Javaのランタイム
- Leiningen...依存関係管理。
#+begin_src shell
  sudo apt-get install leiningen
  lein repl
#+end_src
** Hello, world
#+begin_src clojure :results output
  (println "hello world")
#+end_src

#+RESULTS:
#+begin_results
hello world
#+end_results

#+begin_src clojure
  (defn hello [name] (str "Hello, " name))
#+end_src

#+RESULTS:
#+begin_results
#'user/hello
#+end_results

#+begin_src clojure
  (defn hello-world [username]
    (println (format "Hello, %s" username)))
#+end_src

#+RESULTS:
#+begin_results
#'user/hello-world
#+end_results

状態を共有する。
セットに要素を1つ追加する。
#+begin_src clojure
  (conj coll item)
  (conj #{} "Stu")
#+end_src

#+RESULTS:
#+begin_results
| class clojure.lang.Compiler$CompilerException |
| #{"Stu"}                                      |
#+end_results

セットを知る。
~conj~ を ~update~-fn として渡す。
#+begin_src clojure
  (def visitors (atom #{}))
  (swap! visitors conj "Stu")
#+end_src

#+RESULTS:
#+begin_results
| #'user/visitors |
| #{"Stu"}        |
#+end_results

~atom~ はClojureが持つリファレンスタイプのひとつ。
~ref~ の中身は ~deref~ で見ることができる。略記として ~@~ を使える。

#+begin_src clojure
  (deref visitors)
  @visitors
#+end_src

#+RESULTS:
#+begin_results
| #{"Stu"} |
| #{"Stu"} |
#+end_results

#+begin_src clojure
  (defn hello
    "Writes hello message to *out*. Calls you by username.
  Knows if you have been here before."
    [username]
    (swap! visitors conj username)
    (str "Hello, " username))
#+end_src

#+RESULTS:
#+begin_results
#'user/hello
#+end_results

#+begin_src clojure
  (hello "Rich")
  @visitors
#+end_src

#+RESULTS:
#+begin_results
| "Hello, Rich"   |
| #{"Stu" "Rich"} |
#+end_results

状態の問題。それまでにどういう動作をしたかによって、結果が異なってくる。
純粋な関数なら、局所的な知識だけで動作を理解できるが、状態が絡むとそこに至るすべての履歴を理解しなければならない。
** ライブラリ
~use~ は ~require~ と ~refer~ を一度にやってくれる。
#+begin_src clojure
  (require 'clojure.java.io)
  (use 'clojure.java.io)
#+end_src

#+RESULTS:
#+begin_results
#+end_results

再読込。

#+begin_src clojure
  (use :reload 'clojure.java.io)
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** ドキュメント検索
#+begin_src clojure :results output
  (doc str)
#+end_src

#+RESULTS:
#+begin_results
-------------------------
clojure.core/str
([] [x] [x & ys])
  With no args, returns the empty string. With one arg x, returns
  x.toString().  (str ) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.
#+end_results

#+begin_src clojure  :results output
(find-doc "reduce")
#+end_src

#+RESULTS:
#+begin_results
-------------------------
cider.nrepl.middleware.track-state/fast-reduce
([f coll])
  Like (reduce f {} coll), but faster.
  Inside f, use `assoc!` and `conj!` instead of `assoc` and `conj`.
-------------------------
clojure.core/areduce
([a idx ret init expr])
Macro
  Reduces an expression across an array a, using an index named idx,
  and return value named ret, initialized to init, setting ret to the
  evaluation of expr at each step, returning ret.
-------------------------
clojure.core/eduction
([xform* coll])
  Returns a reducible/iterable application of the transducers
  to the items in coll. Transducers are applied in order as if
  combined with comp. Note that these applications will be
  performed every time reduce/iterator is called.
-------------------------
clojure.core/ensure-reduced
([x])
  If x is already reduced?, returns it, else returns (reduced x)
-------------------------
clojure.core/reduce
([f coll] [f val coll])
  f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.
-------------------------
clojure.core/reduce-kv
([f init coll])
  Reduces an associative collection. f should be a function of 3
  arguments. Returns the result of applying f to init, the first key
  and the first value in coll, then applying f to that result and the
  2nd key and value, etc. If coll contains no entries, returns init
  and f is not called. Note that reduce-kv is supported on vectors,
  where the keys will be the ordinals.
-------------------------
clojure.core/reduced
([x])
  Wraps x in a way such that a reduce will terminate with the value x
-------------------------
clojure.core/reduced?
([x])
  Returns true if x is the result of a call to reduced
-------------------------
clojure.core/reductions
([f coll] [f init coll])
  Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init.
-------------------------
clojure.core/require
([& args])
  Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A 'lib' is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib's
  name also locates its root directory within classpath using Java's
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  'require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol 'x.y.z; it has the root directory
  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or
  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The
  root resource should contain code to create the lib's
  namespace (usually by using the ns macro) and load any additional
  lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib's namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It's common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as 's'.

  (require '(clojure zip [set :as s]))
-------------------------
clojure.core/run!
([proc coll])
  Runs the supplied procedure (via reduce), for purposes of side
  effects, on successive items in the collection. Returns
-------------------------
clojure.core/transduce
([xform f coll] [xform f init coll])
  reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with 'completing'. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.
-------------------------
clojure.core/unreduced
([x])
  If x is reduced?, returns (deref x), else returns x
-------------------------
clojure.core.protocols/CollReduce
  Protocol for collection types that can implement reduce faster than
  first/next recursion. Called by clojure.core/reduce. Baseline
  implementation defined in terms of Iterable.
-------------------------
clojure.core.protocols/IKVReduce
  Protocol for concrete associative types that can reduce themselves
   via a function of key and val faster than first/next recursion over map
   entries. Called by clojure.core/reduce-kv, and has same
   semantics (just different arg order).
-------------------------
clojure.core.protocols/InternalReduce
  Protocol for concrete seq types that can reduce themselves
   faster than first/next recursion. Called by clojure.core/reduce.
-------------------------
clojure.core.protocols/interface-or-naive-reduce
([coll f val])
  Reduces via IReduceInit if possible, else naively.
-------------------------
clojure.core.protocols/naive-seq-reduce
([s f val])
  Reduces a seq, ignoring any opportunities to switch to a more
  specialized implementation.
-------------------------
cider.nrepl.middleware.util.instrument/strip-instrumentation-meta
([form])
  Remove all tags in order to reduce java bytecode size and enjoy cleaner code
  printouts. We keep ::breakfunction for def symbols because that is how we
  identify currently instrumented vars in list-instrumented-defs.
#+end_results
** clojure関数のソースを見る
~repl~ ライブラリを使う。
#+begin_src clojure
  (use 'clojure.repl)
  (source identity)
#+end_src

#+RESULTS:
#+begin_results
#+end_results

Clojureのコレクションが[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]のコレクションであることを確かめる。
#+begin_src clojure
  (ancestors (class [1 2 3]))
#+end_src

#+RESULTS:
#+begin_results
#{clojure.lang.IPersistentVector clojure.lang.Indexed clojure.lang.IMeta clojure.lang.ILookup java.lang.Runnable java.lang.Iterable java.util.List clojure.lang.IPersistentCollection java.io.Serializable clojure.lang.IEditableCollection java.util.Collection clojure.lang.Seqable java.util.concurrent.Callable clojure.lang.IHashEq clojure.lang.Counted java.util.RandomAccess clojure.lang.Associative clojure.lang.IFn clojure.lang.Reversible clojure.lang.IObj clojure.lang.IReduceInit clojure.lang.AFn java.lang.Object clojure.lang.IReduce clojure.lang.Sequential clojure.lang.IPersistentStack clojure.lang.IKVReduce clojure.lang.APersistentVector java.lang.Comparable}
#+end_results

** フォーム
- Clojureは同図像性を持つ。
- ClojureのコードはClojureのデータによって組み立てられる。
- Clojureのプログラムを走らせるときには、まずClojureの中の ~リーダ~ と呼ばれる部分がプログラムを ~フォーム~ と呼ばれる単位ごとに読み込んで、それをClojureのデータ構造へと変換する。そしてデータ構造をコンパイルして実行する。

フォームにはブール値、文字、キーワード、リスト、マップ…などがある。
** シンボル
シンボルは、Clojure内のあらゆる種類のものの名前として使う。

ドットで[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]メソッドの呼び出しであると判断する。
#+begin_src clojure
  (.toUpperCase "hello")
  (str "hello")
#+end_src

#+RESULTS:
#+begin_results
| "HELLO" |
| "hello" |
#+end_results


リテラル表記は ~\{letter}~ 。
#+begin_src clojure
(str \h \e \y \space \y \o \u)
#+end_src

#+RESULTS:
#+begin_results
hey you
#+end_results

文字を交互に結合。
#+begin_src clojure
(interleave "Attack at midnight" "The purple elephant chortled")
#+end_src

#+RESULTS:
#+begin_results
(\A \T \t \h \t \e \a \space \c \p \k \u \space \r \a \p \t \l \space \e \m \space \i \e \d \l \n \e \i \p \g \h \h \a \t \n)
#+end_results

文字列に戻す。
#+begin_src clojure
(apply str (interleave "Attack at midnight" "The purple elephant chortled"))
#+end_src

#+RESULTS:
#+begin_results
ATthtea cpku raptl em iedlneipghhatn
#+end_results

復元する。
#+begin_src clojure
  (apply str (take-nth 2 "ATthtea cpku raptl em iedlneipghhatn"))
#+end_src

#+RESULTS:
#+begin_results
| "clojure.lang.LazySeq@c855d426" |
| "Attack at midnight"            |
#+end_results

Clojureでは空リストは偽ではない。
#+begin_src clojure
(if () "We are in Clojure!" "We are in Common Lisp!")
#+end_src

#+RESULTS:
#+begin_results
We are in Clojure!
#+end_results

~true?~ は値が ~true~ そのものであるかを調べる。
#+begin_src clojure
  (true? true)
  (true? "foo")
#+end_src

#+RESULTS:
#+begin_results
| true  |
| false |
#+end_results

#+begin_src clojure
  (zero? 0.0)
#+end_src

#+RESULTS:
#+begin_results
true
#+end_results

述語一覧。
#+begin_src clojure :results output :evel never
(find-doc #"\?$")
#+end_src

#+RESULTS:
#+begin_results
-------------------------
nrepl.middleware.interruptible-eval/interrupted?
([e])
  Returns true if the given throwable was ultimately caused by an interrupt.
-------------------------
leiningen.core.classpath/ext-dependency?
([dep])
  Should the given dependency be loaded in the extensions classloader?
-------------------------
leiningen.core.pedantic/range?
([{:keys [node]}])
  Does the path point to a DependencyNode asking for a version range?
-------------------------
leiningen.core.pedantic/top-level?
([{:keys [parents]}])
  Is the path a top level dependency in the project?
-------------------------
clojure.test/function?
([x])
  Returns true if argument is a function or a symbol that resolves to
  a function (not a macro).
-------------------------
clojure.test/successful?
([summary])
  Returns true if the given test summary indicates all tests
  were successful, false otherwise.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader/garg
([n])
  Get a symbol for an anonymous ?argument?
-------------------------
dynapath.util/addable-classpath?
([cl])
  Returns true if the given ClassLoader provides add-claspath-url.
-------------------------
dynapath.util/readable-classpath?
([cl])
  Returns true if the given ClassLoader provides classpath-urls.
-------------------------
cider.nrepl.middleware.debug/looks-step-innable?
([form])
  Decide whether a form looks like a call to a function that we could
  instrument and step into.
-------------------------
cider.nrepl.middleware.debug/safe-to-debug?
([ns])
  Some namespaces are not safe to debug, because doing so can cause a stack
  overflow that crashes the nrepl process.
-------------------------
cider.nrepl.middleware.debug/skip-breaks?
([coor STATE__])
  True if the breakpoint at coordinates should be skipped.

  The `*skip-breaks*` map stores a `mode`, `coordinates`, the `code` that it
  applies to, and a `force?` flag.

  Behaviour depends on the `mode`:
   - :all - return true, skipping all breaks
   - :trace - return false, skip nothing
   - :deeper - return true if the given coordinates are deeper than the
               coordinates stored in `*skip-breaks*`, in the same code
   - :before - return true if the given coordinates represent a place before
               the coordinates in `*skip-breaks*`, in the same code

  For :deeper and :before, if we are not in the same code (i.e. we have stepped
  into another instrumented function and code argument doesn't match old code in
  *skip-breaks*), then return the value of `force?`.
-------------------------
cider.nrepl.middleware.debug/step-in?
([v coor code])
  Return true if we can and should step in to the function in the var `v`.
  The "should" part is determined by the value in `step-in-to-next?`, which
  gets set to true by the user sending the "step in" command.
-------------------------
clojure.core.specs.alpha/even-number-of-forms?
([forms])
  Returns true if there are an even number of forms in a binding vector
-------------------------
nrepl.middleware.session/interrupted?
([e])
  Returns true if the given throwable was ultimately caused by an interrupt.
-------------------------
cider.nrepl.inlined-deps.javaclasspath.v1v0v0.clojure.java.classpath/jar-file?
([f])
  Returns true if file is a normal file with a .jar or .JAR extension.
-------------------------
cider.nrepl.middleware.util.error-handling/shallow-bencodable?
([item])
  Returns false if `item`'s type can't be bencoded as defined by the
  algorithm in `nrepl.bencode/write-bencode`. Does not
  examine the elements of a collection to ensure that the enclosed
  elements are also bencodable, and so you probably actually want to
  use `deep-bencodable-or-fail` or write something similar.
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.dynamic-classpath/can-add?
([cl])
  Must return true if add-classpath-url is implemented.
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.dynamic-classpath/can-read?
([cl])
  Must return true if classpath-urls is implemented.
-------------------------
clojure.spec.alpha/?
([pred-form])
Macro
  Returns a regex op that matches zero or one value matching
  pred. Produces a single value (not a collection) if matched.
-------------------------
clojure.spec.alpha/check-asserts?
([])
  Returns the value set by check-asserts.
-------------------------
clojure.spec.alpha/inst-in-range?
([start end inst])
  Return true if inst at or after start and before end
-------------------------
clojure.spec.alpha/int-in-range?
([start end val])
  Return true if start <= val, val < end and val is a fixed
  precision integer.
-------------------------
clojure.spec.alpha/invalid?
([ret])
  tests the validity of a conform return value
-------------------------
clojure.spec.alpha/pvalid?
([pred x] [pred x form])
  internal helper function that returns true when x is valid for spec.
-------------------------
clojure.spec.alpha/regex?
([x])
  returns x if x is a (clojure.spec) regex op, else logical false
-------------------------
clojure.spec.alpha/spec?
([x])
  returns x if x is a spec object, else logical false
-------------------------
clojure.spec.alpha/valid?
([spec x] [spec x form])
  Helper function that returns true when x is valid for spec.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.dependency/dependent?
([graph x y])
  True if y is a dependent of x.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.dependency/depends?
([graph x y])
  True if x is directly or transitively dependent on y.
-------------------------
leiningen.core.project/composite-profile?
([profile])
  Returns true if the profile is composite, false otherwise.
-------------------------
leiningen.core.project/different-priority?
([left right])
  Returns true if either left has a higher priority than right or vice versa.
-------------------------
leiningen.core.project/displace?
([obj])
  Returns true if the object is marked as displaceable
-------------------------
leiningen.core.project/replace?
([obj])
  Returns true if the object is marked as replaceable
-------------------------
leiningen.core.project/top-displace?
([obj])
  Returns true if the object is marked as top-displaceable
-------------------------
clojure.set/subset?
([set1 set2])
  Is set1 a subset of set2?
-------------------------
clojure.set/superset?
([set1 set2])
  Is set1 a superset of set2?
-------------------------
cemerick.pomegranate.aether/within?
([[dep version & opts :as coord] [sdep sversion & sopts :as scoord]])
  Determines if the first coordinate would be a version in the second
   coordinate. The first coordinate is not allowed to contain a
   version range.
-------------------------
clojure.string/blank?
([s])
  True if s is , empty, or contains only whitespace.
-------------------------
clojure.string/ends-with?
([s substr])
  True if s ends with substr.
-------------------------
clojure.string/includes?
([s substr])
  True if s includes substr.
-------------------------
clojure.string/starts-with?
([s substr])
  True if s starts with substr.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/boot-project?
([])
  Check whether we're dealing with a Boot project.
  We figure this by checking for the presence of Boot's fake classpath.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/directory?
([f])
  Whether the argument is a directory or an url that points to a directory
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/file-ext?
([f & exts])
  Whether the argument's path ends in one of the specified case-insensitive
  file extensions
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/ns-obj?
([ns])
  Return true if n is a namespace object
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.misc/url?
([u])
  Check whether the argument is an url
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.java/add-java-sources-via-dynapath?
  Should orchard use the dynapath library to use "fetch Java sources" functionality?

  Note that using dynapath currently implies some bugs, so you might want to disable this option.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.java/immutable-source-file?
([info])
  Return true if the source file is effectively immutable. Specifically, this
  returns true if no source file is available, or if the source file is in a
  jar/zip archive.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.java/initialize-cache-silently?
  Should `#'cache-initializer` refrain from printing to `System/out`?
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.util/addable-classpath?
([cl])
  Returns true if the given ClassLoader provides add-claspath-url.
-------------------------
cider.nrepl.inlined-deps.dynapath.v1v1v0.dynapath.util/readable-classpath?
([cl])
  Returns true if the given ClassLoader provides classpath-urls.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.reader-types/indexing-reader?
([rdr])
  Returns true if the reader satisfies IndexingReader
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.reader-types/line-start?
([rdr])
  Returns true if rdr is an IndexingReader and the current char starts a new line
-------------------------
clojure.core/any?
([x])
  Returns true given any argument.
-------------------------
clojure.core/associative?
([coll])
  Returns true if coll implements Associative
-------------------------
clojure.core/boolean?
([x])
  Return true if x is a Boolean
-------------------------
clojure.core/bound?
([& vars])
  Returns true if all of the vars provided as arguments have any bound value, root or thread-local.
   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.
-------------------------
clojure.core/bytes?
([x])
  Return true if x is a byte array
-------------------------
clojure.core/char?
([x])
  Return true if x is a Character
-------------------------
clojure.core/class?
([x])
  Returns true if x is an instance of Class
-------------------------
clojure.core/coll?
([x])
  Returns true if x implements IPersistentCollection
-------------------------
clojure.core/contains?
([coll key])
  Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. 'contains?' operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also 'some'.
-------------------------
clojure.core/counted?
([coll])
  Returns true if coll implements count in constant time
-------------------------
clojure.core/decimal?
([n])
  Returns true if n is a BigDecimal
-------------------------
clojure.core/delay
([& body])
Macro
  Takes a body of expressions and yields a Delay object that will
  invoke the body only the first time it is forced (with force or deref/@), and
  will cache the result and return it on all subsequent force
  calls. See also - realized?
-------------------------
clojure.core/delay?
([x])
  returns true if x is a Delay created with delay
-------------------------
clojure.core/distinct?
([x] [x y] [x y & more])
  Returns true if no two of the arguments are =
-------------------------
clojure.core/double?
([x])
  Return true if x is a Double
-------------------------
clojure.core/empty?
([coll])
  Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))
-------------------------
clojure.core/even?
([n])
  Returns true if n is even, throws an exception if n is not an integer
-------------------------
clojure.core/every?
([pred coll])
  Returns true if (pred x) is logical true for every x in coll, else
  false.
-------------------------
clojure.core/extends?
([protocol atype])
  Returns true if atype extends protocol
-------------------------
clojure.core/false?
([x])
  Returns true if x is the value false, false otherwise.
-------------------------
clojure.core/fits-table?
([ints])
  Returns true if the collection of ints can fit within the
  max-table-switch-size, false otherwise.
-------------------------
clojure.core/float?
([n])
  Returns true if n is a floating point number
-------------------------
clojure.core/fn?
([x])
  Returns true if x implements Fn, i.e. is an object created via fn.
-------------------------
clojure.core/future-cancelled?
([f])
  Returns true if future f is cancelled
-------------------------
clojure.core/future-done?
([f])
  Returns true if future f is done
-------------------------
clojure.core/future?
([x])
  Returns true if x is a future
-------------------------
clojure.core/ident?
([x])
  Return true if x is a symbol or keyword
-------------------------
clojure.core/identical?
([x y])
  Tests if 2 arguments are the same object
-------------------------
clojure.core/ifn?
([x])
  Returns true if x implements IFn. Note that many data structures
  (e.g. sets and maps) implement IFn
-------------------------
clojure.core/indexed?
([coll])
  Return true if coll implements Indexed, indicating efficient lookup by index
-------------------------
clojure.core/inst?
([x])
  Return true if x satisfies Inst
-------------------------
clojure.core/instance?
([c x])
  Evaluates x and tests if it is an instance of the class
    c. Returns true or false
-------------------------
clojure.core/int?
([x])
  Return true if x is a fixed precision integer
-------------------------
clojure.core/integer?
([n])
  Returns true if n is an integer
-------------------------
clojure.core/isa?
([child parent] [h child parent])
  Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy
-------------------------
clojure.core/keyword?
([x])
  Return true if x is a Keyword
-------------------------
clojure.core/lazy-seq
([& body])
Macro
  Takes a body of expressions that returns an ISeq or , and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?
-------------------------
clojure.core/libspec?
([x])
  Returns true if x is a libspec
-------------------------
clojure.core/list?
([x])
  Returns true if x implements IPersistentList
-------------------------
clojure.core/map-entry?
([x])
  Return true if x is a map entry
-------------------------
clojure.core/map?
([x])
  Return true if x implements IPersistentMap
-------------------------
clojure.core/nat-int?
([x])
  Return true if x is a non-negative fixed precision integer
-------------------------
clojure.core/neg-int?
([x])
  Return true if x is a negative fixed precision integer
-------------------------
clojure.core/neg?
([num])
  Returns true if num is less than zero, else false
-------------------------
clojure.core/?
([x])
  Returns true if x is , false otherwise.
-------------------------
clojure.core/not-any?
([pred coll])
  Returns false if (pred x) is logical true for any x in coll,
  else true.
-------------------------
clojure.core/not-every?
([pred coll])
  Returns false if (pred x) is logical true for every x in
  coll, else true.
-------------------------
clojure.core/number?
([x])
  Returns true if x is a Number
-------------------------
clojure.core/odd?
([n])
  Returns true if n is odd, throws an exception if n is not an integer
-------------------------
clojure.core/pos-int?
([x])
  Return true if x is a positive fixed precision integer
-------------------------
clojure.core/pos?
([num])
  Returns true if num is greater than zero, else false
-------------------------
clojure.core/qualified-ident?
([x])
  Return true if x is a symbol or keyword with a namespace
-------------------------
clojure.core/qualified-keyword?
([x])
  Return true if x is a keyword with a namespace
-------------------------
clojure.core/qualified-symbol?
([x])
  Return true if x is a symbol with a namespace
-------------------------
clojure.core/ratio?
([n])
  Returns true if n is a Ratio
-------------------------
clojure.core/rational?
([n])
  Returns true if n is a rational number
-------------------------
clojure.core/reader-conditional?
([value])
  Return true if the value is the data representation of a reader conditional
-------------------------
clojure.core/realized?
([x])
  Returns true if a value has been produced for a promise, delay, future or lazy sequence.
-------------------------
clojure.core/record?
([x])
  Returns true if x is a record
-------------------------
clojure.core/reduced?
([x])
  Returns true if x is the result of a call to reduced
-------------------------
clojure.core/reversible?
([coll])
  Returns true if coll implements Reversible
-------------------------
clojure.core/satisfies?
([protocol x])
  Returns true if x satisfies the protocol
-------------------------
clojure.core/seq?
([x])
  Return true if x implements ISeq
-------------------------
clojure.core/seqable?
([x])
  Return true if the seq function is supported for x
-------------------------
clojure.core/sequential?
([coll])
  Returns true if coll implements Sequential
-------------------------
clojure.core/set?
([x])
  Returns true if x implements IPersistentSet
-------------------------
clojure.core/simple-ident?
([x])
  Return true if x is a symbol or keyword without a namespace
-------------------------
clojure.core/simple-keyword?
([x])
  Return true if x is a keyword without a namespace
-------------------------
clojure.core/simple-symbol?
([x])
  Return true if x is a symbol without a namespace
-------------------------
clojure.core/some?
([x])
  Returns true if x is not , false otherwise.
-------------------------
clojure.core/sorted?
([coll])
  Returns true if coll implements Sorted
-------------------------
clojure.core/special-symbol?
([s])
  Returns true if s names a special form
-------------------------
clojure.core/string?
([x])
  Return true if x is a String
-------------------------
clojure.core/symbol?
([x])
  Return true if x is a Symbol
-------------------------
clojure.core/tagged-literal?
([value])
  Return true if the value is the data representation of a tagged literal
-------------------------
clojure.core/thread-bound?
([& vars])
  Returns true if all of the vars provided as arguments have thread-local bindings.
   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.
-------------------------
clojure.core/true?
([x])
  Returns true if x is the value true, false otherwise.
-------------------------
clojure.core/uri?
([x])
  Return true if x is a java.net.URI
-------------------------
clojure.core/uuid?
([x])
  Return true if x is a java.util.UUID
-------------------------
clojure.core/var?
([v])
  Returns true if v is of type clojure.lang.Var
-------------------------
clojure.core/vector?
([x])
  Return true if x implements IPersistentVector
-------------------------
clojure.core/volatile?
([x])
  Returns true if x is a volatile.
-------------------------
clojure.core/zero?
([num])
  Returns true if num is zero, else false
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.utils/newline?
([c])
  Checks whether the character is a newline
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.utils/numeric?
([ch])
  Checks whether a given character is numeric
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.utils/whitespace?
([ch])
  Checks whether a given character is whitespace
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v2.clojure.tools.reader.impl.commons/number-literal?
([reader initch])
  Checks whether the reader is at the start of a number literal
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.info/qualified-symbol?
([x])
  Return true if `x` is a symbol with a namespace

  This is only available from Clojure 1.9 so we backport it until we
  drop support for Clojure 1.8.
-------------------------
dynapath.dynamic-classpath/can-add?
([cl])
  Must return true if add-classpath-url is implemented.
-------------------------
dynapath.dynamic-classpath/can-read?
([cl])
  Must return true if classpath-urls is implemented.
-------------------------
cemerick.pomegranate/modifiable-classloader?
([cl])
  Returns true iff the given ClassLoader is of a type that satisfies
   the dynapath.dynamic-classpath/DynamicClasspath protocol, and it can
   be modified.
-------------------------
clojure.pprint/integral?
([x])
  returns true if a number is actually an integer (that is, has no fractional part)
-------------------------
clojure.pprint/pretty-writer?
([x])
  Return true iff x is a PrettyWriter
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/comment?
([form])
  Returns true if form is a (comment ...)
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/ns-decl?
([form])
  Returns true if form is a (ns ...) declaration.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/option-spec?
([form])
  Returns true if form represents a libspec vector containing optional
  keyword arguments like [namespace :as alias] or
  [namespace :refer (x y)] or just [namespace]
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.parse/prefix-spec?
([form])
  Returns true if form represents a libspec prefix list like
  (prefix name1 name1) or [com.example.prefix [name1 :as name1]]
-------------------------
leiningen.core.utils/ancestor?
([a b])
  Is a an ancestor of b?
-------------------------
leiningen.core.utils/symlink?
([file])
  Checks if a File is a symbolic link or points to another file.
-------------------------
leiningen.core.user/gpg-available?
([])
  Verifies (gpg-program) exists
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/has-tests?
([ns])
  Returns a truthy value if the namespace has any vars with `:test` metadata.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/in-project?
([url])
  Whether the URL is in the current project's directory.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/inlined-dependency?
([namespace])
  Returns true if the namespace matches one of our, or eastwood's,
   inlined dependencies.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.namespace/internal-namespace?
([namespace & [prefixes]])
  Returns true if the namespace matches the given prefixes.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.file/clojure-file?
([file])
  Returns true if the java.io.File represents a file which will be
  read by the Clojure (JVM) compiler.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.file/clojurescript-file?
([file])
  Returns true if the java.io.File represents a file which will be
  read by the ClojureScript compiler.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.file/file-with-extension?
([file extensions])
  Returns true if the java.io.File represents a file whose name ends
  with one of the Strings in extensions.
-------------------------
cider.nrepl.middleware.util.instrument/contains-recur?
([form])
  Return true if form is not a `loop` or a `fn` and a `recur` is found in it.
-------------------------
cider.nrepl.middleware.util.instrument/dont-break?
(~[[name :as form]]~)
  Return true if it's NOT ok to wrap form in a breakpoint.
  Expressions we don't want to wrap are those listed in
  `dont-break-forms` and anything containing a `recur`
  form (unless it's inside a `loop`).
-------------------------
cider.nrepl.inlined-deps.orchard.v0v7v1.orchard.inspect
  Clojure data structure inspection functionality.
  This code has a long history and at various points of
  time it lived in different projects. Originally
  it was part of swank-clojure, afterwards it was moved to
  javert, then forked to another project from which it
  was contributed to cider-nrepl. Finally cider-nrepl
  was split into two libraries and the code ended up here.

  Pretty wild, right?
#+end_results
** マップ/キーワード/レコード
マップ。
#+begin_src clojure
(def inventors {"Lisp" "McCarthy" "Clojure" "Hickey"})
#+end_src

#+RESULTS:
#+begin_results
#'user/inventors
#+end_results

みやすさのためにコロンを置くこともできる。
#+begin_src clojure
(def inventors {"Lisp" "McCarthy", "Clojure" "Hickey"})
#+end_src

#+RESULTS:
#+begin_results
#'user/inventors
#+end_results

マップは関数としても動作する。
#+begin_src clojure
  (inventors "Lisp")
#+end_src

#+RESULTS:
#+begin_results
McCarthy
#+end_results

~get~ 関数も使える。存在しない場合の値を指定できる。
#+begin_src clojure
  (get inventors "Lisp" "not find")
  (get inventors "Foo" "not find")
#+end_src

#+RESULTS:
#+begin_results
| "McCarthy" |
| "not find" |
#+end_results

~キーワード~ はシンボルに似ているが、コロンで始まる。評価されると自分自身を返す。
#+begin_src clojure
:foo
#+end_src

#+RESULTS:
#+begin_results
:foo
#+end_results

シンボルとは異なる。シンボルは評価されるとそれに結び付けられた何かを返そうとする。
#+begin_src clojure
foo
#+end_src

#+RESULTS:
#+begin_results
class clojure.lang.Compiler$CompilerException
#+end_results

キーワードをキーにして書き直す。
#+begin_src clojure
(def inventors {:Lisp "McCarthy" :Clojure "Hickey"})
#+end_src

#+RESULTS:
#+begin_results
#'user/inventors
#+end_results

* Tasks
** TODO プログラミングClojure
:LOGBOOK:
CLOCK: [2021-10-16 Sat 23:02]--[2021-10-16 Sat 23:42] =>  0:40
CLOCK: [2021-10-16 Sat 17:28]--[2021-10-16 Sat 17:53] =>  0:25
:END:
* Reference
**  [[https://www.geidai.ac.jp/~marui/clojure/rationale/][Clojureをつくったわけ]]
clojureの特徴がわかる。
* Archive
