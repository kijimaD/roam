:PROPERTIES:
:ID:       7a81eb7c-8e2b-400a-b01a-8fa597ea527a
:header-args+: :wrap :results raw
:END:
#+title: Linux
* 概要
GNU LinuxはオープンソースのOS。
もっとも成功した[[id:bb71747d-8599-4aee-b747-13cb44c05773][OSS]]プロジェクトの1つで、世界中の開発者によって開発が進められている。
* Memo
** ユーザリソースを確認する方法

#+begin_src shell
ulimit -a
#+end_src

#+RESULTS:
#+begin_results
real-time non-blocking time  (microseconds, -R) unlimited
core file size              (blocks, -c) 0
data seg size               (kbytes, -d) unlimited
scheduling priority                 (-e) 0
file size                   (blocks, -f) unlimited
pending signals                     (-i) 126771
max locked memory           (kbytes, -l) 4072104
max memory size             (kbytes, -m) unlimited
open files                          (-n) 1024
pipe size                (512 bytes, -p) 8
POSIX message queues         (bytes, -q) 819200
real-time priority                  (-r) 0
stack size                  (kbytes, -s) 9788
cpu time                   (seconds, -t) unlimited
max user processes                  (-u) 126771
virtual memory              (kbytes, -v) unlimited
file locks                          (-x) unlimited
#+end_results

** tzdataとは
tzdataは、タイムゾーン（時刻帯）のデータベースであり、主にオペレーティングシステムやプログラミング言語で使用される。タイムゾーンデータは、世界中の異なる地域と時間帯の間の変換や日付・時刻の計算を可能にする。

tzdataには、地域ごとの時差や夏時間の情報が含まれている。このデータベースは、世界各地の政府機関や国際的な規格に基づいて維持され、定期的に更新される。タイムゾーンデータは、UTC(協定世界時)を基準として、地域ごとの時差を正確に表現する。

プログラミング言語やオペレーティングシステムでは、tzdataを使用して、タイムゾーンに関連する情報を取得し、日付や時刻の変換、タイムゾーンの切り替え、夏時間…を処理する。一般的に、タイムゾーンデータはデータベースファイルやライブラリとして提供され、プログラム内で利用される。

タイムゾーンデータは、日々の時間管理や国際的な日付やイベントの処理において重要な役割を果たす。正確な時刻の取得や表示、イベントのスケジュール管理、タイムゾーンに関連する問題の処理において、tzdataは欠かせない要素となっている。
** AF_VSOCK(Virtual Socket Family)とは
AF_VSOCKは、Linuxカーネルで利用されるソケットファミリーの1つ。AF_VSOCKは、仮想マシンやコンテナなどの異なるホスト間での通信を可能にするため設計されている。ホストと仮想マシンまたはコンテナ間での高速で効率的な通信ができる。ソケットを介して異なる仮想マシン/コンテナ間でデータを送受信できる。
** プロセスとスレッドの違い
- [[https://webpia.jp/thread_process/][プロセスとスレッドの違いとは？超わかりやすく解説！【図解とプログラム付き】 | Webpia]]

構造。プロセス・スレッドというが、別階層の話。

- OS
  - プロセス
    - スレッド

- プロセス :: 実行中のプログラム。OSによってプロセスは管理される。プロセス間では別のメモリ空間が割り当てられるので影響を及ぼすことはない。プロセス間でメモリを共有しない
- スレッド :: プロセスによってスレッドは管理される。プロセス内の同じメモリ領域を共有する。スレッドは、スレッド同士で同じメモリ領域を使う。マルチスレッドにすることで並列処理ができるのがメリット
  - プログラムから見たスレッドは、メモリにロードされたプログラムの現在の実行状態を持つ仮想CPU
  - 仮想CPUのそれぞれに、スタックメモリが割り当てられている
  - OSやCPUから見たスレッドは、時間が凍結されたプログラムの実行状態
  - OSの仕事は、凍結状態のプログラムの実行状態を復元して、各スレッドを順番に短時間ずつ処理を再開させること
  - 複数のプログラムは、時間分割されてCPUコアにマッピングされて実行される

- シングルスレッドのプロセス: 1つしかスレッドを持たない
- マルチスレッドのプロセス: 複数スレッドを持つプロセス

** 特殊なディレクトリ
慣例的に使われる特別なディレクトリがある。

たとえば ~/etc/skel/~ は、ユーザが作成されたときのホームディレクトリのベースになる。前もってここに配置しておくと、ユーザが作られたあとホームディレクトリにコピーされ、ユーザが扱える。

~/etc/default/useradd~ に書いてあり、useraddを経由した変更もできる。

** インストールディスク作成

Linux環境でブータブルUSBを作成するとき、よくわからない要因によって失敗することが何度かあった。たいていはブートできないというもの。

- [[https://help.ubuntu.com/community/LiveCDCustomization][LiveCDCustomization - Community Help Wiki]]
  - ライブCDのカスタマイズ方法の詳しいドキュメント。GitHub Actionsでも実行できる

既存のベースとなるisoを持ってくる。isoを展開する。展開したシステムディレクトリをマウントする。この時点で、システムはiso内にあるものが使われ、変更もiso内に反映される。

- unetbootinを使う
  - [[https://unetbootin.github.io/linux_download.html][UNetbootin - Linux Downloads]]
- 焼く前に、USBドライブをext4でフォーマットする。それ以外だとbootに失敗することがある
- 仮想マシンで素早くテストできる
  - ~sudo apt install qemu-kvm~
  - ~qemu-system-x86_64 -boot d -cdrom ubuntu.iso -enable-kvm -m 4096~

** lsのソースコード
#+caption: getoptで引数を取り出し、switchで処理する
#+begin_src git-permalink
https://github.com/kd-collective/NetBSD/blob/89341ae2e1875e7f91cefa9b1dcc0e4549edcde0/bin/ls/ls.c#L154-L169
#+end_src

#+RESULTS:
#+begin_results
	while ((ch = getopt(argc, argv, "1AaBbCcdFfghikLlMmnOoPpqRrSsTtuWwXx"))
	    != -1) {
		switch (ch) {
		/*
		 * The -1, -C, -l, -m and -x options all override each other so
		 * shell aliasing works correctly.
		 */
		case '1':
			f_singlecol = 1;
			f_column = f_columnacross = f_longform = f_stream = 0;
			break;
		case 'C':
			f_column = 1;
			f_columnacross = f_longform = f_singlecol = f_stream =
			    0;
			break;
#+end_results

** cdのソースコード
#+begin_src git-permalink
https://github.com/kd-collective/NetBSD/blob/89341ae2e1875e7f91cefa9b1dcc0e4549edcde0/bin/sh/cd.c#L52-L54
#+end_src

#+RESULTS:
#+begin_results
/*
 * The cd and pwd commands.
 */
#+end_results

** echoのソースコード
#+caption: netBSDのechoのソースコード。本質的にprintf
#+begin_src git-permalink
https://github.com/kd-collective/NetBSD/blob/89341ae2e1875e7f91cefa9b1dcc0e4549edcde0/bin/echo/echo.c#L1
#+end_src

#+RESULTS:
#+begin_results
/* $NetBSD: echo.c,v 1.23 2021/11/16 21:38:29 rillig Exp $	*/
#+end_results

#+caption: nflagには0か1が入る
#+begin_src git-permalink
https://github.com/kd-collective/NetBSD/blob/89341ae2e1875e7f91cefa9b1dcc0e4549edcde0/bin/echo/echo.c#L60
#+end_src

#+RESULTS:
#+begin_results
	nflag = *++argv != NULL && strcmp(*argv, "-n") == 0;
#+end_results

- getopt関数を使っていない
** ctrl+shiftが機能しない
インプットメソッドによって、入力方法の変更ショートカットが奪われる。
https://superuser.com/questions/358749/how-to-disable-ctrlshiftu

fcitxを使っている場合、 ~fcitx-configtool~ で設定できる。
全体の設定 → 入力メソッドの切り替えで、別のキーボードの組み合わせを選択する。
** ディスプレイマネージャーを再起動
壊れたときにシステム再起動よりはやく復帰できる。
#+begin_src shell
  systemctl restart display-manager
#+end_src
** linux mintでsnapをインストールする
#+begin_src shell
  sudo rm /etc/apt/preferences.d/nosnap.pref
#+end_src
** bluetoothが動かないとき
新しくクリーンインストールしたところ、Bluetooth接続ができなかった。
インストール前はできていたから、ハードウェアに問題はない。

前はデフォルトでできてたはずだが、bluetooth周辺ライブラリをインストールしてサービスを再起動する。
どれが効いたのかはさだかではないが、接続できるようになった。

#+begin_src shell
  sudo apt-get install bluetooth bluez bluez-tools rfkill blueman

  # 強制的に全てのブロックを解除
  sudo rfkill unblock all
  # Bluetoothを再起動
  sudo systemctl restart bluetooth.service
#+end_src

- [[https://blog.hanhans.net/2019/03/18/ubuntu-enable-bluetooth/][強制的に全てのブロックを解除 1 $ sudo rfkill unblock all Bluetoothを再起動 1 $ sudo systemctl restart bluetooth.service]]
** caps_lockをコマンドで切り替える
Caps LockをControlに入れ替えていると、xmodmapをいじったときに大文字のまま元に戻せなくなることがある。
代替のキーはないので困る。コマンドでできる。
#+begin_src shell
sudo apt-get install xdotool
xdotool key Caps_Lock
#+end_src
* Tasks
** TODO [[https://gihyo.jp/dp/ebook/2022/978-4-297-13149-4][Linuxのしくみ ―実験と図解で学ぶOS、仮想マシン、コンテナの基礎知識【増補改訂版】 | Gihyo Digital Publishing … 技術評論社の電子書籍]]
:LOGBOOK:
CLOCK: [2024-01-08 Mon 10:21]--[2024-01-08 Mon 10:46] =>  0:25
CLOCK: [2024-01-07 Sun 19:37]--[2024-01-07 Sun 20:02] =>  0:25
CLOCK: [2024-01-07 Sun 19:04]--[2024-01-07 Sun 19:29] =>  0:25
CLOCK: [2024-01-07 Sun 18:10]--[2024-01-07 Sun 18:35] =>  0:25
CLOCK: [2024-01-06 Sat 08:59]--[2024-01-06 Sat 09:24] =>  0:25
CLOCK: [2024-01-06 Sat 08:34]--[2024-01-06 Sat 08:59] =>  0:25
CLOCK: [2024-01-05 Fri 22:48]--[2024-01-05 Fri 23:13] =>  0:25
CLOCK: [2024-01-05 Fri 22:23]--[2024-01-05 Fri 22:48] =>  0:25
:END:
動かして学ぶ本。

- 論理CPUが実行している命令の割合は ~sar~ コマンドを使う

#+caption: 論理CPU0の実行状況
#+begin_src shell
sar -P 0 1 1
#+end_src

#+RESULTS:
#+begin_results
Linux 5.15.0-41-generic (orange-ThinkPad-X1-Carbon-Gen-10) 	01/05/2024 	_x86_64_	(16 CPU)

10:35:45 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
10:35:46 PM       0     15.31      0.00      1.02      0.00      0.00     83.67
Average:          0     15.31      0.00      1.02      0.00      0.00     83.67
#+end_results

- tasksetコマンドで、論理CPUを指定してタスクを実行できる

#+caption: プログラムがどのようなライブラリをリンクしているかはlddコマンドで確かめられる
#+begin_src shell
ldd /bin/echo
#+end_src

#+RESULTS:
#+begin_results
	linux-vdso.so.1 (0x00007ffd65ef3000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc6a02a6000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fc6a04ef000)
#+end_results

#+caption: catコマンドも見る
#+begin_src shell
ldd /bin/echo
#+end_src

#+RESULTS:
#+begin_results
	linux-vdso.so.1 (0x00007ffccff55000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f308c86a000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f308cab3000)
#+end_results

#+caption: python3を見る
#+begin_src shell
ldd /usr/bin/python3
#+end_src

#+RESULTS:
#+begin_results
	linux-vdso.so.1 (0x00007fffc69f0000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f754c0a9000)
	libexpat.so.1 => /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f754c078000)
	libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f754c05c000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f754be34000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f754c791000)
#+end_results

#+caption: プロセスの数を調べる
#+begin_src shell
ps aux --no-header | wc -l
#+end_src

#+RESULTS:
#+begin_results
451
#+end_results

- プロセスのメモリマップは `cat /proc/{{pid}}/maps` で調べられる

#+caption: プロセスの木構造を表示する
#+begin_src shell
pstree -p
#+end_src

- 多くのプロセスで、CPUを使った時間は1秒に満たない
  - 各プロセスは起動してから、CPUを使わずに何らかのイベントが発生するのを待つ、スリープ状態になっていた
  - STATフィールドの1文字目がSであるプロセスはスリープ状態にあることを示す
  - プロセスがCPUを使いたいというプロセスは実行可能状態であるという。このときSTATフィールドの1文字目はRになる
  - 実際にCPUを使っている状態は実行状態
  - プロセスが終了するとゾンビ状態(STATフィールドはZ)になり、その後消滅する

#+caption: プロセスの状態を表示する
#+begin_src shell
ps aux
#+end_src

#+caption: wait組み込みコマンドによって終了状態を得る
#+begin_src shell
  false &
  wait $! # falseプロセスの終了を待ち合わせる。falseコマンドのpidは$!変数から得られる
  echo "falseコマンドが終了しました: $?" # wait後にfalseプロセスの戻り値は$?変数から得られる
#+end_src

#+RESULTS:
#+begin_results
falseコマンドが終了しました: 1
#+end_results

- 親プロセスは子プロセスの終了状況を適宜回収して、リソースをカーネルに解放する

#+caption: シグナルの一覧
#+begin_src shell
man 7 signal | head -n 10
#+end_src

#+RESULTS:
#+begin_results
SIGNAL(7)                  Linux Programmer's Manual                 SIGNAL(7)

NAME
       signal - overview of signals

DESCRIPTION
       Linux  supports both POSIX reliable signals (hereinafter "standard sig‐
       nals") and POSIX real-time signals.

   Signal dispositions
#+end_results

#+caption: セッションについての情報
#+begin_src shell
ps ajx | head -n 10
#+end_src

#+RESULTS:
#+begin_results
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
      0       1       1       1 ?             -1 Ss       0   1:16 /sbin/init splash
      0       2       0       0 ?             -1 S        0   0:04 [kthreadd]
      2       3       0       0 ?             -1 I<       0   0:00 [rcu_gp]
      2       4       0       0 ?             -1 I<       0   0:00 [rcu_par_gp]
      2       5       0       0 ?             -1 I<       0   0:00 [netns]
      2      10       0       0 ?             -1 I<       0   0:00 [mm_percpu_wq]
      2      11       0       0 ?             -1 S        0   0:00 [rcu_tasks_rude_]
      2      12       0       0 ?             -1 S        0   0:00 [rcu_tasks_trace]
      2      13       0       0 ?             -1 S        0   0:41 [ksoftirqd/0]
#+end_results

- プロセスグループを使うと、当該プロセスグループに所属する全プロセスに対してシグナルを投げられる

#+caption: プロセスの階層をたどる
#+begin_src shell
  sleep 1 &
  ps ajx | egrep "$PPID|$!"
#+end_src

#+RESULTS:
#+begin_results
      1  148772  148310  148310 ?             -1 Sl    1000 409:32 /home/orange/.guix-profile/bin/emacs
 148772  148817  148817  148817 ?             -1 Ss    1000   0:10 /usr/bin/cmigemo -q --emacs -d /usr/share/cmigemo/utf-8/migemo-dict
 148772  153047  153047  153047 pts/11    153047 SLsl+ 1000 1347:41 /opt/google/chrome/chrome
 148772  153626  153626  153626 pts/6     153626 Ss+   1000   0:00 /bin/bash
 148772  153657  153657  153657 pts/3     153657 Ss+   1000   0:00 /bin/bash
 148772  153776  153776  153776 pts/4     153776 Ss+   1000   0:00 /bin/bash
 148772  153837  153837  153837 pts/0     153837 Ss+   1000   0:00 /bin/bash
 148772  156827  156827  156827 ?             -1 Ss    1000   0:44 /usr/bin/mozc_emacs_helper --suppress_stderr
 148772  449717  449717  449717 ?             -1 Ssl   1000   0:09 /home/orange/.emacs.d/.cask/.cache/lsp/rust/rust-analyzer
 148772  956786  956786  956786 pts/2     956786 Ss+   1000   0:00 /bin/bash
 148772 1030938 1030938 1030938 pts/7    1030938 Ss+   1000   1:40 /usr/bin/python3 -m http.server 8000
 148772 1052415 1052415 1052415 pts/8    1052415 Ss+   1000   0:00 /bin/bash
 148772 1203772 1203772 1203772 pts/9    1203772 Ss+   1000   0:00 /bin/bash
 148772 1215308 1215308 1215308 ?             -1 Ssl   1000   0:50 /home/orange/go/bin/gopls -remote=auto
 148772 1224161 1224161 1224161 ?             -1 Ssl   1000   0:29 /home/orange/go/bin/gopls -remote=auto
 148772 1260197 1260197 1260197 ?             -1 Ssl   1000   0:27 /home/orange/go/bin/gopls -remote=auto
 148772 1260667 1260667 1260667 pts/10   1260667 Ss+   1000   0:00 /bin/bash
 148772 1278406 1278406 1278406 ?             -1 Ssl   1000   1:35 /home/orange/go/bin/gopls -remote=auto
 148772 1386122 1386122 1386122 ?             -1 Ssl   1000   0:36 /home/orange/go/bin/gopls -remote=auto
 148772 1633877 1633877 1633877 pts/12   1633877 Ss+   1000   0:00 /bin/bash
 148772 2345920 2345920 2345920 ?             -1 Ssl   1000   0:12 /home/orange/go/bin/gopls -remote=auto
 148772 2463164 2463164 2463164 pts/13   2463164 Ss+   1000   0:00 /bin/bash
 148772 2791028 2791028 2791028 pts/14   2791028 Ss+   1000   0:00 /bin/bash
 148772 2798220 2798220 2798220 ?             -1 Ssl   1000   0:06 /home/orange/go/bin/gopls -remote=auto
 148772 2798497 2798497 2798497 pts/15   2798497 Ss+   1000   0:00 /bin/bash
 148772 3126717 3126717 3126717 ?             -1 Ss    1000   0:00 /bin/bash
3126717 3126718 3126717 3126717 ?             -1 S     1000   0:00 sleep 1
3126717 3126720 3126717 3126717 ?             -1 S     1000   0:00 grep -E 148772|3126718
#+end_results

- 親 ppid: 1, pid: 148772 ~//home/orange/.guix-profile/bin/emacs~
- 子 ppid: 148772, pid: 3126717 ~/bin/bash~
- 子 ppid: 3126717, pid: 3126718 ~sleep 1~
- ~/bin/bash~, ~sleep 1~, ~grep -E 148772|3126718~ はPGID(プロセスグループID)が同じである

デーモンの特徴。

- 端末から入出力する必要がないので、端末が割り当てられていない
- あらゆるログインセッションが終了しても影響を受けないように、独自のセッションを持つ
- デーモンを生成したプロセスがデーモンの終了を気にしなくていいように、initが親になっている

#+caption: デーモンの場合
#+begin_src shell
  ps ajx | grep dockerd
#+end_src

#+RESULTS:
#+begin_results
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
      1 2952095 2952095 2952095 ?             -1 Ssl      0  23:14 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
3130365 3130367 3130365 3130365 ?             -1 S     1000   0:00 grep dockerd
#+end_results

- 親プロセスはinit(PPIDが1)
- TTYは割り当てられていない
- セッションIDがPIDと同じ

#+caption: 経過時間の実験
#+begin_src shell
  time sleep 1
  # real	0m1.002s
  # user	0m0.002s
  # sys	0m0.001s
#+end_src

- realはほぼ1秒。開始直後にCPUを手放しスリープ状態になり、1秒後にCPUをまた使いはじめても終了処理をするだけなので、userとsysはほぼ0

** TODO [[https://www.kanzennirikaisita.com/posts/linux-learning-roadmap][Linux について学ぶおすすめの流れ【書籍を中心に紹介】 - 完全に理解した.com]]
おすすめの本の紹介記事。
** TODO [[https://tatsu-zine.com/books/linux-bootprocess][新装改訂版 Linuxのブートプロセスをみる【委託】 - 達人出版会]]
ブートプロセスを追う本。
** TODO [[https://tatsu-zine.com/books/naruhounix][なるほどUnixプロセス ― Rubyで学ぶUnixの基礎 - 達人出版会]]
プロセスの解説。
** WIP [[https://www.seshop.com/product/detail/20694][詳解UNIXプログラミング［第3版］【PDF版】 ｜ SEshop｜ 翔泳社の本・電子書籍通販サイト]] :Read:
:PROPERTIES:
:Effort:   20:00
:END:
:LOGBOOK:
CLOCK: [2024-02-04 Sun 21:07]--[2024-02-04 Sun 21:32] =>  0:25
CLOCK: [2024-02-04 Sun 20:29]--[2024-02-04 Sun 20:54] =>  0:25
CLOCK: [2024-02-04 Sun 19:37]--[2024-02-04 Sun 20:03] =>  0:26
CLOCK: [2024-02-04 Sun 18:30]--[2024-02-04 Sun 18:55] =>  0:25
CLOCK: [2023-09-11 Mon 00:52]--[2023-09-11 Mon 01:17] =>  0:25
CLOCK: [2023-09-10 Sun 22:40]--[2023-09-10 Sun 23:05] =>  0:25
CLOCK: [2023-08-09 Wed 20:59]--[2023-08-09 Wed 21:24] =>  0:25
CLOCK: [2023-07-23 Sun 18:08]--[2023-07-23 Sun 18:33] =>  0:25
CLOCK: [2023-07-23 Sun 17:18]--[2023-07-23 Sun 17:43] =>  0:25
CLOCK: [2023-07-20 Thu 23:07]--[2023-07-20 Thu 23:32] =>  0:25
CLOCK: [2023-07-19 Wed 21:55]--[2023-07-19 Wed 22:20] =>  0:25
CLOCK: [2023-07-17 Mon 19:03]--[2023-07-17 Mon 19:28] =>  0:25
CLOCK: [2023-07-17 Mon 18:38]--[2023-07-17 Mon 19:03] =>  0:25
CLOCK: [2023-07-17 Mon 18:08]--[2023-07-17 Mon 18:33] =>  0:25
CLOCK: [2023-07-17 Mon 17:43]--[2023-07-17 Mon 18:08] =>  0:25
CLOCK: [2023-07-17 Mon 11:39]--[2023-07-17 Mon 12:04] =>  0:25
CLOCK: [2023-07-17 Mon 11:14]--[2023-07-17 Mon 11:39] =>  0:25
CLOCK: [2023-07-16 Sun 22:59]--[2023-07-16 Sun 23:24] =>  0:25
CLOCK: [2023-07-02 Sun 11:22]--[2023-07-02 Sun 11:47] =>  0:25
CLOCK: [2023-06-28 Wed 00:53]--[2023-06-28 Wed 01:18] =>  0:25
CLOCK: [2023-06-19 Mon 00:50]--[2023-06-19 Mon 01:15] =>  0:25
CLOCK: [2023-06-18 Sun 22:47]--[2023-06-18 Sun 23:12] =>  0:25
:END:

- 29, 32, 41, 44, 46, 53, 65, 76

UNIXプログラミングの解説本。

- エラーが発生するとほとんどのシステム関数は-1を返す
- プログラムは、ディレクトリ内のディスクにある実行可能なファイル
- プログラムの実行中の実体をプロセスという
- ctrl + D はファイル末尾文字を送る
- プロセス内のすべてのスレッドは、同一のアドレス空間、ファイル記述子、スタック、プロセス関連の属性を共有する
  - スレッドは同一のメモリを参照できるので、共有データへの参照は矛盾を避けるために同期する必要がある
  - スレッドIDはプロセスに固有である
- シェル上では特殊な働きをするキーが存在する。どのキーがどの働きをするのかは、 ~stty -a~ コマンドで確認できる
- シェルがパイプでつながれたプロセス群を起動するたびに「この端末ではいま、このプロセスが動いています」と端末に教えている
- 環境変数とは、プロセスの親子関係を通じて伝播する環境変数のようなもの
- POSIX(Portable Operating System Interface) は、IEEE が作成しはじめた一連の規格
  - 本に関係するのは1003.1オペレーティングシステムインターフェース規格
  - 1003.1規格は実装ではなくインターフェースを規定する
- フォアグラウンドプロセスグループとは、ターミナルと同じプロセスグループIDを持つプロセスグループのこと
- シェルは新しいプロセスをforkし、実行するプログラム。forkしたプログラムの終了を待ちながら標準出力する
- Unixシステムはプロセスに対して3つの値を管理している
  - クロック時間 :: プロセスが実行に費やした時間
  - ユーザCPU時間 :: ユーザの命令に関与したCPU時間
  - システムCPU時間 :: カーネルが関与したCPU時間
- Unixシステムにおけるほとんどのファイル入出力は5つの関数だけで行える

  open, read, write, lseek, close

- ファイル入出力関数は、標準入出力ルーティンに対比してしばしば「アンバッファド入出力」とよばれる

  readやwriteがカーネル内のシステムコールを起動するため、バッファリングしないということ

- カーネルではオープンしているすべてのファイルはファイル記述子で参照する。ファイル記述子は非負の整数
- プロセスの標準入力: ファイル記述子0
- 標準出力: ファイル記述子1
- 標準エラー: ファイル記述子2
- OKならばファイル記述子、エラーなら-1を返す
- ↑これらはシェルやアプリケーションの慣例であり、Unixカーネルの機能ではない
- 2つのファイル関連の関数を呼び出すとき2番めの関数呼び出しが最初の呼び出し結果に依存する場合にはプログラムに脆弱性がある
- オープンしてある各

** TODO [[https://qiita.com/ueokande/items/c75de7c9df2bcceda7a9][シェルとファイルデスクリプタのお話 - Qiita]]
ファイルディスクリプタをシェルで扱う。
** TODO [[https://milestone-of-se.nesuke.com/sv-basic/linux-basic/fd-stdinout-pipe-redirect/][【図解】file descriptorと標準入力/出力とパイプ,リダイレクト | SEの道標]]
ファイルディスクリプタ。
** TODO [[https://book.mynavi.jp/ec/products/detail/id=121220][ゼロからのOS自作入門 | マイナビブックス]]
:LOGBOOK:
CLOCK: [2022-11-19 Sat 09:48]--[2022-11-19 Sat 10:13] =>  0:25
:END:
ゼロからOSを自作する本。
** TODO [[https://www.shuwasystem.co.jp/book/9784798044781.html][ハロー“Hello, World” OSと標準ライブラリのシゴトとしくみ]]
printを実行するとき何が起こっているかの解説。
** TODO [[https://linuxjf.osdn.jp/JFdocs/The-Linux-Kernel.html#toc14][The Linux Kernel]]
:LOGBOOK:
CLOCK: [2022-05-15 Sun 18:20]--[2022-05-15 Sun 18:45] =>  0:25
:END:
Linuxカーネルの解説。
** TODO [[https://0xax.gitbooks.io/linux-insides/content/][Introduction · Linux Inside]]
Linuxカーネルの解説。
** TODO [[https://www.oreilly.co.jp/books/9784873113623/][O'Reilly Japan - Linuxシステムプログラミング]]
システムプログラミングの本。
** TODO [[https://www.oreilly.co.jp/books/9784873115856/][O'Reilly Japan - Linuxプログラミングインタフェース]]
Linuxのリファレンス。
** TODO [[https://www.oreilly.co.jp/books/9784873113135/][O'Reilly Japan - 詳解 Linuxカーネル 第3版]]
:LOGBOOK:
CLOCK: [2022-06-01 Wed 00:42]--[2022-06-01 Wed 01:07] =>  0:25
:END:
- 15
カーネルのソースコードを読む本。
* Reference
** [[https://qiita.com/stc1988/items/41d9da92ea02fc3d15a3][SquashFSをマウントするまで - Qiita]]
システムをファイルに圧縮するとき使う。
** [[https://www.express.nec.co.jp/linux/distributions/knowledge/system/useradd.html][新規ユーザ作成時のデフォルト値の設定]]
ユーザの設定方法。ここでデフォルトディレクトリに ~/etc/skel~ 指定している。
** [[https://tech.unifa-e.com/entry/2019/05/23/172424][sudo実行時のカレントディレクトリや環境変数などの挙動について - ユニファ開発者ブログ]]
sudoの解説。
** [[https://linuxjm.osdn.jp/html/sudo/man8/sudo.8.html][Man page of SUDO]]
sudoの解説。特にプロセスモデルに関する詳しい解説。
** [[https://gihyo.jp/assets/files/event/2008/24svr/report/2-24svr-TechMTG-ito.pdf][Linuxカーネルの読み方]]
Linuxカーネルのソースコードを読むコツと参考文献がある。
** [[https://ja.wikipedia.org/wiki/Linux][Linux - Wikipedia]]
** [[https://www.geekpage.jp/blog/?id=2007/3/1][UNIX哲学の基本原則:Geekなぺーじ]]
UNIX哲学の一覧。
* Archives
** DONE [[https://www.amazon.co.jp/%E3%81%B5%E3%81%A4%E3%81%86%E3%81%AELinux%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E7%AC%AC2%E7%89%88-Linux%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B9%E3%82%8Bgcc%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E7%8E%8B%E9%81%93-%E9%9D%92%E6%9C%A8-%E5%B3%B0%E9%83%8E/dp/4797386479][ふつうのLinuxプログラミング 第2版 Linuxの仕組みから学べるgccプログラミングの王道 Amazon]]
CLOSED: [2023-07-09 Sun 16:04]
:PROPERTIES:
:Effort:   10:00
:END:
:LOGBOOK:
CLOCK: [2023-07-09 Sun 11:46]--[2023-07-09 Sun 12:12] =>  0:26
CLOCK: [2023-07-09 Sun 01:28]--[2023-07-09 Sun 01:53] =>  0:25
CLOCK: [2023-07-09 Sun 00:54]--[2023-07-09 Sun 01:19] =>  0:25
CLOCK: [2023-07-09 Sun 00:23]--[2023-07-09 Sun 00:48] =>  0:25
CLOCK: [2023-07-08 Sat 21:18]--[2023-07-08 Sat 21:43] =>  0:25
CLOCK: [2023-07-08 Sat 20:49]--[2023-07-08 Sat 21:14] =>  0:25
CLOCK: [2023-07-08 Sat 20:18]--[2023-07-08 Sat 20:43] =>  0:25
CLOCK: [2023-07-08 Sat 11:41]--[2023-07-08 Sat 12:06] =>  0:25
CLOCK: [2023-07-04 Tue 22:03]--[2023-07-04 Tue 22:28] =>  0:25
CLOCK: [2023-07-04 Tue 21:37]--[2023-07-04 Tue 22:02] =>  0:25
CLOCK: [2023-07-04 Tue 00:44]--[2023-07-04 Tue 01:09] =>  0:25
CLOCK: [2023-07-02 Sun 23:08]--[2023-07-02 Sun 23:33] =>  0:25
CLOCK: [2023-07-02 Sun 22:35]--[2023-07-02 Sun 23:00] =>  0:25
CLOCK: [2023-07-02 Sun 18:55]--[2023-07-02 Sun 19:20] =>  0:25
CLOCK: [2023-07-02 Sun 18:26]--[2023-07-02 Sun 18:51] =>  0:25
CLOCK: [2023-07-02 Sun 14:30]--[2023-07-02 Sun 14:55] =>  0:25
CLOCK: [2023-07-02 Sun 14:00]--[2023-07-02 Sun 14:25] =>  0:25
CLOCK: [2023-07-02 Sun 13:30]--[2023-07-02 Sun 13:55] =>  0:25
CLOCK: [2023-07-02 Sun 13:00]--[2023-07-02 Sun 13:25] =>  0:25
CLOCK: [2023-07-02 Sun 10:51]--[2023-07-02 Sun 11:16] =>  0:25
CLOCK: [2023-07-02 Sun 01:33]--[2023-07-02 Sun 01:58] =>  0:25
CLOCK: [2023-07-01 Sat 20:21]--[2023-07-01 Sat 20:47] =>  0:26
CLOCK: [2023-07-01 Sat 18:33]--[2023-07-01 Sat 18:58] =>  0:25
CLOCK: [2023-07-01 Sat 18:07]--[2023-07-01 Sat 18:32] =>  0:25
CLOCK: [2023-07-01 Sat 15:31]--[2023-07-01 Sat 15:56] =>  0:25
:END:

Linuxの仕組みから学べるシステムプログラミング。

- Linuxはファイルシステムとプロセスとストリームでできている
- Linux上において、活動する主体はユーザではなく、プロセス
- ログイン時にクレデンシャルが作られ、プロセスに渡している
- シェルと端末は異なる
  - 端末はユーザとのインターフェースになる部分。現代では仮想化されていて無数にある。端末に対応するデバイスファイル ~/dev/tty0~ などがある
  - シェルはユーザからの命令を解釈し実行するプログラムのこと。ストリームからコマンドを読み込んで実行するプログラムにすぎない
- ttyの語源はテレタイプ。ディスプレイがなかったので長い紙に結果を出力していた
- tabの語源はtable
- キーボード → 端末ドライバ → ストリーム → プロセス → ストリーム → 端末ドライバ → ディスプレイ
- Linuxの入出力の主な4つのシステムコール
  - ストリームからバイト列を読み込むread
  - ストリームにバイト列を書き込むwrite
  - ストリームを作るopen
  - 用済みのストリームを始末するclose
- ファイルディスクリプタは整数値にすぎない
- 固定のファイルディスクリプタ
  - 0: 標準入力
  - 1: 標準出力
  - 2: 標準エラー出力
- 標準エラー出力がある理由。標準出力は次のプログラムの標準入力につながれている場合が多いので、ここでエラーを出しても気づかない可能性が高いから
- ストリームはファイルディスクリプタで表現され、read()またはwrite()で操作できるもののこと
- システムコールは遅いので、バッファに溜まってからシステムコールするとよい
- gets()はバッファオーバーフローを起こす可能性があり、使ってはいけない。世界初のインターネットワームはバッファオーバーフローの脆弱性を利用した
- ビルド
  - プリプロセス
    - 純粋なC言語のソースコードを出力する
  - コンパイル
    - C言語のソースコードをアセンブリ言語のソースコードに変換する
  - アセンブル
    - アセンブリ言語のソースコードを機械語を含むオブジェクトファイルに変換する
  - リンク
    - オブジェクトファイルから実行ファイルを生成する
- /proc にはプロセスの情報がファイルに格納されている
- ダイナミックロードは、すべてのリンク作業を実行時に行う手法
- 0は成功、1はエラーというのはLinuxに特有の決まりごと
- プロセスの親子関係を調べる ~pstree~
- ログインシェルを調べる ~w~, ~last~
- HTTPの仕組みとファイルシステムはよく似ている
- HTTPで公開されるのはファイルシステムの一部だけ。これをドキュメントツリーという。ドキュメントツリーのルートディレクトリをドキュメントルートという。デフォルト設定のWebサーバでいうところの ~/var/www/html~ のことか
- HTTPサーバのしごと: HTTPリクエストをドキュメントルート以下のファイルにマップし、レスポンスとして送り返すこと
** DONE [[https://www.amazon.co.jp/%E7%A7%81%E3%81%AF%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%81%97%E3%81%A6Linux%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%92%E5%AD%A6%E3%82%93%E3%81%A0%E3%81%8B-Device-Tree%E7%B7%A8%E3%82%86%E3%81%9F%E3%81%8B%E3%81%95%E3%82%93%E3%81%AE%E6%8A%80%E8%A1%93%E6%9B%B8-%E5%B9%B3%E7%94%B0%E8%B1%8A-ebook/dp/B08P2ST2DG/ref=sr_1_2?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=2YLIYL7A4S8SB&keywords=%E7%A7%81%E3%81%AF%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%81%97%E3%81%A6&qid=1704440282&sprefix=%E7%A7%81%E3%81%AF%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%81%97%E3%81%A6%2Caps%2C161&sr=8-2][私はどのようにしてLinuxカーネルを学んだか]]
CLOSED: [2024-01-05 Fri 21:57]
:LOGBOOK:
CLOCK: [2024-01-05 Fri 21:26]--[2024-01-05 Fri 21:51] =>  0:25
CLOCK: [2024-01-05 Fri 19:18]--[2024-01-05 Fri 19:43] =>  0:25
CLOCK: [2024-01-05 Fri 17:04]--[2024-01-05 Fri 17:29] =>  0:25
CLOCK: [2024-01-05 Fri 16:38]--[2024-01-05 Fri 17:03] =>  0:25
:END:
Linuxカーネルの学び方についての本。

- 動かしながら読む
- マクロが多用されているので、あらかじめ展開して読む
- 図を書く
