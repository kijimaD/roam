:PROPERTIES:
:ID:       c4c3816f-e03f-41a8-9a97-ddcfd3d738ff
:header-args+: :results output
:END:
#+title: Haskell

* 概要
Haskellは純粋関数型[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]。
* Memo
** stack
stackはHaskellの開発ツール。
- [[https://docs.haskellstack.org/en/stable/README/][Home - The Haskell Tool Stack]]
** REPL
対話実行環境を立ち上げる。
#+begin_src haskell
  ghci
  >> :load -- ファイル読み込み
  >> :quit -- ghci終了
#+end_src

#+RESULTS:
: <interactive>:972:1-4: error: Variable not in scope: ghci
: <interactive>:973:1-2: error: parse error on input ‘>>’
: <interactive>:974:1-2: error: parse error on input ‘>>’

** 前置引数
#+begin_src haskell
  (+) 2 2
#+end_src

#+RESULTS:
: 4
** マイナス演算子
#+begin_src haskell
  2 + (- 1)
#+end_src

#+RESULTS:
: 1
** :infoコマンド
~infixl~ が演算子の優先順位。
#+begin_src haskell
  :info (+)
#+end_src

#+RESULTS:
: class Num a where
:   (+) :: a -> a -> a
:   ...
:   	-- Defined in ‘GHC.Num’
: infixl 6 +

#+begin_src haskell
  :info (*)
#+end_src

#+RESULTS:
: class Num a where
:   ...
:   (*) :: a -> a -> a
:   ...
:   	-- Defined in ‘GHC.Num’
: infixl 7 *
** 定数
#+begin_src haskell
  pi
#+end_src

#+RESULTS:
: 3.141592653589793
** 代入
#+begin_src haskell
  let e = exp 1
  (e ** pi) - pi
#+end_src

#+RESULTS:
:
: 19.99909997918947
** リスト
#+begin_src haskell
["foo", "bar", "baz"]
#+end_src

#+RESULTS:
: ["foo","bar","baz"]
** 列挙表記
#+begin_src haskell
[1..10]
#+end_src

#+RESULTS:
: [1,2,3,4,5,6,7,8,9,10]

#+begin_src haskell
[1.0,1.25..2.0]
#+end_src

#+RESULTS:
: [1.0,1.25,1.5,1.75,2.0]
** リスト結合
#+begin_src haskell
[3,1,3] ++ [3,7]
#+end_src

#+RESULTS:
: [3,1,3,3,7]
** cons
#+begin_src haskell :results output
  1 : [2, 3]
#+end_src

#+RESULTS:
: [1,2,3]
** 型情報
⚠babelで実行すると実行されなくなるので、GHCIだけで試すこと。
#+begin_src haskell :eval never
  Prelude> :set +t
  Prelude> 'c'
  'c'
  it :: Char

  Prelude> :unset +t
#+end_src
** 型エラー
#+begin_src haskell
1.2 % 3.4
#+end_src

#+RESULTS:
: <interactive>:999:5: error:
:     Variable not in scope: (%) :: Double -> Double -> t
** :type
#+begin_src haskell
:type 1
#+end_src

#+RESULTS:
: 1 :: Num p => p

#+begin_src haskell
:type "abc"
#+end_src

#+RESULTS:
: "abc" :: [Char]

#+begin_src haskell
:type it
#+end_src

#+RESULTS:
: it :: [Char]
** いくつかの数値型関数
#+begin_src haskell
succ 6
#+end_src

#+RESULTS:
: 7

#+begin_src haskell
pred 9
#+end_src

#+RESULTS:
: 8

#+begin_src haskell
sin (pi / 2)
#+end_src

#+RESULTS:
: 1.0

#+begin_src haskell
truncate pi
#+end_src

#+RESULTS:
: 3

#+begin_src haskell
round 3.4
#+end_src

#+RESULTS:
: 3
** ~:?~ コマンド
#+begin_src haskell
:?
#+end_src

#+RESULTS:
#+begin_example
display this list of commands
   :info[!] [<name> ...]       display information about the given names
                               (!: do not filter instances)
   :issafe [<mod>]             display safe haskell information of module <mod>
   :kind[!] <type>             show the kind of <type>
                               (!: also print the normalised type)
   :load[!] [*]<module> ...    load module(s) and their dependents
                               (!: defer type errors)
   :main [<arguments> ...]     run the main function with the given arguments
   :module [+/-] [*]<mod> ...  set the context for expression evaluation
   :quit                       exit GHCi
   :reload[!]                  reload the current module set
                               (!: defer type errors)
   :run function [<arguments> ...] run the function with the given arguments
   :script <file>              run the script <file>
   :type <expr>                show the type of <expr>
   :type +d <expr>             show the type of <expr>, defaulting type variables
   :type +v <expr>             show the type of <expr>, with its specified tyvars
   :unadd <module> ...         remove module(s) from the current target set
   :undef <cmd>                undefine user-defined command :<cmd>
   :!<command>                 run the shell command <command>

 -- Commands for debugging:

   :abandon                    at a breakpoint, abandon current computation
   :back [<n>]                 go back in the history N steps (after :trace)
   :break [<mod>] <l> [<col>]  set a breakpoint at the specified location
   :break <name>               set a breakpoint on the specified function
   :continue                   resume after a breakpoint
   :delete <number>            delete the specified breakpoint
   :delete *                   delete all breakpoints
   :force <expr>               print <expr>, forcing unevaluated parts
   :forward [<n>]              go forward in the history N step s(after :back)
   :history [<n>]              after :trace, show the execution history
   :list                       show the source code around current breakpoint
   :list <identifier>          show the source code for <identifier>
   :list [<module>] <line>     show the source code around line number <line>
   :print [<name> ...]         show a value without forcing its computation
   :sprint [<name> ...]        simplified version of :print
   :step                       single-step after stopping at a breakpoint
   :step <expr>                single-step into <expr>
   :steplocal                  single-step within the current top-level binding
   :stepmodule                 single-step restricted to the current module
   :trace                      trace after stopping at a breakpoint
   :trace <expr>               evaluate <expr> with tracing on (see :history)

 -- Commands for changing settings:

   :set <option> ...           set options
   :seti <option> ...          set options for interactive evaluation only
   :set args <arg> ...         set the arguments returned by System.getArgs
   :set prog <progname>        set the value returned by System.getProgName
   :set prompt <prompt>        set the prompt used in GHCi
   :set prompt-cont <prompt>   set the continuation prompt used in GHCi
   :set prompt-function <expr> set the function to handle the prompt
   :set prompt-cont-function <expr>set the function to handle the continuation prompt
   :set editor <cmd>           set the command used for :edit
   :set stop [<n>] <cmd>       set the command to run when a breakpoint is hit
   :unset <option> ...         unset options

  Options for ':set' and ':unset':

    +m            allow multiline commands
    +r            revert top-level expressions after each evaluation
    +s            print timing/memory stats after each evaluation
    +t            print type after evaluation
    +c            collect type/location info after loading modules
    -<flags>      most GHC command line flags can also be set here
                         (eg. -v2, -XFlexibleInstances, etc.)
                    for GHCi-specific flags, see User's Guide,
                    Flag reference, Interactive-mode options

 -- Commands for displaying information:

   :show bindings              show the current bindings made at the prompt
   :show breaks                show the active breakpoints
   :show context               show the breakpoint context
   :show imports               show the current imports
   :show linker                show current linker state
   :show modules               show the currently loaded modules
   :show packages              show the currently active package flags
   :show paths                 show the currently active search paths
   :show language              show the currently active language flags
   :show targets               show the current set of targets
   :show <setting>             show value of <setting>, which is one of
                                  [args, prog, editor, stop]
   :showi language             show language flags for interactive evaluation
#+end_example
** 型推論
式の後ろに書く::と型の組み合わせのことを ~型シグネチャ~ という。

#+begin_src haskell
  :type 'a'
  'a' :: Char
#+end_src

#+RESULTS:
: 'a' :: Char
: 'a'

#+begin_src haskell
  [1, 2, 3] :: Int
#+end_src

#+RESULTS:
: In an equation for ‘it’: it = [1, 2, 3] :: Int
** 関数適用
#+begin_src haskell
odd 3
#+end_src

#+RESULTS:
: True

#+begin_src haskell
odd 6
#+end_src

#+RESULTS:
: False

#+begin_src haskell
compare 3 3
#+end_src

#+RESULTS:
: EQ

#+begin_src haskell
compare 3 2
#+end_src

#+RESULTS:
: GT

#+begin_src haskell
  (compare 2 3) == LT
  compare 2 3 == LT
#+end_src

#+RESULTS:
: True
: True

#+begin_src haskell
  compare (sqrt 3) (sqrt 6)
#+end_src

#+RESULTS:
: LT
** 合成データ型: リスト
合成データ型は他のデータ型から構成する。よく使う合成データ型はリスト(可変長)とタプル(固定長)。

リスト型は ~多相的~ である。多相型を書く場合には ~型変数~ を使う。
~head :: [a] -> a~ は「どんな型の値を含むかはわからないが、その型の値のリストは作れる」と言っている。
#+begin_src haskell
  :type head
  head [1,2,3,4]
  head ['a','b','c']
  tail [1,2,3,4]
  tail [True,False]
#+end_src

#+RESULTS:
: head :: [a] -> a
: 1
: 'a'
: [2,3,4]
: [False]

#+begin_src haskell
:type [[True],[False,False]]
#+end_src

#+RESULTS:
: [[True],[False,False]] :: [[Bool]]

異なる型ではエラー。

#+begin_src haskell
:type [1, 'a']
#+end_src

#+RESULTS:
: <interactive>:1:2: error:
:     • No instance for (Num Char) arising from the literal ‘1’
:     • In the expression: 1
:       In the expression: [1, 'a']

** 合成データ型: タプル
リストと違ってタプルは型が異なっていてもOK。

#+begin_src haskell
  (1964, "Labyrinths")
  ()
#+end_src

#+RESULTS:
: (1964,"Labyrinths")
: ()

#+begin_src haskell
:type (True, "hello")
#+end_src

#+RESULTS:
: (True, "hello") :: (Bool, [Char])

#+begin_src haskell
:type (4, ['a', 'm'], (16, True))
#+end_src

#+RESULTS:
: (4, ['a', 'm'], (16, True))
:   :: (Num a1, Num a2) => (a1, [Char], (a2, Bool))

タプルの型は数/位置/その位置に含まれる要素の型、で表す。
含まれている要素の型や数が異なれば別の型。

#+begin_src haskell
  :type (False, 'a')
#+end_src

#+RESULTS:
: (False, 'a') :: (Bool, Char)

#+begin_src haskell
  :type ('a', False)
#+end_src

#+RESULTS:
: ('a', False) :: (Char, Bool)

#+begin_src haskell
  :type (False, 'a')
#+end_src

#+RESULTS:
: (False, 'a') :: (Bool, Char)
** 関数
#+begin_src haskell
take 2 [1,2,3,4,5]
#+end_src

#+RESULTS:
: [1,2]

#+begin_src haskell
drop 3 [1,2,3,4,5]
#+end_src

#+RESULTS:
: [4,5]

⚠ ~fst(1,'a')~ と空白なしで書くと、引数2つに見えるが、違うことに注意。
単一のペアへの関数の適用である。

#+begin_src haskell
fst (1,'a')
#+end_src

#+RESULTS:
: 1

#+begin_src haskell
snd (1,'a')
#+end_src

#+RESULTS:
: 'a'
** 関数の型
#+begin_src haskell
:type lines
#+end_src

#+RESULTS:
: lines :: String -> [String]

#+begin_src haskell
lines "the quick\nbrown for\njumps"
#+end_src

#+RESULTS:
: ["the quick","brown for","jumps"]

副作用がある関数で結果の型は ~IO~ ではじまる。

#+begin_src haskell
:type readFile
#+end_src

#+RESULTS:
: readFile :: FilePath -> IO String
** 関数定義
Haskellのコードの中では、記号 ~=~ は「〜を意味する」ということ。左辺の名前は右辺の式であると定義される。
変数は式に名前をつける手段。

#+begin_quote
命令形言語を使ってきたのなら、変数は、異なる辞典で、異なる値を格納し得るメモリの番地(またはそれに類するもの)を特定する方法と考えるのが自然かもしれません。命令形言語では、いつでも変数の値を変更することが可能です。したがって、その変数のメモリ番地を確認するたびに違う結果になりえます。
変数に対する、この2つの概念には決定的な違いがあります。Haskellでは、式にいったん束縛した変数は、いつでも元の式に置き換えても良いのです。変数の値は変わらないからです。命令形言語はこの置き換え可能性を保持していません。
#+end_quote

#+begin_src haskell
  add a b = a + b
  add 1 2
#+end_src

#+RESULTS:
:
: 3

#+begin_src haskell
  drop 2 "foobar"
  drop 4 "foobar"
  drop 4 [1, 2]
  drop 0 [1, 2]
  drop 7 []
  drop (-2) "foo"
#+end_src

#+RESULTS:
: obar
: ar
: []
: [1,2]
: []
: foo
** myDrop関数
インデントによって既存の定義が継続する。
org-babelでは1行ごとで新しいセッションになってしまうよう。 ~:{~ と ~}:~ を使って複数行評価されるようにする。

変数名 ~xs~ は ~x~ の複数形という意味。

式指向のためelseが必須(elseに入ったとき結果や型がないという事態になるため)。
#+begin_src haskell
  :{
    myDrop n xs = if n <= 0 || null xs
                  then xs
                  else myDrop (n - 1) (tail xs)
  :}

  myDrop 2 "foobar"
  myDrop 4 "foobar"
  myDrop 4 [1, 2]
  myDrop 0 [1, 2]
  myDrop 7 []
  myDrop(-2) "foo"
#+end_src

#+RESULTS:
:
: Prelude> "obar"
: ar
: []
: [1,2]
: []
: foo

論理演算子。
#+begin_src haskell
  :type null
  :type (||)
#+end_src

#+RESULTS:
: null :: Foldable t => t a -> Bool
: (||) :: Bool -> Bool -> Bool
** 遅延評価
正格評価: 関数を適用する前に関数への引数を評価する。
*非正格評価(遅延評価)*: 評価せず、値が必要になったとき計算する「プロミス」を作る。未評価の式を追跡するのに使うレコードを *サンク* という。式の結果が使われないなら、値は計算されない。

#+begin_src haskell
  isOdd n = mod n 2 == 1
  isOdd 3
#+end_src

#+RESULTS:
:
: True

#+begin_src haskell
  print (myDrop 2 "abcd")

  :type 2 <= 0 || null "abcd"
  null "abcd"
#+end_src

#+RESULTS:
: cd
: Prelude> 2 <= 0 || null "abcd" :: Prelude.Bool
: False
** 型変数
#+begin_src haskell
  last [1,2,3]
  last "baz"
  :type last
#+end_src

#+RESULTS:
: 3
: 'z'
: last :: [a] -> a

この ~a~ が型変数。
型シグネチャに型変数を持つ時には引数のいくつかはどのような型にでもなれることを示している。→ 多相的である。
** 多相関数
#+begin_src haskell
  :type fst
#+end_src

#+RESULTS:
: fst :: (a, b) -> a

#+begin_src haskell
:type take
#+end_src

#+RESULTS:
: take :: Int -> [a] -> [a]

これは実際にはこういうこと↓。

~take :: Int -> ([a] -> [a])~
** 純粋性
#+begin_src haskell
:type not
#+end_src

#+RESULTS:
: not :: Bool -> Bool
** 型定義

↓ BookInfoを ~型構成子~ という。
続く Bookは ~値構成子~ という。
Int, String, [String]は ~構成要素~ という。

#+begin_src haskell
  :{
  data BookInfo = Book Int String [String]
                  deriving (Show)
  :}
#+end_src

#+RESULTS:

同じ構造を持っていても、2つの型を区別する。型構成子と値構成子の名前が違うから。

#+begin_src haskell
  :{
  data MagazineInfo = Magazine Int String [String]
                      deriving (Show)
  :}
#+end_src

#+RESULTS:

#+begin_src haskell
  :info BookInfo

  myInfo = Book 9780135072455 "Algebra of Programming" ["Richard Bird", "Oege de Moor"]
  myInfo
  :type myInfo
  :type Book
#+end_src

#+RESULTS:
: data BookInfo = Book Int String [String]
:   	-- Defined at <interactive>:1534:1
: instance [safe] Show BookInfo -- Defined at <interactive>:1535:27
: Prelude> Prelude> Book 9780135072455 "Algebra of Programming" ["Richard Bird","Oege de Moor"]
: myInfo :: BookInfo
: Book :: Int -> String -> [String] -> BookInfo
** 型シノニム
型シノニムはコードを読みやすくするだけのもの。

#+begin_src haskell
  type CustomerID = Int
  type ReviewBody = String
  data BetterReview = BetterReview BookInfo CustomerID ReviewBody
#+end_src

#+RESULTS:
** 代数データ型
値構成子が2つある。 *選択肢* あるいは *ケース* という。

#+begin_src haskell
  data Bool = False | True
#+end_src

#+RESULTS:

#+begin_src haskell
  type CardHolder = String
  type CardNumber = String
  type Address = [String]

  :{
  data BillingInfo = CreditCard CardNumber CardHolder Address
                     | CashOnDelivery
                     | Invoice CustomerID
                       deriving (Show)
  :}
  :info BillingInfo
#+end_src

#+RESULTS:
:
: Prelude> Prelude> Prelude> Prelude| Prelude| Prelude| Prelude| Prelude| Prelude> data BillingInfo
:   = CreditCard CardNumber CardHolder Address
:   | CashOnDelivery
:   | Invoice CustomerID
:   	-- Defined at <interactive>:1636:1
: instance [safe] Show BillingInfo
:   -- Defined at <interactive>:1639:32
: Prelude> CreditCard :: CardNumber -> CardHolder -> Address -> BillingInfo

#+begin_src haskell
  :type CreditCard
  CreditCard "2901650221064486" "Thomas Gradgrind"  ["Dickens", "England"]
#+end_src

#+RESULTS:
: CreditCard :: CardNumber -> CardHolder -> Address -> BillingInfo
: CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens","England"]

#+begin_src haskell
  :type it
#+end_src

#+RESULTS:
: it :: [Char]

#+begin_src haskell
  :type Invoice
  Invoice 2222
#+end_src

#+RESULTS:
: Invoice :: CustomerID -> BillingInfo
: Invoice 2222

** タプルと代数データ型
#+begin_src haskell
  Book 2 "The Wealth of Networks" ["Yochai Benkler"]
  (2, "The Wealth of Networks", ["Yochai Benkler"])
#+end_src

#+RESULTS:
: Book 2 "The Wealth of Networks" ["Yochai Benkler"]
: (2,"The Wealth of Networks",["Yochai Benkler"])

↓構造的に同一なので同じ型。

#+begin_src haskell
  a = ("Porpoise", "Gray")
  b = ("Table", "Oak")
#+end_src

↓別の名前なので別の型。

#+begin_src haskell
  data Cetacean = Cetacean String String
  data Furniture = Furniture String String

  c = Cetacean "Porpoise" "Gray"
  d = Furniture "Table" "Oak"
#+end_src

#+RESULTS:

座標。

#+begin_src haskell
  :{
  -- x, yの座標
  data Cartesian2D = Cartesian2D Double Double
                     deriving (Eq, Show)

  -- 偏角と長さ
  data Polar2D = Polar2D Double Double
                 deriving (Eq, Show)
  :}
#+end_src

#+RESULTS:

~==~ 演算子は引数が同じ型でないといけないのでエラー。

#+begin_src haskell
  Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
#+end_src

#+RESULTS:
: <interactive>:1737:34-51: error:
:     • Couldn't match expected type ‘Cartesian2D’
:                   with actual type ‘Polar2D’
:     • In the second argument of ‘(==)’, namely ‘Polar2D (pi / 4) 2’
:       In the expression:
:         Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
:       In an equation for ‘it’:
:           it = Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
: Prelude> False

タプルの場合判断しようがないのでチェックが効かない。

#+begin_src haskell
(1, 2) == (1, 2)
#+end_src

#+RESULTS:
: True

- 複合型をコードの中で広く使う場合には ~data~ 宣言を使う
- 規模が小さく、局所的にしか使わない場合はタプルでいい

** 他の言語との類似

#+begin_src C
  struct book_info {
    int id;
    char *name;
    char **authors;
  };
#+end_src

#+RESULTS:

#+begin_src haskell
  :{
  data BookInfo = Book Int String [String]
                    deriving (Show)
  :}
#+end_src

#+RESULTS:

** 列挙型

[[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C language]]ではこう書く。

#+begin_src C
  enum roygbiv {
    red,
    orange,
    yellow,
    green,
    blue,
    indigo,
    violet,
  };
#+end_src

#+RESULTS:

#+begin_src haskell
  :{
  data Roygbiv = Red
               | Orange
               | Yellow
               | Green
               | Blue
               | Indigo
               | Violet
                 deriving (Eq, Show)
  :}
  :type Yellow
  :type Red
  Red == Yellow
  Green == Green
#+end_src

#+RESULTS:
:
: Yellow :: Roygbiv
: Red :: Roygbiv
: False
: True

haskellのenumは型が厳密。
#+begin_src haskell
  take 3 "foobar"
  take Red "foobar"
#+end_src

#+RESULTS:
: foo
: <interactive>:1854:6-8: error:
:     • Couldn't match expected type ‘Int’ with actual type ‘Roygbiv’
:     • In the first argument of ‘take’, namely ‘Red’
:       In the expression: take Red "foobar"
:       In an equation for ‘it’: it = take Red "foobar"

** union
代数データ型が複数の選択肢を持つ場合は [[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C language]]の ~union~ と同じ。
#+begin_src haskell
  type Vector = (Double, Double)
  :{
  data Shape = Circle Vector Double
             | Poly [Vector]
  :}
  :info Shape
#+end_src

#+RESULTS:
:
: Prelude| Prelude| Prelude| Prelude> data Shape = Circle Vector Double | Poly [Vector]
:   	-- Defined at <interactive>:1888:1
: <interactive>:1:1-5: error: Data constructor not in scope: Shape

** パターンマッチ

↓2つの関数というわけではない。
同一関数の異なる入力パターンに対する振る舞いを定義している。

#+begin_src haskell
  myNot True = False
  myNot False = True
#+end_src

#+RESULTS:

#+begin_src haskell
  sumList (x:xs) = x + sumList xs
  sumList [] = 0

  sum [1,2]
#+end_src

#+RESULTS:
:
: Prelude> Prelude> 3

タプルのパターンマッチ。

#+begin_src haskell
  complicated (True, a, x:xs, 5) = (a, xs)
  complicated (True, 1, [1,2,3], 5)
#+end_src

#+RESULTS:
:
: (1,[2,3])

ぴったり一致しないと成功しない。
すべてのパターンマッチが失敗すると実行時エラー。

#+begin_src haskell
complicated (False, 1, [1,2,3], 5)
#+end_src

#+RESULTS:
: *** Exception: <interactive>:1963:1-40: Non-exhaustive patterns in function complicated


BookInfo型の場合。
パターンマッチをセット。

#+begin_src haskell
  bookID (Book id title authors) = id
  bookTitle (Book id title authors) = title
  bookAuthors (Book id title authors) = authors
#+end_src

#+RESULTS:

アクセスできる。

#+begin_src haskell
  bookID (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
  bookTitle (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
  bookAuthors (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
#+end_src

#+RESULTS:
: 3
: Probability Theory
: ["E.T.H. Jaynes"]

構成子に基づいて、アクセサ関数の型を推論できる。

#+begin_src haskell
  :type bookID
  :type bookTitle
  :type bookAuthors
#+end_src

#+RESULTS:
: bookID :: BookInfo -> Int
: bookTitle :: BookInfo -> String
: bookAuthors :: BookInfo -> [String]
** ワイルドカード
この類のコードをボイラープレートという。

#+begin_src haskell
  nicerID (Book id _ _ ) = id
  nicerTitle (Book _ title _) = title
  nicerAuthors (Book _ _ authors) = authors
#+end_src

#+RESULTS:

#+begin_src haskell
  goodExample (x:xs) = x + goodExample xs
  goodExample _ = 0
  goodExample []
  goodExample [1, 2]
#+end_src

#+RESULTS:
:
: Prelude> 0
: 0
** レコード構文
#+begin_src haskell
  :{
    data Customer = Customer {
       customerID :: CustomerID
     , customerName :: String
     , customerAddress :: Address
       } deriving (Show)
  :}
  :type customerID
#+end_src

#+RESULTS:
:
: customerID :: Customer -> CustomerID

#+begin_src haskell
  :{
  customer2 = Customer {
      customerID = 271828
    , customerAddress = ["1048576 Disk Drive",
                        "Milpitas, CA 95134",
                        "USA"]
    , customerName = "Jane Q. Citizen"
    }
  :}
  customer2
  cities
#+end_src

#+RESULTS:
:
: Customer {customerID = 271828, customerName = "Jane Q. Citizen", customerAddress = ["1048576 Disk Drive","Milpitas, CA 95134","USA"]}
: Book 173 "Use of weapons" ["Iain M. Banks"]

レコード構文によって使えるアクセサ関数は、通常のHaskellの関数。

#+begin_src haskell
  :type customerName
  customerName customer2
#+end_src

#+RESULTS:
: customerName :: Customer -> String
: Jane Q. Citizen
** パラメータ化された型
独自に定義する型も多相型にできる。型宣言に型変数を導入する。

↓この変数は型変数。
#+begin_src haskell
  :{
  data Maybe a = Just a
               | Nothing
  :}
  :info Maybe
#+end_src

#+RESULTS:
:
: data Maybe a = Just a | Nothing 	-- Defined at <interactive>:2300:1

これによって任意の型上の ~Maybe~ 型を使える。

#+begin_src haskell
  someBool = Just True
  :type someBool
  someString = Just "something"
  :type someString
  :type Just "Invisible bike"
#+end_src

#+RESULTS:
:
: someBool :: Maybe Bool
: Prelude> someString :: Maybe [Char]
: Just "Invisible bike" :: Maybe [Char]

#+begin_src haskell
  wrapped = Just (Just "wrapped")
  :type wrapped
#+end_src

#+RESULTS:
:
: wrapped :: Maybe (Maybe [Char])
** 再帰型
リスト型は再帰型。定義に自身が含まれる。
#+begin_src haskell
  :{
  data List a = Cons a (List a)
              | Nil
                deriving (Show)
  :}
#+end_src

#+RESULTS:

確かめる。
#+begin_src haskell
  Nil
  Cons 0 Nil
  Cons 1 it
  Cons 2 it
  Cons 3 it
#+end_src

#+RESULTS:
: Nil
: Cons 0 Nil
: Cons 1 (Cons 0 Nil)
: Cons 2 (Cons 1 (Cons 0 Nil))
: Cons 3 (Cons 2 (Cons 1 (Cons 0 Nil)))

二分木。

#+begin_src haskell
  :{
  data Tree a = Node a (Tree a) (Tree a)
              | Empty
                deriving (Show)
  :}
#+end_src

#+RESULTS:

#+begin_src haskell
  fromList (x:xs) = Cons x (fromList xs)
  fromList [] = Nil
  fromList "durian"
  fromList [Just True, Nothing, Just False]
#+end_src

本と違ってなぜかエラーになる。

#+RESULTS:
:
: Prelude> *** Exception: <interactive>:2452:1-17: Non-exhaustive patterns in function fromList
: *** Exception: <interactive>:2452:1-17: Non-exhaustive patterns in function fromList

[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]の例(クラス定義)。
#+begin_src java
  class Tree<A>
  {
      A value;
      Tree<A> left;
      Tree<B> right;

      public Tree(A v, Tree<A> l, Tree<A> r)
      {
          value = v;
          left = l;
          right = r;
      }
  }
#+end_src

葉を構成する関数。

#+begin_src java
  class Example
  {
      static Tree<String> simpleTree()
      {
          return new Tree<String>(
                                  "parent",
                                  new Tree<String>("left leaf", null, null),
                                  new Tree<String>("right leaf", null, null));
      }
  }
#+end_src

#+begin_src haskell
  simpleTree = Node "parent" (Node "left child" Empty Empty)
                             (Node "right child" Empty Empty)
#+end_src

* Tasks
** TODO org-babelでhaskellを実行できなくなる
~:set +t~ を評価すると使えなくなる。
** TODO xmpfilterのHaskell版を探す or 作る
なければ簡易版で作る。
いちいちロード、コンパイルは学習に不便。既存のがあるはずだが、調べ方がわからない。

~org-babel~ でよさそう。
** TODO [[https://www.oreilly.co.jp/books/9784873114231/][O'Reilly Japan - Real World Haskell]] [0%]
<2021-10-15 Fri>

*** TODO 100
:LOGBOOK:
CLOCK: [2021-10-07 Thu 09:58]--[2021-10-07 Thu 10:57] =>  0:59
CLOCK: [2021-10-07 Thu 09:24]--[2021-10-07 Thu 09:34] =>  0:10
CLOCK: [2021-10-06 Wed 22:25]--[2021-10-07 Thu 00:07] =>  1:42
CLOCK: [2021-10-06 Wed 08:47]--[2021-10-06 Wed 09:18] =>  0:31
CLOCK: [2021-10-06 Wed 00:05]--[2021-10-06 Wed 00:55] =>  0:50
CLOCK: [2021-10-05 Tue 22:08]--[2021-10-05 Tue 23:37] =>  1:29
CLOCK: [2021-10-05 Tue 09:48]--[2021-10-05 Tue 10:54] =>  1:06
CLOCK: [2021-10-05 Tue 09:22]--[2021-10-05 Tue 09:31] =>  0:09
CLOCK: [2021-10-04 Mon 10:13]--[2021-10-04 Mon 11:03] =>  0:50
CLOCK: [2021-10-03 Sun 20:22]--[2021-10-03 Sun 21:53] =>  1:31
CLOCK: [2021-10-03 Sun 16:41]--[2021-10-03 Sun 17:29] =>  0:48
CLOCK: [2021-10-03 Sun 15:15]--[2021-10-03 Sun 15:23] =>  0:08
CLOCK: [2021-10-02 Sat 23:12]--[2021-10-03 Sun 00:16] =>  1:04
:END:
<2021-10-03 Sun>
*** TODO 200
*** TODO 300
*** TODO 400
*** TODO 500
*** TODO 600
*** TODO 700
* Reference
** [[https://www.infoq.com/jp/articles/Understanding-Monads-guide-for-perplexed/][モナドを理解する - 迷える者への手引き]]
Haskellのモナドの解説。
** [[https://ja.wikipedia.org/wiki/Haskell][Haskell - Wikipedia]]
* Archive
** DONE すごいHaskellたのしく学ぼう [100%]
CLOSED: [2021-09-28 Tue 23:44] DEADLINE: <2021-09-30 Thu>
:LOGBOOK:
CLOCK: [2021-09-19 Sun 14:38]--[2021-09-19 Sun 15:03] =>  0:25
CLOCK: [2021-09-17 Fri 22:40]--[2021-09-17 Fri 23:05] =>  0:25
CLOCK: [2021-09-15 Wed 10:19]--[2021-09-15 Wed 10:44] =>  0:25
CLOCK: [2021-09-15 Wed 09:52]--[2021-09-15 Wed 10:17] =>  0:25
:END:

何か作る的なテーマがないので読むのがつらい。
参考になりそうなパッケージを探したけど、ピンとくるものがない。
いくつかパッケージをbuildしてみたが、依存パッケージで動かない。どうするかな。

よくわからん。
*** DONE 30%
CLOSED: [2021-09-23 Thu 21:14] DEADLINE: <2021-09-23 Thu>
:LOGBOOK:
CLOCK: [2021-09-23 Thu 20:15]--[2021-09-23 Thu 21:14] =>  0:59
:END:
*** DONE 40%
CLOSED: [2021-09-24 Fri 23:59] DEADLINE: <2021-09-24 Fri>
:LOGBOOK:
CLOCK: [2021-09-24 Fri 22:50]--[2021-09-24 Fri 23:59] =>  1:09
CLOCK: [2021-09-24 Fri 22:11]--[2021-09-24 Fri 22:26] =>  0:15
:END:
*** DONE 50%
CLOSED: [2021-09-25 Sat 16:31]
:LOGBOOK:
CLOCK: [2021-09-25 Sat 15:54]--[2021-09-25 Sat 16:30] =>  0:36
CLOCK: [2021-09-25 Sat 14:43]--[2021-09-25 Sat 14:53] =>  0:10
:END:
<2021-09-25 Sat>
*** DONE 60%
CLOSED: [2021-09-25 Sat 17:26]
:LOGBOOK:
CLOCK: [2021-09-25 Sat 16:35]--[2021-09-25 Sat 17:26] =>  0:51
:END:
<2021-09-25 Sat>
*** DONE 70%
CLOSED: [2021-09-26 Sun 22:06]
:LOGBOOK:
CLOCK: [2021-09-26 Sun 21:13]--[2021-09-26 Sun 22:06] =>  0:53
:END:
<2021-09-26 Sun>
*** DONE 80%
CLOSED: [2021-09-27 Mon 00:04]
:LOGBOOK:
CLOCK: [2021-09-26 Sun 22:49]--[2021-09-27 Mon 00:04] =>  1:15
:END:
<2021-09-26 Sun>
*** DONE 90%
CLOSED: [2021-09-28 Tue 22:56]
:LOGBOOK:
CLOCK: [2021-09-28 Tue 22:05]--[2021-09-28 Tue 22:56] =>  0:51
:END:
<2021-09-28 Tue>
*** DONE 100%
CLOSED: [2021-09-28 Tue 23:44]
:LOGBOOK:
CLOCK: [2021-09-28 Tue 22:56]--[2021-09-28 Tue 23:44] =>  0:48
:END:
<2021-09-28 Tue>
