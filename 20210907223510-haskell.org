:PROPERTIES:
:ID:       c4c3816f-e03f-41a8-9a97-ddcfd3d738ff
:header-args+: :results output :wrap
:mtime:    20241102180400 20241028101410
:ctime:    20210907223510
:END:
#+title: Haskell
* 概要
Haskellは純粋関数型[[id:868ac56a-2d42-48d7-ab7f-7047c85a8f39][Programming Language]]。
* Memo
** QuickCheck
QuickCheckというテストライブラリがある。型に基づくプロパティテスト、というもののよう。

[[https://haskell.e-bigmoon.com/stack/test/quickcheck.html][【基礎】ランダムテスト (QuickCheck)]]
** stack
stackはHaskellの開発ツール。
- [[https://docs.haskellstack.org/en/stable/README/][Home - The Haskell Tool Stack]]
** REPL
対話実行環境を立ち上げる。
#+begin_src haskell :eval never
  ghci
  >> :load -- ファイル読み込み
  >> :reload -- 再読込。org-babelがおかしくなったときに使える
  >> :quit -- ghci終了
#+end_src

プロンプトをセット。
#+begin_src haskell
  :set prompt "GHCi> "
#+end_src
** 前置引数
#+begin_src haskell
  (+) 2 2
#+end_src

#+RESULTS:
#+begin_results
4
#+end_results
** マイナス演算子
#+begin_src haskell
  2 + (- 1)
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results
** :infoコマンド
~infixl~ が演算子の優先順位。
#+begin_src haskell
  :info (+)
#+end_src

#+RESULTS:
#+begin_results
class Num a where
  (+) :: a -> a -> a
  ...
  -- Defined in ‘GHC.Num’
infixl 6 +
#+end_results

#+begin_src haskell
  :info (*)
#+end_src

#+RESULTS:
#+begin_results
class Num a where
  ...
  (*) :: a -> a -> a
  ...
  -- Defined in ‘GHC.Num’
infixl 7 *
#+end_results
** 定数
#+begin_src haskell
  pi
#+end_src

#+RESULTS:
#+begin_results
3.141592653589793
#+end_results
** 代入
#+begin_src haskell
  let e = exp 1
  (e ** pi) - pi
#+end_src

#+RESULTS:
#+begin_results
19.99909997918947
#+end_results
** リスト
#+begin_src haskell
["foo", "bar", "baz"]
#+end_src

#+RESULTS:
#+begin_results
["foo","bar","baz"]
#+end_results
** 列挙表記
#+begin_src haskell
[1..10]
#+end_src

#+RESULTS:
#+begin_results
[1,2,3,4,5,6,7,8,9,10]
#+end_results

#+begin_src haskell
[1.0,1.25..2.0]
#+end_src

#+RESULTS:
#+begin_results
[1.0,1.25,1.5,1.75,2.0]
#+end_results
** リスト結合
#+begin_src haskell
[3,1,3] ++ [3,7]
#+end_src

#+RESULTS:
#+begin_results
[3,1,3,3,7]
#+end_results
** cons
#+begin_src haskell :results output
  1 : [2, 3]
#+end_src

#+RESULTS:
#+begin_results
[1,2,3]
#+end_results
** 型情報
⚠babelで実行すると実行されなくなるので、GHCIだけで試すこと。
#+begin_src haskell :eval never
  Prelude> :set +t
  Prelude> 'c'
  'c'
  it :: Char

  Prelude> :unset +t
#+end_src
** 型エラー
#+begin_src haskell
1.2 % 3.4
#+end_src

#+RESULTS:
#+begin_results
<interactive>:6213:5: error:
    Variable not in scope: (%) :: Double -> Double -> t
#+end_results
** :type
#+begin_src haskell
:type 1
#+end_src

#+RESULTS:
#+begin_results
1 :: Num p => p
#+end_results

#+begin_src haskell
:type "abc"
#+end_src

#+RESULTS:
#+begin_results
"abc" :: [Char]
#+end_results

#+begin_src haskell
:type it
#+end_src

#+RESULTS:
#+begin_results
it :: [Char]
#+end_results
** いくつかの数値型関数
#+begin_src haskell
succ 6
#+end_src

#+RESULTS:
#+begin_results
7
#+end_results

#+begin_src haskell
pred 9
#+end_src

#+RESULTS:
#+begin_results
8
#+end_results

#+begin_src haskell
sin (pi / 2)
#+end_src

#+RESULTS:
#+begin_results
1.0
#+end_results

#+begin_src haskell
truncate pi
#+end_src

#+RESULTS:
#+begin_results
3
#+end_results

#+begin_src haskell
round 3.4
#+end_src

#+RESULTS:
#+begin_results
3
#+end_results
** ~:?~ コマンド
#+begin_src haskell
:?
#+end_src

#+RESULTS:
#+begin_results
display this list of commands
   :info[!] [<name> ...]       display information about the given names
                               (!: do not filter instances)
   :issafe [<mod>]             display safe haskell information of module <mod>
   :kind[!] <type>             show the kind of <type>
                               (!: also print the normalised type)
   :load[!] [*]<module> ...    load module(s) and their dependents
                               (!: defer type errors)
   :main [<arguments> ...]     run the main function with the given arguments
   :module [+/-] [*]<mod> ...  set the context for expression evaluation
   :quit                       exit GHCi
   :reload[!]                  reload the current module set
                               (!: defer type errors)
   :run function [<arguments> ...] run the function with the given arguments
   :script <file>              run the script <file>
   :type <expr>                show the type of <expr>
   :type +d <expr>             show the type of <expr>, defaulting type variables
   :type +v <expr>             show the type of <expr>, with its specified tyvars
   :unadd <module> ...         remove module(s) from the current target set
   :undef <cmd>                undefine user-defined command :<cmd>
   :!<command>                 run the shell command <command>

 -- Commands for debugging:

   :abandon                    at a breakpoint, abandon current computation
   :back [<n>]                 go back in the history N steps (after :trace)
   :break [<mod>] <l> [<col>]  set a breakpoint at the specified location
   :break <name>               set a breakpoint on the specified function
   :continue                   resume after a breakpoint
   :delete <number>            delete the specified breakpoint
   :delete *                   delete all breakpoints
   :force <expr>               print <expr>, forcing unevaluated parts
   :forward [<n>]              go forward in the history N step s(after :back)
   :history [<n>]              after :trace, show the execution history
   :list                       show the source code around current breakpoint
   :list <identifier>          show the source code for <identifier>
   :list [<module>] <line>     show the source code around line number <line>
   :print [<name> ...]         show a value without forcing its computation
   :sprint [<name> ...]        simplified version of :print
   :step                       single-step after stopping at a breakpoint
   :step <expr>                single-step into <expr>
   :steplocal                  single-step within the current top-level binding
   :stepmodule                 single-step restricted to the current module
   :trace                      trace after stopping at a breakpoint
   :trace <expr>               evaluate <expr> with tracing on (see :history)

 -- Commands for changing settings:

   :set <option> ...           set options
   :seti <option> ...          set options for interactive evaluation only
   :set args <arg> ...         set the arguments returned by System.getArgs
   :set prog <progname>        set the value returned by System.getProgName
   :set prompt <prompt>        set the prompt used in GHCi
   :set prompt-cont <prompt>   set the continuation prompt used in GHCi
   :set prompt-function <expr> set the function to handle the prompt
   :set prompt-cont-function <expr>set the function to handle the continuation prompt
   :set editor <cmd>           set the command used for :edit
   :set stop [<n>] <cmd>       set the command to run when a breakpoint is hit
   :unset <option> ...         unset options

  Options for ':set' and ':unset':

    +m            allow multiline commands
    +r            revert top-level expressions after each evaluation
    +s            print timing/memory stats after each evaluation
    +t            print type after evaluation
    +c            collect type/location info after loading modules
    -<flags>      most GHC command line flags can also be set here
                         (eg. -v2, -XFlexibleInstances, etc.)
                    for GHCi-specific flags, see User's Guide,
                    Flag reference, Interactive-mode options

 -- Commands for displaying information:

   :show bindings              show the current bindings made at the prompt
   :show breaks                show the active breakpoints
   :show context               show the breakpoint context
   :show imports               show the current imports
   :show linker                show current linker state
   :show modules               show the currently loaded modules
   :show packages              show the currently active package flags
   :show paths                 show the currently active search paths
   :show language              show the currently active language flags
   :show targets               show the current set of targets
   :show <setting>             show value of <setting>, which is one of
                                  [args, prog, editor, stop]
   :showi language             show language flags for interactive evaluation
#+end_results
** 型推論
式の後ろに書く::と型の組み合わせのことを ~型シグネチャ~ という。

#+begin_src haskell
  :type 'a'
  'a' :: Char
#+end_src

#+RESULTS:
#+begin_results
'a' :: Char
'a'
#+end_results

#+begin_src haskell
  [1, 2, 3] :: Int
#+end_src

#+RESULTS:
#+begin_results
In an equation for ‘it’: it = [1, 2, 3] :: Int
#+end_results
** 関数適用
#+begin_src haskell
odd 3
#+end_src

#+RESULTS:
#+begin_results
True
#+end_results

#+begin_src haskell
odd 6
#+end_src

#+RESULTS:
#+begin_results
False
#+end_results

#+begin_src haskell
compare 3 3
#+end_src

#+RESULTS:
#+begin_results
EQ
#+end_results

#+begin_src haskell
compare 3 2
#+end_src

#+RESULTS:
#+begin_results
GT
#+end_results

#+begin_src haskell
  (compare 2 3) == LT
  compare 2 3 == LT
#+end_src

#+RESULTS:
#+begin_results
True
True
#+end_results

#+begin_src haskell
  compare (sqrt 3) (sqrt 6)
#+end_src

#+RESULTS:
#+begin_results
LT
#+end_results
** 合成データ型: リスト
合成データ型は他のデータ型から構成する。よく使う合成データ型はリスト(可変長)とタプル(固定長)。

リスト型は ~多相的~ である。多相型を書く場合には ~型変数~ を使う。
~head :: [a] -> a~ は「どんな型の値を含むかはわからないが、その型の値のリストは作れる」と言っている。
#+begin_src haskell
  :type head
  head [1,2,3,4]
  head ['a','b','c']
  tail [1,2,3,4]
  tail [True,False]
#+end_src

#+RESULTS:
#+begin_results
<interactive>:5924:1-17: error:
    • No instance for (Show Bool) arising from a use of ‘print’
      There are instances for similar types:
        instance Show Prelude.Bool -- Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
#+end_results

#+begin_src haskell :eval never
  -- 評価結果のBoolがリンクで解釈されてエクスポート時にエラーになるので再評価しない。
  :type [[True],[False,False]]
#+end_src

#+RESULTS:
#+begin_results
[[True],[False,False]] :: ~[[Bool]]~
#+end_results

異なる型ではエラー。

#+begin_src haskell
:type [1, 'a']
#+end_src

#+RESULTS:
#+begin_results
<interactive>:1:2: error:
    • No instance for (Num Char) arising from the literal ‘1’
    • In the expression: 1
      In the expression: [1, 'a']
#+end_results

** 合成データ型: タプル
リストと違ってタプルは型が異なっていてもOK。

#+begin_src haskell
  (1964, "Labyrinths")
  ()
#+end_src

#+RESULTS:
#+begin_results
(1964,"Labyrinths")
()
#+end_results

#+begin_src haskell
:type (True, "hello")
#+end_src

#+RESULTS:
#+begin_results
(True, "hello") :: (Bool, [Char])
#+end_results

#+begin_src haskell
:type (4, ['a', 'm'], (16, True))
#+end_src

#+RESULTS:
#+begin_results
(4, ['a', 'm'], (16, True))
  :: (Num a1, Num a2) => (a1, [Char], (a2, Bool))
#+end_results

タプルの型は数/位置/その位置に含まれる要素の型、で表す。
含まれている要素の型や数が異なれば別の型。

#+begin_src haskell
  :type (False, 'a')
#+end_src

#+RESULTS:
#+begin_results
(False, 'a') :: (Bool, Char)
#+end_results

#+begin_src haskell
  :type ('a', False)
#+end_src

#+RESULTS:
#+begin_results
('a', False) :: (Char, Bool)
#+end_results

#+begin_src haskell
  :type (False, 'a')
#+end_src

#+RESULTS:
#+begin_results
(False, 'a') :: (Bool, Char)
#+end_results
** 関数
#+begin_src haskell
take 2 [1,2,3,4,5]
#+end_src

#+RESULTS:
#+begin_results
[1,2]
#+end_results

#+begin_src haskell
drop 3 [1,2,3,4,5]
#+end_src

#+RESULTS:
#+begin_results
[4,5]
#+end_results

⚠ ~fst(1,'a')~ と空白なしで書くと、引数2つに見えるが、違うことに注意。
単一のペアへの関数の適用である。

#+begin_src haskell
fst (1,'a')
#+end_src

#+RESULTS:
#+begin_results
1
#+end_results

#+begin_src haskell
snd (1,'a')
#+end_src

#+RESULTS:
#+begin_results
'a'
#+end_results
** 関数の型
#+begin_src haskell
:type lines
#+end_src

#+RESULTS:
#+begin_results
lines :: String -> [String]
#+end_results

#+begin_src haskell
lines "the quick\nbrown for\njumps"
#+end_src

#+RESULTS:
#+begin_results
["the quick","brown for","jumps"]
#+end_results

副作用がある関数で結果の型は ~IO~ ではじまる。

#+begin_src haskell
:type readFile
#+end_src

#+RESULTS:
#+begin_results
readFile :: FilePath -> IO String
#+end_results
** 関数定義
Haskellのコードの中では、記号 ~=~ は「〜を意味する」ということ。左辺の名前は右辺の式であると定義される。
変数は式に名前をつける手段。

#+begin_quote
命令形言語を使ってきたのなら、変数は、異なる辞典で、異なる値を格納し得るメモリの番地(またはそれに類するもの)を特定する方法と考えるのが自然かもしれません。命令形言語では、いつでも変数の値を変更することが可能です。したがって、その変数のメモリ番地を確認するたびに違う結果になりえます。
変数に対する、この2つの概念には決定的な違いがあります。Haskellでは、式にいったん束縛した変数は、いつでも元の式に置き換えても良いのです。変数の値は変わらないからです。命令形言語はこの置き換え可能性を保持していません。
#+end_quote

#+begin_src haskell
  add a b = a + b
  add 1 2
#+end_src

#+RESULTS:
#+begin_results

3
#+end_results

#+begin_src haskell
  drop 2 "foobar"
  drop 4 "foobar"
  drop 4 [1, 2]
  drop 0 [1, 2]
  drop 7 []
  drop (-2) "foo"
#+end_src

#+RESULTS:
#+begin_results
obar
ar
[]
[1,2]
[]
foo
#+end_results
** myDrop関数
インデントによって既存の定義が継続する。
org-babelでは1行ごとで新しいセッションになってしまうよう。 ~:{~ と ~}:~ を使って複数行評価されるようにする。

変数名 ~xs~ は ~x~ の複数形という意味。

式指向のためelseが必須(elseに入ったとき結果や型がないという事態になるため)。
#+begin_src haskell
  :{
    myDrop n xs = if n <= 0 || null xs
                  then xs
                  else myDrop (n - 1) (tail xs)
  :}

  myDrop 2 "foobar"
  myDrop 4 "foobar"
  myDrop 4 [1, 2]
  myDrop 0 [1, 2]
  myDrop 7 []
  myDrop(-2) "foo"
#+end_src

#+RESULTS:
#+begin_results

GHCi> "obar"
ar
[]
[1,2]
[]
foo
#+end_results

論理演算子。
#+begin_src haskell
  :type null
  :type (||)
#+end_src

#+RESULTS:
#+begin_results
null :: Foldable t => t a -> Prelude.Bool
(||) :: Prelude.Bool -> Prelude.Bool -> Prelude.Bool
#+end_results
** 遅延評価
正格評価: 関数を適用する前に関数への引数を評価する。
*非正格評価(遅延評価)*: 評価せず、値が必要になったとき計算する「プロミス」を作る。未評価の式を追跡するのに使うレコードを *サンク* という。式の結果が使われないなら、値は計算されない。

#+begin_src haskell
  isOdd n = mod n 2 == 1
  isOdd 3
#+end_src

#+RESULTS:
#+begin_results

True
#+end_results

#+begin_src haskell
  print (myDrop 2 "abcd")

  :type 2 <= 0 || null "abcd"
  null "abcd"
#+end_src

#+RESULTS:
#+begin_results
cd
GHCi> 2 <= 0 || null "abcd" :: Prelude.Bool
False
#+end_results
** 型変数
#+begin_src haskell
  last [1,2,3]
  last "baz"
  :type last
#+end_src

#+RESULTS:
#+begin_results
3
'z'
last :: [a] -> a
#+end_results

この ~a~ が型変数。
型シグネチャに型変数を持つときには引数のいくつかはどのような型にでもなれることを示している。→ 多相的である。
** 多相関数
#+begin_src haskell
  :type fst
#+end_src

#+RESULTS:
#+begin_results
fst :: (a, b) -> a
#+end_results

#+begin_src haskell
:type take
#+end_src

#+RESULTS:
#+begin_results
take :: Int -> [a] -> [a]
#+end_results

これは実際にはこういうこと↓。

~take :: Int -> ([a] -> [a])~
** 純粋性
#+begin_src haskell
:type not
#+end_src

#+RESULTS:
#+begin_results
not :: Prelude.Bool -> Prelude.Bool
#+end_results
** 型定義

↓ BookInfoを ~型構成子~ という。
続く Bookは ~値構成子~ という。
Int, String, [String]は ~構成要素~ という。

#+begin_src haskell
  :{
  data BookInfo = Book Int String [String]
                  deriving (Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

同じ構造を持っていても、2つの型を区別する。型構成子と値構成子の名前が違うから。

#+begin_src haskell
  :{
  data MagazineInfo = Magazine Int String [String]
                      deriving (Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :info BookInfo

  myInfo = Book 9780135072455 "Algebra of Programming" ["Richard Bird", "Oege de Moor"]
  myInfo
  :type myInfo
  :type Book
#+end_src

#+RESULTS:
#+begin_results
data BookInfo = Book Int String [String]
  -- Defined at <interactive>:6313:1
instance [safe] Show BookInfo -- Defined at <interactive>:6314:27
GHCi> GHCi> Book 9780135072455 "Algebra of Programming" ["Richard Bird","Oege de Moor"]
myInfo :: BookInfo
Book :: Int -> String -> [String] -> BookInfo
#+end_results
** 型シノニム
型シノニムはコードを読みやすくするだけのもの。

#+begin_src haskell
  type CustomerID = Int
  type ReviewBody = String
  data BetterReview = BetterReview BookInfo CustomerID ReviewBody
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** 代数データ型
値構成子が2つある。 *選択肢* あるいは *ケース* という。

#+begin_src haskell
  data Bool = False | True
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  type CardHolder = String
  type CardNumber = String
  type Address = [String]

  :{
  data BillingInfo = CreditCard CardNumber CardHolder Address
                     | CashOnDelivery
                     | Invoice CustomerID
                       deriving (Show)
  :}
  :info BillingInfo
#+end_src

#+RESULTS:
#+begin_results

GHCi> GHCi> GHCi> Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| GHCi> data BillingInfo
  = CreditCard CardNumber CardHolder Address
  | CashOnDelivery
  | Invoice CustomerID
  -- Defined at <interactive>:6340:1
instance [safe] Show BillingInfo
  -- Defined at <interactive>:6343:32
#+end_results

#+begin_src haskell
  :type CreditCard
  CreditCard "2901650221064486" "Thomas Gradgrind"  ["Dickens", "England"]
#+end_src

#+RESULTS:
#+begin_results
CreditCard :: CardNumber -> CardHolder -> Address -> BillingInfo
CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens","England"]
#+end_results

#+begin_src haskell
  :type it
#+end_src

#+RESULTS:
#+begin_results
it :: [Char]
#+end_results

#+begin_src haskell
  :type Invoice
  Invoice 2222
#+end_src

#+RESULTS:
#+begin_results
Invoice :: CustomerID -> BillingInfo
Invoice 2222
#+end_results

** タプルと代数データ型
#+begin_src haskell
  Book 2 "The Wealth of Networks" ["Yochai Benkler"]
  (2, "The Wealth of Networks", ["Yochai Benkler"])
#+end_src

#+RESULTS:
#+begin_results
Book 2 "The Wealth of Networks" ["Yochai Benkler"]
(2,"The Wealth of Networks",["Yochai Benkler"])
#+end_results

↓構造的に同一なので同じ型。

#+begin_src haskell
  a = ("Porpoise", "Gray")
  b = ("Table", "Oak")
#+end_src

#+RESULTS:
#+begin_results
#+end_results

↓別の名前なので別の型。

#+begin_src haskell
  data Cetacean = Cetacean String String
  data Furniture = Furniture String String

  c = Cetacean "Porpoise" "Gray"
  d = Furniture "Table" "Oak"
#+end_src

#+RESULTS:
#+begin_results
#+end_results

座標。

#+begin_src haskell
  :{
  -- x, yの座標
  data Cartesian2D = Cartesian2D Double Double
                     deriving (Eq, Show)

  -- 偏角と長さ
  data Polar2D = Polar2D Double Double
                 deriving (Eq, Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

~==~ 演算子は引数が同じ型でないといけないのでエラー。

#+begin_src haskell
  Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
#+end_src

#+RESULTS:
#+begin_results
In an equation for ‘it’:
          it = Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
#+end_results

タプルの場合判断しようがないのでチェックが効かない。

#+begin_src haskell
(1, 2) == (1, 2)
#+end_src

#+RESULTS:
#+begin_results
True
#+end_results

- 複合型をコードの中で広く使う場合には ~data~ 宣言を使う
- 規模が小さく、局所的にしか使わない場合はタプルでいい

** 他の言語との類似

#+begin_src C
  struct book_info {
    int id;
    char *name;
    char **authors;
  };
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :{
  data BookInfo = Book Int String [String]
                    deriving (Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

** 列挙型

[[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C言語]]ではこう書く。

#+begin_src C
  enum roygbiv {
    red,
    orange,
    yellow,
    green,
    blue,
    indigo,
    violet,
  };
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :{
  data Roygbiv = Red
               | Orange
               | Yellow
               | Green
               | Blue
               | Indigo
               | Violet
                 deriving (Eq, Show)
  :}
  :type Yellow
  :type Red
  Red == Yellow
  Green == Green
#+end_src

#+RESULTS:
#+begin_results

Yellow :: Roygbiv
Red :: Roygbiv
False
True
#+end_results

haskellのenumは型が厳密。
#+begin_src haskell
  take 3 "foobar"
  take Red "foobar"
#+end_src

#+RESULTS:
#+begin_results
foo
<interactive>:6405:6-8: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Roygbiv’
    • In the first argument of ‘take’, namely ‘Red’
      In the expression: take Red "foobar"
      In an equation for ‘it’: it = take Red "foobar"
#+end_results

** union
代数データ型が複数の選択肢を持つ場合は[[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C言語]]の ~union~ と同じ。
#+begin_src haskell
  type Vector = (Double, Double)
  :{
  data Shape = Circle Vector Double
             | Poly [Vector]
  :}
  :info Shape
#+end_src

#+RESULTS:
#+begin_results

GHCi> data Shape = Circle Vector Double | Poly [Vector]
-- Defined at <interactive>:6409:1
#+end_results

** パターンマッチ

↓2つの関数というわけではない。
同一関数の異なる入力パターンに対する振る舞いを定義している。

#+begin_src haskell
  myNot True = False
  myNot False = True
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  sumList (x:xs) = x + sumList xs
  sumList [] = 0

  sum [1,2]
#+end_src

#+RESULTS:
#+begin_results

GHCi> 3
#+end_results

タプルのパターンマッチ。

#+begin_src haskell
  complicated (True, a, x:xs, 5) = (a, xs)
  complicated (True, 1, [1,2,3], 5)
#+end_src

#+RESULTS:
#+begin_results

(1,[2,3])
#+end_results

ぴったり一致しないと成功しない。
すべてのパターンマッチが失敗すると実行時エラー。

#+begin_src haskell
complicated (False, 1, [1,2,3], 5)
#+end_src

#+RESULTS:
#+begin_results
: *** Exception: <interactive>:1963:1-40: Non-exhaustive patterns in function complicated
#+end_results

** Exception: <interactive>:6422:1-40: Non-exhaustive patterns in function complicated
BookInfo型の場合。
パターンマッチをセット。

#+begin_src haskell
  bookID (Book id title authors) = id
  bookTitle (Book id title authors) = title
  bookAuthors (Book id title authors) = authors
#+end_src

#+RESULTS:
#+begin_results
#+end_results

アクセスできる。

#+begin_src haskell
  bookID (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
  bookTitle (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
  bookAuthors (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
#+end_src

#+RESULTS:
#+begin_results
3
Probability Theory
["E.T.H. Jaynes"]
#+end_results

構成子に基づいて、アクセサ関数の型を推論できる。

#+begin_src haskell
  :type bookID
  :type bookTitle
  :type bookAuthors
#+end_src

#+RESULTS:
#+begin_results
bookID :: BookInfo -> Int
bookTitle :: BookInfo -> String
bookAuthors :: BookInfo -> [String]
#+end_results
** ワイルドカード
この類のコードをボイラープレートという。

#+begin_src haskell
  nicerID (Book id _ _ ) = id
  nicerTitle (Book _ title _) = title
  nicerAuthors (Book _ _ authors) = authors
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  goodExample (x:xs) = x + goodExample xs
  goodExample _ = 0
  goodExample []
  goodExample [1, 2]
#+end_src

#+RESULTS:
#+begin_results

GHCi> 0
0
#+end_results
** レコード構文
#+begin_src haskell
  :{
    data Customer = Customer {
       customerID :: CustomerID
     , customerName :: String
     , customerAddress :: Address
       } deriving (Show)
  :}
  :type customerID
#+end_src

#+RESULTS:
#+begin_results

customerID :: Customer -> CustomerID
#+end_results

#+begin_src haskell
  :{
  customer2 = Customer {
      customerID = 271828
    , customerAddress = ["1048576 Disk Drive",
                        "Milpitas, CA 95134",
                        "USA"]
    , customerName = "Jane Q. Citizen"
    }
  :}
  customer2
  cities
#+end_src

#+RESULTS:
#+begin_results

Customer {customerID = 271828, customerName = "Jane Q. Citizen", customerAddress = ["1048576 Disk Drive","Milpitas, CA 95134","USA"]}
Book 173 "Use of weapons" ["Iain M. Banks"]
#+end_results

レコード構文によって使えるアクセサ関数は、通常のHaskellの関数。

#+begin_src haskell
  :type customerName
  customerName customer2
#+end_src

#+RESULTS:
#+begin_results
customerName :: Customer -> String
Jane Q. Citizen
#+end_results
** パラメータ化された型
独自に定義する型も多相型にできる。型宣言に型変数を導入する。

↓この変数は型変数。
#+begin_src haskell
  :{
  data Maybe a = Just a
               | Nothing
  :}
  :info Maybe
#+end_src

#+RESULTS:
#+begin_results

data Maybe a = Just a | Nothing -- Defined at <interactive>:6475:1
#+end_results

これによって任意の型上の ~Maybe~ 型を使える。

#+begin_src haskell
  someBool = Just True
  :type someBool
  someString = Just "something"
  :type someString
  :type Just "Invisible bike"
#+end_src

#+RESULTS:
#+begin_results
someBool :: Maybe Bool
GHCi> someString :: Maybe [Char]
Just "Invisible bike" :: Maybe [Char]
#+end_results

#+begin_src haskell
  wrapped = Just (Just "wrapped")
  :type wrapped
#+end_src

#+RESULTS:
#+begin_results

wrapped :: Maybe (Maybe [Char])
#+end_results
** 再帰型
リスト型は再帰型。定義に自身が含まれる。
#+begin_src haskell
  :{
  data List a = Cons a (List a)
              | Nil
                deriving (Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

確かめる。
#+begin_src haskell
  Nil
  Cons 0 Nil
  Cons 1 it
  Cons 2 it
  Cons 3 it
#+end_src

#+RESULTS:
#+begin_results
Nil
Cons 0 Nil
Cons 1 (Cons 0 Nil)
Cons 2 (Cons 1 (Cons 0 Nil))
Cons 3 (Cons 2 (Cons 1 (Cons 0 Nil)))
#+end_results

二分木。

#+begin_src haskell
  :{
  data Tree a = Node a (Tree a) (Tree a)
              | Empty
                deriving (Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

本と違ってなぜかエラーになる。

#+begin_src haskell
  fromList (x:xs) = Cons x (fromList xs)
  fromList [] = Nil
  fromList "durian"
  fromList [Just True, Nothing, Just False]
#+end_src

#+RESULTS:
#+begin_results
GHCi> *** Exception: <interactive>:6518:1-17: Non-exhaustive patterns in function fromList
Exception: <interactive>:6518:1-17: Non-exhaustive patterns in function fromList
#+end_results

[[id:9fa3711b-a22e-4cf5-ae97-5c057083674a][Java]]の例(クラス定義)。
#+begin_src java
  class Tree<A>
  {
      A value;
      Tree<A> left;
      Tree<B> right;

      public Tree(A v, Tree<A> l, Tree<A> r)
      {
          value = v;
          left = l;
          right = r;
      }
  }
#+end_src

葉を構成する関数。

#+begin_src java
  class Example
  {
      static Tree<String> simpleTree()
      {
          return new Tree<String>(
                                  "parent",
                                  new Tree<String>("left leaf", null, null),
                                  new Tree<String>("right leaf", null, null));
      }
  }
#+end_src

#+begin_src haskell
  :{
  simpleTree = Node "parent" (Node "left child" Empty Empty)
                             (Node "right child" Empty Empty)
  :}
  :type simpleTree
#+end_src

#+RESULTS:
#+begin_results

simpleTree :: Tree [Char]
#+end_results
** エラー報告表示
listの要素が1つのときはエラー表示を出す。

#+begin_src haskell
  :{
  mySecond :: [a] -> a
  mySecond xs = if null (tail xs)
                then error ("list too short")
                else head (tail xs)
  :}
  mySecond "xi"
  mySecond [2, 3]
  mySecond [2]
#+end_src

#+RESULTS:
#+begin_results
'i'
3
Exception: list too short
CallStack (from HasCallStack):
  error, called at <interactive>:6531:20 in interactive:Ghci3189
#+end_results

ちゃんとエラーメッセージが出ている。
** エラーの可能性, Maybe
#+begin_src haskell
  :{
  safeSecond :: [a] -> Maybe a
  safeSecond [] = Nothing
  safeSecond xs = if null (tail xs)
                  then Nothing
                  else Just (head (tail xs))
  :}
  safeSecond [1,2] -- なぜかできない。
#+end_src

#+RESULTS:
#+begin_results

<interactive>:6545:1-16: error:
    • No instance for (Show (Maybe Integer))
        arising from a use of ‘print’
      There are instances for similar types:
        instance Show a => Show (Prelude.Maybe a) -- Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
#+end_results

パターンマッチを使って改善。

#+begin_src haskell
  tidySecond :: [a] -> Maybe a

  tidySecond (_:x:_) = Just x
  tidySecond _       = Nothing
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** 局所変数
#+begin_src haskell
  :{
  lend amount balance = let reserve = 100
                            newBalance = balance - amount
                        in if balance < reserve
                           then Nothing
                           else Just newBalance
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

** シャドウ
内側の ~x~ が外側の ~x~ を隠す。
#+begin_src haskell
  :{
  bar = let x = 1
        in ((let x = "foo" in x), x)
  :}
  bar
#+end_src

#+RESULTS:
#+begin_results

("foo",1)
#+end_results
** where節
#+begin_src haskell
  :{
  lend2 amount balance = if amount < reserve * 0.5
                         then Just newBalance
                         else Nothing
        where reserve  = 100
              newBalance = balance - amount
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :{
  pluralise :: String -> [Int] -> [String]
  pluralise word counts = map plural counts
      where plural 0 = "no " ++ word ++ "s"
            plural 1 = "one " ++ word
            plural n = show n ++ " " ++ word ++ "s"
  :}
  pluralise "car" [0]
  pluralise "car" [1]
  pluralise "car" [2]
#+end_src

#+RESULTS:
#+begin_results

["no cars"]
["one car"]
["2 cars"]
#+end_results
** case式
#+begin_src haskell
  :{
  fromMaybe defval wrapped =
    case wrapped of
      Nothing -> defval
      Just value -> value
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :{
    data Fruit = Apple | Orange
    betterFruit f = case f of
                    "apple" -> Apple
                    "orange" -> Orange
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** ガード
#+begin_src haskell
  :{
  nodesAreSame (Node a _ _) (Node b _ _)
      | a == b     = Just a
  nodesAreSame _ _ = Nothing
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

lend関数を書き直す。
#+begin_src haskell
  :{
  lend3 amount balance
       | amount <= 0            = Nothing
       | amount > reserve * 0.5 = Nothing
       | otherwise              = Just newBalance
      where reserve    = 100
            newBalance = balance - amount
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

myDrop関数を書き直す。
元コード。
#+begin_src haskell
  :{
  myDrop n xs = if n <= 0 || null xs
                then xs
                else myDrop (n - 1) (tail xs)
   :}
  myDrop 2 "abcd"
#+end_src

#+RESULTS:
#+begin_results

cd
#+end_results

#+begin_src haskell
  :{
  niceDrop n xs | n <= 0 = xs
  niceDrop _ []          = []
  niceDrop n (_:xs)      = niceDrop (n - 1) xs
  :}
  niceDrop 2 "abcd"
#+end_src

#+RESULTS:
#+begin_results

cd
#+end_results
** テキスト行分割
#+begin_src haskell
  :type lines
  lines "line 1\nline 2"
  lines "foo\n\nbar\n"
#+end_src

#+RESULTS:
#+begin_results
lines :: String -> [String]
["line 1","line 2"]
["foo","","bar"]
#+end_results

#+begin_src haskell
  break odd [2,4,5,6,8]
  :module +Data.Char
  break isUpper "isUpper"
#+end_src

#+RESULTS:
#+begin_results
([2,4],[5,6,8])
GHCi> ("is","Upper")
#+end_results

#+begin_src haskell
  :{
    a `plus` b = a + b
    data a `Pair` b = a `Pair` b
               deriving (Show)
    foo = Pair 1 2
    bar = True `Pair` "quux"
  :}
  1 `plus` 2
  plus 1 2
  Pair "a" "a"
  "a" `Pair` "a"
#+end_src

#+RESULTS:
#+begin_results

3
3
a" `Pair` "a
a" `Pair` "a
#+end_results
** リストの処理

#+begin_src haskell
  :type length
  length []
  length [1,2,3]
  null []
  head [1,2]
  tail "foo"
  last "bar"
#+end_src

#+RESULTS:
#+begin_results
length :: Foldable t => t a -> Int
0
3
True
1
oo
'r'
#+end_results

連結関数。

#+begin_src haskell
  :type (++)
  "foo" ++ "bar"
  [] ++ [1,2,3]
  [1] ++ []
#+end_src

#+RESULTS:
#+begin_results
(++) :: [a] -> [a] -> [a]
foobar
[1,2,3]
[1]
#+end_results

~concat~ 連結して1つのリストにする。

#+begin_src haskell
  :type concat
  concat [[1,2,3], [4,5,6]]
  concat [[[1,2],[3]], [[4],[5],[6]]]
  concat (concat [[1,2],[3]], [[4],[5],[6]])
#+end_src

#+RESULTS:
#+begin_results
concat :: Foldable t => t [a] -> [a]
[1,2,3,4,5,6]
[[1,2],[3],[4],[5],[6]]
[[4],[5],[6]]
#+end_results

~reverse~ 逆順にする。

#+begin_src haskell
  :type reverse
  reverse "foo"
#+end_src

#+RESULTS:
#+begin_results
reverse :: [a] -> [a]
oof
#+end_results

便利な条件判定、 ~all~ と ~any~ 。

#+begin_src haskell
  :type all
  all odd [1,3,5]
  all odd [3,1,4]
  all odd []
  :type any
  any even [3,1,4]
  any even []
#+end_src

#+RESULTS:
#+begin_results
all :: Foldable t => (a -> Prelude.Bool) -> t a -> Prelude.Bool
True
False
True
any :: Foldable t => (a -> Prelude.Bool) -> t a -> Prelude.Bool
True
False
#+end_results

部分リスト。

#+begin_src haskell
  :type take
  take 3 "foobar"
  take 2 [1]
  :type drop
  drop 3 "xyzzy"
  drop 1 []
#+end_src

#+RESULTS:
#+begin_results
take :: Int -> [a] -> [a]
foo
[1]
drop :: Int -> [a] -> [a]
zy
[]
#+end_results

~splitAt~ インデックスで分割したリストのペアを返す。
#+begin_src haskell
  :type splitAt
  splitAt 3 "foobar"
#+end_src

#+RESULTS:
#+begin_results
splitAt :: Int -> [a] -> ([a], [a])
("foo","bar")
#+end_results

~span~ 条件に合うもの、以外でリストを返す。

#+begin_src haskell
  :type span
  span even [2,4,6,7,9,10,11]
  :type break
  break even [1,3,5,6,8,9,10]
#+end_src

#+RESULTS:
#+begin_results
span :: (a -> Prelude.Bool) -> [a] -> ([a], [a])
([2,4,6],[7,9,10,11])
break :: (a -> Prelude.Bool) -> [a] -> ([a], [a])
([1,3,5],[6,8,9,10])
#+end_results

~elem~ 値がリスト中に存在するか示す。

#+begin_src haskell
  :type elem
  2 `elem` [5,3,2,1,1]
  2 `notElem` [5,3,2,1,1]
#+end_src

#+RESULTS:
#+begin_results
elem :: (Foldable t, Eq a) => a -> t a -> Prelude.Bool
True
False
#+end_results

~filter~ 条件に合うリストを返す。

#+begin_src haskell
  :type filter
   filter odd [2,4,1,3,6,8,5,7]
#+end_src

#+RESULTS:
#+begin_results
filter :: p -> [a1] -> [a2]
Exception: <interactive>:4825:1-16: Non-exhaustive patterns in function filter
#+end_results

~isPrefixOf~ 部分リストがより大きなリストの中にあるか調べる。

#+begin_src haskell
  :module +Data.List
  :type isPrefixOf
  "foo" `isPrefixOf` "foobar"
  [1,2] `isPrefixOf` []
#+end_src

#+RESULTS:
#+begin_results

isPrefixOf :: Eq a => [a] -> [a] -> Prelude.Bool
True
False
#+end_results

~zip~ 2つのリストをペアのリストにする。

#+begin_src haskell
  :type zip
  zip [12,72,93] "zippity"
#+end_src

#+RESULTS:
#+begin_results
zip :: [a] -> [b] -> [(a, b)]
[(12,'z'),(72,'i'),(93,'p')]
#+end_results

~zipWith~ 2つのリストのペアごとに関数を適用する。

#+begin_src haskell
  :type zipWith
  zipWith (+) [1,2,3] [4,5,6]
#+end_src

#+RESULTS:
#+begin_results
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
[5,7,9]
#+end_results

可変長引数はHaskellの型システムのうえでは難しい。
複数のリストを閉じ合わせるには ~zip3~ 〜 ~zip7`~ を使う。
** リストのいけてる扱い方
haskellにおいてはほかの言語と同じように、扱えない部分がある。
~length~ はリスト全体を辿らないといけないが、無限リストである可能性がある。

#+begin_src haskell
  :{
    mySmartExample xs = if not (null xs)
                        then head xs
                        else 'Z'
    myOtherExample (x:_) = x
    myOtherExample [] = 'Z'
  :}
  mySmartExample "head"
  mySmartExample []
#+end_src

#+RESULTS:
#+begin_results

'h'
'Z'
#+end_results
** 部分関数
正当な入力の部分集合の値に対してのみ値を返す関数のことを部分関数という。
入力の全定義域に対して正しい結果を返す関数のことを全関数という。
** 文字列専用の関数
#+begin_src haskell
  lines "foo\nbar"
  unlines ["foo", "bar"]
#+end_src

#+RESULTS:
#+begin_results
["foo","bar"]
foo\nbar\n
#+end_results

~words~ は入力文字を任意の空白で区切る。

#+begin_src haskell
  words "the \r quick \t brown\n\n\nfox"
  unwords ["jumps", "over", "the", "lazy", "dog"]
#+end_src

#+RESULTS:
#+begin_results
["the","quick","brown","fox"]
jumps over the lazy dog
#+end_results
** ループ
Haskellには、 ~for~ ループ、 ~while~ ループはない。

[[id:656a0aa4-e5d3-416f-82d5-f909558d0639][C言語]]の例。
こんなふうにはできないので末尾再帰を使う。

#+begin_src C
  int as_int(char *str)
  {
    int acc;
    for (acc = 0; isdigit(*str); str++) {
      acc = acc * 10 + (*str - '0');
    }

    return acc;
  }
#+end_src

#+RESULTS:
#+begin_results
#+end_results

配列の中のすべての要素を2乗する。

#+begin_src C
  void square(double *out, const double *in, size_t length)
  {
    for (size_t i = 0; i < length; i++) {
      out[i] = in[i] * in[i];
    }
  }
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :{
   square :: [Double] -> [Double]
   square (x:xs) = x*x : square xs
   square []     = []
  :}
  square [1,2]
  square []
#+end_src

#+RESULTS:
#+begin_results

[1.0,4.0]
[]
#+end_results

大文字化。

#+begin_src haskell
  :{
  upperCase :: String -> String

  upperCase (x:xs) = toUpper x : upperCase xs
  upperCase []     = []
  :}
  upperCase "hello"
#+end_src

#+RESULTS:
#+begin_results

HELLO
#+end_results

~map~ は関数を引数としてとり、リストのすべての要素に適用する。

#+begin_src haskell
  upperCase2 xs = map toUpper xs
  upperCase2 "hello"
#+end_src

#+RESULTS:
#+begin_results

HELLO
#+end_results

~map~ を書き直してみる。

#+begin_src haskell
  :{
    myMap :: (a -> b) -> [a] -> [b]
    myMap f (x:xs) = f x : myMap f xs
    myMap _ _      = []
  :}
    upperCase3 xs = myMap toUpper xs
    upperCase3 "hello"
#+end_src

#+RESULTS:
#+begin_results

GHCi> "HELLO"
#+end_results
** フィルター
#+begin_src haskell
  :{
  oddList :: [Int] -> [Int]

  oddList (x:xs) | odd x = x : oddList xs
                 | otherwise = oddList xs
  oddList _                  = []
  :}
  oddList [1,2,3,4,5,6,7,8,9,10]
#+end_src

#+RESULTS:
#+begin_results

[1,3,5,7,9]
#+end_results

~helper~ は末尾再帰の関数で、蓄積変数 ~acc~ を使ってリストのその時点での部分和を保持する。

#+begin_src haskell
  :{
  mySum xs = helper 0 xs
    where helper acc (x:xs) = helper (acc + x) xs
          helper acc _      = acc
  :}
  mySum [1,2,3,4]
#+end_src

#+RESULTS:
#+begin_results

10
#+end_results
** 畳み込み
畳み込み: リストのすべての要素に何かを行い、蓄積変数を更新していって、終わったところで蓄積変数を返す。

#+begin_src haskell
  :{
  foldl :: (a -> b -> a) -> a -> [b] -> a

  foldl step zero (x:xs) = foldl step (step zero x) xs
  foldl _    zero []     = zero
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :{
  niceSum :: [Integer] -> Integer
  niceSum xs = foldl (+) 0 xs
  :}
  niceSum [1,2,3,4,5]
#+end_src

#+RESULTS:
#+begin_results

15
#+end_results

問題を2つに単純化することで、すっきり書けるようになった。
蓄積値の初期値をどうするかと、蓄積変数の更新。

明示的再帰は綿密に読む必要があり、わかりづらい。
畳み込みを使えば再帰を理解しやすい。

右側からの畳み込み。
#+begin_src haskell
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr step zero (x:xs) = step x (foldr step zero xs)
  foldr _    zero []     = 0
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** 再帰と畳み込みの比較
#+begin_src haskell
  :{
  filter :: (a -> Bool) -> [a] -> [a]
  filter p [] = []
  filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
  :}
#+end_src

#+begin_src haskell
  :{
  myFilter p xs = foldr step [] xs
    where step x ys | p x = x : ys
                    | otherwise = ys
  :}
  myFilter (+) [1,2]
#+end_src
** 無名関数
普通に書く例。
#+begin_src haskell
  :{
  isInAny needle haystack = any inSequence haystack
      where inSequence s = needle `isInfixOf` s
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

無名関数を使う例。

#+begin_src haskell
isInAny2 needle haystack = any (\s -> needle `isInfixOf` s) haystack
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** 部分適用
#+begin_src haskell
:type dropWhile
#+end_src

#+RESULTS:
#+begin_results
dropWhile :: (a -> Prelude.Bool) -> [a] -> [a]
#+end_results

->の意味…左側の型を引数に取り、右側の型の値を返す関数。

Haskellにおいては、 *すべての関数は1つしか引数を取らない* 。
1つ渡すと型シグネチャから1つ削られたことがわかる。

#+begin_src haskell
  :type dropWhile
  :type dropWhile isSpace
  map (dropWhile isSpace) [" a", "f", "    e"]
#+end_src

#+RESULTS:
#+begin_results
dropWhile :: (a -> Prelude.Bool) -> [a] -> [a]
dropWhile isSpace :: [Char] -> [Char]
["a","f","e"]
#+end_results

#+begin_src haskell
  :type zip3
  zip3 "foo" "bar" "quux"
#+end_src

#+RESULTS:
#+begin_results
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
[('f','b','q'),('o','a','u'),('o','r','u')]
#+end_results

#+begin_src haskell
  :type zip3 "foo"
  let zip3foo = zip3 "foo"
  :type zip3foo
  zip3foo "aaa" "bbb"
#+end_src

#+RESULTS:
#+begin_results
zip3 "foo" :: [b] -> [c] -> [(Char, b, c)]
GHCi> zip3foo :: [b] -> [c] -> [(Char, b, c)]
[('f','a','b'),('o','a','b'),('o','a','b')]
#+end_results

関数が受け入れ可能な数よりも少ない数の引数を渡すことを関数の部分適用という(~カリー化~)。

#+begin_src haskell
  isInAny3 needle haystack = any (isInfixOf needle) haystack
#+end_src

#+RESULTS:
#+begin_results
#+end_results

カリー化の例。
使う前。
#+begin_src haskell
  niceSum :: [Integer] -> Integer
  niceSum xs = foldl (+) 0 xs
#+end_src

#+RESULTS:
#+begin_results
#+end_results

完全に適用せずに、省略できる。
#+begin_src haskell
  niceSum :: [Integer] -> Integer
  niceSum = foldl (+) 0
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** セクション
括弧で中置スタイルの関数の部分適用を書ける。
#+begin_src haskell
  (1+) 2
  map (*3) [24,36]
  map (2^) [3,5,7,9]
#+end_src

#+RESULTS:
#+begin_results
3
[72,108]
[8,32,128,512]
#+end_results

#+begin_src haskell
:type (`elem` ['a'..'z'])
#+end_src

#+RESULTS:
#+begin_results
(`elem` ['a'..'z']) :: Char -> Prelude.Bool
#+end_results

引数が小文字アルファベットか調べる関数になる。

#+begin_src haskell
  (`elem` ['a'..'z']) 'a'
  (`elem` [1..9]) 1
  (`elem` [1..9]) 10
#+end_src

#+RESULTS:
#+begin_results
True
True
False
#+end_results

~all~ と組み合わせる。簡潔にリスト全体か判定する関数になった。
#+begin_src haskell
  all (`elem` ['a'..'z']) "Frobozz"
#+end_src

#+RESULTS:
#+begin_results
False
#+end_results

~inInAny3~ の改良版。

#+begin_src haskell
  isInAny4 needle haystack = any (needle `isInfixOf`) haystack
  :type isInAny4

#+end_src

#+RESULTS:
#+begin_results

isInAny4 :: (Foldable t, Eq a) => [a] -> t [a] -> Prelude.Bool
#+end_results
** アズパターン
#+begin_src haskell
  :m +Data.List
  tail "foobar"
  tail (tail "foobar")
  tails "foobar"
  tails []
#+end_src

#+RESULTS:
#+begin_results

oobar
obar
["foobar","oobar","obar","bar","ar","r",""]
[[]]
#+end_results

空でない接尾辞が欲しくなったとする。

~xs@(_:xs')~ はアズパターンという。
変数 ~xs~ を、 ~@~ 記号の右辺とマッチした値に束縛する、という意味。
#+begin_src haskell
  :{
  sufixes :: [a] -> [[a]]
  sufixes xs@(_:xs') = xs : sufixes xs'
  sufixes _          = []
  :}
  sufixes "foo"
#+end_src

#+RESULTS:
#+begin_results

["foo","oo","o"]
#+end_results

アズパターンはデータをコピーする代わりに共有する(~xs~ を再利用している)。
メモリの割り当てを回避するのでパフォーマンスが良い。
** 合成
~init~ 関数はリストの最期の要素を除いた残りを返す。
#+begin_src haskell
  init [1,2,3]
#+end_src

#+RESULTS:
#+begin_results
[1,2]
#+end_results

~init~ ~tails~ を合成する。

#+begin_src haskell
  suffix2 xs = init (tails xs)
  suffix2 [1,2,3]
#+end_src

#+RESULTS:
#+begin_results

[[1,2,3],[2,3],[3]]
#+end_results

ある関数を適用してから、その結果に別の関数をしている。このパターンを関数にできる。

#+begin_src haskell
  :{
  compose :: (b -> c) -> (a -> b) -> a -> c
  compose f g x = f (g x)
  suffixes3 xs = compose init tails xs
  :}
  suffixes3 [1,2,3]
#+end_src

#+RESULTS:
#+begin_results

[[1,2,3],[2,3],[3]]
#+end_results

勝手にカリー化するので変数は外せる。

#+begin_src haskell
  suffixes4 = compose init tails
  suffixes4 [1,2,3]
#+end_src

#+RESULTS:
#+begin_results

[[1,2,3],[2,3],[3]]
#+end_results

連結はよくあることなので、 ~.~ 演算子として使える。

#+begin_src haskell
  suffixes5 = init . tails
  suffixes5 [1,2,3]
#+end_src

#+RESULTS:
#+begin_results

[[1,2,3],[2,3],[3]]
#+end_results

通常の演算子のひとつ。

#+begin_src haskell
  :type (.)
#+end_src

#+RESULTS:
#+begin_results
(.) :: (b -> c) -> (a -> b) -> a -> c
#+end_results

単語の先頭が大文字か。

#+begin_src haskell
  :type isUpper . head
  isUpper 'W'
#+end_src

#+RESULTS:
#+begin_results
isUpper . head :: [Char] -> Prelude.Bool
True
#+end_results

#+begin_src haskell
  :type filter (isUpper . head)
#+end_src

#+RESULTS:
#+begin_results
filter (isUpper . head) :: [a1] -> [a2]
#+end_results

関数合成の例。

~words~ を使う。
#+begin_src haskell
  :type words
  words "#define DLT_CHAOS     5"
#+end_src

#+RESULTS:
#+begin_results
words :: String -> [String]
["#define","DLT_CHAOS","5"]
#+end_results

~tail~ を使う。

#+begin_src haskell
  :type tail
  tail ["#define","DLT_CHAOS","5"]
#+end_src

#+RESULTS:
#+begin_results
tail :: [a] -> [a]
["DLT_CHAOS","5"]
#+end_results

合成する。

#+begin_src haskell
  :type tail . words
  (tail . words) "#define DLT_CHAOS           5"
#+end_src

#+RESULTS:
#+begin_results
tail . words :: String -> [String]
["DLT_CHAOS","5"]
#+end_results

~head~ を使う。

#+begin_src haskell
  :type head . tail . words
  (head . tail . words) "#define DLT_CHAOS     5"
#+end_src

#+RESULTS:
#+begin_results
head . tail . words :: String -> String
DLT_CHAOS
#+end_results

優先順位...ライブラリ関数の合成 > 畳み込み > 末尾再帰。
** スペースリーク
遅延評価しない式のことを ~正格な式~ という。
~seq~ は正格化する。

#+begin_src haskell
  :{
  foldl' _ zero []    = zero
  foldl' step zero (x:xs) =
      let new = step zero x
      in new `seq` foldl' step new xs
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

~seq~ は値を評価する方法としての存在価値しかない。
#+begin_src haskell
  :type seq
#+end_src

#+RESULTS:
#+begin_results
seq :: a -> b -> b
#+end_results

#+begin_src haskell
  foldl' (+) 1 (2:[])
#+end_src

#+RESULTS:
#+begin_results
3
#+end_results

これは↓のように展開される。

#+begin_src haskell
  :{
  let new = 1 + 2
  in new `seq` foldl' (+) new []
  :}
#+end_src

#+RESULTS:
#+begin_results
3
#+end_results

一度↓のように展開する。

#+begin_src haskell
  fold' (+) 3 []
#+end_src

~seq~ によってサンクがない。
** 型クラス
同値性検査をしたい。

色の場合。
#+begin_src haskell
  :{
  data Color = Red | Green | Blue
  colorEq :: Color -> Color -> Bool
  colorEq Red Red = True
  colorEq Green Green = True
  colorEq Blue Blue = True
  colorEq _ _ = False
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

stringの場合。
#+begin_src haskell
  stringEq :: [Char] -> [Char] -> Bool
  stringEq [] [] = True
  stringEq (x:xs) (y:ys) = x == y && stringEq xs ys
  stringEq _ _ = False
#+end_src

#+RESULTS:
#+begin_results
#+end_results

つまり…型ごとに別の名前の関数を使って比較しなければならない。
すべて ~==~ で比較できると便利(ジェネリック関数)。
型クラスは実際に与えられたデータの型ごとに実装を持ち得る関数の集合によって定義するもの。

型クラスを定義する。 ~BasicEq~ という型クラスを定義する。
インスタンスの型は ~a~ 。
#+begin_src haskell
  :{
  class BasicEq a where
      isEqual :: a -> a -> Bool
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
:type isEqual
#+end_src

#+RESULTS:
#+begin_results
isEqual :: BasicEq a => a -> a -> Bool
#+end_results

→ あらゆる型 ~a~ に対して、 ~a~ が ~BasicEq~ のインスタンスである限り、 ~isEqual~ は型 ~a~ のパラメータを2つ取り、 ~Bool~ を返す。

#+begin_src haskell
  :{
  instance BasicEq Bool where
      isEqual True  True  = True
      isEqual False False = True
      isEqual _     _     = False
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  :{
  class BasicEq2 a where
      isEqual2    :: a -> a -> Bool
      isNotEqual2 :: a -> a -> Bool
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

notを追加する。
#+begin_src haskell
  :{
  class BasicEq3 a where
        isEqual3 :: a -> a -> Bool
        -- isEqual3 x y = not (isNotEqual3 x y)

        isNotEqual3 :: a -> a -> Bool
        -- isNotEqual3 x y = not (isEqual3 x y)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

組み込みの ~Eq~ 型を見る。
#+begin_src haskell
  class Eq a where
      (==), (/=) :: a -> a -> Bool

      -- 最低限の完全な定義は(==) か (/=) のどちらか
      x /= y     = not (x == y)
      x == y     = not (x /= y)
#+end_src

#+RESULTS:
#+begin_results
#+end_results

** 型クラスのインスタンス宣言
Color型だけでなく、BasicEq3のインスタンスとして宣言したあらゆる型に対して ~isEqual3~ が使える。
#+begin_src haskell
  instance BasicEq3 Color where
      isEqual3 Red   Red   = True
      isEqual3 Green Green = True
      isEqual3 Blue  Blue  = True
      isEqual3 _     _     = False
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** Show
#+begin_src haskell
:type show
#+end_src

#+RESULTS:
#+begin_results
show :: Show a => a -> String
#+end_results

#+begin_src haskell
  show 1
  show [1,2,3]
  show (1,2)
#+end_src

#+RESULTS:
#+begin_results
1
[1,2,3]
(1,2)
#+end_results

#+begin_src haskell
  putStrLn (show 1)
  putStrLn (show [1,2,3])
#+end_src

#+RESULTS:
#+begin_results
1
[1,2,3]
#+end_results

#+begin_src haskell
  show "Hello!"
  putStrLn (show "Hello!")
  show ['H', 'i']
  show "Hi, \"Jane\""
  putStrLn (show "Hi, \"Jane\"")
#+end_src

#+RESULTS:
#+begin_results
\"Hello!\"
Hello!
\"Hi\"
\"Hi, \\\"Jane\\\"\"
Hi, \"Jane\"
#+end_results

自分で定義した型に対して ~Show~ インスタンスを定義する。
#+begin_src haskell
  instance Show Color where
      show Red   = "Red"
      show Green = "Green"
      show Blue  = "Blue"
#+end_src

#+RESULTS:
#+begin_results
#+end_results
** Read
#+begin_src haskell
:type read
#+end_src

#+RESULTS:
#+begin_results
read :: Read a => String -> a
#+end_results

エラーが出てうまくいかない...。
#+begin_src haskell
  :{
  main = do
      putStrLn "Please enter a Double:"
      inpStr <- getLine
      let inpDouble = (read inpStr)::Double
      putStrLn ("Twice " ++ show inpDouble ++ " is " ++ show (inpDouble * 2))
  :}
#+end_src

#+begin_src haskell
read "5"
#+end_src

#+RESULTS:
#+begin_results
Exception: Prelude.read: no parse
#+end_results

型の ~a~ は、それぞれのReadのインスタンスのこと。

#+begin_src haskell
:type (read "5")
#+end_src

#+RESULTS:
#+begin_results
(read "5") :: Read a => a
#+end_results

実際に呼ばれる特定の関数はreadの返り値から期待される型で決まる。

#+begin_src haskell
(read "5")::Integer
(read "5")::Double
#+end_src

#+RESULTS:
#+begin_results
5
5.0
#+end_results

#+begin_src haskell
  :{
  instance Read Color where
     readsPrec _ value =
         -- ペアは文字列と欲しい返り値
         tryParse [("Red", Red), ("Green", Green), ("Blue", Blue)]
         where tryParse [] = []
               tryParse ((attempt, result):xs) =
                   if (take (length attempt) value) == attempt
                      then [(result, drop (length attempt) value)]
                      else tryParse xs
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

なぜかstack overflowでできない。

#+begin_src haskell
  (read "Red")::Color
  (read "Green")::Color
  (read "Blue")::Color
  (read "[Red]")::Color
  (read "[Red,Red,Blue]")::Color
#+end_src

#+RESULTS:
#+begin_results
Exception: stack overflow
#+end_results
** シリアライズ
#+begin_src haskell
  let d1 = [Just 5, Nothing, Nothing, Just 8, Just 9]::[Maybe Int]
  :type show
  :type show d1
  putStrLn (show d1)
#+end_src

#+RESULTS:
#+begin_results

show :: Show a => a -> String
show d1 :: String
[Just 5,Nothing,Nothing,Just 8,Just 9]
#+end_results

ファイルに書き込み。

#+begin_src haskell
  writeFile "test" (show d1)
#+end_src

#+RESULTS:
#+begin_results
#+end_results

再度読み込み。
~d2~ に明示的に型を与えるのがポイント。

#+begin_src haskell
  input <- readFile "test"
  let d2 = (read input) ::[Maybe Int]
  print d1
  print d2
  d1 == d2
#+end_src

#+RESULTS:
#+begin_results

GHCi> [Just 5,Nothing,Nothing,Just 8,Just 9]
[Just 5,Nothing,Nothing,Just 8,Just 9]
True
#+end_results

showにほかの引数を与えてみる。

#+begin_src haskell
putStrLn $ show [("hi", 1), ("there", 3)]
#+end_src

#+RESULTS:
#+begin_results
[("hi",1),("there",3)]
#+end_results

#+begin_src haskell
putStrLn $ show [[1, 2, 3], [4, 0, 1], [], [503]]
#+end_src

#+RESULTS:
#+begin_results
[[1,2,3],[4,0,1],[],[503]]
#+end_results

#+begin_src haskell
putStrLn $ show [Left 5, Right "there", Left 0, Right "nine"]
#+end_src

#+RESULTS:
#+begin_results
[Left 5,Right "there",Left 0,Right "nine"]
#+end_results

#+begin_src haskell
putStrLn $ show [Left 0, Right [1, 2, 3], Left 5, Right []]
#+end_src

#+RESULTS:
#+begin_results
[Left 0,Right [1,2,3],Left 5,Right []]
#+end_results
** 数値型
強力な数値型がある。
Haskellの演算子は関数にすぎない。
演算子を関数とみなす場合には括弧で囲む。

#+begin_src haskell
  :{
  data Color = Red | Green | Blue
         deriving (Read, Show, Eq, Ord)
  :}
  show Red
  (read "Red")::Color
  (read "[Red,Red,Blue]")::[Color]
  (read "[Red, Red, Blue]")::[Color]
  Red == Red
  Red == Blue
  Data.List.sort [Blue,Green,Blue,Red]
  Red < Blue
#+end_src

#+RESULTS:
#+begin_results

Red
Red
[Red,Red,Blue]
[Red,Red,Blue]
True
False
[Red,Green,Blue,Blue]
True
#+end_results

型が参照している型が、やはりその型クラスのインスタンスであると宣言しないといけない。

CannotShow が Show のインスタンスではないので、エラー。
#+begin_src haskell
  :{
  data CannotShow = CannotShow
  data CannotDeriveShow = CannotDeriveShow CannotShow
                          deriving (Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char| Prelude Data.Char Data.List Data.Char Data.Char|
<interactive>:7599:35-38: error:
    • No instance for (Show CannotShow)
        arising from the first field of ‘CannotDeriveShow’
          (type ‘CannotShow’)
      Possible fix:
        use a standalone 'deriving instance' declaration,
          so you can specify the instance context yourself
    • When deriving the instance for (Show CannotDeriveShow)
#+end_results

#+begin_src haskell
  :{
  data OK = OK
  instance Show OK where
      show _ = "OK"
  data ThisWorks = ThisWorks OK
                   deriving (Show)
  :}
#+end_src

#+RESULTS:
#+begin_results
#+end_results

Haskell では異なる型の値を含むリストはサポートされてないので、JSONオブジェクトを直接表現できない。
代わりにデータ構成子でそれぞれの値を含む必要がある。

#+begin_src haskell
  type JSONError = String

  class JSON a where
      toJValue :: a -> JValue
      fromJValue :: JValue -> Either JSONError a

  instance JSON JValue where
      toJValue = id
      fromJValue = Right
#+end_src

#+RESULTS:
#+begin_results
#+end_results

よりよいエラー文。

#+begin_src haskell
  data Maybe a = Nothing
               | Just a
                 deriving (Eq, Ord, Read, Show)

  data Either a b = Left a
                  | Right b
                    deriving (Eq, Ord, Read, Show)
#+end_src

#+begin_src haskell
  instance JSON Bool where
      toJValue = JBool
      fromJValue (JBool b) = Right b
      fromJValue _ = Left "not a JSON boolean"
#+end_src

#+RESULTS:
#+begin_results
#+end_results

特殊なコメントで制限回避。プラグマというコンパイラ指令。

#+begin_src haskell
{-# LANGUAGE TypeSynonymInstances #-}
#+end_src
** 型クラスとインスタンス

新しいインスタンスはどこででも追加できる。型クラスを定義したモジュール内のみに限定されてない。
型クラスは開世界仮説に基づいている。

#+begin_src haskell
  doubleToJValue :: (Double -> a) -> JValue -> Either JSONError a
  doubleToJValue f (JNumber v) = Right (f v)
  doubleToJValue _ _ = Left "not a JSON number"

  instance JSON Int where
      toJValue = JNumber . realToFrac
      fromJValue = doubleToJValue round

  instance JSON Integer where
      toJValue = JNumber . realToFrac
      fromJValue = doubleToJValue round

  instance JSON Double where
      toJValue = JNumber
      fromJValue = doubleToJValue id
#+end_src

#+RESULTS:
#+begin_results
#+end_results

インスタンスの重複。
リストをJSONの配列に変換する例。

#+begin_src haskell
  instance (JSON a) => JSON [a] where
      toJValue = undefined
      fromJValue = undefined
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  instance (JSON a) => JSON [(String, a)] where
      toJValue = undefined
      fromJValue = undefined
#+end_src

#+RESULTS:
#+begin_results
#+end_results

#+begin_src haskell
  {-# LANGUAGE FlexibleInstances #-}
  class Borked a where
      bork :: a -> String

  instance Borked Int where
      bork = show

  instance Borked (Int, Int) where
      bork (a, b) = bork a ++ ", " ++ bork b

  instance (Borked a, Borked b) => Borked (a, b) where
      bork (a, b) = ">>" ++ bork a ++ " " ++ bork b ++ "<<"
#+end_src

GHC は保守的で、使える可能性のあるインスタンスは1つだけであるべきとする。
なのでbork を使おうとするとエラーになる。
** 型クラスに関する制約の緩和
* Tasks
** TODO org-babelでhaskellを実行できなくなる
~:set +t~ を評価すると使えなくなる。
** TODO xmpfilterのHaskell版を探す or 作る
なければ簡易版で作る。
いちいちロード、コンパイルは学習に不便。既存のがあるはずだが、調べ方がわからない。

~org-babel~ でよさそう。
** TODO [[https://www.oreilly.co.jp/books/9784873114231/][O'Reilly Japan - Real World Haskell]] [14%]
<2021-10-20 Wed>
*** DONE 100
CLOSED: [2021-10-10 Sun 21:58]
:LOGBOOK:
CLOCK: [2021-10-10 Sun 21:08]--[2021-10-10 Sun 21:58] =>  0:50
CLOCK: [2021-10-10 Sun 11:38]--[2021-10-10 Sun 12:04] =>  0:26
CLOCK: [2021-10-10 Sun 10:29]--[2021-10-10 Sun 10:59] =>  0:30
CLOCK: [2021-10-09 Sat 22:21]--[2021-10-09 Sat 23:48] =>  1:27
CLOCK: [2021-10-09 Sat 19:34]--[2021-10-09 Sat 20:06] =>  0:32
CLOCK: [2021-10-08 Fri 22:23]--[2021-10-09 Sat 00:07] =>  1:44
CLOCK: [2021-10-07 Thu 09:58]--[2021-10-07 Thu 10:57] =>  0:59
CLOCK: [2021-10-07 Thu 09:24]--[2021-10-07 Thu 09:34] =>  0:10
CLOCK: [2021-10-06 Wed 22:25]--[2021-10-07 Thu 00:07] =>  1:42
CLOCK: [2021-10-06 Wed 08:47]--[2021-10-06 Wed 09:18] =>  0:31
CLOCK: [2021-10-06 Wed 00:05]--[2021-10-06 Wed 00:55] =>  0:50
CLOCK: [2021-10-05 Tue 22:08]--[2021-10-05 Tue 23:37] =>  1:29
CLOCK: [2021-10-05 Tue 09:48]--[2021-10-05 Tue 10:54] =>  1:06
CLOCK: [2021-10-05 Tue 09:22]--[2021-10-05 Tue 09:31] =>  0:09
CLOCK: [2021-10-04 Mon 10:13]--[2021-10-04 Mon 11:03] =>  0:50
CLOCK: [2021-10-03 Sun 20:22]--[2021-10-03 Sun 21:53] =>  1:31
CLOCK: [2021-10-03 Sun 16:41]--[2021-10-03 Sun 17:29] =>  0:48
CLOCK: [2021-10-03 Sun 15:15]--[2021-10-03 Sun 15:23] =>  0:08
CLOCK: [2021-10-02 Sat 23:12]--[2021-10-03 Sun 00:16] =>  1:04
:END:
*** TODO 200
:LOGBOOK:
CLOCK: [2021-10-15 Fri 09:22]--[2021-10-15 Fri 09:45] =>  0:23
CLOCK: [2021-10-14 Thu 09:40]--[2021-10-14 Thu 10:14] =>  0:34
CLOCK: [2021-10-13 Wed 22:22]--[2021-10-13 Wed 23:34] =>  1:12
CLOCK: [2021-10-13 Wed 19:18]--[2021-10-13 Wed 22:03] =>  2:45
CLOCK: [2021-10-13 Wed 18:49]--[2021-10-13 Wed 19:09] =>  0:20
CLOCK: [2021-10-13 Wed 12:51]--[2021-10-13 Wed 13:50] =>  0:59
CLOCK: [2021-10-13 Wed 10:04]--[2021-10-13 Wed 10:53] =>  0:49
CLOCK: [2021-10-13 Wed 09:30]--[2021-10-13 Wed 09:43] =>  0:13
CLOCK: [2021-10-12 Tue 22:21]--[2021-10-12 Tue 23:43] =>  1:22
CLOCK: [2021-10-11 Mon 23:25]--[2021-10-11 Mon 23:45] =>  0:20
CLOCK: [2021-10-11 Mon 21:52]--[2021-10-11 Mon 23:03] =>  1:11
CLOCK: [2021-10-11 Mon 09:55]--[2021-10-11 Mon 10:25] =>  0:30
:END:
<2021-10-13 Wed>
160pまで到達。
*** TODO 300
*** TODO 400
*** TODO 500
*** TODO 600
*** TODO 700
* Reference
** [[http://walk.northcol.org/haskell/][ウォークスルー Haskell - Haskell 入門]]
わかりやすそうな入門。
** [[https://www.lambdanote.com/collections/haskell][『プログラミングHaskell 第2版』 – 技術書出版と販売のラムダノート]]
** [[https://www.cs.nott.ac.uk/~pszgmh/fold.pdf][A tutorial on the universality and expressiveness of fold]]
haskellの畳み込みのすぐれたチュートリアル。
** [[https://www.haskell.org/onlinereport/haskell2010/haskellpa1.html#haskellch4.html][I The Haskell 2010 Language]]
Haskellの仕様書。
** [[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8777][CiteSeerX — The Design of a Pretty-printing Library]]
haskellのjsonプリティプリンタライブラリの設計。
** [[https://wiki.haskell.org/IO%E5%85%A5%E9%96%80%E7%B7%A8][IO入門編 - HaskellWiki]]
IOの説明。
** [[http://www.allureofthestars.com/play/][Allure of the Stars]]
Haskellのブラウザローグライクゲーム。
** [[https://www.infoq.com/jp/articles/Understanding-Monads-guide-for-perplexed/][モナドを理解する - 迷える者への手引き]]
Haskellのモナドの解説。
** [[https://ja.wikipedia.org/wiki/Haskell][Haskell - Wikipedia]]
* Archives
** DONE すごいHaskellたのしく学ぼう [100%]
CLOSED: [2021-09-28 Tue 23:44] DEADLINE: <2021-09-30 Thu>
:LOGBOOK:
CLOCK: [2021-09-19 Sun 14:38]--[2021-09-19 Sun 15:03] =>  0:25
CLOCK: [2021-09-17 Fri 22:40]--[2021-09-17 Fri 23:05] =>  0:25
CLOCK: [2021-09-15 Wed 10:19]--[2021-09-15 Wed 10:44] =>  0:25
CLOCK: [2021-09-15 Wed 09:52]--[2021-09-15 Wed 10:17] =>  0:25
:END:

何か作る的なテーマがないので読むのがつらい。
参考になりそうなパッケージを探したけど、ピンとくるものがない。
いくつかパッケージをbuildしてみたが、依存パッケージで動かない。どうするかな。

よくわからん。
*** DONE 30%
CLOSED: [2021-09-23 Thu 21:14] DEADLINE: <2021-09-23 Thu>
:LOGBOOK:
CLOCK: [2021-09-23 Thu 20:15]--[2021-09-23 Thu 21:14] =>  0:59
:END:
*** DONE 40%
CLOSED: [2021-09-24 Fri 23:59] DEADLINE: <2021-09-24 Fri>
:LOGBOOK:
CLOCK: [2021-09-24 Fri 22:50]--[2021-09-24 Fri 23:59] =>  1:09
CLOCK: [2021-09-24 Fri 22:11]--[2021-09-24 Fri 22:26] =>  0:15
:END:
*** DONE 50%
CLOSED: [2021-09-25 Sat 16:31]
:LOGBOOK:
CLOCK: [2021-09-25 Sat 15:54]--[2021-09-25 Sat 16:30] =>  0:36
CLOCK: [2021-09-25 Sat 14:43]--[2021-09-25 Sat 14:53] =>  0:10
:END:
<2021-09-25 Sat>
*** DONE 60%
CLOSED: [2021-09-25 Sat 17:26]
:LOGBOOK:
CLOCK: [2021-09-25 Sat 16:35]--[2021-09-25 Sat 17:26] =>  0:51
:END:
<2021-09-25 Sat>
*** DONE 70%
CLOSED: [2021-09-26 Sun 22:06]
:LOGBOOK:
CLOCK: [2021-09-26 Sun 21:13]--[2021-09-26 Sun 22:06] =>  0:53
:END:
<2021-09-26 Sun>
*** DONE 80%
CLOSED: [2021-09-27 Mon 00:04]
:LOGBOOK:
CLOCK: [2021-09-26 Sun 22:49]--[2021-09-27 Mon 00:04] =>  1:15
:END:
<2021-09-26 Sun>
*** DONE 90%
CLOSED: [2021-09-28 Tue 22:56]
:LOGBOOK:
CLOCK: [2021-09-28 Tue 22:05]--[2021-09-28 Tue 22:56] =>  0:51
:END:
<2021-09-28 Tue>
*** DONE 100%
CLOSED: [2021-09-28 Tue 23:44]
:LOGBOOK:
CLOCK: [2021-09-28 Tue 22:56]--[2021-09-28 Tue 23:44] =>  0:48
:END:
<2021-09-28 Tue>
