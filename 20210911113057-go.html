<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-05-07 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Go</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css' /><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css'><link rel='stylesheet' href='../css/site.css' /><link rel='stylesheet' href='../roam/css/code.css' /><link rel='stylesheet' href='css/site.css' /><link rel='stylesheet' href='css/code.css' />
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content">
<h1 class="title">Go</h1>

<div id="outline-container-org2fc2376" class="outline-2">
<h2 id="org2fc2376"><a href="#org2fc2376">概要</a></h2>
<div class="outline-text-2" id="text-org2fc2376">
<p>
Go言語はGoogleによって開発された<a href="20210509101246-programming_language.html#ID-868ac56a-2d42-48d7-ab7f-7047c85a8f39">Programming Language</a>。<a href="20210805005543-docker.html#ID-1658782a-d331-464b-9fd7-1f8233b8b7f8">Docker</a>はGoで書かれている。シンプルさをコンセプトにしている。シンプルすぎて必要な機能が足りてない、という批判もあるくらい。
</p>
</div>
</div>
<div id="outline-container-org698e183" class="outline-2">
<h2 id="org698e183"><a href="#org698e183">Memo</a></h2>
<div class="outline-text-2" id="text-org698e183">
</div>
<div id="outline-container-org8c9aa62" class="outline-3">
<h3 id="org8c9aa62"><a href="#org8c9aa62">golanglint-ci のgci warningが出たとき</a></h3>
<div class="outline-text-3" id="text-org8c9aa62">
<p>
原因はよくわからない。ツールをインストールしてフォーマットをかける。
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/75174808/meaning-of-file-is-not-gci-ed-with-skip-generated-s-standard-default-gci">main.go:24: File is not `gci`-ed with &#x2013;skip-generated -s standard,default (gci)</a></li>
</ul>

<blockquote>
<p>
main.go:24: File is not `gci`-ed with &#x2013;skip-generated -s standard,default (gci)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-shell">go install github.com/daixiang0/gci@latest
gci write --skip-generated -s standard,default .
</pre>
</div>
</div>
</div>
<div id="outline-container-org31fc016" class="outline-3">
<h3 id="org31fc016"><a href="#org31fc016">カバレッジ計測方法</a></h3>
<div class="outline-text-3" id="text-org31fc016">
<p>
カバレッジフラグをオンにしているとコンパイル時、各ブロックにカウンタが挿入されて実行されている。
</p>
</div>
</div>
<div id="outline-container-orgb7c06b8" class="outline-3">
<h3 id="orgb7c06b8"><a href="#orgb7c06b8">一部のテストを実行する</a></h3>
<div class="outline-text-3" id="text-orgb7c06b8">
<p>
ファイル指定でテストを実行しようとすると、ほかのパッケージを読み込んでくれないため走らせられないことがある。多くの場合、ほかのファイルへの読み込みがあるので、現実的ではない。なので、読み込むファイルは全体にして、走らせる関数を指定して一部だけ実行する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Buildinfoとつくテストだけを実行する</label><pre class="src src-go">go test ./... -run Buildinfo
</pre>
</div>
</div>
</div>
<div id="outline-container-org0c3ffe5" class="outline-3">
<h3 id="org0c3ffe5"><a href="#org0c3ffe5">スタックとヒープ</a></h3>
<div class="outline-text-3" id="text-org0c3ffe5">
<ul class="org-ul">
<li>メモリの読み書きを行う場所は、スタックとヒープに分かれる
<ul class="org-ul">
<li>スタックはメモリの使い方や使用量がコンパイル時に決定できる場合に用いられる
<ul class="org-ul">
<li>関数呼び出し時に確保され、関数から抜けるときに開放される。</li>
<li>あらかじめどのメモリをどれだけ使うかわかっているため、必要になる直前で確保し、いらなくなったらすぐに破棄できメモリを効率よく使える</li>
</ul></li>
<li>ヒープはメモリの使い方や使用量が実行時にしかわからない場合に用いる
<ul class="org-ul">
<li>ヒープに確保した変数の生存期間は用途によってバラバラ</li>
<li>ガベージコレクタを用いてヒープのメモリを集中管理し、しかるべきタイミングで解放する</li>
<li>GoではGC時にSTW(Stop The World)が発生するものを採用しているので、GCが動いている間はプログラムの実行が止まる</li>
</ul></li>
<li>なので、パフォーマンスを考慮するときはメモリを確保する先がスタックになるかヒープになるかは重要</li>
<li>変数の型が実態で定義される場合、Goはその変数をスタック上に確保する。<a href="20210911104632-c_language.html#ID-656a0aa4-e5d3-416f-82d5-f909558d0639">C language</a>と同じ</li>
<li>変数の型をポインタにすると、メモリはヒープかスタックのどちらかに確保される</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org61aa938" class="outline-3">
<h3 id="org61aa938"><a href="#org61aa938">一時ファイルを作る</a></h3>
<div class="outline-text-3" id="text-org61aa938">
<ul class="org-ul">
<li>os.CreateTemp が便利</li>
<li>os.MkdirTemp → ディレクトリ</li>
<li>(*testing.T).TempDir → テストで便利。テスト関数の終了時にディレクトリを消してくれる</li>
</ul>
</div>
</div>

<div id="outline-container-org53268a5" class="outline-3">
<h3 id="org53268a5"><a href="#org53268a5">大文字かを確認する</a></h3>
<div class="outline-text-3" id="text-org53268a5">
<div class="org-src-container">
<pre class="src src-go">fmt.Print(unicode.IsUpper('a'))
</pre>
</div>

<div class="results" id="org56fc6e9">
<p>
false
</p>

</div>

<div class="org-src-container">
<pre class="src src-go">fmt.Print(unicode.IsUpper('A'))
</pre>
</div>

<div class="results" id="org58f54e6">
<p>
true
</p>

</div>
</div>
</div>

<div id="outline-container-org41d1e4d" class="outline-3">
<h3 id="org41d1e4d"><a href="#org41d1e4d">goimportsが必要なパッケージを消してしまうときに確認すること</a></h3>
<div class="outline-text-3" id="text-org41d1e4d">
<p>
goimportsは面倒なimportを自動で書いてくれる便利なパッケージ。必要なパッケージを自動で消してしまうのでハマった。チェックリストを残す。
</p>

<ul class="org-ul">
<li>名前は合っているか。特に自分のパッケージを読み込む場合、module名と一致しているか</li>
<li>本当にその箇所から読み込めている記述になっているか。publicな呼び出しになっていないか</li>
</ul>
</div>
</div>

<div id="outline-container-org0966f16" class="outline-3">
<h3 id="org0966f16"><a href="#org0966f16">copyは固定長のsliceに対してしかできない</a></h3>
<div class="outline-text-3" id="text-org0966f16">
<p>
copyはその名の通りsliceをコピーするメソッド。固定長でないとコピーされない。
</p>
</div>
</div>
<div id="outline-container-org5c57ea3" class="outline-3">
<h3 id="org5c57ea3"><a href="#org5c57ea3">カバレッジを計測する</a></h3>
<div class="outline-text-3" id="text-org5c57ea3">
<div class="org-src-container">
<pre class="src src-shell">$ go test -coverprofile=cover.out .
$ go tool cover -html=cover.out -o cover.html
</pre>
</div>

<p>
Golang/goのリポジトリ全体を計測する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Go自体をビルドしてから、テストを実行する</label><pre class="src src-shell"><span class="org-builtin">cd</span> ./src
./all.bash
../bin/go test -cover ./... -coverprofile=cover.out
../bin/go tool cover -html=cover.out -o cover.html
</pre>
</div>
</div>
</div>
<div id="outline-container-org5a2dc5f" class="outline-3">
<h3 id="org5a2dc5f"><a href="#org5a2dc5f">対象のインターフェースを満たしている関数の一覧を見る</a></h3>
<div class="outline-text-3" id="text-org5a2dc5f">
<div class="org-src-container">
<pre class="src src-shell">godoc -http <span class="org-string">":8000"</span> -analysis type
<span class="org-comment-delimiter"># </span><span class="org-comment">http://localhost:6060/pkg/io/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org78755df" class="outline-3">
<h3 id="org78755df"><a href="#org78755df">失敗する可能性のあるときはerrorを返す</a></h3>
<div class="outline-text-3" id="text-org78755df">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>errorを返す関数の例</label><pre class="src src-go">
func (w *Wallet) Withdraw(amount Bitcoin) error {
	if amount &gt; w.balance {
		return ErrInsufficientFunds
	}

	w.balance -= amount
	return nil
}
</pre>
</div>

<p>
成功したときは、errorにnilが入る。
</p>

<p>
error時の処理は呼び出し元で定義し、errorを返す可能性のある関数定義では単にerrorを返すことだけに集中する。
</p>
</div>
</div>

<div id="outline-container-org9828f86" class="outline-3">
<h3 id="org9828f86"><a href="#org9828f86">named return value</a></h3>
<div class="outline-text-3" id="text-org9828f86">
<p>
返り値に名前をつける機能。最初に初期化され、returnするとそれ時点の名前のついた変数が返される。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>value1, value2は自動で初期化される。returnするとその時点でバインドされた変数が返される</label><pre class="src src-go">func test() (value1, value2 int) {
        value1 = 1
        value2 = 2
        return
}
</pre>
</div>

<p>
とすると、返り値には1, 2が返る。長い関数だとわかりづらくなるので注意。
</p>
</div>
</div>

<div id="outline-container-org898f91e" class="outline-3">
<h3 id="org898f91e"><a href="#org898f91e">コールグラフを活用して関数呼び出しの全体像を把握する</a></h3>
<div class="outline-text-3" id="text-org898f91e">
<p>
どの関数がどこから呼び出されているかの図を生成する。
</p>

<div class="org-src-container">
<pre class="src src-shell">go install github.com/ofabry/go-callvis@master <span class="org-comment-delimiter"># </span><span class="org-comment">&#12394;&#12380;&#12363;latest&#12496;&#12540;&#12472;&#12519;&#12531;&#12391;&#12399;&#22833;&#25943;&#12375;&#12383;</span>
</pre>
</div>

<p>
そして調べたい関数を呼び出したmain.goのあるディレクトリで実行する。
</p>

<div class="org-src-container">
<pre class="src src-shell">go-callvis -group pkg,type ./ <span class="org-comment-delimiter"># </span><span class="org-comment">-group&#12399;&#12464;&#12523;&#12540;&#12500;&#12531;&#12464;&#34920;&#31034;&#12377;&#12427;&#12458;&#12503;&#12471;&#12519;&#12531;</span>

go-callvis -group pkg,type -focus fmt ./ <span class="org-comment-delimiter"># </span><span class="org-comment">&#12501;&#12457;&#12540;&#12459;&#12473;&#34920;&#31034;</span>
</pre>
</div>

<p>
と、ブラウザが立ち上がって、図が表示される。図の中のライブラリをクリックすると、さらにそのライブラリの呼び出しを描画する。
</p>
</div>
</div>

<div id="outline-container-orgb4695e4" class="outline-3">
<h3 id="orgb4695e4"><a href="#orgb4695e4">go getしたときの証明書エラー</a></h3>
<div class="outline-text-3" id="text-orgb4695e4">
<p>
go get したとき <code>x509: certificate signed by unknown authority</code> エラーになる。
</p>

<p>
証明書の更新をすればよいとのこと。
</p>

<div class="org-src-container">
<pre class="src src-shell">$ sudo apt update
$ sudo apt install --only-upgrade -y ca-certificates <span class="org-comment-delimiter">#</span><span class="org-comment">&#26368;&#26032;</span>
$ update-ca-certificates
</pre>
</div>
</div>
</div>

<div id="outline-container-org06df596" class="outline-3">
<h3 id="org06df596"><a href="#org06df596">リクエストデータを構造体にバインドする</a></h3>
<div class="outline-text-3" id="text-org06df596">
<p>
リクエストを使うときに通常使われる方法。値の検証と後で利用しやすくするため、定義した構造体に入れる。
</p>

<ul class="org-ul">
<li><a href="https://echo.labstack.com/guide/binding/">Binding Request Data | Echo - High performance, minimalist Go web framework</a></li>
</ul>
</div>
</div>
<div id="outline-container-org8802aaf" class="outline-3">
<h3 id="org8802aaf"><a href="#org8802aaf">構造体の埋め込みの使い方</a></h3>
<div class="outline-text-3" id="text-org8802aaf">
<ul class="org-ul">
<li><a href="https://qiita.com/momotaro98/items/4f6e2facc40a3f37c3c3">Go言語の埋め込みについて4つのポイントでまとめました - Qiita</a></li>
</ul>
<p>
Goの埋め込みの解説。
</p>

<p>
埋め込みはあくまでも借りているだけで、埋め込み元のオブジェクトのメソッドとして実行される。埋め込み先の構造体が埋め込み元のメソッドを実行しても埋め込み先のオブジェクトには影響を与えない。
</p>
</div>
</div>

<div id="outline-container-orgc6fc056" class="outline-3">
<h3 id="orgc6fc056"><a href="#orgc6fc056"><a href="https://christina04.hatenablog.com/entry/pointers-in-golang">ポインタを図で理解する - Carpe Diem</a></a></h3>
<div class="outline-text-3" id="text-orgc6fc056">
<p>
図によるポインタのわかりやすい解説。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>値の比較</label><pre class="src src-go">var x = 100
fmt.Println("1: x address:\t", &amp;x)

var y *int
fmt.Println("2: y value:\t", y)
fmt.Println("3: y address:\t", &amp;y)
y = &amp;x
fmt.Println("4: y value:\t", y)	// yの値には、xのアドレスが入っている
fmt.Println("5: y address:\t", &amp;y)
</pre>
</div>

<div class="results" id="orgc925518">
<p>
1: x address:	 0xc00001a0c0
2: y value:	 &lt;nil&gt;
3: y address:	 0xc000012030
4: y value:	 0xc00001a0c0
5: y address:	 0xc000012030
</p>

</div>

<ul class="org-ul">
<li>型としての <code>*</code>
<ul class="org-ul">
<li>ポインタ変数はメモリ上のアドレスを値として入れられる変数</li>
<li>変数の中身(つまり値)はメモリアドレス</li>
</ul></li>
<li>変数の演算子としての <code>*</code>, <code>&amp;</code>
<ul class="org-ul">
<li><code>*</code> ポインタの指すメモリアドレスの実データ(value)</li>
<li><code>&amp;</code> 変数がメモリ上で確保された際のアドレス(address)</li>
</ul></li>
</ul>

<p>
<code>*x</code> だけど <code>x</code> がポインタ型変数でない場合、値にアドレスがなくて辿れず当然値も取得できないのでエラー。
</p>

<ul class="org-ul">
<li>メモリアドレスは変数であれば必ず存在する。なのでどの変数でも <code>&amp;</code> が使える</li>
<li>valueは値(1)か、メモリアドレス(0xc00001a0c0)が入っているか、nil。値にメモリアドレスが入っている場合のみ <code>*</code> が使える</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>ポインタ変数だけどnilのとき、runtime errorになる</label><pre class="src src-go">var x *int
fmt.Println("x value:\t", *x)
</pre>
</div>

<div class="results" id="orge8f138c">
<p>
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x480f1a]
</p>

</div>

<p>
ポインタ変数のvalueにメモリアドレスがないのでpanicが起きる。動かしてみないとわからないのでコンパイルエラーでなくruntimeエラー。
</p>

<p>
Goはすべて値渡し(=コピー)。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>valueは同じだが、addressはすべて異なる</label><pre class="src src-go">func main() {
        var x = "alice"
        fmt.Println("x address:\t", &amp;x)
        y := &amp;x
        fmt.Println("y value:\t", y)
        fmt.Println("y address:\t", &amp;y)

        show(y)
}

func show(s *string) {
        fmt.Println("f value:\t", s)
        fmt.Println("f address:\t", &amp;s)
}
</pre>
</div>

<div class="results" id="orgca52de6">
<p>
x address:	 0xc000014250
y value:	 0xc000014250
y address:	 0xc000012030
f value:	 0xc000014250
f address:	 0xc000012038
</p>

</div>

<p>
定義された変数と、関数引数として使われた変数では、参照先アドレスは同じ(xのアドレス)。アドレスは異なる、つまりコピーされている。
</p>

<p>
ポインタレシーバ。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>main関数から、レシーバから呼ばれたときのアドレスと値を比較する</label><pre class="src src-go">type Person struct {
        Name string
        Age int
}

func main() {
        x := &amp;Person{"alice", 20}
        fmt.Printf("x value:\t%p\n", x)
        fmt.Printf("x address:\t%p\n", &amp;x)
        x.Greet("test")

        fmt.Printf("new x value:\t%v\n", x)
}

func (p *Person) Greet(msg string) {
        fmt.Printf("p value:\t%p\n", p)
        fmt.Printf("p address:\t%p\n", &amp;p)

        // ポインタ変数を上書きするのではなく、参照先を上書きする
        p.Name = "hahaha"
}
</pre>
</div>

<div class="results" id="org321f549">
<p>
x value:	0xc000010030
x address:	0xc000012028
p value:	0xc000010030
p address:	0xc000012038
new x value:	&amp;{hahaha 20}
</p>

</div>
</div>
</div>

<div id="outline-container-orgd53d7fa" class="outline-3">
<h3 id="orgd53d7fa"><a href="#orgd53d7fa">レシーバーを値とポインタのどちらにするか</a></h3>
<div class="outline-text-3" id="text-orgd53d7fa">
<p>
メソッドのレシーバーを値にするかポインタにするかは、レシーバのフィールドに変更をしたいかによって決める。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>インスタンスのフィールドは変更されない(エラーにもならないので注意)</label><pre class="src src-go">func (s Struct) SetValue(v int {
        s.v = v
})
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>値を変更できる</label><pre class="src src-go">func (s *Struct) SetValue(v int {
        s.v = v
})
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc040968" class="outline-3">
<h3 id="orgc040968"><a href="#orgc040968">ポインタの操作</a></h3>
<div class="outline-text-3" id="text-orgc040968">
<ul class="org-ul">
<li>ポインタ型を示すときは <code>*Person</code> と宣言。これによってPerson型の変数のポインタが入ることが示される</li>
<li>ポインタ型を生成するときは <code>&amp;</code> を使う。これは変換関数のようなもの。 <code>&amp;変数名</code> という形式。実際に変数宣言されているものに対してポインタがある。それぞれにアドレスが割り当てられるようなもの。だから、型とか関数自体はポインタにしない(意味がない)。あくまで変数をリンクさせて、変更を波及させられるのが良いところだから</li>
<li>ポインタを解決実際の値を見るときは *p</li>
<li>&amp;p で*Person型を生成する、というような関係性</li>
</ul>

<div class="org-src-container">
<pre class="src src-go">var p *int // 変数pには、int型の変数のポインタが入るという宣言
i := 1
p = &amp;i				// 変数iを参照するポインタ型変数p

// p 				// -&gt; 0xc000010000
// *p 				// -&gt; 1

fmt.Println(p)
fmt.Println(*p)
i = 2				// あくまで変えるのは参照先の値であって、p -&gt; i のリンク自体を変えるわけじゃない
fmt.Println(p)			// メモリアドレスは変わらない
fmt.Println(*p)			// 参照先のアドレスが変わった
</pre>
</div>

<div class="results" id="org6c118c1">
<p>
0xc00001a0c0
1
0xc00001a0c0
2
</p>

</div>

<ul class="org-ul">
<li>「アドレスを取得(&amp;)」という操作と「アドレスを解決(*)」という操作がある。</li>
</ul>
</div>
</div>

<div id="outline-container-org8e6c5bb" class="outline-3">
<h3 id="org8e6c5bb"><a href="#org8e6c5bb"><span class="todo TODO">TODO</span> <a href="https://qiita.com/hnakamur/items/848097aad846d40ae84b">Goでファイルの存在チェック - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org8e6c5bb">
<p>
存在チェックの方法。
</p>
</div>
</div>
<div id="outline-container-org96b72e6" class="outline-3">
<h3 id="org96b72e6"><a href="#org96b72e6">ファイル埋め込み</a></h3>
<div class="outline-text-3" id="text-org96b72e6">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>sample.jsonを型sampleBytesに格納する</label><pre class="src src-go">//go:embed sample.json
var sampleBytes []byte
</pre>
</div>

<p>
ファイルを直に変数に入れることができる。いちいち読み込みのコードを書かなくて良くなる。
</p>

<p>
複数ファイルの埋め込みもできる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>embed.FS型のファイルシステムとして変数に埋め込む。あとから各々ファイルを取り出す</label><pre class="src src-go">//go:embed README.md version.txt
var static embed.FS

r, err := static.Readfile("README.md")
</pre>
</div>

<p>
確かに短く書ける。しかしこれだけなら、従来の方法でもできる。メリットは、設定ファイルをバイナリに埋め込めること。
</p>

<ul class="org-ul">
<li><a href="https://future-architect.github.io/articles/20210208/">Go 1.16からリリースされたgo:embedとは | フューチャー技術ブログ</a></li>
</ul>
</div>
</div>
<div id="outline-container-org6946740" class="outline-3">
<h3 id="org6946740"><a href="#org6946740">変数名のかぶりに注意する</a></h3>
<div class="outline-text-3" id="text-org6946740">
<p>
型名と同じ変数名を宣言すると、よりローカルな変数名が優先されるため、その型が使えなくなる。それだけでなく、型指定で~は型ではありませんエラーが謎に出るため、ハマる可能性が高い。Lintで防げるだろうか。
</p>
</div>
</div>
<div id="outline-container-org9773f19" class="outline-3">
<h3 id="org9773f19"><a href="#org9773f19">よく使う型の定義</a></h3>
<div class="outline-text-3" id="text-org9773f19">
<ul class="org-ul">
<li>fdはファイルディスクリプタ。プログラムからファイルを操作する際、操作対象のファイルを識別・同定するために割り当てられる番号</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>file型</label><pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file_unix.go#L54-L61
</pre>
</div>

<div class="results" id="orgbf31de2">
<p>
type file struct {
	pfd         poll.FD
	name        string
	dirinfo     *dirInfo <i>/ nil unless directory being read
	nonblock    bool     /</i> whether we set nonblocking mode
	stdoutOrErr bool     <i>/ whether this is stdout or stderr
	appendMode  bool     /</i> whether file is opened for appending
}
</p>

</div>

<ul class="org-ul">
<li>ネットワークで使うConnインターフェース</li>
</ul>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/net/net.go#L113-L168
</pre>
</div>

<div class="results" id="orge584e52">
<p>
type Conn interface {
	<i>/ Read reads data from the connection.
	/</i> Read can be made to time out and return an error after a fixed
	// time limit; see SetDeadline and SetReadDeadline.
	Read(b []byte) (n int, err error)
</p>

<p>
<i>/ Write writes data to the connection.
/</i> Write can be made to time out and return an error after a fixed
// time limit; see SetDeadline and SetWriteDeadline.
Write(b []byte) (n int, err error)
</p>

<p>
<i>/ Close closes the connection.
/</i> Any blocked Read or Write operations will be unblocked and return errors.
Close() error
</p>

<p>
// LocalAddr returns the local network address, if known.
LocalAddr() Addr
</p>

<p>
// RemoteAddr returns the remote network address, if known.
RemoteAddr() Addr
</p>

<p>
<i>/ SetDeadline sets the read and write deadlines associated
/</i> with the connection. It is equivalent to calling both
<i>/ SetReadDeadline and SetWriteDeadline.
/</i>
<i>/ A deadline is an absolute time after which I/O operations
/</i> fail instead of blocking. The deadline applies to all future
<i>/ and pending I/O, not just the immediately following call to
/</i> Read or Write. After a deadline has been exceeded, the
<i>/ connection can be refreshed by setting a deadline in the future.
/</i>
<i>/ If the deadline is exceeded a call to Read or Write or to other
/</i> I/O methods will return an error that wraps os.ErrDeadlineExceeded.
<i>/ This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
/</i> The error&rsquo;s Timeout method will return true, but note that there
<i>/ are other possible errors for which the Timeout method will
/</i> return true even if the deadline has not been exceeded.
<i>/
/</i> An idle timeout can be implemented by repeatedly extending
<i>/ the deadline after successful Read or Write calls.
/</i>
// A zero value for t means I/O operations will not time out.
SetDeadline(t time.Time) error
</p>

<p>
<i>/ SetReadDeadline sets the deadline for future Read calls
/</i> and any currently-blocked Read call.
// A zero value for t means Read will not time out.
SetReadDeadline(t time.Time) error
</p>

<p>
	<i>/ SetWriteDeadline sets the deadline for future Write calls
	/</i> and any currently-blocked Write call.
	<i>/ Even if write times out, it may return n &gt; 0, indicating that
	/</i> some of the data was successfully written.
	// A zero value for t means Write will not time out.
	SetWriteDeadline(t time.Time) error
}
</p>

</div>
</div>
</div>

<div id="outline-container-orge5cf3f3" class="outline-3">
<h3 id="orge5cf3f3"><a href="#orge5cf3f3">ファイルを開く関数</a></h3>
<div class="outline-text-3" id="text-orge5cf3f3">
<ul class="org-ul">
<li>Open(), Create() は引数が違うだけで同じ関数OpenFile()を呼び出している</li>
<li>よく使う権限の組み合わせでラップしているだけ</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>Open</label><pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file.go#L311-L313
</pre>
</div>

<div class="results" id="org1c16094">
<p>
func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>Create</label><pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file.go#L320-L322
</pre>
</div>

<div class="results" id="org422fdc7">
<p>
func Create(name string) (*File, error) {
	return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>OpenFile</label><pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/a813be86df74bf2a9c5b272c0b0934d196ac665d/src/os/file.go#L330-L339
</pre>
</div>

<div class="results" id="org9f5c042">
<p>
func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	testlog.Open(name)
	f, err := openFileNolog(name, flag, perm)
	if err != nil {
		return nil, err
	}
	f.appendMode = flag&amp;O_APPEND != 0
</p>

<p>
	return f, nil
}
</p>

</div>
</div>
</div>

<div id="outline-container-org63bbc97" class="outline-3">
<h3 id="org63bbc97"><a href="#org63bbc97">基本コマンド</a></h3>
<div class="outline-text-3" id="text-org63bbc97">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>mod.goを作成する</label><pre class="src src-shell">go mod init example
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>依存パッケージをインストールする。mod.goに記載される</label><pre class="src src-shell">go install
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>ビルド+実行</label><pre class="src src-shell">go run hello.go
</pre>
</div>

<p>
<a href="20210508234743-emacs.html#ID-1ad8c3d5-97ba-4905-be11-e6f2626127ad">Emacs</a> dap-modeでデバッガ起動。行の横をクリックしてブレークポイントをセットしたのち、コマンド実行。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>デバッグ実行</label><pre class="src src-emacs-lisp">M-x dap-debug
</pre>
</div>
</div>
</div>

<div id="outline-container-org3146180" class="outline-3">
<h3 id="org3146180"><a href="#org3146180"><a href="20210907012153-org_mode.html#ID-7e85e3f3-a6b9-447e-9826-307a3618dac8">org-mode</a>での実行方法</a></h3>
<div class="outline-text-3" id="text-org3146180">
<p>
ob-goをインストールして <code>(require "ob-go")</code> する。実行方法が少し変わっていて、下のように指定する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>babel引数で指定importを指定する。本文には書かない</label><pre class="src src-go">fmt.Println("hello world")
</pre>
</div>

<div class="results" id="org530cf58">
<p>
hello world
</p>

</div>

<ul class="org-ul">
<li><a href="https://github.com/pope/ob-go">pope/ob-go: Org-Babel support for evaluating go code.</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgaba0ae1" class="outline-3">
<h3 id="orgaba0ae1"><a href="#orgaba0ae1"><a href="20210508234743-emacs.html#ID-1ad8c3d5-97ba-4905-be11-e6f2626127ad">Emacs</a>に<a href="20220305121848-lsp.html#ID-eb807577-cd69-478c-8f82-264243c67354">LSP</a>+DAPを設定する</a></h3>
<div class="outline-text-3" id="text-orgaba0ae1">
<p>
DAP(Debug Adapter Protocol)はデバッガー補助。エディタ関係なくIDEのようにエディタ上でブレークポイントをセットできるプロトコル。<a href="20220305121848-lsp.html#ID-eb807577-cd69-478c-8f82-264243c67354">LSP</a>のデバッガーバージョンな概念。
</p>

<p>
Go用のデバッガはemacsコマンドでインストールできず、go installでインストールする必要がある。
</p>

<ul class="org-ul">
<li><a href="https://emacs-lsp.github.io/dap-mode/page/configuration/#go">Configuration - DAP Mode</a>
<ul class="org-ul">
<li>外部コマンドをgo installでインストール
<ul class="org-ul">
<li>LSPのライブラリ名は <code>gopls</code></li>
<li>Debuggerのライブラリ名は <code>delve</code> (注意: VScode用のプログラムを用いる方法はdeprecatedで、現在は直接installするのが最新)</li>
</ul></li>
<li>go installしたあと、Emacs側が認識できるように設定する</li>
</ul></li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>インストールする</label><pre class="src src-shell">$ go install golang.org/x/tools/gopls@master            <span class="org-comment-delimiter"># </span><span class="org-comment">Language Server</span>
$ go install github.com/go-delve/delve/cmd/dlv@master   <span class="org-comment-delimiter"># </span><span class="org-comment">debugger</span>
</pre>
</div>

<p>
自分の環境では一瞬デバッガのボタンが表示されて Debug Adapter finished になってしまう状態になった。Warningには <code>Warning (emacs): Initialize request failed: Failed to launch Disable showing Disable logging</code> が表示される。理由がよくわからないため、表示させる。 <code>(setq dap-print-io t)</code> を評価すると、messageバッファに詳細なログを出力する。
</p>

<p>
原因は、しっかりと表示されていた。
</p>

<blockquote>
<p>
&ldquo;format&rdquo;: &ldquo;Failed to launch: Go version 1.14.15 is too old for this version of Delve (minimum supported version 1.17, suppress this error with &#x2013;check-go-version=false)&rdquo;,
</p>
</blockquote>

<p>
ということで、goのバージョンを上げると無事デバッガが起動するようになった。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>その他便利ライブラリ</label><pre class="src src-shell">$ go install github.com/uudashr/gopkgs/cmd/gopkgs       <span class="org-comment-delimiter"># </span><span class="org-comment">Go &#12497;&#12483;&#12465;&#12540;&#12472;</span>
$ go install golang.org/x/tools/cmd/goimports@master    <span class="org-comment-delimiter"># </span><span class="org-comment">import &#12398;&#36942;&#19981;&#36275;&#12434;&#33258;&#21205;&#12391;&#35036;&#23436;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb510e85" class="outline-3">
<h3 id="orgb510e85"><a href="#orgb510e85">printの仕組み</a></h3>
<div class="outline-text-3" id="text-orgb510e85">
<p>
プリンターの状態を保存している、重要そうな構造体。
</p>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/fmt/print.go#L119-L120
</pre>
</div>

<div class="results" id="org5038ee0">
<p>
// pp is used to store a printer&rsquo;s state and is reused with sync.Pool to avoid allocations.
type pp struct {
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>フラグを実装している箇所。歴史的理由で引数はintになっているらしい</label><pre class="src src-git-permalink">https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/fmt/print.go#L188-L202
</pre>
</div>

<div class="results" id="orgacda4e3">
<p>
func (p *pp) Flag(b int) bool {
	switch b {
	case &rsquo;-&rsquo;:
		return p.fmt.minus
	case &rsquo;+&rsquo;:
		return p.fmt.plus || p.fmt.plusV
	case &rsquo;#&rsquo;:
		return p.fmt.sharp || p.fmt.sharpV
	case &rsquo; &rsquo;:
		return p.fmt.space
	case &rsquo;0&rsquo;:
		return p.fmt.zero
	}
	return false
}
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span>Printは出力先が標準出力の、Fprintのエイリアスにすぎない</label><pre class="src src-git-permalink">https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/fmt/print.go#L271-L273
</pre>
</div>

<div class="results" id="org2b07c76">
<p>
func Print(a &#x2026;any) (n int, err error) {
	return Fprint(os.Stdout, a&#x2026;)
}
</p>

</div>

<ul class="org-ul">
<li>doPrintf
<ul class="org-ul">
<li>printArg
<ul class="org-ul">
<li>printValue</li>
</ul></li>
</ul></li>

<li>実際画面に表示してるのはどこなんだろう
<ul class="org-ul">
<li>print系の中でbufに書き込みをしているのはよく見る</li>
<li>関数の中に画面出力、みたいな部分は見当たらず</li>
<li>別に「画面に出力する」という関数があるわけじゃなくて、「標準出力にあたるファイルに書き込みをする」関数があるだけ。だから、標準出力以外への書き込みとの差は一切ない</li>
<li>/dev/stdin は特殊ファイルという。画面への入出力などをファイルとして操作できるようにしたものだから、ファイル書き込みとなんら変わらずに操作できる</li>
<li>Stdoutは1と定義されている。なので、fd1つまり/dev/stdout/1を作成する</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/os/file.go#L66
</pre>
</div>

<div class="results" id="org85e444c">
<p>
Stdout = NewFile(uintptr(syscall.Stdout), &ldquo;/dev/stdout&rdquo;)
</p>

</div>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/cmd/vendor/golang.org/x/sys/unix/syscall_unix.go#L20
</pre>
</div>

<div class="results" id="orgc193aeb">
<p>
Stdout = 1
</p>

</div>

<ul class="org-ul">
<li>print系は、ベースになる関数がある。書き込み先とフォーマット解析の組み合わせで、いろいろ名前がついている</li>
<li>本質的に、ファイル書き込みにすぎない</li>
<li>フォーマット解析でいろいろ処理があって、多くを占める。各型での文字列の取り出し方とか</li>
</ul>
</div>
</div>
<div id="outline-container-orge3e7907" class="outline-3">
<h3 id="orge3e7907"><a href="#orge3e7907">Stringerとは</a></h3>
<div class="outline-text-3" id="text-orge3e7907">
<p>
よく見るが、何か。
</p>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/fmt/print.go#L63-L65
</pre>
</div>

<div class="results" id="org4feed24">
<p>
type Stringer interface {
	String() string
}
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>String()を実装してるのでMyStringはStringer</label><pre class="src src-go">type MyString string

func (s MyString) String() string {
  return "mystring"
}

func main() {
  s := MyString("hello")
  fmt.Println(s) // String()の結果が使われる
}
</pre>
</div>

<div class="results" id="orgb974dd3">
<p>
mystring
</p>

</div>

<p>
printするときには、先にStringerの判定が入る。Stringerを満たしていれば、String()を使う。満たさなければ、通常の、printに渡された文字列引数を使って表示する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>fmtパッケージのhandleMethodsという関数</label><pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/fmt/print.go#L670-L675
</pre>
</div>

<div class="results" id="org76d021a">
<p>
case Stringer:
	handled = true
	defer p.catchPanic(p.arg, verb, &ldquo;String&rdquo;)
	p.fmtString(v.String(), verb)
	return
}
</p>

</div>
</div>
</div>

<div id="outline-container-org6fbb2c5" class="outline-3">
<h3 id="org6fbb2c5"><a href="#org6fbb2c5">runeとは</a></h3>
<div class="outline-text-3" id="text-org6fbb2c5">
<ul class="org-ul">
<li><a href="https://qiita.com/seihmd/items/4a878e7fa340d7963fee">Goのruneを理解するためのUnicode知識 - Qiita</a></li>
<li>文字と01の並びを対応づける仕組み、それが文字コード。その1つのUnicodeは世界中のあらゆる文字列を収録されるために作られている規格
<ul class="org-ul">
<li>aはUnicodeでu+0041と表される。16進数で0041という値と対応づけられる。この値はcode point(code position)と呼ばれ、文字コード中の位置を指し示す文字のIDといえる</li>
<li>符号化方式は41とか1F601といったcode pointの値をコンピュータが扱うデータ形式に置き換えるための規則。方式によってcode pointを何byte単位で扱うかが異なってくる</li>
<li>Goでは符号化方式としてUTF-8を使用している。UTF-8では1byteから4byteの可変長データでcode pointを置換する。数字やアルファベットのような広く使われている文字は1byteになり、Unicodeに後から追加された絵文字などは4byteになる。</li>
<li>Unicodeの符号化方式にはUTF-16やUTF-8がある</li>
</ul></li>
<li>stringにインデックスでアクセスしたときに得られるbyte値は文字コードをUTF-8で1byteごとに区切った値</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>&ldquo;あ&rdquo;は3byteで表される</label><pre class="src src-go">s := "あ"
for i := 0; i &lt; len(s); i++{
  fmt.Printf("% x", s[i])
}
</pre>
</div>

<div class="results" id="org4c901ba">
<p>
e3 81 82
</p>

</div>

<ul class="org-ul">
<li>ひとつの文字は複数byteで表現される可能性がある。文字を表すbyteをまとめて読まないと正しい文字として認識できなくなる</li>
<li>なので文字を数える単位としてはbyteではなくcode pointのほうが都合がいい。Goではcode pointを単位として文字を扱うための仕組み、つまりruneを用意している</li>
<li>runeの実体はint32のエイリアス。int32なのはUnicodeの4byte分のcode pointを表現するため</li>
</ul>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L90-L92
</pre>
</div>

<div class="results" id="orgf25e5ed">
<p>
<i>/ rune is an alias for int32 and is equivalent to int32 in all ways. It is
/</i> used, by convention, to distinguish character values from integer values.
type rune = int32
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span>runeはint32のエイリアス。なので単なる数字</label><pre class="src src-go">fmt.Println('あ')
fmt.Println('a')
fmt.Println(' ')
fmt.Println('!')
fmt.Println('"')
fmt.Println('a' * 2)
fmt.Println('a' - 'b')
</pre>
</div>

<div class="results" id="org8866329">
<p>
12354
97
32
33
34
194
-1
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 30: </span>stringを[]runeと[]byteにキャストする。文字列が対応するcodepoint、byteに姿を変えているだけ</label><pre class="src src-go">s := "あいう"
fmt.Println([]rune(s))
fmt.Println([]byte(s))
</pre>
</div>

<div class="results" id="org73166ae">
<p>
[12354 12356 12358]
[227 129 130 227 129 132 227 129 134]
</p>

</div>
</div>
</div>
<div id="outline-container-org4e978e9" class="outline-3">
<h3 id="org4e978e9"><a href="#org4e978e9"><span class="done DONE">DONE</span> <a href="https://go.dev/ref/spec">The Go Programming Language Specification - The Go Programming Language</a></a></h3>
<div class="outline-text-3" id="text-org4e978e9">
<p>
言語の仕様書。
</p>

<ul class="org-ul">
<li>リテラルってなんだ
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB">リテラル - Wikipedia</a></li>
<li>ソースコード内に値を直接表記したもの
<ul class="org-ul">
<li><code>int x = 7;</code> だと7</li>
<li><code>double pi = 3.14;</code> だと3.14</li>
<li><code>string s = "hello";</code> だと&ldquo;hello&rdquo;</li>
</ul></li>
<li>トークンとは違うのかな。トークンは値だけでなく識別子や予約語も含む</li>
<li><a href="https://e-words.jp/w/%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB.html">リテラル（直値）とは - 意味をわかりやすく - IT用語辞典 e-Words</a></li>
<li>リテラルとは、コンピュータプログラムのソースコードなどの中に、特定のデータ型の値を直に記載したもの。また、そのように値をコードに書き入れるために定められている書式。</li>
</ul></li>
<li>セレクタってなんだ
<ul class="org-ul">
<li><code>x.f</code> は値 <code>x</code> のフィールド <code>f</code> 、またはメソッド <code>f</code> を示す</li>
</ul></li>
<li>定義型(defined type)ってなんだ
<ul class="org-ul">
<li>事前定義された型か、独自に定義された型</li>
<li><code>type S []int</code> の <code>S</code></li>
<li><code>type T int</code> の <code>T</code> と <code>int</code></li>
<li>defined typeでない型は複合型</li>
</ul></li>
<li>型リテラルってなんだ
<ul class="org-ul">
<li><a href="https://zenn.dev/syumai/articles/77bc12aca9b654">Goの型同一性を理解する</a></li>
<li>他の型を利用して構成される型</li>
<li><code>var a [5]int</code> における[5]int</li>
<li><code>type B int</code> (Bは型名)</li>
<li><code>var b []B</code> における[]B</li>
<li>リテラル中に他の型が使われない、func()や、struct{}といった型リテラルも存在する</li>
<li>型リテラルを使って示される型は、型定義が行われていないためdefined typeではない</li>
<li>型リテラルの種類
<ul class="org-ul">
<li>要素型を持つ
<ul class="org-ul">
<li>配列型</li>
<li>スライス型</li>
<li>マップ型</li>
<li>チャンネル型</li>
</ul></li>
<li>キー型を持つ
<ul class="org-ul">
<li>マップ型</li>
</ul></li>
<li>フィールド型を持つ
<ul class="org-ul">
<li>構造体型</li>
</ul></li>
<li>ベースの型を持つ
<ul class="org-ul">
<li>ポインタ型</li>
</ul></li>
<li>仮引数型、結果型を持つ
<ul class="org-ul">
<li>関数型</li>
</ul></li>
</ul></li>
<li>型リテラルによって示される型同士が同一かどうかを判定するには、型リテラルの構造が同一かつ、型リテラル中に現れる型が同一であることを確認する必要がある</li>
<li>型リテラルごとに、同一性の条件がある</li>
<li>インターフェース型は任意の型を使って構成されるわけではない。インターフェース型はメソッドを持ち、それぞれのメソッドは関数型を持つ</li>
</ul></li>
<li>underlying type(基底型)ってなんだ
<ul class="org-ul">
<li>すべての型はunderlying typeを持つ</li>
<li>事前に定義された型や、型リテラルによって示される型のunderlying typeはその型自身
<ul class="org-ul">
<li><code>int</code> -&gt; 基底型: int</li>
<li><code>string</code> -&gt; 基底型: string</li>
<li><code>[]int</code> -&gt; 基底型: []int</li>
<li><code>struct{}</code> -&gt; 基底型: struct{}</li>
</ul></li>
<li>それ以外の型のunderlying typeは型宣言の対象によって決まる</li>
<li>2つの型宣言
<ul class="org-ul">
<li><code>type A string</code> -&gt; 型宣言
<ul class="org-ul">
<li><code>type A string</code> -&gt; Aの基底型: string</li>
<li><code>type B A</code> -&gt; Bの基底型: string</li>
<li><code>type C []int</code> -&gt; Cの基底型: []int</li>
</ul></li>
<li><code>type B = int</code> -&gt; エイリアス宣言
<ul class="org-ul">
<li><code>type A string</code> -&gt; defined type</li>
<li><code>type B = A</code> -&gt; Bの基底型: string</li>
<li><code>type C = []int</code> -&gt; Cの基底型: []int</li>
</ul></li>
</ul></li>
<li>2つの型のいずれもdefined typeでない場合、それぞれの型のunderlying typeの型リテラルが構造的に等しい場合に同一となる
<ul class="org-ul">
<li>defined typeでない型とは、型リテラルと型エイリアス</li>
<li>型リテラルのunderlying typeはその型リテラル自身</li>
<li>型同一性においてunderlying typeの考慮が必要なのは型エイリアスのみ
<ul class="org-ul">
<li><code>type NamedMap = map[string][]int</code>
<ul class="org-ul">
<li>NamedMapの基底型はmap[string][]int</li>
<li>m1とm2はunderlying typeの型リテラルの構造が同一なので同一</li>
<li><code>var m1 map[string][]int</code></li>
<li><code>var m2 NamedMap</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>参考になる用語 <a href="https://zenn.dev/senk/articles/91fa080844bb12">[Go] 言語仕様書に出てくる型関連の用語まとめ</a></li>
<li><a href="https://zenn.dev/nobishii/articles/defined_types">Go言語のdefined typeとは何か</a></li>
<li>修飾識別子
<ul class="org-ul">
<li>パッケージ名をつけて修飾された識別子</li>
<li>PackageName &ldquo;.&rdquo; identifier .</li>
<li>修飾識別子は、インポートされなければならない</li>
</ul></li>
<li>runeの例で白鵬が出てきて笑う
<ul class="org-ul">
<li><a href="https://github.com/golang/go/blob/20e9b7f1b53d49fd66e0344b1d0d42d3cf5e47b6/doc/go_spec.html#L5624">https://github.com/golang/go/blob/20e9b7f1b53d49fd66e0344b1d0d42d3cf5e47b6/doc/go_spec.html#L5624</a></li>
</ul></li>
<li>終端文
<ul class="org-ul">
<li>return, goto, panic&#x2026;</li>
</ul></li>
<li>式文(expression statements)
<ul class="org-ul">
<li>関数呼び出しとメソッド呼び出しと受信演算は、文コンテキストに現れる。そのような文は、丸括弧で囲まれている必要がある</li>
</ul></li>
<li>アドレス演算子</li>
<li>ポインター間接参照</li>
<li>誤字
<ul class="org-ul">
<li>自薦宣言</li>
<li>関数内え</li>
<li>キーを全く含まないは要素リスト</li>
<li>ある要素がキーをもつならば，すべて要素が</li>
<li>関数はリテラルは</li>
<li>ようそが要素が</li>
<li>定数インデック</li>
<li>インデックは</li>
<li>次の関係を満足する</li>
<li>連続した要素がその文字列のバイトたち</li>
<li>であるスライスを生成される</li>
<li>結合性を上書して</li>
<li>fStmt =</li>
<li>仕様できる</li>
<li>文囲む親関数</li>
<li>じたがって</li>
<li>を満足する</li>
<li>を基準としたの</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd34bb57" class="outline-2">
<h2 id="orgd34bb57"><a href="#orgd34bb57">Tasks</a></h2>
<div class="outline-text-2" id="text-orgd34bb57">
</div>
<div id="outline-container-org1e0de18" class="outline-3">
<h3 id="org1e0de18"><a href="#org1e0de18"><span class="todo TODO">TODO</span> <a href="https://deeeet.com/writing/2016/05/08/gogc-2016/">GolangのGCを追う | Taichi Nakashima</a></a></h3>
<div class="outline-text-3" id="text-org1e0de18">
<p>
GCの解説。
</p>
</div>
</div>
<div id="outline-container-org91f8396" class="outline-3">
<h3 id="org91f8396"><a href="#org91f8396"><span class="todo TODO">TODO</span> <a href="https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/">Golang Internals, Part 5: the Runtime Bootstrap Process | Altoros</a></a></h3>
<div class="outline-text-3" id="text-org91f8396">
<p>
Goのランタイムの解説。
</p>
</div>
</div>
<div id="outline-container-org2856f9c" class="outline-3">
<h3 id="org2856f9c"><a href="#org2856f9c"><span class="todo TODO">TODO</span> <a href="https://speakerdeck.com/rhysd/go-detukurufan-yong-yan-yu-chu-li-xi-shi-zhuang-zhan-lue">Go でつくる汎用言語処理系 実装戦略 - Speaker Deck</a></a></h3>
<div class="outline-text-3" id="text-org2856f9c">
<p>
言語処理系の作り方。
</p>
</div>
</div>
<div id="outline-container-org9353362" class="outline-3">
<h3 id="org9353362"><a href="#org9353362"><span class="todo TODO">TODO</span> <a href="https://go.dev/src/cmd/compile/README">Introduction to the Go compiler - The Go Programming Language</a></a></h3>
<div class="outline-text-3" id="text-org9353362">
<p>
Goコンパイルの流れ。
</p>
</div>
</div>
<div id="outline-container-org92b686a" class="outline-3">
<h3 id="org92b686a"><a href="#org92b686a"><span class="todo TODO">TODO</span> <a href="https://maku77.github.io/p/29dgjnq/">ベンチマークを行う (testing.B) - まくまく Golang ノート</a></a></h3>
<div class="outline-text-3" id="text-org92b686a">
<p>
ベンチマークする方法。
</p>
</div>
</div>
<div id="outline-container-org0062dae" class="outline-3">
<h3 id="org0062dae"><a href="#org0062dae"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/spiegel/books/error-handling-in-golang/viewer/evaluations">エラー評価のいろいろ｜Go のエラーハンドリング</a></a></h3>
<div class="outline-text-3" id="text-org0062dae">
<p>
エラーハンドリングの本。
</p>
</div>
</div>
<div id="outline-container-orge8929e2" class="outline-3">
<h3 id="orge8929e2"><a href="#orge8929e2"><span class="todo TODO">TODO</span> <a href="https://qiita.com/hkurokawa/items/a4d402d3182dff387674">Go の定数の話 - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orge8929e2">
<p>
じつは複雑な定数。
</p>
</div>
</div>
<div id="outline-container-orgc6f76b8" class="outline-3">
<h3 id="orgc6f76b8"><a href="#orgc6f76b8"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/senk/articles/33c9dc7ea25dab">[Go] 言語仕様書の「型と値の特性」を理解する</a></a></h3>
<div class="outline-text-3" id="text-orgc6f76b8">
<p>
値。
</p>
</div>
</div>
<div id="outline-container-org485e141" class="outline-3">
<h3 id="org485e141"><a href="#org485e141"><span class="todo TODO">TODO</span> interfaceを満たす構造体の調べ方</a></h3>
<div class="outline-text-3" id="text-org485e141">
<p>
どうするんだっけ。
</p>
</div>
</div>
<div id="outline-container-org903dbef" class="outline-3">
<h3 id="org903dbef"><a href="#org903dbef"><span class="todo TODO">TODO</span> <a href="https://github.com/golang/example">golang/example: Go example projects</a></a></h3>
<div class="outline-text-3" id="text-org903dbef">
<p>
例で学ぶ解説。
</p>
</div>
</div>
<div id="outline-container-org96ebcea" class="outline-3">
<h3 id="org96ebcea"><a href="#org96ebcea"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/spiegel/articles/20201010-ni-is-not-nil">nil == nil でないとき（または Go プログラマは息をするように依存を注入する）</a></a></h3>
<div class="outline-text-3" id="text-org96ebcea">
<p>
直感に反する挙動からわかる、内部の仕組みの話。
</p>
</div>
</div>
<div id="outline-container-org4eae5f4" class="outline-3">
<h3 id="org4eae5f4"><a href="#org4eae5f4"><span class="todo TODO">TODO</span> <a href="https://gihyo.jp/book/2023/978-4-297-13419-8">Go言語プログラミングエッセンス：書籍案内｜技術評論社</a></a></h3>
<div class="outline-text-3" id="text-org4eae5f4">
<p>
来月発売される本。
</p>
</div>
</div>
<div id="outline-container-orgb1b799e" class="outline-3">
<h3 id="orgb1b799e"><a href="#orgb1b799e"><span class="todo TODO">TODO</span> ecspressoが本質的に何をしているか調べる&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DontKnow">DontKnow</span></span></a></h3>
</div>
<div id="outline-container-org8bbe07f" class="outline-3">
<h3 id="org8bbe07f"><a href="#org8bbe07f"><span class="todo TODO">TODO</span> <a href="https://d-tsuji.github.io/effective_go/documents/effective_go_ja.html">Effective Go — Effective Go ドキュメント</a></a></h3>
<div class="outline-text-3" id="text-org8bbe07f">
<p>
日本語訳。
</p>
</div>
</div>
<div id="outline-container-orgdc8c292" class="outline-3">
<h3 id="orgdc8c292"><a href="#orgdc8c292"><span class="todo TODO">TODO</span> <a href="https://runebook.dev/ja/docs/go/-index-">Go 1.19 日本語</a></a></h3>
<div class="outline-text-3" id="text-orgdc8c292">
<p>
日本語訳された公式ドキュメント。
</p>
</div>
</div>
<div id="outline-container-orga06d33e" class="outline-3">
<h3 id="orga06d33e"><a href="#orga06d33e"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/hsaki/books/golang-concurrency/viewer/intro">はじめに｜Goでの並行処理を徹底解剖！</a></a></h3>
<div class="outline-text-3" id="text-orga06d33e">
<p>
並行処理の解説本。
</p>

<p>
並行処理と並列処理は全く異なる。
</p>

<ul class="org-ul">
<li>並行処理(Concurrency)
<ul class="org-ul">
<li>ある時点の範囲において、複数のタスクを扱うこと</li>
<li>どういう風にふたつを終わらせるかは自由</li>
<li>複数の処理を独立に実行できる <b>構成</b> のこと</li>
<li>「並行処理できる設備がある」</li>
<li>一度に多くのことを扱うこと</li>
<li>問題解決の手段としてのプログラミングパターン</li>
<li>平行性はコードの性質</li>
</ul></li>
<li>並列処理(Parallelism)
<ul class="org-ul">
<li>ある時点の点において、複数のタスクを扱うこと</li>
<li>1点において、タスクAとBを同時に実行する</li>
<li>複数の処理を同時に <b>実行</b> すること</li>
<li>「並列処理で生産する」</li>
<li>一度に多くのことを行うこと</li>
<li>並行処理を可能にするハードウェアの特性のこと</li>
<li>並列性は動作しているプログラムの性質</li>
</ul></li>
</ul>

<p>
チャネルは送受信、実行同期のための機構。
</p>
</div>
</div>

<div id="outline-container-org4995b51" class="outline-3">
<h3 id="org4995b51"><a href="#org4995b51"><span class="todo TODO">TODO</span> <a href="https://www.manning.com/books/learn-go-with-pocket-sized-projects?utm_source=donia&amp;utm_medium=affiliate&amp;utm_campaign=book_latour_learn_1_5_23&amp;utm_content=linkedin&amp;a_aid=donia&amp;a_bid=48b0541c">Learn Go with Pocket-Sized Projects</a></a></h3>
<div class="outline-text-3" id="text-org4995b51">
<p>
Goのハンズオン集。
</p>
</div>
</div>
<div id="outline-container-orgfb91647" class="outline-3">
<h3 id="orgfb91647"><a href="#orgfb91647"><span class="todo TODO">TODO</span> <a href="https://qiita.com/tenntenn/items/b1bb5eb4d372bd2d936f">gorenameをライブラリとして使う #golang - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orgfb91647">
<p>
IdをIDに変換する例。
</p>
</div>
</div>
<div id="outline-container-org5c047e7" class="outline-3">
<h3 id="org5c047e7"><a href="#org5c047e7"><span class="todo TODO">TODO</span> <a href="https://qiita.com/lighttiger2505/items/8c1c2222d8ceb04b43fd">Go標準のflagパッケージと比べてみようサードパーティflagライブラリ - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org5c047e7">
<p>
読む。
</p>
</div>
</div>
<div id="outline-container-orgf602294" class="outline-3">
<h3 id="orgf602294"><a href="#orgf602294"><span class="todo TODO">TODO</span> <a href="http://go.shibu.jp/effective_go.html">Effective Go — プログラミング言語 Go ドキュメント v0.1 documentation</a></a></h3>
<div class="outline-text-3" id="text-orgf602294">
<p>
Goらしく書くためのtips。
</p>
</div>
</div>
<div id="outline-container-orgb5611a4" class="outline-3">
<h3 id="orgb5611a4"><a href="#orgb5611a4"><span class="todo TODO">TODO</span> <a href="https://qiita.com/mnuma/items/109458d90ce9dbdde426">Go Patternsで学ぶGo - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orgb5611a4">
<p>
Goで役立つパターン。
</p>
</div>
</div>
<div id="outline-container-org62cf606" class="outline-3">
<h3 id="org62cf606"><a href="#org62cf606"><span class="todo TODO">TODO</span> <a href="https://www.educative.io/answers/how-to-read-and-write-with-golang-bufio">How to read and write with Golang bufio</a></a></h3>
<div class="outline-text-3" id="text-org62cf606">
<p>
bufioのわかりやすい解説。
</p>
</div>
</div>
<div id="outline-container-org7b169ae" class="outline-3">
<h3 id="org7b169ae"><a href="#org7b169ae"><span class="todo TODO">TODO</span> <a href="https://qiita.com/tutuz/items/e875d8ea3c31450195a7">Go言語を使ったTCPクライアントの作り方 - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org7b169ae">
<p>
TCPの仕組み、作り方。
</p>
</div>
</div>
<div id="outline-container-orgbdd02ac" class="outline-3">
<h3 id="orgbdd02ac"><a href="#orgbdd02ac"><span class="todo TODO">TODO</span> new()とmake()の違い&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DontKnow">DontKnow</span></span></a></h3>
<div class="outline-text-3" id="text-orgbdd02ac">
<p>
どちらも大まかには初期化するものだが、微妙に異なる。
</p>

<ul class="org-ul">
<li>newはゼロ値で確保された値へのポインタを得る関数</li>
</ul>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L212
</pre>
</div>

<div class="results" id="org07a4aaa">
<p>
func new(Type) *Type
</p>

</div>

<ul class="org-ul">
<li>makeはマップ、スライス、チャンネル（map[type]type, []type, chan）の確保と初期化を行い型そのものを得る関数</li>
</ul>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L207
</pre>
</div>

<p>
#+begin_resultsg go
func make(t Type, size &#x2026;IntegerType) Type
#+end_results
</p>
</div>
</div>

<div id="outline-container-orgafaf95d" class="outline-3">
<h3 id="orgafaf95d"><a href="#orgafaf95d"><span class="todo TODO">TODO</span> Len()の仕組み&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DontKnow">DontKnow</span></span></a></h3>
<div class="outline-text-3" id="text-orgafaf95d">
<p>
スライスなどの長さを調べるLen()はどういう実装になっているのだろうか。組み込みだから、ほかの関数とは異なりそう。
</p>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/go/blob/9b8750f53ed89fb326e4d811524e647683136bac/src/builtin/builtin.go#L161-L173
</pre>
</div>

<div class="results" id="org96bd51e">
<p>
<i>/ The len built-in function returns the length of v, according to its type:
/</i>
<i>/	Array: the number of elements in v.
/</i> Pointer to array: the number of elements in *v (even if v is nil).
<i>/	Slice, or map: the number of elements in v; if v is nil, len(v) is zero.
/</i> String: the number of bytes in v.
<i>/	Channel: the number of elements queued (unread) in the channel buffer;
/</i>          if v is nil, len(v) is zero.
<i>/
/</i> For some arguments, such as a string literal or a simple array expression, the
<i>/ result can be a constant. See the Go language specification&rsquo;s &ldquo;Length and
/</i> capacity&ldquo; section for details.
func len(v Type) int
</p>

</div>
</div>
</div>

<div id="outline-container-org631ee2a" class="outline-3">
<h3 id="org631ee2a"><a href="#org631ee2a"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/hsaki/articles/go-convert-json-struct">Goにおけるjsonの扱い方を整理・考察してみた ~ データスキーマを添えて</a></a></h3>
<div class="outline-text-3" id="text-org631ee2a">
<p>
エンコードの解説。
</p>
</div>
</div>
<div id="outline-container-org04225f4" class="outline-3">
<h3 id="org04225f4"><a href="#org04225f4"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/hsaki/books/golang-httpserver-internal">Deep Dive into The Go&rsquo;s Web Server</a></a></h3>
<div class="outline-text-3" id="text-org04225f4">
<p>
Goのサーバーの解説。
</p>
</div>
</div>
<div id="outline-container-org8d54eb7" class="outline-3">
<h3 id="org8d54eb7"><a href="#org8d54eb7"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/hsaki/books/golang-concurrency">Goでの並行処理を徹底解剖！</a></a></h3>
<div class="outline-text-3" id="text-org8d54eb7">
<p>
Goの平行処理を解説した本。
</p>
</div>
</div>
<div id="outline-container-orgba4cf55" class="outline-3">
<h3 id="orgba4cf55"><a href="#orgba4cf55"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/hsaki/books/golang-context/viewer/intro">よくわかるcontextの使い方</a></a></h3>
<div class="outline-text-3" id="text-orgba4cf55">
<p>
contextの詳しい解説。この人すごいなあ。
</p>
</div>
</div>
<div id="outline-container-orga502bca" class="outline-3">
<h3 id="orga502bca"><a href="#orga502bca"><span class="todo TODO">TODO</span> 誤字修正</a></h3>
<div class="outline-text-3" id="text-orga502bca">
<ul class="org-ul">
<li>driectory</li>
</ul>
</div>
</div>
<div id="outline-container-org357bedc" class="outline-3">
<h3 id="org357bedc"><a href="#org357bedc"><span class="todo TODO">TODO</span> orgパーサを書く</a></h3>
<div class="outline-text-3" id="text-org357bedc">
<p>
パーサの理解を深めるためにやる。
</p>

<p>
参考。
</p>

<ul class="org-ul">
<li><a href="https://www.m3tech.blog/entry/2021/08/23/124000">マークダウンパーサを作ろう - エムスリーテックブログ</a></li>
</ul>

<p>
最終的にフォーマッタにしたい。
</p>

<ul class="org-ul">
<li>複数行で継続するものと、行内だけで有効化されるものがある。基本的に行内</li>
<li>先頭行で効果を発揮するものと、囲むことで有効化するものがある</li>
</ul>
</div>
</div>

<div id="outline-container-org211b1a7" class="outline-3">
<h3 id="org211b1a7"><a href="#org211b1a7"><span class="todo TODO">TODO</span> <a href="https://compilerbook.com/">Writing A Compiler In Go | Thorsten Ball</a></a></h3>
<div class="outline-text-3" id="text-org211b1a7">
<p>
Goでインタプリタを書く本の続編。
</p>
</div>
</div>
<div id="outline-container-org67b37f6" class="outline-3">
<h3 id="org67b37f6"><a href="#org67b37f6"><span class="todo TODO">TODO</span> <a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/ja/?q=">Introduction · Build web application with Golang</a></a></h3>
<div class="outline-text-3" id="text-org67b37f6">
<p>
Go Web プログラミング。
</p>
</div>
</div>
<div id="outline-container-orgdfd0774" class="outline-3">
<h3 id="orgdfd0774"><a href="#orgdfd0774"><span class="todo TODO">TODO</span> <a href="http://go.shibu.jp/">プログラミング言語 Go ドキュメント — プログラミング言語 Go ドキュメント v0.1 documentation</a></a></h3>
<div class="outline-text-3" id="text-orgdfd0774">
<p>
Goドキュメント。
</p>
</div>
</div>
<div id="outline-container-org15b1925" class="outline-3">
<h3 id="org15b1925"><a href="#org15b1925"><span class="todo TODO">TODO</span> <a href="https://knsh14.github.io/translations/go-codereview-comments/">Go Codereview Comments</a></a></h3>
<div class="outline-text-3" id="text-org15b1925">
<p>
GoのTips集。
</p>
</div>
</div>
<div id="outline-container-orgd9e3e88" class="outline-3">
<h3 id="orgd9e3e88"><a href="#orgd9e3e88"><span class="todo TODO">TODO</span> <a href="https://hiwane.github.io/gospec-ja/">Go プログラミング言語仕様 | gospec-ja</a></a></h3>
<div class="outline-text-3" id="text-orgd9e3e88">
<p>
言語仕様の日本語訳。
</p>
</div>
</div>
<div id="outline-container-org40fc8f1" class="outline-3">
<h3 id="org40fc8f1"><a href="#org40fc8f1"><span class="todo TODO">TODO</span> <a href="https://qiita.com/taigamikami/items/fc798cdd6a4eaf9a7d5e">Goのgoroutine, channelをちょっと攻略！ - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org40fc8f1">
<p>
ゴルーチンの解説。
</p>
</div>
</div>
<div id="outline-container-org2959bf1" class="outline-3">
<h3 id="org2959bf1"><a href="#org2959bf1"><span class="todo TODO">TODO</span> <a href="https://qiita.com/tenntenn/items/45c568d43e950292bc31">Goを学びたての人が誤解しがちなtypeと構造体について #golang - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org2959bf1">
<p>
typeとstructの違いの解説。
</p>
</div>
</div>
<div id="outline-container-orgc397027" class="outline-3">
<h3 id="orgc397027"><a href="#orgc397027"><span class="todo TODO">TODO</span> actをworkflow化する</a></h3>
<div class="outline-text-3" id="text-orgc397027">
<p>
<a href="20220427215330-github_actions.html#ID-2d35ac9e-554a-4142-bba7-3c614cbfe4c4">GitHub Actions</a>ですぐに実行できるようにする。
</p>

<ul class="org-ul">
<li>workflow化する</li>
<li>スターターパッケージを作成する</li>
</ul>

<p>
フォークをどう扱うか問題がある。自分は運用でカバーしてるけど。自分で使うには十分だけど、他の人に利用してもらうにはまだビミョー。
</p>
</div>
</div>
<div id="outline-container-org81aeaaf" class="outline-3">
<h3 id="org81aeaaf"><a href="#org81aeaaf"><span class="todo TODO">TODO</span> actをバージョン対応する</a></h3>
<div class="outline-text-3" id="text-org81aeaaf">
<p>
mainを使ってるので、バージョンを固定して安全に使えるようにする。
</p>
</div>
</div>
<div id="outline-container-org0f8dfc1" class="outline-3">
<h3 id="org0f8dfc1"><a href="#org0f8dfc1"><span class="todo TODO">TODO</span> maruをバージョン対応する</a></h3>
<div class="outline-text-3" id="text-org0f8dfc1">
<p>
READMEのタグをmainにしてるので、バージョン番号にする。タグを切り替えると画像も変わるようにして、安全にする。安心して使えるようにする。
</p>
</div>
</div>
<div id="outline-container-org1440608" class="outline-3">
<h3 id="org1440608"><a href="#org1440608"><span class="todo TODO">TODO</span> ローカルパッケージをimportする方法</a></h3>
<div class="outline-text-3" id="text-org1440608">
<p>
読みたいライブラリがmoduleで、直接実行できない。実行できないと、printデバッグもできない。テストでもできるか。だが引数が面倒なのだと大変。
</p>

<p>
ローカルimportの方法も一応知っておきたい。
</p>
</div>
</div>
<div id="outline-container-orgc93027a" class="outline-3">
<h3 id="orgc93027a"><a href="#orgc93027a"><span class="todo TODO">TODO</span> octocovを読む</a></h3>
<div class="outline-text-3" id="text-orgc93027a">
<ul class="org-ul">
<li><a href="https://github.com/k1LoW/octocov">k1LoW/octocov</a></li>
</ul>

<p>
何か作っていて参考にするときは、よく読める。理解できる。が大雑把なスコープで「理解しよう」でやるとあまり進まない。
</p>
</div>
</div>

<div id="outline-container-orgc2eceb8" class="outline-3">
<h3 id="orgc2eceb8"><a href="#orgc2eceb8"><span class="todo TODO">TODO</span> goclocを読む</a></h3>
<div class="outline-text-3" id="text-orgc2eceb8">
<p>
goclocはリポジトリのコード量を調べるツール。
</p>

<ul class="org-ul">
<li><a href="https://github.com/hhatto/gocloc">hhatto/gocloc: A little fast cloc(Count Lines Of Code)</a></li>
</ul>

<p>
参考になるところのメモ。
</p>

<ul class="org-ul">
<li>気軽にコマンド実行できるようにdockerイメージを用意する</li>
<li>オプションの取り回し方。構造体に入れておく</li>
<li>結果を構造体に入れておく</li>
<li>本体とCLIは別packageになっている</li>
</ul>

<p>
気になる部分。
</p>

<ul class="org-ul">
<li>言語判定のライブラリを使っているみたいだが、大きな、割と雑なマップがある</li>
</ul>
</div>
</div>

<div id="outline-container-org4ac6c1f" class="outline-3">
<h3 id="org4ac6c1f"><a href="#org4ac6c1f"><span class="todo TODO">TODO</span> colorを読む</a></h3>
<div class="outline-text-3" id="text-org4ac6c1f">
<p>
CLIに色をつけるライブラリ。
</p>

<ul class="org-ul">
<li><a href="https://github.com/fatih/color">fatih/color: Color package for Go (golang)</a></li>
</ul>

<p>
別の色関係のライブラリが出てくる。何が違うのかわからない。
</p>

<ul class="org-ul">
<li><a href="https://github.com/mattn/go-colorable">mattn/go-colorable</a></li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 31: </span>関数Set。メソッドSetを呼び出す</label><pre class="src src-git-permalink">https://github.com/kd-collective/color/blob/dbae876e45b9c53e464d101d63f4758c9f0bd8e8/color.go#L131-L137
</pre>
</div>

<div class="results" id="orga5ffc3b">
<p>
<i>/ Set sets the given parameters immediately. It will change the color of
/</i> output with the given SGR parameters until color.Unset() is called.
func Set(p &#x2026;Attribute) *Color {
	c := New(p&#x2026;)
	c.Set()
	return c
}
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span>メソッドSet。Printfで、色指定された文字を表示している</label><pre class="src src-git-permalink">https://github.com/kd-collective/color/blob/dbae876e45b9c53e464d101d63f4758c9f0bd8e8/color.go#L149-L157
</pre>
</div>

<div class="results" id="orgb1fb97d">
<p>
// Set sets the SGR sequence.
func (c *Color) Set() *Color {
	if c.isNoColorSet() {
		return c
	}
</p>

<p>
	fmt.Fprint(Output, c.format())
	return c
}
</p>

</div>

<p>
なんだか地味に長いし、よくわからない。
</p>
</div>
</div>

<div id="outline-container-orgc0cc70c" class="outline-3">
<h3 id="orgc0cc70c"><a href="#orgc0cc70c"><span class="todo TODO">TODO</span> <a href="https://www.amazon.co.jp/Go%E8%A8%80%E8%AA%9Ereflect%E3%83%8F%E3%83%B3%E3%83%89%E3%83%96%E3%83%83%E3%82%AF-%E6%8A%80%E8%A1%93%E3%81%AE%E6%B3%89%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA%EF%BC%88NextPublishing%EF%BC%89-%E5%8D%83%E8%91%89-%E5%A4%A7%E4%BA%8C%E9%83%8E-ebook/dp/B08NT59MS4/ref=sr_1_16?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;crid=1HEEXC8ONO3XN&amp;keywords=go+%E8%A8%80%E8%AA%9E&amp;qid=1663726078&amp;sprefix=go+%E3%81%92n%2Caps%2C202&amp;sr=8-16">Go言語reflectハンドブック (技術の泉シリーズ（NextPublishing）) | 千葉 大二郎 | 工学 | Kindleストア | Amazon</a></a></h3>
<div class="outline-text-3" id="text-orgc0cc70c">
<p>
reflectの解説。
</p>
</div>
</div>
<div id="outline-container-org0acf996" class="outline-3">
<h3 id="org0acf996"><a href="#org0acf996"><span class="todo TODO">TODO</span> <a href="https://www.amazon.co.jp/Go%E3%81%A8SAM%E3%81%A7%E5%AD%A6%E3%81%B6AWS-Lambda-%E6%8A%80%E8%A1%93%E3%81%AE%E6%B3%89%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA%EF%BC%88NextPublishing%EF%BC%89-%E6%9D%89%E7%94%B0-%E5%AF%BF%E6%86%B2-ebook/dp/B07LGNGDHF/ref=sr_1_36?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;crid=1HEEXC8ONO3XN&amp;keywords=go+%E8%A8%80%E8%AA%9E&amp;qid=1663726078&amp;sprefix=go+%E3%81%92n%2Caps%2C202&amp;sr=8-36">GoとSAMで学ぶAWS Lambda (技術の泉シリーズ（NextPublishing）) | 杉田 寿憲 | 工学 | Kindleストア | Amazon</a></a></h3>
<div class="outline-text-3" id="text-org0acf996">
<p>
Goを使ったサーバレスの解説。
</p>
</div>
</div>
<div id="outline-container-org0586cd2" class="outline-3">
<h3 id="org0586cd2"><a href="#org0586cd2"><span class="todo TODO">TODO</span> <a href="https://www.amazon.co.jp/Go%E8%A8%80%E8%AA%9E%E3%81%AB%E3%82%88%E3%82%8B%E4%B8%A6%E8%A1%8C%E5%87%A6%E7%90%86-Katherine-Cox-Buday/dp/4873118468/ref=sr_1_19?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;crid=1HEEXC8ONO3XN&amp;keywords=go+%E8%A8%80%E8%AA%9E&amp;qid=1663726078&amp;sprefix=go+%E3%81%92n%2Caps%2C202&amp;sr=8-19">Go言語による並行処理 | Katherine Cox-Buday, 山口 能迪 |本 | 通販 | Amazon</a></a></h3>
<div class="outline-text-3" id="text-org0586cd2">
<p>
平行処理の解説。
</p>
</div>
</div>
<div id="outline-container-orgb72b27b" class="outline-3">
<h3 id="orgb72b27b"><a href="#orgb72b27b"><span class="todo TODO">TODO</span> <a href="https://www.amazon.co.jp/Go%E8%A8%80%E8%AA%9E%E3%81%AB%E3%82%88%E3%82%8B%E5%88%86%E6%95%A3%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9-%E2%80%95%E4%BF%A1%E9%A0%BC%E6%80%A7%E3%80%81%E6%8B%A1%E5%BC%B5%E6%80%A7%E3%80%81%E4%BF%9D%E5%AE%88%E6%80%A7%E3%81%AE%E9%AB%98%E3%81%84%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%A7%8B%E7%AF%89-Travis-Jeffery/dp/4873119979/ref=sr_1_5?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;crid=1HEEXC8ONO3XN&amp;keywords=go+%E8%A8%80%E8%AA%9E&amp;qid=1663726078&amp;sprefix=go+%E3%81%92n%2Caps%2C202&amp;sr=8-5">Go言語による分散サービス ―信頼性、拡張性、保守性の高いシステムの構築 | Travis Jeffery, 柴田 芳樹 |本 | 通販 | Amazon</a></a></h3>
<div class="outline-text-3" id="text-orgb72b27b">
<p>
分散サービスの解説。
</p>
</div>
</div>
<div id="outline-container-org3be4279" class="outline-3">
<h3 id="org3be4279"><a href="#org3be4279"><span class="todo TODO">TODO</span> <a href="https://www.amazon.co.jp/%E5%AE%9F%E7%94%A8-Go%E8%A8%80%E8%AA%9E-%E2%80%95%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E9%96%8B%E7%99%BA%E3%81%AE%E7%8F%BE%E5%A0%B4%E3%81%A7%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9-%E6%B8%8B%E5%B7%9D-%E3%82%88%E3%81%97%E3%81%8D/dp/4873119693/ref=sr_1_3?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;crid=1HEEXC8ONO3XN&amp;keywords=go+%E8%A8%80%E8%AA%9E&amp;qid=1663726078&amp;sprefix=go+%E3%81%92n%2Caps%2C202&amp;sr=8-3">実用 Go言語 ―システム開発の現場で知っておきたいアドバイス | 渋川 よしき, 辻 大志郎, 真野 隼記 |本 | 通販 | Amazon</a></a></h3>
<div class="outline-text-3" id="text-org3be4279">
<ul class="org-ul">
<li>45, 94, 102, 199, 232</li>
</ul>

<p>
業務に役立つGoの解説。
</p>

<blockquote>
<p>
Javaの世界では、親のコントロールクラスを継承して必要なメソッドを再定義しフレームワークから利用する、といった大規模なフレームワーク風のコーディングスタイルがあります。これはmain()関数が見えない、「ハリウッドの法則」にのっとったもので、一見コード量が少なく効率も良さそうに思えますが、フレームワークの進化が進めば進むほど、ソフトウェアの構造を考えて実装するという経験が得られず、「ソフトウェアの仕組みや開発技術を学ぶ」よりも「フレームワークの作法」を学ぶことが要求されるようになります。ジュニアな開発者でもレールから外れることなく、一定の成果をあげられるという利点がありますが、プログラマーとしての成長が難しいという欠点があります。
</p>
</blockquote>

<ul class="org-ul">
<li>オーバーライド・継承のあるオブジェクト指向プログラミングではテンプレートメソッドパターンが一般的に用いられる
<ul class="org-ul">
<li>テンプレートメソッドパターン: フレームワーク側でロジックの大部分をにない、一部のカスタマイズ可能なポイントのロジックのみを変更する設計</li>
</ul></li>
<li>Goではテンプレートメソッドパターンを使用しない代わりにストラテジーパターンを用いる</li>
<li>シンプルなインターフェースを使うAPI(Reader, Writerを引数にとる)をコアとして作り、それをラップして使いやすいAPIを別に提供するのが、Goで広く行われている設計方法
<ul class="org-ul">
<li>ユニットテストなどが行いやすい。</li>
</ul></li>
<li>文法がシンプルだからこそ、どう使うかが重要になっている</li>
<li>エラーのラップ、アンラップができる。たとえば「ファイルパスエラー」という低レベルなエラーをラップして「設定ファイルの読み込みエラー」とより抽象度の高いエラーで表現でき、必要に応じてアンラップし、詳細情報にもアクセスできる</li>
<li>エラーのチェック忘れをkisielk/errcheckで確かめられる</li>
<li><code>go install</code> はgo.modに影響なくインストールできる。 <code>go get</code> はgo.modに反映する</li>
<li>Goの場合、パッケージを相互依存の関係にできないことから、パッケージ連携ごとに同じような構造体を量産することになりコード量が増加する。まずはシンプルに、パッケージを細かく分割しないことを考える</li>
<li>フォークしたGoプロジェクトはハッシュが異なるため、そのままでは依存関係に記述できない</li>
</ul>
</div>
</div>

<div id="outline-container-orgbe9b8bd" class="outline-3">
<h3 id="orgbe9b8bd"><a href="#orgbe9b8bd"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/hokita/articles/66cc118b227ae3">はじめてのゲームプログラミング（Ebiten）</a></a></h3>
<div class="outline-text-3" id="text-orgbe9b8bd">
<p>
簡単なゲームのチュートリアル。
</p>
</div>
</div>
<div id="outline-container-orgf7e053e" class="outline-3">
<h3 id="orgf7e053e"><a href="#orgf7e053e"><span class="todo TODO">TODO</span> <a href="https://golangprojectstructure.com/creating-cool-games-with-ebiten-in-go/">Creating Cool Games With Ebiten | Golang Project Structure</a></a></h3>
<div class="outline-text-3" id="text-orgf7e053e">
<p>
ゲームのチュートリアル。
</p>
</div>
</div>
<div id="outline-container-org457ac89" class="outline-3">
<h3 id="org457ac89"><a href="#org457ac89"><span class="todo TODO">TODO</span> <a href="https://www.fatoldyeti.com/categories/roguelike-tutorial/">Roguelike Tutorial | Fat Old Yeti</a></a></h3>
<div class="outline-text-3" id="text-org457ac89">
<p>
Ebitenでローグライクを作るチュートリアル。
</p>
</div>
</div>
<div id="outline-container-org843310b" class="outline-3">
<h3 id="org843310b"><a href="#org843310b"><span class="todo TODO">TODO</span> <a href="https://medium.com/@chrisandrews_76960/2d-game-development-in-golang-part-1-5e2c11a513ed">2D Game Development in Golang — Part 1 | by Chris Andrews | Medium</a></a></h3>
<div class="outline-text-3" id="text-org843310b">
<p>
Ebitenの小さなチュートリアル。
</p>
</div>
</div>
<div id="outline-container-orgd6476a3" class="outline-3">
<h3 id="orgd6476a3"><a href="#orgd6476a3"><span class="todo TODO">TODO</span> <a href="https://qiita.com/bokuweb/items/1575337bef44ae82f4d3">ファミコンエミュレータの創り方 - Hello, World!編 - - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orgd6476a3">
<p>
エミュレータの作り方の概要。
</p>
</div>
</div>
<div id="outline-container-orgdcfd4f2" class="outline-3">
<h3 id="orgdcfd4f2"><a href="#orgdcfd4f2"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/akatsuki/articles/ec95ab95f0e89ea8c38f">ゲームボーイのエミュレータをGoで作った話</a></a></h3>
<div class="outline-text-3" id="text-orgdcfd4f2">
<p>
作り方の解説。
</p>
</div>
</div>
<div id="outline-container-org11ed9ba" class="outline-3">
<h3 id="org11ed9ba"><a href="#org11ed9ba"><span class="todo TODO">TODO</span> <a href="https://swet.dena.com/entry/2021/12/07/123000">「テスタビリティの高いGoのAPIサーバを開発しよう」というハンズオンを公開しました - DeNA Testing Blog</a></a></h3>
<div class="outline-text-3" id="text-org11ed9ba">
<p>
GoのAPIハンズオン。
</p>
</div>
</div>
<div id="outline-container-org4e67100" class="outline-3">
<h3 id="org4e67100"><a href="#org4e67100"><span class="todo TODO">TODO</span> <a href="https://wxdublin.gitbooks.io/docker-code-walk/content/client.html">Client | Docker Code Walk</a></a></h3>
<div class="outline-text-3" id="text-org4e67100">
<p>
Dockerコードの概略。
</p>
</div>
</div>
<div id="outline-container-orgffe5e48" class="outline-3">
<h3 id="orgffe5e48"><a href="#orgffe5e48"><span class="todo TODO">TODO</span> <a href="https://tatsu-zine.com/books/starting-grpc">スターティングgRPC【委託】 - 達人出版会</a></a></h3>
<div class="outline-text-3" id="text-orgffe5e48">
<p>
サーバ側Go, クライアント側Rubyと異なる言語を用いてサンプルアプリケーションを実装する。
</p>
</div>
</div>
<div id="outline-container-org8615e50" class="outline-3">
<h3 id="org8615e50"><a href="#org8615e50"><span class="todo TODO">TODO</span> <a href="https://gihyo.jp/dp/ebook/2019/978-4-297-10728-4">改訂2版 みんなのGo言語 | Gihyo Digital Publishing … 技術評論社の電子書籍</a></a></h3>
<div class="outline-text-3" id="text-org8615e50">
<p>
わかりやすいという入門書。
</p>
</div>
</div>
<div id="outline-container-org8cdb505" class="outline-3">
<h3 id="org8cdb505"><a href="#org8cdb505"><span class="todo TODO">TODO</span> <a href="https://tatsu-zine.com/books/go-web-programming">Goプログラミング実践入門 標準ライブラリでゼロからWebアプリを作る【委託】 - 達人出版会</a></a></h3>
<div class="outline-text-3" id="text-org8cdb505">
<ul class="org-ul">
<li>27, 68, 73, 93, 148</li>
</ul>

<p>
ゼロから実装する。あまりピンとこない。
</p>
</div>

<div id="outline-container-org0216578" class="outline-4">
<h4 id="org0216578"><a href="#org0216578">フレームワークの弊害</a></h4>
<div class="outline-text-4" id="text-org0216578">
<ul class="org-ul">
<li>フレームワークを使えばすぐ構築できる。が、フレームワーク独自の約束事やパターンに従わないといけないことも多い。それがベストプラクティスであると仮定しているが、ベストプラクティスは理解していないとカーゴカルト・プログラミングに陥りどんなときでも無条件で適用してしまう</li>
<li>フレームワークを構築する基盤となっている概念を理解することが重要。正しい理解があれば、ある約束事やパターンが存在する理由がわかるようになる</li>
<li>たとえばクライアント側にクッキーとしてデータを保持し、サーバ側にセッションとして保持するのには理由がある。HTTPがコネクションレスのプロトコルであり、サーバの各回の呼び出しには以前の呼び出しの情報が含まれていないからである</li>
<li>Go言語においてハンドラとは、ServeHttpというメソッドを持ったインターフェースのこと</li>
<li><a href="https://qiita.com/huji0327/items/c85affaf5b9dbf84c11e">【Go】マルチプレクサってなんやねん - Qiita</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc94daa7" class="outline-3">
<h3 id="orgc94daa7"><a href="#orgc94daa7"><span class="todo TODO">TODO</span> Go Design Patterns</a></h3>
</div>
<div id="outline-container-org91af30c" class="outline-3">
<h3 id="org91af30c"><a href="#org91af30c"><span class="todo TODO">TODO</span> Cloud Native Go</a></h3>
</div>
<div id="outline-container-orgd279a35" class="outline-3">
<h3 id="orgd279a35"><a href="#orgd279a35"><span class="todo TODO">TODO</span> Go and Go-Moku The Oriental Board Games</a></h3>
</div>
<div id="outline-container-org60b8d5a" class="outline-3">
<h3 id="org60b8d5a"><a href="#org60b8d5a"><span class="todo TODO">TODO</span> Mastering Go Create Golang production applications using network libraries, concurrency, and advanced Go data structures</a></h3>
</div>
<div id="outline-container-orgdcfa9f4" class="outline-3">
<h3 id="orgdcfa9f4"><a href="#orgdcfa9f4"><span class="todo TODO">TODO</span> RESTful Go APIs Design und Implementierung leichtgewichtiger Hypermedia Services</a></h3>
</div>
<div id="outline-container-orgd9aee9e" class="outline-3">
<h3 id="orgd9aee9e"><a href="#orgd9aee9e"><span class="todo TODO">TODO</span> Hands-On System Programming with Go</a></h3>
</div>
<div id="outline-container-org8562723" class="outline-3">
<h3 id="org8562723"><a href="#org8562723"><span class="todo TODO">TODO</span> Powerful Command-Line Applications in Go</a></h3>
</div>
<div id="outline-container-org5982f5c" class="outline-3">
<h3 id="org5982f5c"><a href="#org5982f5c"><span class="todo TODO">TODO</span> Build an Orchestrator in Go</a></h3>
</div>
<div id="outline-container-org7684aaa" class="outline-3">
<h3 id="org7684aaa"><a href="#org7684aaa"><span class="todo TODO">TODO</span> The Docker Book</a></h3>
</div>
<div id="outline-container-orge678797" class="outline-3">
<h3 id="orge678797"><a href="#orge678797"><span class="todo TODO">TODO</span> <a href="https://github.com/google/go-github">google/go-github: Go library for accessing the GitHub v3 API</a></a></h3>
<div class="outline-text-3" id="text-orge678797">
<p>
GoのGitHubアクセスのためのライブラリ。
</p>

<p>
実際の参考になる使用例。
</p>
<ul class="org-ul">
<li><a href="https://github.com/k1LoW/octocov/blob/main/gh/gh.go">https://github.com/k1LoW/octocov/blob/main/gh/gh.go</a></li>
</ul>
</div>
</div>
<div id="outline-container-org5ec0bdf" class="outline-3">
<h3 id="org5ec0bdf"><a href="#org5ec0bdf"><span class="todo TODO">TODO</span> <a href="https://www.ebiebievidence.com/posts/2020/12/golang-compiler/">Go コンパイラのコードを読んでみよう | ebiebievidence.com</a></a></h3>
<div class="outline-text-3" id="text-org5ec0bdf">
<p>
Goのコンパイラの解説。
</p>
</div>
</div>
<div id="outline-container-org90aa765" class="outline-3">
<h3 id="org90aa765"><a href="#org90aa765"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/ytakaya/articles/ff6321bad0cbea">Goを学ぶときに参照した学習リソースまとめ</a></a></h3>
<div class="outline-text-3" id="text-org90aa765">
<p>
面白くためになる題材の紹介。
</p>
</div>
</div>
<div id="outline-container-org8510440" class="outline-3">
<h3 id="org8510440"><a href="#org8510440"><span class="todo TODO">TODO</span> <a href="https://zenn.dev/hsaki/articles/gospecdictionary#%E3%81%9D%E3%81%AE%E8%A8%98%E8%BF%B0%E3%81%8C%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E4%BD%95%E3%81%8C%E5%AC%89%E3%81%97%E3%81%84%E3%81%AE%E3%81%8B%EF%BC%9F%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%82%92%E6%84%8F%E8%AD%98%E3%81%99%E3%82%8B">Goの言語仕様書精読のススメ &amp; 英語彙集</a></a></h3>
<div class="outline-text-3" id="text-org8510440">
<p>
読み方。より深い理解のやりかた。
</p>

<blockquote>
<p>
GoSpecは言語仕様書であり、全ての記述には意味があるはずです。
</p>

<p>
例えばTypesの章で導入される「全ての型にはunderlying typeがある」という概念は、一見すると「なんでこんなものを導入するんだ？？」と思うかもしれません。
</p>

<p>
(略)
</p>

<p>
しかし、このunderlying typeはassignability(代入可能性)を定義するために不可欠なものです(後述)。
</p>

<p>
このように「この記述はどこで役に立つの？」という意識を持つことで、全体像の理解につながります。
</p>
</blockquote>

<blockquote>
<p>
某書籍に「例示は理解の試金石」という言葉があります。
</p>

<p>
(略)
</p>

<p>
これは本当にそうで、読んだ内容を元に「こういうコードはこの記述を元に確かにこういう挙動をする」という例が作れるかどうかで理解の深さが段違いだという実感があります。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgfcc5c33" class="outline-2">
<h2 id="orgfcc5c33"><a href="#orgfcc5c33">Go言語へのコントリビュート準備</a></h2>
<div class="outline-text-2" id="text-orgfcc5c33">
</div>
<div id="outline-container-orgf505dc4" class="outline-3">
<h3 id="orgf505dc4"><a href="#orgf505dc4"><span class="done DONE">DONE</span> <a href="https://go.dev/doc/contribute">Contribution Guide - The Go Programming Language</a></a></h3>
<div class="outline-text-3" id="text-orgf505dc4">
<p>
Goのコントリビューションガイド。
</p>
</div>
</div>
<div id="outline-container-org6cdd4b0" class="outline-3">
<h3 id="org6cdd4b0"><a href="#org6cdd4b0"><span class="done DONE">DONE</span> <a href="https://www.youtube.com/watch?v=DjZMKKfNVMc">justforfunc #17: contributing to the Go project - YouTube</a></a></h3>
<div class="outline-text-3" id="text-org6cdd4b0">
<p>
Goにコントリビュートするチュートリアル。開発環境構築、Googleの規約へのサイン、変更、レビューまでの流れを全てカバーしている。わかりやすい。
</p>
</div>
</div>
<div id="outline-container-org91d5107" class="outline-3">
<h3 id="org91d5107"><a href="#org91d5107"><span class="done DONE">DONE</span> リポジトリを見てどういう開発の種類があるか把握する</a></h3>
<div class="outline-text-3" id="text-org91d5107">
<ul class="org-ul">
<li>388fbf287c</li>
</ul>

<p>
毎日たくさんのコミットがある。どういったことをやって、より良くしているのだろうか。コードの種類、議論の進め方。ファイルを見てイチから理解していくのは難しいが、差分から少しずつ見ていけば糸口がつかめるのではないか。また、プログラミング言語の場合、ライブラリでも全然違うはずなので調べる。
</p>

<p>
開発参加に必要な段階として、コードというより周辺知識をつければいいように見える。
</p>

<ul class="org-ul">
<li>未使用コード削除</li>
<li>contextオプション追加</li>
<li>オーバーフローを防ぐためuint型へ</li>
<li>画像変換の高速化</li>
<li>特定の条件でvendorモードに入るのを防ぐ</li>
<li>cmd.StdinPipe()を使ってテストのsleepヘルパーを消す</li>
<li>特定のテスト失敗時のデバッグ情報を増やす</li>
<li>メモリ効率の良いコードに置き換える</li>
<li>OSごとに異なる部分の一部を修正する</li>
<li>フレーキーテストを修正する</li>
<li>テストのカバーしてない部分を追加する</li>
<li>エラー時の挙動</li>
<li>意味のない中間変数の削除</li>
<li>エラーコードの修正</li>
<li>エラーコードの共通化</li>
<li>変数名の修正</li>
<li>ドキュメントの修正</li>
<li>Plan9での、ファイル並列アクセス</li>
<li>バージョンによって異なる挙動部分のエラーについて、メッセージにバージョン情報を追加</li>
<li>テストを並列にする</li>
<li>不要になったテストの削除</li>
<li>無限ループになってタイムアウトする問題の修正</li>
<li>便利関数を使う(strings.Cut) 2e054128bf</li>
<li>tarのヘッダーにファイルサイズ制限をつける 0bf7ee9977</li>
</ul>

<p>
こうやって列挙してみると、多くの領域をカバーする必要はないことがわかる。取り組みやすいところや、集中的にやる領域を決めればよさそう。
</p>

<p>
issueを見てみる。これらがうまく解ければ楽なのだが。種類。今の段階でよくわからなくても、議論を見ることは調べる取っ掛かりになりそう。何を理解することがゴールになるのか、ということだ。散漫に読むより、ある問題があることを念頭において、仕組みを知ろうとするほうが頭に入る。解くために必要だからだ。
</p>

<ul class="org-ul">
<li>go fmtのバグ</li>
<li>機能リクエスト</li>
<li>フレーキーテスト</li>
</ul>

<p>
メモ。
</p>
<ul class="org-ul">
<li>経験豊富なプログラマーがどうやって問題解決しているかの生の資料になる。</li>
<li>全体をふんわりではなく、特定のコマンドに絞って知識を深める、問題に取り組むのがよさそう</li>
</ul>
</div>
</div>
<div id="outline-container-orgfa53b77" class="outline-3">
<h3 id="orgfa53b77"><a href="#orgfa53b77"><span class="done DONE">DONE</span> コンパイルする</a></h3>
<div class="outline-text-3" id="text-orgfa53b77">
<p>
開発を開始するには、まずGo自体をコンパイルする必要がある。そうでないと、テストも実行できない。
</p>

<p>
src/all.bash にシェルスクリプトがあり、それでコンパイルできる。実行にはgoが必要。goを使ってgoをコンパイルする。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 33: </span>コンパイルを実行する</label><pre class="src src-shell">$ cd src <span class="org-comment-delimiter"># </span><span class="org-comment">&#12459;&#12524;&#12531;&#12488;&#12487;&#12451;&#12524;&#12463;&#12488;&#12522;&#12364;src&#19979;&#12391;&#12354;&#12427;&#24517;&#35201;&#12364;&#12354;&#12427;</span>
$ ./all.bash
</pre>
</div>
</div>
</div>

<div id="outline-container-org75491d2" class="outline-3">
<h3 id="org75491d2"><a href="#org75491d2"><span class="done DONE">DONE</span> テストを実行する</a></h3>
<div class="outline-text-3" id="text-org75491d2">
<p>
手元でコンパイルしてgo処理系を最新にしてない場合、↓のような状態になる。
</p>

<ul class="org-ul">
<li>テストを実行するとパッケージ関連で失敗する</li>
<li>実行できるテストもあるが、ソースコード(本体、テスト)への変更が全く反映されず、すべて成功する</li>
</ul>

<blockquote>
<p>
$ go test -v
package std/math/big
	arith_amd64.go:10:8: use of internal package internal/cpu not allowed
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org03023fd" class="outline-3">
<h3 id="org03023fd"><a href="#org03023fd"><span class="done DONE">DONE</span> テストがソースコードを反映してない</a></h3>
<div class="outline-text-3" id="text-org03023fd">
<p>
いじってテストを走らせたりビルドしても反映しない。通常であれば構文レベルになるものも無視される。別のソースコードを見ているぽい。本体コードについてはワーキングディレクトリではなく、マシンにインストールしてあるgoを使っている気がするな。テストが反映しないのはよくわからない。
</p>

<ul class="org-ul">
<li>手元ビルドした最新のgoへのパスが通っていないためだった。パスを通すと、テストを失敗させられるように</li>
<li>どうしてテストが反映されないという結果になるのかわからない</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2ea97ea" class="outline-2">
<h2 id="org2ea97ea"><a href="#org2ea97ea">Reference</a></h2>
<div class="outline-text-2" id="text-org2ea97ea">
</div>
<div id="outline-container-orgf1d17d7" class="outline-3">
<h3 id="orgf1d17d7"><a href="#orgf1d17d7"><a href="https://go.dev/talks/2015/simplicity-is-complicated.slide#1">Simplicity is Complicated</a></a></h3>
<div class="outline-text-3" id="text-orgf1d17d7">
<p>
ロブ・パイクによるGoのスライド。
</p>
</div>
</div>
<div id="outline-container-org220ee6d" class="outline-3">
<h3 id="org220ee6d"><a href="#org220ee6d"><a href="https://speakerdeck.com/retervision/go-runtime-scheduler">Go Runtime Scheduler - Speaker Deck</a></a></h3>
<div class="outline-text-3" id="text-org220ee6d">
<p>
Goのスケジューラを実装する。
</p>
</div>
</div>
<div id="outline-container-orgdf83e99" class="outline-3">
<h3 id="orgdf83e99"><a href="#orgdf83e99"><a href="https://zenn.dev/tmk616/articles/383fc3fbb0ec4b">【Go】go getは不要？go installとは？</a></a></h3>
<div class="outline-text-3" id="text-orgdf83e99">
<p>
わかりやすい説明。
</p>

<ul class="org-ul">
<li>go get はgo.modに変更を加える</li>
<li>go install はバイナリをインストールする</li>
</ul>
</div>
</div>

<div id="outline-container-org1e89215" class="outline-3">
<h3 id="org1e89215"><a href="#org1e89215"><a href="https://qiita.com/sueken/items/30b6da9259e94c1ede71">golangのio.Readerは使い回しできない - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org1e89215">
<p>
知らなかったな。
</p>
</div>
</div>
<div id="outline-container-orgd56dbfe" class="outline-3">
<h3 id="orgd56dbfe"><a href="#orgd56dbfe"><a href="https://engineering.mercari.com/blog/entry/2018-08-08-080000/">Go Fridayこぼれ話：非公開（unexported）な機能を使ったテスト #golang | メルカリエンジニアリング</a></a></h3>
<div class="outline-text-3" id="text-orgd56dbfe">
<ul class="org-ul">
<li>プロダクトコードとテストは別パッケージしたほうがいい
<ul class="org-ul">
<li>はじめてのユーザになり、インターフェースや公開の状態を考えられるから</li>
</ul></li>
<li>非公開な関数や変数をテストしたときは、テスト用にエクスポートすればいい</li>
</ul>
</div>
</div>
<div id="outline-container-orgc0b1fa2" class="outline-3">
<h3 id="orgc0b1fa2"><a href="#orgc0b1fa2"><a href="https://go.dev/blog/survey2022-q2-results">Go Developer Survey 2022 Q2 Results - The Go Programming Language</a></a></h3>
<div class="outline-text-3" id="text-orgc0b1fa2">
<p>
サーベイ結果。
</p>
</div>
</div>
<div id="outline-container-org602e649" class="outline-3">
<h3 id="org602e649"><a href="#org602e649"><a href="https://go.googlesource.com/proposal/+/master/design">design - proposal - Git at Google</a></a></h3>
<div class="outline-text-3" id="text-org602e649">
<p>
proposal一覧。
</p>
</div>
</div>
<div id="outline-container-orgb25eb71" class="outline-3">
<h3 id="orgb25eb71"><a href="#orgb25eb71"><a href="https://github.com/golang/proposal#proposal-review">golang/proposal: Go Project Design Documents</a></a></h3>
<div class="outline-text-3" id="text-orgb25eb71">
<p>
Go言語のproposal。
</p>
</div>
</div>
<div id="outline-container-org77076e0" class="outline-3">
<h3 id="org77076e0"><a href="#org77076e0"><a href="https://zenn.dev/tenntenn/books/d168faebb1a739/viewer/22e4d4">はじめに｜逆引き Goによる静的解析</a></a></h3>
<div class="outline-text-3" id="text-org77076e0">
<p>
Goで静的解析をする入門本。
</p>
</div>
</div>
<div id="outline-container-org44fed55" class="outline-3">
<h3 id="org44fed55"><a href="#org44fed55"><a href="https://yuroyoro.github.io/goast-viewer/">yuroyoro.github.io/goast-viewer/</a></a></h3>
<div class="outline-text-3" id="text-org44fed55">
<p>
GoのASTビューワー。
</p>
</div>
</div>
<div id="outline-container-org623874d" class="outline-3">
<h3 id="org623874d"><a href="#org623874d"><a href="https://divan.dev/posts/visual_programming_go/">Rethinking Visual Programming with Go · divan&rsquo;s blog</a></a></h3>
<div class="outline-text-3" id="text-org623874d">
<p>
ソースコードの呼び出し関係をグラフィカルに表示する。
</p>
</div>
</div>
<div id="outline-container-org28657a4" class="outline-3">
<h3 id="org28657a4"><a href="#org28657a4"><a href="https://www.onlinetool.io/xmltogo/">XML to Go</a></a></h3>
<div class="outline-text-3" id="text-org28657a4">
<p>
XMLからGoの構造体に変換するツール。
</p>
</div>
</div>
<div id="outline-container-orga8398c0" class="outline-3">
<h3 id="orga8398c0"><a href="#orga8398c0"><a href="https://www.campoy.cat/">Francesc Campoy Flores</a></a></h3>
<div class="outline-text-3" id="text-orga8398c0">
<p>
Goプログラマー、Youtuber。チャンネルは更新止まってるぽい。
</p>
</div>
</div>
<div id="outline-container-orge65b298" class="outline-3">
<h3 id="orge65b298"><a href="#orge65b298"><a href="https://go.dev/blog/">The Go Blog - The Go Programming Language</a></a></h3>
<div class="outline-text-3" id="text-orge65b298">
<p>
Goの公式ブログ。
</p>
</div>
</div>
<div id="outline-container-org0037b2b" class="outline-3">
<h3 id="org0037b2b"><a href="#org0037b2b"><a href="https://go.dev/doc/">Documentation - The Go Programming Language</a></a></h3>
<div class="outline-text-3" id="text-org0037b2b">
<p>
公式ドキュメント。
</p>
</div>
</div>
<div id="outline-container-orga8063d0" class="outline-3">
<h3 id="orga8063d0"><a href="#orga8063d0"><a href="https://github.com/golang/go/issues/54968">debug/buildinfo: timeout in Read · Issue #54968 · golang/go</a></a></h3>
<div class="outline-text-3" id="text-orga8063d0">
<p>
参考になるissue。バグ報告のうまいやり方。playgroundを使う。タイムアウトになるバグの原因。
</p>
</div>
</div>
<div id="outline-container-orge59de1f" class="outline-3">
<h3 id="orge59de1f"><a href="#orge59de1f"><a href="https://unknownplace.org/archives/golang-editing-with-emacs/">EmacsでのGo言語編集環境 - unknownplace.org</a></a></h3>
<div class="outline-text-3" id="text-orge59de1f">
<p>
<a href="20210508234743-emacs.html#ID-1ad8c3d5-97ba-4905-be11-e6f2626127ad">Emacs</a>のgo-modeでのフォーマット、定義ジャンプ、便利なさまざまな機能。
</p>

<ul class="org-ul">
<li>C-c C-a でimportを追加できる</li>
</ul>
</div>
</div>
<div id="outline-container-org69d7b7a" class="outline-3">
<h3 id="org69d7b7a"><a href="#org69d7b7a"><a href="https://zenn.dev/hsaki/books/golang-concurrency/viewer/goelement">ゴールーチンとチャネル｜Goでの並行処理を徹底解剖！</a></a></h3>
<div class="outline-text-3" id="text-org69d7b7a">
<p>
Goルーチンの解説。
</p>
</div>
</div>
<div id="outline-container-orgea9f702" class="outline-3">
<h3 id="orgea9f702"><a href="#orgea9f702"><a href="https://qiita.com/Yaruki00/items/7edc04720a24e71abfa2">Goでflagを使ってコマンドライン引数を扱う - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orgea9f702">
<p>
手軽に使える。
</p>
</div>
</div>
<div id="outline-container-org4cfcbb3" class="outline-3">
<h3 id="org4cfcbb3"><a href="#org4cfcbb3"><a href="https://ebiten.org/">Ebitengine - A dead simple 2D game library for Go</a></a></h3>
<div class="outline-text-3" id="text-org4cfcbb3">
<p>
Goのゲームライブラリ。
</p>
</div>
</div>
<div id="outline-container-org8b2ba66" class="outline-3">
<h3 id="org8b2ba66"><a href="#org8b2ba66"><a href="https://www.techscore.com/tech/Go/Lang/Basic15/">15. スライスのハマりどころ | TECHSCORE(テックスコア)</a></a></h3>
<div class="outline-text-3" id="text-org8b2ba66">
<p>
スライスの詳しい解説。
</p>

<p>
キャパシティは参照するメモリ配列の範囲。
</p>
</div>
</div>
</div>
<div id="outline-container-org918e1ce" class="outline-2">
<h2 id="org918e1ce"><a href="#org918e1ce">Archives</a></h2>
<div class="outline-text-2" id="text-org918e1ce">
</div>
<div id="outline-container-orgf9fce38" class="outline-3">
<h3 id="orgf9fce38"><a href="#orgf9fce38"><span class="done DONE">DONE</span> <a href="https://tatsu-zine.com/books/go-five-recipes">Go言語を楽しむ5つのレシピ コタツと蜜柑とゴーファーとわたし【委託】 - 達人出版会</a></a></h3>
<div class="outline-text-3" id="text-orgf9fce38">
<p>
画像処理やWebAssemblyなど。
</p>

<p>
ざっと読んだだけ。コードの中は読んでないので必要になったら確認する。
</p>
</div>
</div>
<div id="outline-container-org1ff8341" class="outline-3">
<h3 id="org1ff8341"><a href="#org1ff8341"><span class="done DONE">DONE</span> <a href="https://go-tour-jp.appspot.com/list">A Tour of Go</a></a></h3>
<div class="outline-text-3" id="text-org1ff8341">
<p>
最初のチュートリアル。
</p>
</div>
</div>
<div id="outline-container-org964df3d" class="outline-3">
<h3 id="org964df3d"><a href="#org964df3d"><span class="done DONE">DONE</span> <a href="https://dev.classmethod.jp/articles/list-containers-by-docker-sdk-go/">Docker Engine SDKでコンテナ一覧を取得する | DevelopersIO</a></a></h3>
<div class="outline-text-3" id="text-org964df3d">
<p>
小さなコマンドラインツールの例。
</p>
</div>
</div>
<div id="outline-container-orgf4e61e7" class="outline-3">
<h3 id="orgf4e61e7"><a href="#orgf4e61e7"><span class="done DONE">DONE</span> <a href="https://haibara-works.hatenablog.com/entry/2020/12/05/235227">GoでDockerを操る [Docker Engine SDK] - はいばらのブログ</a></a></h3>
<div class="outline-text-3" id="text-orgf4e61e7">
<p>
goとdockerの解説。
</p>
</div>
</div>
<div id="outline-container-org34d8139" class="outline-3">
<h3 id="org34d8139"><a href="#org34d8139"><span class="done DONE">DONE</span> <a href="https://zenn.dev/kenny/articles/b9dd668bf09efe">Goで作成したAPIをDockerで動かす</a></a></h3>
<div class="outline-text-3" id="text-org34d8139">
<p>
APIのサンプルコード。
</p>
</div>
</div>
<div id="outline-container-org740b7ab" class="outline-3">
<h3 id="org740b7ab"><a href="#org740b7ab"><span class="done DONE">DONE</span> <a href="https://www.amazon.co.jp/%E6%94%B9%E8%A8%822%E7%89%88-%E5%9F%BA%E7%A4%8E%E3%81%8B%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8B-Go%E8%A8%80%E8%AA%9E-%E5%8F%A4%E5%B7%9D%E6%98%87-ebook/dp/B06WP6S2QT/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;crid=1GPYX46MK3OK&amp;keywords=%E5%9F%BA%E7%A4%8E%E3%81%8B%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8B+go%E8%A8%80%E8%AA%9E&amp;qid=1663028634&amp;sprefix=%E5%9F%BA%E7%A4%8E%E3%81%8B%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8Bgo%E8%A8%80%E8%AA%9E%2Caps%2C2056&amp;sr=8-1">改訂2版 基礎からわかる Go言語 | 古川昇 | 工学 | Kindleストア | Amazon</a></a></h3>
<div class="outline-text-3" id="text-org740b7ab">
<ul class="org-ul">
<li>117, 133, 141, 155</li>
</ul>

<p>
Go言語の入門本。
</p>

<ul class="org-ul">
<li>Goでは、最初の文字が大文字で始まる名前は、外部のパッケージから参照できるエクスポートされた名前。例えばPiはmathパッケージでエクスポートされる</li>
</ul>

<div class="org-src-container">
<pre class="src src-go">package main
import (
        "fmt"
        "math"
)
func main() {
        fmt.println(Math.pi)
}
</pre>
</div>

<ul class="org-ul">
<li>変数が存在するメモリ上の位置を「アドレス」といい、そのアドレスを格納可能な変数を「ポインタ」という</li>
<li><code>int</code> 型変数のアドレスを格納できるポインタの型は <code>*int</code> 型というように、アスタリスクをつける</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span>ポインタ</label><pre class="src src-go">var ptr *int
var i int = 12345
ptr = &amp;i

fmt.Println("iのアドレス:", &amp;i)
fmt.Println("ptrの値(変数iのアドレス):", ptr)

fmt.Println("iの値:", i)
fmt.Println("ポインタ経由のiの値:", *ptr)

*ptr = 999
fmt.Println("ポインタ経由で変更したiの値:", i)
</pre>
</div>

<div class="results" id="orge658aa5">
<p>
iのアドレス: 0xc0000b6010
ptrの値(変数iのアドレス): 0xc0000b6010
iの値: 12345
ポインタ経由のiの値: 12345
ポインタ経由で変更したiの値: 999
</p>

</div>

<div class="org-src-container">
<pre class="src src-go">func main() {
        a, b := 1, 1

        double(a, &amp;b)
        fmt.Println("値渡し:", a)
        fmt.Println("ポインタ渡し:", b)
}

func double(x int, y *int) {
        x = x * 2
        *y = *y * 2
}
</pre>
</div>

<div class="results" id="orgbd722d8">
<p>
値渡し: 1
ポインタ渡し: 2
</p>

</div>

<p>
関数リテラル。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 35: </span>関数リテラル = 無名関数</label><pre class="src src-go">func main() {
        val := 123

        // 関数リテラルの記述と呼び出しを同時に行う
        func(i int) {
                // 関数リテラル外の変数valにアクセス可能
                fmt.Println(i * val)
        }(10)

        // 関数リテラルを変数に代入
        f := func(s string) {
                fmt.Println(s)
        }

        f("hoge")
}
</pre>
</div>

<div class="results" id="org29e2219">
<p>
1230
hoge
</p>

</div>

<p>
関数型。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 36: </span>代入して呼び出す</label><pre class="src src-go">func main() {
        // 関数型の変数宣言
        var f func(int, int) int

        // 関数リテラルの値を代入
        f = func(a int, b int) int {
                return a + b
        }

        // 関数型の変数経由で関数を呼び出す
        fmt.Println(f(1, 2))


        // 関数型の変数に値を代入
        f = multiply

        // 関数型の変数経由で関数を呼び出す
        fmt.Println(f(1, 2))
}

func multiply(x int, y int) int {
        return x * y
}
</pre>
</div>

<div class="results" id="org3c846a8">
<p>
3
2
</p>

</div>

<p>
メソッドの宣言。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 37: </span>型に実装する</label><pre class="src src-go">type myType int

// myType型をレシーバに持つ関数、すなわちmyType型のメソッドを宣言。レシーバは一番最初に書く
func (value myType) println() {
        fmt.Println(value)
}

func main() {
        // myType型の変数を宣言する
        var z myType = 1234

        // myType型のメソッドを呼び出す
        z.println()
}
</pre>
</div>

<div class="results" id="org34d8eb5">
<p>
1234
</p>

</div>

<p>
メソッドのレシーバをポインタにする。
</p>

<div class="org-src-container">
<pre class="src src-go">// int型
type myType int

func (value myType) setByValue(newValue myType) {
        // ここで値を代入しても無意味。Valueはコピーされるので
        value = newValue
}

func(value *myType) setByPointer(newValue myType) {
        // 代入した値が反映される
        *value = newValue
}
func main() {
        var x myType = 0

        // レシーバは値。値は変更できない
        x.setByValue(1)
        fmt.Println("値: 0 -&gt;", x)

        // レシーバはポインタ。値は変更できる
        x.setByPointer(2)
        fmt.Println("ポインタ: 0 -&gt;", x)
}

</pre>
</div>

<div class="results" id="org5ab4bc4">
<p>
値: 0 -&gt; 0
ポインタ: 0 -&gt; 2
</p>

</div>

<p>
構造体型に名前をつける。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 38: </span>構造体にMyDataという新しい型名を与える</label><pre class="src src-go">type MyData struct {
      s string
      b byte
}
</pre>
</div>

<div class="results" id="org6c0a44a">

</div>

<ul class="org-ul">
<li>メソッドの宣言には値レシーバ、ポインタレシーバの2つがある。混在させるべきではない
<ul class="org-ul">
<li>変数レシーバではメソッドの操作は元の変数のコピーを操作する</li>
<li>ポインタレシーバでは、ポインタを使うので元の変数を変更できる</li>
</ul></li>
<li>ポインタレシーバを使う2つの理由
<ul class="org-ul">
<li>メソッドがレシーバが指す先の変数を変更するため</li>
<li>メソッドの呼び出しごとに変数のコピーを避けるため</li>
</ul></li>
</ul>

<p>
匿名フィールド。匿名フィールドが持つフィールドとメソッドが、埋め込み先の構造体型にも実装されているかのように扱われる。Go言語には型の実装はないが、構造体に他の型を埋め込むことで継承似たようなことを実現できる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 39: </span>埋め込み</label><pre class="src src-go">// 埋め込まれる型の構造体
type embedded struct {
        i int
}

// embedded型のメソッド
func (x embedded) doSomething() {
        fmt.Println("test.doSomething()")
}

// 埋め込み先の構造体
type test struct {
        embedded // embedded型の埋め込み
}

func main() {
        var x test

        // embedded型に実装されているメソッドに、test型の値でアクセス
        x.doSomething()

        // embedded型のフィールドに、test型の値でアクセス
        fmt.Println(x.i)
}
</pre>
</div>

<div class="results" id="orgfc5ba54">
<p>
test.doSomething()
0
</p>

</div>

<p>
構造体の初期化。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 40: </span>2つの方法がある</label><pre class="src src-go">type Person struct {
        name string
        age int
}

func main() {
        // 構造体リテラルを使用せず、フィールドを個別に初期化
        var p1 Person
        p1.name = "Jhon"
        p1.age = 23

        // 構造体リテラルで初期化
        p2 := Person{age: 31, name: "Tom"}
        p3 := Person{"Jane", 42}
        p4 := &amp;Person{"Mike", 36}
        fmt.Println(p1, p2, p3, p4)
}
</pre>
</div>

<div class="results" id="orgf9f3f67">
<p>
{Jhon 23} {Tom 31} {Jane 42} &amp;{Mike 36}
</p>

</div>

<p>
埋め込みを行った構造体を構造体リテラルで初期化する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 41: </span>埋め込み</label><pre class="src src-go">type Person struct {
        name string
        age int
}

type Employee struct {
        id int
        Person // 埋め込み
}

func main() {
        e := Employee{1, Person{"jack", 28}}
        fmt.Println(e)
}
</pre>
</div>

<div class="results" id="org07fec46">
<p>
{1 {jack 28}}
</p>

</div>

<p>
Go言語のインターフェースの役割は「振る舞い」を規定すること。Go言語のインターフェースは「インターフェース」と「それを実装した型」との関係性を明示的に記述する必要がない。インターフェースに定義されている関数をメソッドとして実装している型は、自動的にそのインターフェースを実装していることになる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 42: </span>インターフェースと型は自動で関連付けられる</label><pre class="src src-go">type Calculator interface {
        // 関数の定義
        Calculate(a int, b int) int
}

type Add struct {
        // フィールドは持たない
}

// Add型にCalculatorインターフェースのCalculator関数を実装
func (x Add) Calculate(a int, b int) int {
        return a + b
}

type Sub struct { }

func (x Sub) Calculate(a int, b int) int {
        return a - b
}

func main() {
        var add Add
        var sub Sub

        var cal Calculator // interface

        cal = add // interfaceを満たす関数を持っているので、自動的にインターフェースを実装していることになり、代入できる
        fmt.Println("和:", cal.Calculate(1, 2))

        cal = sub
        fmt.Println("差:", cal.Calculate(1, 2))
}
</pre>
</div>

<div class="results" id="org4a190e9">
<p>
和: 3
差: -1
</p>

</div>

<p>
空インターフェース。関数を持たない空のインターフェース。定義関数をすべて実装している型はインターフェースを実装したことになるので、すべての型は空インターフェースを実装していることになる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 43: </span>空インターフェース。どんな値でも代入できる。_ は未使用エラーを防ぐため</label><pre class="src src-go">var empty interface {}

empty = "abc"
empty = 12345
empty = 3.14

_ = empty
</pre>
</div>

<div class="results" id="org5c37bea">

</div>

<p>
関数を1つしか持たないインターフェースの場合、そのインターフェース名は「関数名+er」とするのが慣わし。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 44: </span>関数名がReadであれば、インターフェース名はReader</label><pre class="src src-go">type Reader interface {
        Read(p []byte) (n int, err error)
}
</pre>
</div>

<p>
型アサーションはインターフェース型の値を他の型へ変換するとき、または変換できるか確認するときに使う。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 45: </span>型アサーション</label><pre class="src src-go">func main() {
        // 空インターフェースにstring型の値を格納
        var i interface{} = "test"
        // 型アサーションを使いstring型へ
        var s string = i.(string) // 型アサーション
        fmt.Printf("i: %T\n", i)
        fmt.Printf("s: %T\n", s)
}
</pre>
</div>

<div class="results" id="org44f6db2">
<p>
i: string
s: string
</p>

</div>

<p>
型アサーション失敗時にランタイムパニックを発生させない。チェックに使う。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 46: </span>型アサーションから2番目の値を受け取るときは、変換できなくてもランタイムパニックは起きない</label><pre class="src src-go">func main() {
        // 空インターフェースにstring型の値を格納
        var i interface{} = "test"

        // 型アサーションに成功する例
        s1, ok := i.(string)
        fmt.Println(s1, ok)

        // 型アサーションに失敗する例
        // string型はdummyメソッドを持たないので変換できない
        s2, ok := i.(interface {
                dummy()
        })
        fmt.Println(s2, ok)
}
</pre>
</div>

<div class="results" id="org1082921">
<p>
test true
&lt;nil&gt; false
</p>

</div>

<p>
型switch文。通常のswitch文とは異なる。式switchが値によって分岐するのに対し、型switch文は値が持つ型によって分岐する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 47: </span>型switch</label><pre class="src src-go">func main() {
        showType(nil)
        showType(12345)
        showType("abcdef")
        showType(3.14)
}

func showType(x interface{}) {
        switch x.(type) {

        case nil:
                fmt.Println("nil")

        case int, int32, int64:
                fmt.Println("整数")

        case string:
                fmt.Println("文字列")

        default:
                fmt.Println("不明")
        }
}
</pre>
</div>

<div class="results" id="org8e93a98">
<p>
nil
整数
文字列
不明
</p>

</div>

<p>
配列アクセス。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 48: </span>配列にアクセスする</label><pre class="src src-go">func main() {
        var date [7]string

        date[0] = "日曜日"
        date[1] = "月曜日"
        date[2] = "火曜日"
        date[3] = "水曜日"
        date[4] = "木曜日"
        date[5] = "金曜日"
        date[6] = "土曜日"

        // indexバージョン
        for i := 0; i &lt; len(date); i++ {
                fmt.Print(date[i], " ")
        }

        // rangeバージョン
        // 改行
        fmt.Println()

        for _, value := range date {
                fmt.Print(value, " ")
        }

        fmt.Println()
}
</pre>
</div>

<div class="results" id="org83462a4">
<p>
日曜日 月曜日 火曜日 水曜日 木曜日 金曜日 土曜日
日曜日 月曜日 火曜日 水曜日 木曜日 金曜日 土曜日
</p>

</div>

<ul class="org-ul">
<li>スライス → 可変長</li>
<li>配列 → 非可変長</li>
</ul>

<p>
スライス式。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 49: </span>スライスにアクセスする</label><pre class="src src-go">func main() {
        // 配列を宣言
        x := [5]string{"a", "b", "c", "d", "e"}
        // スライス型の変数を宣言
        var s1 []string

        // 配列全体をスライス
        s1 = x[:]
        fmt.Println(s1)

        // インデックス1~3までをスライス
        s2 := x[1:4]
        fmt.Println(s2)

        // インデックス3~をスライス
        s3 := x[3:]
        fmt.Println(s3)

        // インデックス1~3をスライス
        s4 := x[:4]
        fmt.Println(s4)
}
</pre>
</div>

<div class="results" id="orgb02b571">
<p>
[a b c d e]
[b c d]
[d e]
[a b c d]
</p>

</div>

<p>
スライスは「参照型」の1つ。Go言語にはスライス、マップ、チャネルという3つの参照型がある。データの実体を持たず、データへの参照情報しか持たない。
</p>

<p>
スライスを可変長パラメータに直接受け渡す。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 50: </span>スライス&#x2026;で展開して渡す</label><pre class="src src-go">func main() {
        s := []string{"a", "b", "c"}

        // 以下2つの結果は同じ
        test(s...)
        test("a", "b", "c")
}
func test(s ...string) {
        fmt.Println(len(s), s)
}
</pre>
</div>

<div class="results" id="orgd8127be">
<p>
3 [a b c]
3 [a b c]
</p>

</div>

<p>
エラーハンドリング。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 51: </span>存在しないファイルを参照して失敗させて検証する</label><pre class="src src-go">func main() {
        file, err := os.Open("test.txt")

        if err != nil {
                fmt.Println(err.Error())
                // os.Exit(1)
        }

        file.Close()
        fmt.Println("finish")
}
</pre>
</div>

<div class="results" id="orgfc953f1">
<p>
open test.txt: no such file or directory
finish
</p>

</div>

<p>
独自のエラー処理。
</p>

<div class="org-src-container">
<pre class="src src-go">        type MyError struct {
                message string
        }

        func (err MyError) Error() string {
                return err.message
        }

      func main() {
          val, err := hex2int("1")
          fmt.Println(val, err)

          val, err = hex2int("00000f")
          fmt.Println(val, err)

          val, err = hex2int("abcd")
          fmt.Println(val, err)

          val, err = hex2int("z")
          fmt.Println(val, err)
    }

// 16進数文字列をint型に変換する
  func hex2int(hex string) (val int, err error) {
        // 1文字づつ取り出す
      for _, r := range hex {
            val *= 16
            switch {
                  case '0' &lt;= r &amp;&amp; r &lt;= '9':
                  val += int(r - '0')
                  case 'a' &lt;= r &amp;&amp; r &lt;= 'f':
                  val += int(r-'a') + 10
                  default:
                  return 0, MyError{"不正な文字列です。" + string(r)}
            }
      }

      // 戻り値errには初期値であるnilが返る
      return
}

</pre>
</div>

<div class="results" id="org2bb9710">
<p>
1 &lt;nil&gt;
15 &lt;nil&gt;
43981 &lt;nil&gt;
0 不正な文字列です。z
</p>

</div>

<p>
処理終了。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 52: </span>panic関数</label><pre class="src src-go">func main() {
        f1()
}

func f1() {
        panic("パニック発生 ")
}
</pre>
</div>

<div class="results" id="org53f467a">

</div>

<p>
チャネルはGoプログラムの中の通信機構で、ゴルーチン間における通信、同期、値の同期に使用する。
</p>

<div class="org-src-container">
<pre class="src src-go">func main() {
        c := make(chan int, 10)
        c &lt;- 0

        fmt.Println("cap:", cap(c))
        fmt.Println("len:", len(c))
}
</pre>
</div>

<div class="results" id="orgfc781c1">
<p>
cap: 10
len: 1
</p>

</div>

<p>
selectは複数のチャネルに対して同時に送受信待ちを行うときに使用する。
</p>
</div>
</div>
<div id="outline-container-org2175526" class="outline-3">
<h3 id="org2175526"><a href="#org2175526"><span class="done DONE">DONE</span> <a href="https://future-architect.github.io/articles/20210427b/">GoでDockerのAPIを叩いてみる | フューチャー技術ブログ</a></a></h3>
<div class="outline-text-3" id="text-org2175526">
<p>
goとdocker。
</p>
</div>
</div>
<div id="outline-container-org850c84b" class="outline-3">
<h3 id="org850c84b"><a href="#org850c84b"><span class="done DONE">DONE</span> <a href="https://blog.zaim.co.jp/n/nc05117f6dffd">Go でコマンドラインツールを作るときに便利なパッケージ｜@hira</a></a></h3>
<div class="outline-text-3" id="text-org850c84b">
<p>
環境変数、カラー、インジケータ。
</p>
</div>
</div>
<div id="outline-container-org4944f5a" class="outline-3">
<h3 id="org4944f5a"><a href="#org4944f5a"><span class="done DONE">DONE</span> cloneツール作成</a></h3>
<div class="outline-text-3" id="text-org4944f5a">
<p>
clonerのgoバージョンを作成する。
</p>
</div>
</div>
<div id="outline-container-orge38a247" class="outline-3">
<h3 id="orge38a247"><a href="#orge38a247"><span class="done DONE">DONE</span> gcloneをリファクタする</a></h3>
<div class="outline-text-3" id="text-orge38a247">
<p>
goclocを読んでいると、gcloneのひどい書き方が目につく。型、構造体の使い方、ファイルやモジュール分割。一通り完了。非常に勉強になった。
</p>
</div>
</div>
<div id="outline-container-org10bbb6b" class="outline-3">
<h3 id="org10bbb6b"><a href="#org10bbb6b"><span class="done DONE">DONE</span> <a href="https://zenn.dev/hsaki/books/golang-io-package">Goから学ぶI/O</a></a></h3>
<div class="outline-text-3" id="text-org10bbb6b">
<p>
GoのIOの解説。
</p>

<blockquote>
<p>
os.File型のReadメソッドは以下のような実装となっています。
</p>

<ol class="org-ol">
<li>os.file型のReadメソッドを呼ぶ</li>
<li>1の中でos.file型のreadメソッドを呼ぶ</li>
<li>2の中でpoll.FD型のReadメソッドを呼ぶ</li>
<li>3の中でsyscall.Readメソッドを呼ぶ</li>
<li>OSカーネルのシステムコールで読み込み処理</li>
</ol>
</blockquote>

<ul class="org-ul">
<li><a href="20220113160623-network.html#ID-c5102c82-3146-4710-a826-85a802997929">network</a>もI/Oと捉えられる。コネクションからデータを読み取る・書き込むといえるから</li>
<li><a href="20220108110637-linux.html#ID-7a81eb7c-8e2b-400a-b01a-8fa597ea527a">Linux</a>の設計思想として&ldquo;everything-is-a-file philosophy&rdquo;というものがある。キーボードからの入力も、プリンターへの出力も、ハードディスクやネットワークからのI/Oもありとあらゆるものをすべて「OSのファイルシステムにあるファイルへのI/Oとして捉える」という思想。ネットワークからのデータ読み取り・書き込みも、OS内部的には通常のファイルI/Oと変わらない。そのため、ネットワークコネクションに対しても、通常ファイルと同様にfdが与えられる</li>
<li>ファイル読み込みでもネットワークコネクションでも、システムコールsocket()を呼んで、fdを取得し、fdを内部フィールドに含んだ型を生成するところは共通</li>
<li>リスナーからコネクションを得る = リスナーからfdを取り出して、それをTCPConnにラップする</li>
</ul>
</div>
</div>
<div id="outline-container-org7e588be" class="outline-3">
<h3 id="org7e588be"><a href="#org7e588be"><span class="done DONE">DONE</span> gclone拡張</a></h3>
<div class="outline-text-3" id="text-org7e588be">
<p>
ファイルサイズの増分、各所要時間を表示する。
</p>

<p>
ダウンロードしているとき先にリポジトリ名を表示して、あとから結果に応じて記号をつける。
</p>

<div class="org-src-container">
<pre class="src src-shell">github@gclone... &#10004; (10s)
github@go............ &#10007; (0.6s)
...
40.4s
10.1G
</pre>
</div>

<p>
インラインに表示するのがむずかしい。spinnerとコンフリクトしてるのか。
</p>
</div>
</div>
<div id="outline-container-orgb259dca" class="outline-3">
<h3 id="orgb259dca"><a href="#orgb259dca"><span class="done DONE">DONE</span> GitHub APIで統計を取る</a></h3>
<div class="outline-text-3" id="text-orgb259dca">
<p>
アイデア。
</p>

<ul class="org-ul">
<li>言語別のリポジトリ数、行数、コミット数</li>
<li>シールド
<ul class="org-ul">
<li>定期的にGitHub Actionsでビルドすることで、数値を画像に反映させる</li>
</ul></li>
<li>データストア用リポジトリという考え方を深める(octcovやupptime的な)
<ul class="org-ul">
<li>汎用的なデータストアとして用いる</li>
<li>別リポジトリから簡単に扱えるworkflowを作成する</li>
<li>データストアリポジトリのURLと、キーによって、保存する</li>
<li>データを元に画像なり生成して、時系列を見られるようにする</li>
</ul></li>
<li>リポジトリ一覧を作る。コミット数、言語情報を一覧する</li>
<li>データストアに保存、加工しやすい形にする</li>
<li>画像/jsonで出力する</li>
<li>他サイトに貼れるようにする</li>
</ul>

<pre class="example">
総コミット: 5000

| 名前     | 概要           | 言語       |
|----------+----------------+------------|
| .emacs.d | emacs dotfiles | Emacs Lisp |
| dotfiles | system config  | Shell      |
| gclone   | git clone tool | Go         |

| 言語         | リポジトリ数 | コミット数 |
|------------+--------------+------------|
| Go         |            4 |        100 |
| Ruby       |            5 |        200 |
| Emacs Lisp |            2 |        100 |
</pre>

<ul class="org-ul">
<li>汎用的なデータストアリポジトリ(配信用)。ツールを実行して更新する</li>
<li>CLIツール
<ul class="org-ul">
<li>情報取得</li>
<li>json出力</li>
<li>画像出力</li>
<li>README.md出力</li>
<li>コミット機能</li>
</ul></li>
<li>フロントエンド</li>
</ul>
</div>

<div id="outline-container-org0336fbe" class="outline-4">
<h4 id="org0336fbe"><a href="#org0336fbe">作業ログ</a></h4>
<div class="outline-text-4" id="text-org0336fbe">
<p>
コミット数を取るのが難しい。<a href="20211030122204-graphql.html#ID-b4f456cf-d250-4877-ac4c-4b03144392f0">GraphQL</a>で取るようにした。
</p>
</div>
</div>
</div>
<div id="outline-container-orgd7dd25d" class="outline-3">
<h3 id="orgd7dd25d"><a href="#orgd7dd25d"><span class="done DONE">DONE</span> 丸画像を生成する</a></h3>
<div class="outline-text-3" id="text-orgd7dd25d">
<p>
言語別の色の丸画像を生成するパッケージ。
</p>
</div>
</div>
<div id="outline-container-org05a495d" class="outline-3">
<h3 id="org05a495d"><a href="#org05a495d"><span class="done DONE">DONE</span> act出力の順番固定</a></h3>
<div class="outline-text-3" id="text-org05a495d">
<ol class="org-ol">
<li>keyだけを別のスライスにして、ソートする。</li>
<li>keyをイテレートして、mapの中身を取り出す</li>
</ol>
</div>
</div>
<div id="outline-container-orgc6dfe2c" class="outline-3">
<h3 id="orgc6dfe2c"><a href="#orgc6dfe2c"><span class="done DONE">DONE</span> バナー生成</a></h3>
<div class="outline-text-3" id="text-orgc6dfe2c">
<p>
ほかの形も追加する。
</p>
</div>
</div>
<div id="outline-container-org3ae6169" class="outline-3">
<h3 id="org3ae6169"><a href="#org3ae6169"><span class="done DONE">DONE</span> 誤字修正PRを送る</a></h3>
<div class="outline-text-3" id="text-org3ae6169">
<ul class="org-ul">
<li><a href="https://github.com/golang/go">golang/go: The Go programming language</a></li>

<li>TestStdErrorHander</li>
<li>hexdecimal</li>
</ul>
</div>
</div>
<div id="outline-container-orgae4ffe0" class="outline-3">
<h3 id="orgae4ffe0"><a href="#orgae4ffe0"><span class="done DONE">DONE</span> <a href="https://www.oreilly.co.jp/books/9784873118222/">O&rsquo;Reilly Japan - Go言語でつくるインタプリタ</a></a></h3>
<div class="outline-text-3" id="text-orgae4ffe0">
<ul class="org-ul">
<li>31, 42, 45, 52, 75, 86, 105, 115, 162, 184, 238, 252, 297</li>
</ul>

<p>
インタプリタを実装する。
</p>

<ul class="org-ul">
<li>字句解析フェーズが文字列をトークン列に変換</li>
<li>構文解析フェーズがトークン列をASTに変換</li>
<li>マクロ展開フェーズがASTを受け取り、修正して、返却</li>
<li>評価</li>
</ul>

<p>
一通りやったが、あまり腑に落ちてない。部分的なコードの多くは読んで理解できたが、自分で別のことに利用したり、拡張は全くできそうにない。
</p>
</div>
</div>
<div id="outline-container-orgb316481" class="outline-3">
<h3 id="orgb316481"><a href="#orgb316481"><span class="done DONE">DONE</span> <a href="https://tatsu-zine.com/books/nuxt-go-web-app-development">NuxtとGoではじめるWebアプリ開発【委託】 - 達人出版会</a></a></h3>
<div class="outline-text-3" id="text-orgb316481">
<p>
動画検索アプリを題材に、NuxtとGoを使ったアプリ開発をやる本。
</p>

<p>
ところどころSDKのバージョンの違いで本の記述では動かないところがある。どこか間違ったらしく、jsonトークンを受け取る箇所がうまくできない。Firebaseへのログイン状態を判断する箇所がうまくいってないので、データベースの動きも確かめられていない。
</p>
</div>
</div>
<div id="outline-container-org298c3c3" class="outline-3">
<h3 id="org298c3c3"><a href="#org298c3c3"><span class="done DONE">DONE</span> ライフゲーム作成</a></h3>
<div class="outline-text-3" id="text-org298c3c3">
<p>
バックエンドGo, フロントReactで作る。
</p>

<ul class="org-ul">
<li><a href="https://github.com/kijimaD/golife">kijimaD/golife: implement Conway&rsquo;s Game of Life</a></li>
</ul>
</div>
</div>
<div id="outline-container-org66b1cc2" class="outline-3">
<h3 id="org66b1cc2"><a href="#org66b1cc2"><span class="done DONE">DONE</span> gofmtを読む</a></h3>
<div class="outline-text-3" id="text-org66b1cc2">
<p>
整形の方法を読む。
</p>

<p>
主要な関数を見ていく。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 53: </span>各ファイルにフォーマットを実行する関数</label><pre class="src src-git-permalink">https://github.com/golang/go/blob/51af90445696772703ed88d967e8c23c8e9e992d/src/cmd/gofmt/gofmt.go#L229
</pre>
</div>

<div class="results" id="org36fc17a">
<p>
func processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter) error {
</p>

</div>

<ol class="org-ol">
<li>ファイル読み込み</li>
<li>ast取り出し</li>
<li>フォーマット</li>
<li>差分があれば、結果に対する各種処理
<ul class="org-ul">
<li>複数ファイルオプションがあれば、ファイル名をプリント</li>
<li>書き込みオプションがあれば、ファイルに書き込み。最初にバックアップを別ファイルに保存し、目標ファイルへの上書きにエラーがあれば戻せるようにする。エラーがなかった場合は完了</li>
<li>差分表示オプションがあれば、差分をプリント</li>
</ul></li>
</ol>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 54: </span>実行の全体像</label><pre class="src src-git-permalink">https://github.com/golang/go/blob/51af90445696772703ed88d967e8c23c8e9e992d/src/cmd/gofmt/gofmt.go#L387
</pre>
</div>

<div class="results" id="org442d4b4">
<p>
func gofmtMain(s *sequencer) {
</p>

</div>

<p>
疑問。
</p>

<ul class="org-ul">
<li><code>fdSem</code> とは
<ul class="org-ul">
<li>fdSem guards the number of concurrently-open file descriptors.</li>
<li>file descriptor semaphore か。セマフォとは、同時実行を制御する仕組み</li>
<li>定義の make(chan bool, 200) はバッファ作成。チャネルに一時データを保存する</li>
<li><code>fdsem &lt;- true</code> は入れる</li>
<li><code>&lt;-fdSem</code> は取り出し</li>
<li>ファイル関係の処理が入るときにfdSemをコントロールして、file descriptorの上限を超えないようにしている</li>
</ul></li>
<li><code>weight</code> とは
<ul class="org-ul">
<li>maxWeightはコア数の環境変数から計算した値を使う</li>
<li>maxWeightは最大の同時接続数のことで、weightはその接続数のカウントのこと。接続が増えるとカウントが減り、0になるとほかのゴルーチンは並列実行できない</li>
<li>weightはファイルサイズから計算する</li>
<li>ファイルサイズによって同時実行数を制御する…ということか。あまりピンとこない</li>
</ul></li>
<li><code>sequencer</code> とは
<ul class="org-ul">
<li>スライス等ではないが、prevフィールドで辿れるグループピング構造に見える</li>
<li>weight, ファイル処理を含む無名関数が入っている</li>
<li>エラーを出す無名関数を入れることもある</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb7b0de9" class="outline-3">
<h3 id="orgb7b0de9"><a href="#orgb7b0de9"><span class="done DONE">DONE</span> bufioを読む</a></h3>
<div class="outline-text-3" id="text-orgb7b0de9">
<p>
結局全然ピンと来てない。
</p>

<p>
まずバッファの概念を理解することが必要そう。解説してあった。こういうのを自分でコードから調査できるようになりたい。
</p>
<ul class="org-ul">
<li><a href="https://zenn.dev/hsaki/books/golang-io-package/viewer/bufio">bufioパッケージによるbuffered I/O｜Goから学ぶI/O</a></li>
</ul>

<p>
あるバイト数に達するまでbufioの内部バッファにためておく処理がある。それが普通のbufioとioの違い。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 55: </span>重要そうな部分。余りバッファがあればコピーし、余りバッファがないときはコピーせず直接write</label><pre class="src src-git-permalink">https://github.com/golang/go/blob/122a22e0e9eba7fe712030d429fc4bcf6f447f5e/src/bufio/bufio.go#L662-L685
</pre>
</div>

<div class="results" id="orgf6fc1fe">
<p>
func (b *Writer) Write(p []byte) (nn int, err error) {
	for len(p) &gt; b.Available() &amp;&amp; b.err == nil {
		var n int
		if b.Buffered() == 0 {
			<i>/ Large write, empty buffer.
			/</i> Write directly from p to avoid copy.
			n, b.err = b.wr.Write(p)
		} else {
			n = copy(b.buf[b.n:], p)
			b.n += n
			b.Flush()
		}
		nn += n
		p = p[n:]
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], p)
	b.n += n
	nn += n
	return nn, nil
}
</p>

</div>
</div>
</div>
<div id="outline-container-orge55229e" class="outline-3">
<h3 id="orge55229e"><a href="#orge55229e"><span class="done DONE">DONE</span> <a href="https://gihyo.jp/dp/ebook/2021/978-4-297-12520-2">エキスパートたちのGo言語 一流のコードから応用力を学ぶ | Gihyo Digital Publishing … 技術評論社の電子書籍</a></a></h3>
<div class="outline-text-3" id="text-orge55229e">
<p>
ノウハウ集。通読するものというよりは、好きな箇所をつまみ食いする本。
</p>
</div>
</div>
<div id="outline-container-org441dba3" class="outline-3">
<h3 id="org441dba3"><a href="#org441dba3"><span class="done DONE">DONE</span> <a href="https://zenn.dev/empenguin/articles/09c1b50ebeb8e7">Golang による Strategy パターン</a></a></h3>
<div class="outline-text-3" id="text-org441dba3">
<p>
必要になったので参考にする。
</p>
</div>
</div>
<div id="outline-container-org957677b" class="outline-3">
<h3 id="org957677b"><a href="#org957677b"><span class="done DONE">DONE</span> <a href="https://selfnote.work/20210516/programming/golang-design-pattern-prototype/">[Go言語]Prototypeパターンを学ぼう | セルフノート</a></a></h3>
<div class="outline-text-3" id="text-org957677b">
<p>
デザインパターンの紹介。
</p>
</div>
</div>
<div id="outline-container-org0465de2" class="outline-3">
<h3 id="org0465de2"><a href="#org0465de2"><span class="done DONE">DONE</span> <a href="https://andmorefine.gitbook.io/learn-go-with-tests/">テスト駆動開発でGO言語を学びましょう - テスト駆動開発でGO言語を学びましょう</a></a></h3>
<div class="outline-text-3" id="text-org0465de2">
<p>
テスト駆動開発によるGo入門。動かしてわかりやすいだけでなく、後の学習に役に立ちそうな言葉も多い。
</p>

<ul class="org-ul">
<li>標準ライブラリを使ってみるときにテストで動作チェックしてみると、勉強になる</li>
</ul>

<blockquote>
<p>
Go標準ライブラリは本当に良いです。時間をかけて勉強してください。
このようにio.Writerインターフェースにある程度慣れていることで、テストでbytes.Bufferを Writerとして使うことができ、標準ライブラリの他のWriterを使ってコマンドラインアプリやウェブサーバで関数を使うことができます。
標準ライブラリに慣れるほど、これらの汎用インターフェイスが表示され、独自のコードで再利用して、ソフトウェアをさまざまなコンテキストで再利用可能にすることができます。
</p>
</blockquote>

<blockquote>
<p>
システムの実行にとって実装が本当に重要でない限り、テストが有用な動作をチェックするようにしてください。
</p>
</blockquote>

<blockquote>
<ul class="org-ul">
<li>リファクタリングの定義では、コードは変更されますが、動作は同じです。理論的にリファクタリングを行うことに決めた場合は、テストを変更せずにコミットを実行できるはずです。だからテストを書くときは自問してください

<ul class="org-ul">
<li>必要な動作や実装の詳細をテストしていますか？</li>
<li>このコードをリファクタリングする場合、テストに多くの変更を加える必要がありますか？</li>
</ul></li>
<li>テストが3つ以上のモックで動作している場合、それは危険信号であるように感じます（デザインを再検討する時間）</li>
</ul>
</blockquote>

<blockquote>
<p>
TDDアプローチの詳細
</p>
<ul class="org-ul">
<li>ささいな例に直面した場合は、問題を「薄いスライス」に分解してください。ウサギの穴に入り込み、「ビッグバン」アプローチをとらないように、できるだけ早く_testsで動作するソフトウェアを使用できるようにしてください。</li>
<li>動作するソフトウェアを入手したら、必要なソフトウェアにたどり着くまで小さなステップで繰り返すのが簡単です。</li>
</ul>
</blockquote>
</div>
</div>
<div id="outline-container-org7e404a9" class="outline-3">
<h3 id="org7e404a9"><a href="#org7e404a9"><span class="done DONE">DONE</span> 実行結果をいい感じに保持するにはどうするか</a></h3>
<div class="outline-text-3" id="text-org7e404a9">
<p>
都度printするのではなく、貯めておいて、表示する箇所で整形して表示したい。表示部分と処理が分離される効果もある。何か公開されているツールを参考にすればできそう。
</p>

<ul class="org-ul">
<li>単純に1階層の結果であれば、構造体に入れて普通に返せばいい</li>
<li>複数階層であれば、工夫が必要そう</li>
</ul>

<pre class="example">
[python 2/4]RUN pip3 install
[build  2/13] COPY . .
</pre>
</div>
</div>
<div id="outline-container-orga256b7c" class="outline-3">
<h3 id="orga256b7c"><a href="#orga256b7c"><span class="done DONE">DONE</span> <a href="https://qiita.com/tenntenn/items/ac5940dfbca703183fdf">Goのスコープについて考えてみよう #golang - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orga256b7c">
<p>
スコープの解説。
</p>

<p>
スコープには4つの種類がある。
</p>

<ul class="org-ul">
<li>ユニバース</li>
<li>ファイル</li>
<li>パッケージ</li>
<li>ローカル</li>
</ul>

<p>
それぞれの種類のスコープでは以下のオブジェクトが定義できる。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">ユニバース</th>
<th scope="col" class="org-left">ファイル</th>
<th scope="col" class="org-left">パッケージ</th>
<th scope="col" class="org-left">ローカル</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">組み込み関数(types.Builtin)</td>
<td class="org-left">✔</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">nil(types.nil)</td>
<td class="org-left">✔</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">定数(types.Const)</td>
<td class="org-left">✔</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">✔</td>
<td class="org-left">✔</td>
</tr>

<tr>
<td class="org-left">型名(types.TypeName)</td>
<td class="org-left">✔</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">✔</td>
<td class="org-left">✔</td>
</tr>

<tr>
<td class="org-left">関数(types.Func)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">✔</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">変数(types.Var)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">✔</td>
<td class="org-left">✔</td>
</tr>

<tr>
<td class="org-left">パッケージ名(types.PkgName)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">✔</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ラベル(Label)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">✔</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgc7bee21" class="outline-3">
<h3 id="orgc7bee21"><a href="#orgc7bee21"><span class="done DONE">DONE</span> <a href="https://qiita.com/tenntenn/items/e15cc0c54b3bbfddb04e">Goの比較可能性（comparable） - Qiita</a></a></h3>
<div class="outline-text-3" id="text-orgc7bee21">
<p>
比較可能な型の説明。
</p>

<ul class="org-ul">
<li>比較可能
<ul class="org-ul">
<li>真偽値</li>
<li>整数値</li>
<li>浮動小数点値</li>
<li>複素数値</li>
<li>文字列</li>
<li>ポインタ</li>
<li>チャネル</li>
<li>インタフェース
<ul class="org-ul">
<li>動的型と動的値の2つから構成される</li>
<li>動的型が <code>%T</code> verbで表示できる</li>
</ul></li>
<li>構造体(条件あり)</li>
<li>配列(条件あり)
<ul class="org-ul">
<li>構成するフィールドや要素に比較できない型がある場合は比較できない</li>
</ul></li>
</ul></li>
<li>比較可能の場合、 <code>==</code> 演算子、 <code>!=</code> 演算子で比較できる。</li>
<li>順序付け可能な場合はさらに <code>&lt;</code> , <code>&lt;=</code> , <code>&gt;</code> , <code>&gt;=</code> が使用できる</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 57: </span>falseになる。動的型はint型で同じだが、動的値が同じなため</label><pre class="src src-go">var x, y any = 100, 200
fmt.Println(x == y)
</pre>
</div>

<div class="results" id="orgfa95489">
<p>
false
</p>

</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 58: </span>falseになる。動的型が違うので</label><pre class="src src-go">var x, y any = int(100), int32(100)
fmt.Println(x == y)
</pre>
</div>

<div class="results" id="org9abed67">
<p>
false
</p>

</div>

<p>
まとめ。
</p>

<ul class="org-ul">
<li>動的型が違う場合は必ずfalse</li>
<li>動的型が同じでどちらかの動的型が比較不可能な場合はパニック</li>
<li>動的型が同じでcomparableでかつ動的値が同じ場合はtrue</li>
<li>動的型が同じでcomparableでかつ動的値が違う場合はfalse</li>
</ul>
</div>
</div>
<div id="outline-container-org59382b8" class="outline-3">
<h3 id="org59382b8"><a href="#org59382b8"><span class="done DONE">DONE</span> ネストしたときのoavの挙動を確認する</a></h3>
<div class="outline-text-3" id="text-org59382b8">
<ul class="org-ul">
<li><a href="https://github.com/kijimaD/oav">kijimaD/oav</a></li>
</ul>

<p>
検知してない疑惑。問題なかった。
</p>

<ul class="org-ul">
<li>type: objectをつけてない項目があった</li>
<li>その項目はarrayだけを子に持っていた。そのため、自身のtypeもarrayになっていた</li>
<li>おそらく、子の項目で自身のtypeが決定する。ほとんどは複合型で、objectに自動で決定して問題ないが、今回のように問題があるケースがある</li>
</ul>
</div>
</div>
<div id="outline-container-org9073b9e" class="outline-3">
<h3 id="org9073b9e"><a href="#org9073b9e"><span class="done DONE">DONE</span> <a href="https://www.amazon.co.jp/Go%E3%81%AA%E3%82%89%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E6%B8%8B%E5%B7%9D-%E3%82%88%E3%81%97%E3%81%8D/dp/4908686033/ref=sr_1_3?keywords=go+%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0&amp;qid=1653145833&amp;sprefix=go+%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%2Caps%2C206&amp;sr=8-3">Goならわかるシステムプログラミング | 渋川 よしき, ごっちん |本 | 通販 - Amazon.co.jp</a></a></h3>
<div class="outline-text-3" id="text-org9073b9e">
<p>
途中まで読んだが、あまりおもしろくないので後回しにする。
</p>

<ul class="org-ul">
<li>36, 53, 119, 158, 248</li>
</ul>

<p>
システムプログラミングをGoで学ぶ本。
</p>

<ul class="org-ul">
<li>まずデバッガ環境を整えることから</li>
<li>ファイルディスクリプタに対応するものは、通常のファイルに限らない。標準入出力/ソケット/OS/CPUに内蔵されている乱数生成の仕組みなど、ファイルではないものにもファイルディスクリプタが割り当てられ、どれもファイルと同じようにアクセスできる</li>
<li>OSは、プロセスが起動されるとまず3つの疑似ファイルを作成し、それぞれにファイルディスクリプタを割り当てる。0が標準入力、1が標準出力、2が標準エラー出力</li>
<li>可能な限りすべてのものがファイルとして抽象化されている</li>
<li>go言語ではファイルディスクリプタのような共通化の仕組みを言語レベルで持ってOSによる差異を吸収している。io.Writer</li>
<li>インターフェースは、構造体と違って何かしら実体を持つものを表すのではなく、「どんなことができるか」を宣言しているだけ</li>
<li>リクエストではスロースタートによって、最適な速度を決定している。大きなファイル転送するときに徐々に速度が上がっていくのはこのためか</li>
<li>Linuxのファイルの管理情報を格納している領域を、inodeという</li>
<li>Linuxでファイルを読み書きする場合には、まずバッファにデータが格納される。すでにバッファに載っていて、そのファイルに対する書き込みが行われていないならバッファだけにしかアクセスしない</li>
<li>.envファイルを利用するアイデアは、<a href="20210509095946-rails.html#ID-e04aa1a3-509c-45b2-ac64-53d69c961214">Rails</a>での発明らしい</li>
<li>OSが実行ファイルを読み込んで実行するには、そのためのリソースを用意しなければならない。そのようなリソースをまとめたプログラムの実行単位がプロセス
<ul class="org-ul">
<li>カーネルは新しいプロセスを作るたびに各プロセスでどういった入出力が行われるかの管理テーブルをつくる。そのインデックス値がファイルディスクリプタ</li>
</ul></li>
<li>プロセスを束ねたグループというものもある。プロセスグループ(別名ジョブ)。パイプを使うと同じプロセスグループになる</li>
<li>シグナルはプロセスに対して送られる</li>
<li id="システムコール">プロセス → OSカーネル</li>
<li id="シグナル">OSカーネル → プロセス</li>
<li>スレッドがCPUコアに対してマッピングされるのに対し、goroutineはOSのスレッドにマッピングされる</li>
<li>goroutineはOSのスレッドと比較してタスク切り替えのコストが低い
<ul class="org-ul">
<li>スイッチには前の処理が使っていたレジスタの退避が必要になるが、退避が最小限が済むコード位置にスイッチのためのコードが埋め込める</li>
<li>初期スタックメモリのサイズが小さい。メモリ確保は処理時間がかかるので、起動時間では小さいほうが有利</li>
<li>などによって、goroutineは起動時間、切り替え時間がOSのスレッドより1000倍のオーダーで高速</li>
<li>Goが提供する並行・並列処理の3要素
<ul class="org-ul">
<li>goroutine: 実行</li>
<li>チャネル・コミュニケーション</li>
<li>select: 調停</li>
</ul></li>
<li>並行・並列処理の実現手法
<ul class="org-ul">
<li>マルチプロセス</li>
<li>イベント駆動</li>
<li>マルチスレッド</li>
<li>ストリーミング・プロセッシング</li>
</ul></li>
<li>スライスの裏には配列がある。実際には配列を参照するウィンドウ(対象の配列のスタート位置，終了位置、確保済みのサイズの3つの情報を持つ)で構成されている</li>
<li>バックエンドの配列に対し、使いやすいフロントエンドとして提供されているのがスライス</li>
<li>スライスの実態は3つの数値とポインタを持った24バイトのデータ
<ul class="org-ul">
<li>スライスの先頭の要素へのポインタ</li>
<li>スライスの長さ</li>
<li>スライスが確保している要素数</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"/>
</div>
</body>
</html>
