:properties:
:ID: 20240717T223527
:end:
#+title:      KDOC 202: 『30日でできる! OS自作入門』
#+date:       [2024-07-17 Wed 22:35]
#+filetags:   :draft:book:
#+identifier: 20240717T223527

# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。

* この文書のステータス
:PROPERTIES:
:Effort:   20:00
:END:
:LOGBOOK:
CLOCK: [2024-08-03 Sat 11:24]--[2024-08-03 Sat 11:49] =>  0:25
CLOCK: [2024-08-03 Sat 10:50]--[2024-08-03 Sat 11:15] =>  0:25
CLOCK: [2024-08-03 Sat 10:01]--[2024-08-03 Sat 10:26] =>  0:25
CLOCK: [2024-08-03 Sat 00:58]--[2024-08-03 Sat 01:23] =>  0:25
CLOCK: [2024-08-02 Fri 22:26]--[2024-08-02 Fri 22:51] =>  0:25
CLOCK: [2024-08-02 Fri 21:56]--[2024-08-02 Fri 22:21] =>  0:25
CLOCK: [2024-08-02 Fri 00:33]--[2024-08-02 Fri 00:58] =>  0:25
CLOCK: [2024-08-01 Thu 23:42]--[2024-08-02 Fri 00:07] =>  0:25
CLOCK: [2024-08-01 Thu 22:31]--[2024-08-01 Thu 22:56] =>  0:25
CLOCK: [2024-08-01 Thu 22:06]--[2024-08-01 Thu 22:31] =>  0:25
CLOCK: [2024-08-01 Thu 00:19]--[2024-08-01 Thu 00:44] =>  0:25
CLOCK: [2024-07-31 Wed 23:49]--[2024-08-01 Thu 00:14] =>  0:25
CLOCK: [2024-07-28 Sun 22:30]--[2024-07-28 Sun 22:55] =>  0:25
CLOCK: [2024-07-28 Sun 21:47]--[2024-07-28 Sun 22:12] =>  0:25
CLOCK: [2024-07-24 Wed 00:07]--[2024-07-24 Wed 00:32] =>  0:25
CLOCK: [2024-07-23 Tue 00:20]--[2024-07-23 Tue 00:45] =>  0:25
CLOCK: [2024-07-22 Mon 23:48]--[2024-07-23 Tue 00:13] =>  0:25
CLOCK: [2024-07-22 Mon 21:52]--[2024-07-22 Mon 22:17] =>  0:25
CLOCK: [2024-07-22 Mon 21:11]--[2024-07-22 Mon 21:36] =>  0:25
CLOCK: [2024-07-22 Mon 20:39]--[2024-07-22 Mon 21:04] =>  0:25
CLOCK: [2024-07-22 Mon 00:27]--[2024-07-22 Mon 00:52] =>  0:25
CLOCK: [2024-07-21 Sun 19:40]--[2024-07-21 Sun 20:05] =>  0:25
CLOCK: [2024-07-21 Sun 17:20]--[2024-07-21 Sun 17:45] =>  0:25
CLOCK: [2024-07-21 Sun 16:53]--[2024-07-21 Sun 17:18] =>  0:25
CLOCK: [2024-07-21 Sun 16:20]--[2024-07-21 Sun 16:45] =>  0:25
CLOCK: [2024-07-21 Sun 15:41]--[2024-07-21 Sun 16:06] =>  0:25
CLOCK: [2024-07-21 Sun 11:12]--[2024-07-21 Sun 11:38] =>  0:26
CLOCK: [2024-07-21 Sun 10:47]--[2024-07-21 Sun 11:12] =>  0:25
CLOCK: [2024-07-20 Sat 22:04]--[2024-07-20 Sat 22:29] =>  0:25
CLOCK: [2024-07-20 Sat 21:39]--[2024-07-20 Sat 22:04] =>  0:25
CLOCK: [2024-07-20 Sat 21:07]--[2024-07-20 Sat 21:32] =>  0:25
CLOCK: [2024-07-20 Sat 20:37]--[2024-07-20 Sat 21:02] =>  0:25
CLOCK: [2024-07-20 Sat 20:03]--[2024-07-20 Sat 20:28] =>  0:25
CLOCK: [2024-07-20 Sat 17:55]--[2024-07-20 Sat 18:20] =>  0:25
CLOCK: [2024-07-20 Sat 17:20]--[2024-07-20 Sat 17:45] =>  0:25
CLOCK: [2024-07-17 Wed 22:35]--[2024-07-17 Wed 23:00] =>  0:25
:END:
- 作成
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
# 本文(タイトルをつける)。
[[https://tatsu-zine.com/books/make-your-own-os-in30days][30日でできる! OS自作入門【委託】 - 達人出版会]]は、OS自作の本。付録コードは[[https://github.com/hide27k/haribote-os][hide27k/haribote-os]]にある。
* メモ

- EQUは、C言語でいうところの ~#define~ のようなもので、定数を宣言するのに使う(p57)
- 空の状態のディスクに対してファイルを保存したとき(p59)
  1. ファイル名は0x002600以降に入る
  2. ファイルの中身は0x004200以降に入る
- BIOSは16ビット用の機械語で書いてある(p61)
- VRAMというのはビデオメモリ、画面用のメモリのこと。それぞれの番地が画面上の画素に対応していて、画面に絵を出せる(p62)
- オブジェクトファイルは、ほかのオブジェクトファイルとリンクするための特別な機械語ファイル。C言語だけではプログラム全体を書けない限界がある。一部はアセンブラで書かなければならない。アセンブラで書いてある部分とくっつけなければならない。そのため、オブジェクトファイルは他のオブジェクトファイルとくっつけるための「のりしろ」に相当する情報を余分に持っていて、単独では機械語としては一部未完成になっている(p65)

#+caption: 特定のアドレスに書き込むC言語のイディオム。書き込み先は確保してないのでSegmentation faultになる
#+begin_src C
  char *p;
  int i = 0;
  *p = i & 0x0f;
#+end_src

#+RESULTS:
#+begin_src
[ Babel evaluation exited with code "Segmentation fault" ]
#+end_src

#+caption: コピー先にレジスタ以外を指定するときは、サイズを指定しなければならない
#+begin_export asm
MOV BYTE [i], (i & 0x0f)
#+end_export

- ポインタは番地にすぎない(p83)
  - ~p[i]~ は、 ~*(p + i)~ と完全に同じ意味
  - ~p[i]~ は、 ~i[p]~ と完全に同じ意味
- CPUにはメモリだけでなく装置(device)もつながっている。装置へ電気信号を送るのがIN命令やOUT命令。送り先の装置を区別するために、装置番号(ポート)を使う(p88)
- CLI命令は、割り込みフラグを0にする命令(p89)
- STI命令は、割り込みフラグを1にする命令(p89)
- FLAGSはキャリーフラグや割り込みフラグが詰まったレジスタ。EFLAGSはFLAGSを32ビットに拡張(Extend)したレジスタ(p89)
- ポインタ参照でカッコがある場合とない場合の違い
  - ~xsize = *binfo.scrnx;~ はbinfoが指す構造体のメンバscrnxがさらにポインタであり、そのポインタを参照する
  - ~xsize = (*binfo).scrnx;~ はbinfoが指す構造体のメンバscrnxにアクセスする
- カッコを使わずに矢印表記で ~xsize = binfo->scrnx;~ と書ける
- 文字列というのは、文字コードを順番にメモリに並べて、最後に ~0x00~ をつけたもののこと(p107)
- セグメンテーションというのは、メモリを好きなように切り分けて、それぞれのブロックの最初の番地を0として扱える機能である、という。したがって、どのプログラムも ~ORG 0~ とすればよい。また、セグメンテーションでなくページングでも開始アドレスの問題を解決できる(p112)
- セグメント1つの情報には8バイト必要である。セグメント番号は1~8191が使える。つまり8*8191=65536(64KB)が必要になる。こんなにたくさんのデータはCPUが覚えられないのでメモリに保存する。この64KBの領域をGDT(Global Descriptor table)という。メモリのどこかにセグメントの設定を並べて、その先頭の番地と有効設定個数をCPUの ~GDTR~ という特別なレジスタに保存する(p113)
- 割り込み処理を管理するIDT(Interrupt Descriptor Table)もある。IDTは割り込み番号0から255に対して、割り込み番号123が発生したら〜関数を呼び出してね、みたいな設定の表。設定方法はGDTとよく似ている(p113)
- IDTの設定の際には、セグメントの設定が先に完了している必要がある。なのでGDTを先に設定する(p114)
- C言語ではポインタに足し算するときには、掛け算をしている。例えば8バイトの構造体へのポインタの変数に1を足すと、番地が8増える

#+caption: コンパイラはこの記述を見つけると、その場所に指定されたソースファイルを埋め込んだものとしてコンパイルしてくれる
#+begin_src C
#include "example.h"
#+end_src

- 割り込みを使うにはGDT、IDT、PICを設定しておく必要がある(p127)
- CPUは単独では1つしか割り込みを扱えない設計になっている。補助チップとしてPIC(programmable interrupt controller)がついている。PICは8個の割り込み信号を1つの割り込み信号にまとめる装置。入力ピンの8個の信号を監視してどれか1つでも割り込み信号が来たら出力ピンがオンになってお知らせするというもの(p127)
  - PICはCPUから見ると外部装置なので、CPUからはOUT命令を使って操作する
- ~INT 0x00~0x1f~ はIRQ用に使ってはいけない。 ~INT 0x00~0x1f~ はアプリケーションがOSに対して悪さをしようとしたときにCPUが内部で自動的に発生させて、それを通じてOSに通報するためのものだから。IRQをこれに重なるように割り当てると、IRQからなのか、それともCPU保護の通知なのか、わからなくなってしまう(p130)
- 割り込み処理は基本的に本来の仕事に割り込んで実行されるものだから、すぐに終わらなければならない。ほかの割り込みが受け付けられなくなる(p139)
- 2バイトのキーコードの場合、キーボード回路は一度には1バイトしか送れない。なので一度のキーの押し下げに対して2回のキーボード割り込みが発生する(p142)
- キーボード割り込みのバッファを実装する。遅いコピーを避け、使い回せるような構造を持ったFIFOキュー(p148)
- 486以降にしかセットされないビットがあり、そこに書き込んでみて反映するかで判定する。使えるメモリがどこまであるかを、書き込んで反映されるかで調べる(p178)
* 用語集
- IDT(Interrupt Descriptor Table) :: 割り込み処理が発生したとき、対応する命令を設定する機能。キーボードの入力処理などをやる
- GDT(Global Descriptor Table) :: システムで唯一のセグメントディスクリプタテーブル
- LGDT命令 :: GDTRレジスタをロードする命令
- セグメントディスクリプタ :: 論理アドレスと対になった物理アドレスとのマッピング
- CLI命令 :: ハードウェア割り込みを禁止する
- STI命令 :: ハードウェア割り込みを許可する
- PIC :: プログラマブル割り込みコントローラ。外部デバイスからの割り込みを管理するためのハードウェア
- OCW2レジスタ :: PICに対して割り込みの処理完了を通知するために使用されるレジスタ。特定のビットフィールドを設定することでどの割り込みラインの処理が完了したかをPICに伝える
  - 例えば、 ~0x61~ が設定されたとき、 ~0x60~ はOCW2レジスタの基本値で、割り込み受付完了を通知するコマンドを示す。 ~0x01~ はIRQライン1(キーボード割り込み)を表す
- KBC :: キーボード制御回路
- IPL :: Initial Program Loader
* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# この事実は自分のこのアイデアとどう整合するか。
# この現象はあの理論でどう説明できるか。
# ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# いま聞いた内容は以前に聞いたことがなかったか。
# メモ y についてメモ x はどういう意味か。
- [[id:20240505T160356][KDOC 167: 『CPUの創り方』]]。低レイヤーつながり
- [[id:20240427T113714][KDOC 140: 『自作エミュレータで学ぶx86アーキテクチャ』]]。低レイヤーつながり
