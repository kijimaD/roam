:properties:
:ID: 20240717T223527
:end:
#+title:      KDOC 202: 『30日でできる! OS自作入門』
#+date:       [2024-07-17 Wed 22:35]
#+filetags:   :draft:book:
#+identifier: 20240717T223527

# (denote-rename-file-using-front-matter (buffer-file-name) 0)
# (save-excursion (while (re-search-backward ":draft" nil t) (replace-match "")))
# (flush-lines "^\\#\s.+?")

# ====ポリシー。
# 1ファイル1アイデア。
# 1ファイルで内容を完結させる。
# 常にほかのエントリとリンクする。
# 自分の言葉を使う。
# 参考文献を残しておく。
# 文献メモの場合は、感想と混ぜないこと。1つのアイデアに反する
# ツェッテルカステンの議論に寄与するか
# 頭のなかやツェッテルカステンにある問いとどのようにかかわっているか
# エントリ間の接続を発見したら、接続エントリを追加する。カード間にあるリンクの関係を説明するカード。
# アイデアがまとまったらアウトラインエントリを作成する。リンクをまとめたエントリ。
# エントリを削除しない。古いカードのどこが悪いかを説明する新しいカードへのリンクを追加する。
# 恐れずにカードを追加する。無意味の可能性があっても追加しておくことが重要。

# ====永久保存メモのルール。
# 自分の言葉で書く。
# 後から読み返して理解できる。
# 他のメモと関連付ける。
# ひとつのメモにひとつのことだけを書く。
# メモの内容は1枚で完結させる。
# 論文の中に組み込み、公表できるレベルである。

# ====価値があるか。
# その情報がどういった文脈で使えるか。
# どの程度重要な情報か。
# そのページのどこが本当に必要な部分なのか。

* この文書のステータス
:PROPERTIES:
:Effort:   20:00
:END:
:LOGBOOK:
CLOCK: [2024-07-21 Sun 19:40]--[2024-07-21 Sun 20:05] =>  0:25
CLOCK: [2024-07-21 Sun 17:20]--[2024-07-21 Sun 17:45] =>  0:25
CLOCK: [2024-07-21 Sun 16:53]--[2024-07-21 Sun 17:18] =>  0:25
CLOCK: [2024-07-21 Sun 16:20]--[2024-07-21 Sun 16:45] =>  0:25
CLOCK: [2024-07-21 Sun 15:41]--[2024-07-21 Sun 16:06] =>  0:25
CLOCK: [2024-07-21 Sun 11:12]--[2024-07-21 Sun 11:38] =>  0:26
CLOCK: [2024-07-21 Sun 10:47]--[2024-07-21 Sun 11:12] =>  0:25
CLOCK: [2024-07-20 Sat 22:04]--[2024-07-20 Sat 22:29] =>  0:25
CLOCK: [2024-07-20 Sat 21:39]--[2024-07-20 Sat 22:04] =>  0:25
CLOCK: [2024-07-20 Sat 21:07]--[2024-07-20 Sat 21:32] =>  0:25
CLOCK: [2024-07-20 Sat 20:37]--[2024-07-20 Sat 21:02] =>  0:25
CLOCK: [2024-07-20 Sat 20:03]--[2024-07-20 Sat 20:28] =>  0:25
CLOCK: [2024-07-20 Sat 17:55]--[2024-07-20 Sat 18:20] =>  0:25
CLOCK: [2024-07-20 Sat 17:20]--[2024-07-20 Sat 17:45] =>  0:25
CLOCK: [2024-07-17 Wed 22:35]--[2024-07-17 Wed 23:00] =>  0:25
:END:
- 作成
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))
- レビュー
  - [ ] <署名>
# (progn (kill-line -1) (insert (format "  - [X] %s 貴島" (format-time-string "%Y-%m-%d"))))

# 関連をつけた。
# タイトルがフォーマット通りにつけられている。
# 内容をブラウザに表示して読んだ(作成とレビューのチェックは同時にしない)。
# 文脈なく読めるのを確認した。
# おばあちゃんに説明できる。
# いらない見出しを削除した。
# タグを適切にした。
# すべてのコメントを削除した。
* 概要
# 本文(タイトルをつける)。
[[https://tatsu-zine.com/books/make-your-own-os-in30days][30日でできる! OS自作入門【委託】 - 達人出版会]]は、OS自作の本。付録コードは[[https://github.com/hide27k/haribote-os][hide27k/haribote-os]]にある。
* メモ

- EQUは、C言語でいうところの ~#define~ のようなもので、定数を宣言するのに使う(p57)
- 空の状態のディスクに対してファイルを保存したとき(p59)
  1. ファイル名は0x002600以降に入る
  2. ファイルの中身は0x004200以降に入る
- BIOSは16ビット用の機械語で書いてある(p61)
- VRAMというのはビデオメモリ、画面用のメモリのこと。それぞれの番地が画面上の画素に対応していて、画面に絵を出せる(p62)
- オブジェクトファイルは、ほかのオブジェクトファイルとリンクするための特別な機械語ファイル。C言語だけではプログラム全体を書けない限界がある。一部はアセンブラで書かなければならない。アセンブラで書いてある部分とくっつけなければならない。そのため、オブジェクトファイルは他のオブジェクトファイルとくっつけるための「のりしろ」に相当する情報を余分に持っていて、単独では機械語としては一部未完成になっている(p65)

#+caption: 特定のアドレスに書き込むC言語のイディオム。書き込み先は確保してないのでSegmentation faultになる
#+begin_src C
  char *p;
  int i = 0;
  *p = i & 0x0f;
#+end_src

#+RESULTS:
#+begin_src
[ Babel evaluation exited with code "Segmentation fault" ]
#+end_src

#+caption: コピー先にレジスタ以外を指定するときは、サイズを指定しなければならない
#+begin_export asm
MOV BYTE [i], (i & 0x0f)
#+end_export

- ポインタは番地にすぎない(p83)
  - ~p[i]~ は、 ~*(p + i)~ と完全に同じ意味
  - ~p[i]~ は、 ~i[p]~ と完全に同じ意味
- CPUにはメモリだけでなく装置(device)もつながっている。装置へ電気信号を送るのがIN命令やOUT命令。送り先の装置を区別するために、装置番号(ポート)を使う(p88)
- CLI命令は、割り込みフラグを0にする命令(p89)
- STI命令は、割り込みフラグを1にする命令(p89)
- FLAGSはキャリーフラグや割り込みフラグが詰まったレジスタ。EFLAGSはFLAGSを32ビットに拡張(Extend)したレジスタ(p89)
- ポインタ参照でカッコがある場合とない場合の違い
  - ~xsize = *binfo.scrnx;~ はbinfoが指す構造体のメンバscrnxがさらにポインタであり、そのポインタを参照する
  - ~xsize = (*binfo).scrnx;~ はbinfoが指す構造体のメンバscrnxにアクセスする
- カッコを使わずに矢印表記で ~xsize = binfo->scrnx;~ と書ける
- 文字列というのは、文字コードを順番にメモリに並べて、最後に ~0x00~ をつけたもののこと(p107)
- セグメンテーションというのは、メモリを好きなように切り分けて、それぞれのブロックの最初の番地を0として扱える機能である、という。したがって、どのプログラムも ~ORG 0~ とすればよい。また、セグメンテーションでなくページングでも開始アドレスの問題を解決できる(p112)
- セグメント1つの情報には8バイト必要である。セグメント番号は1~8191が使える。つまり8*8191=65536(64KB)が必要になる。こんなにたくさんのデータはCPUが覚えられないのでメモリに保存する。この64KBの領域をGDT(Global Descriptor table)という。メモリのどこかにセグメントの設定を並べて、その先頭の番地と有効設定個数をCPUの ~GDTR~ という特別なレジスタに保存する(p113)
- 割り込み処理を管理するIDT(Interrupt Descriptor Table)もある。IDTは割り込み番号0から255に対して、割り込み番号123が発生したら〜関数を呼び出してね、みたいな設定の表。設定方法はGDTとよく似ている(p113)

* 関連
# 関連するエントリ。なぜ関連させたか理由を書く。意味のあるつながりを意識的につくる。
# この事実は自分のこのアイデアとどう整合するか。
# この現象はあの理論でどう説明できるか。
# ふたつのアイデアは互いに矛盾するか、互いを補っているか。
# いま聞いた内容は以前に聞いたことがなかったか。
# メモ y についてメモ x はどういう意味か。
