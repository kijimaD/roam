<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-02-07 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Emacs Lisp</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<link rel='shortcut icon' type='image/x-icon' href='/roam/favicon.ico' /><link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css' /><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css' /><link rel='stylesheet' href='../css/site.css' /><link rel='stylesheet' href='../roam/css/code.css' /><link rel='stylesheet' href='css/site.css' /><link rel='stylesheet' href='css/code.css' />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<div><div class="header"><div class="container"><div class="row"><div class="col-sm-12 col-md-12"><nav class="navbar navbar-light"/></div></div></div></div></div>
</div>
<div id="content">
<h1 class="title">Emacs Lisp</h1>
<div id="outline-container-org6241d2e" class="outline-2">
<h2 id="org6241d2e"><a href="#org6241d2e">概要</a></h2>
<div class="outline-text-2" id="text-org6241d2e">
<p>
<a href="20210508234743-emacs.html#ID-1ad8c3d5-97ba-4905-be11-e6f2626127ad">Emacs</a>で使われている<a href="20210509101246-programming_language.html#ID-868ac56a-2d42-48d7-ab7f-7047c85a8f39">Programming Language</a>、Lispの方言。
Emacs自体のコードの多くがEmacs Lispで構成されているほか、拡張するために用いる。
</p>
</div>
</div>
<div id="outline-container-orgb0fc258" class="outline-2">
<h2 id="orgb0fc258"><a href="#orgb0fc258">Memo</a></h2>
<div class="outline-text-2" id="text-orgb0fc258">
</div>
<div id="outline-container-orgafd7eb0" class="outline-3">
<h3 id="orgafd7eb0"><a href="#orgafd7eb0">M-xで引数を割り当てる</a></h3>
<div class="outline-text-3" id="text-orgafd7eb0">
<p>
M-x <code>ert-run-tests-interactively</code> は実行できるが、 <code>(ert-run-tests-interactively)</code> は引数足りないエラーで実行できない。
</p>

<p>
interactive special formが関係している。interactiveの引数はarg-descriptor。arg-descriptorは、そのコマンドがインタラクティブに呼び出されたとき引数を計算する方法を宣言する。
</p>

<ul class="org-ul">
<li><a href="https://ayatakesi.github.io/emacs/24.5/elisp_html/Using-Interactive.html">Using Interactive (GNU Emacs Lisp Reference Manual)</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/src/callint.c#L37
</pre>
</div>

<div class="results" id="org9f26012">
<p>
DEFUN (&ldquo;interactive&rdquo;, Finteractive, Sinteractive, 0, UNEVALLED, 0,
</p>

</div>

<ul class="org-ul">
<li><a href="https://flex.phys.tohoku.ac.jp/texi/eljman/eljman_135.html">GNU Emacs Lisp Reference Manual - Completion</a></li>
</ul>

<p>
interactiveに渡したリストが、関数定義の引数に割り当てられる。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>M-xで実行できる</label><pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">interactive-test</span> (select)
  (<span class="org-keyword">interactive</span> '(<span class="org-string">"test"</span>))
  (insert select))
</pre>
</div>

<div class="results" id="org511f112">
<p>
interactive-test
</p>

</div>
</div>
</div>
<div id="outline-container-org41de417" class="outline-3">
<h3 id="org41de417"><a href="#org41de417">defunを読む&#xa0;&#xa0;&#xa0;<span class="tag"><span class="DontKnow">DontKnow</span></span></a></h3>
<div class="outline-text-3" id="text-org41de417">
<p>
defunは関数定義でよく使うマクロ。どのような仕組みになっているのだろうか。
</p>
</div>
</div>
<div id="outline-container-org6c046b9" class="outline-3">
<h3 id="org6c046b9"><a href="#org6c046b9">プロパティはなにか</a></h3>
<div class="outline-text-3" id="text-org6c046b9">
<p>
任意のオブジェクトに情報を付加し、後で取り出せる仕組み。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(define-symbol-prop 'test-symbol 'test-group '(1 2 3))

(get 'test-symbol 'test-group)
</pre>
</div>

<div class="results" id="org35754f4">
<p>
(1 2 3)
</p>

</div>
</div>
</div>

<div id="outline-container-orgd62829c" class="outline-3">
<h3 id="orgd62829c"><a href="#orgd62829c">関数とはlambdaで始まるリスト</a></h3>
<div class="outline-text-3" id="text-orgd62829c">
<ul class="org-ul">
<li><a href="http://quruli.ivory.ne.jp/document/elisp_20.3/elisp_12.html">http://quruli.ivory.ne.jp/document/elisp_20.3/elisp_12.html</a></li>
</ul>

<blockquote>
<p>
Lispでは, 関数とは, lambdaで始まるリスト, そのようなリストをコンパイルしたバイトコード関数, あるいは, 基本関数のsubrオブジェクトです
</p>
</blockquote>

<p>
関数はよくdefunで定義するが、これは単に便利関数というだけで、本質的にlambdaをつけているにすぎない。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>defunの定義。(cons &rsquo;lambda &#x2026; に注目</label><pre class="src src-git-permalink">https://github.com/kd-collective/emacs/blob/30cf1f34c583d6ed16bdc5b9578370f30c95fe1b/lisp/emacs-lisp/byte-run.el#L401-L442
</pre>
</div>

<div class="results" id="orgf8e3fe2">
<p>
(defmacro defun (name arglist &amp;rest body)
  &ldquo;Define NAME as a function.
The definition is (lambda ARGLIST [DOCSTRING] [INTERACTIVE] BODY&#x2026;).
DECL is a declaration, optional, of the form (declare DECLS&#x2026;) where
DECLS is a list of elements of the form (PROP . VALUES).  These are
interpreted according to `defun-declarations-alist&rsquo;.
INTERACTIVE is an optional `interactive&rsquo; specification.
The return value is undefined.
</p>

<p>
\(fn NAME ARGLIST [DOCSTRING] [DECL] [INTERACTIVE] BODY&#x2026;)&ldquo;
  (declare (doc-string 3) (indent 2))
  (or name (error &rdquo;Cannot define &rsquo;%s&rsquo; as a function&ldquo; name))
  (if (null
       (and (listp arglist)
            (null (delq t (mapcar #&rsquo;symbolp arglist)))))
      (error &rdquo;Malformed arglist: %s&ldquo; arglist))
  (let* ((parse (byte-run&#x2013;parse-body body t))
         (docstring (nth 0 parse))
         (declare-form (nth 1 parse))
         (interactive-form (nth 2 parse))
         (body (nth 3 parse))
         (warnings (nth 4 parse))
         (declarations
          (and declare-form (byte-run&#x2013;parse-declarations
                             name arglist (cdr declare-form) &lsquo;defun
                             defun-declarations-alist))))
    (setq body (nconc warnings body))
    (setq body (nconc (cdr declarations) body))
    (if interactive-form
        (setq body (cons interactive-form body)))
    (if docstring
        (setq body (cons docstring body)))
    (if (null body)
        (setq body &rsquo;(nil)))
    (let ((def (list &lsquo;defalias
                     (list &lsquo;quote name)
                     (list &lsquo;function
                           (cons &lsquo;lambda
                                 (cons arglist body))))))
      (if declarations
          (cons &lsquo;prog1 (cons def (car declarations)))
        def))))
</p>

</div>
</div>
</div>

<div id="outline-container-org4cc83d0" class="outline-3">
<h3 id="org4cc83d0"><a href="#org4cc83d0">interactiveモードか判定する変数</a></h3>
<div class="outline-text-3" id="text-org4cc83d0">
<ul class="org-ul">
<li>noninteractive 変数
<ul class="org-ul">
<li>Non-nil means Emacs is running without interactive terminal.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb021d16" class="outline-3">
<h3 id="orgb021d16"><a href="#orgb021d16">defmacroの短い例</a></h3>
<div class="outline-text-3" id="text-orgb021d16">
<p>
macroを理解するには、それが必要な状況をイメージできるとわかりやすい。bodyを未評価の状態で渡すのが必要なので、defmacroを使う。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">cask--shut-up-unless-debug</span> (<span class="org-type">&amp;rest</span> body)
  <span class="org-doc">"The shut-up module is singularly designed to defeat *every*</span>
<span class="org-doc"> attempt at making your elisp package tractable."</span>
  (<span class="org-keyword">declare</span> (indent defun))
  `(<span class="org-keyword">if</span> debug-on-error
       (<span class="org-keyword">cl-flet</span> ((shut-up-current-output () (ignore)))
         ,@body)
     (shut-up ,@body)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org49eb601" class="outline-3">
<h3 id="org49eb601"><a href="#org49eb601">letfを関数モックとして使う</a></h3>
<div class="outline-text-3" id="text-org49eb601">
<p>
モックとして使える。princをinsertに置き換えて、テスト可能にする例。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>princをinsertに置き換えて、テスト可能にする例</label><pre class="src src-git-permalink">https://github.com/cask/cask/blob/bc168a11d7881a62657cdf19bab2e7966033ec2c/test/cask-cli-test.el#L48-L58
</pre>
</div>

<div class="results" id="org4370bd8">
<p>
(ert-deftest cask-cli-test/print-table-with-links ()
  (cask-test/with-bundle
      &rsquo;((source localhost)
        (depends-on &ldquo;package-c&rdquo; &ldquo;0.0.1&rdquo;)
        (depends-on &ldquo;package-d&rdquo; &ldquo;0.0.1&rdquo;))
    (let ((package-c-path (cask-test/link bundle &rsquo;package-c &ldquo;package-c-0.0.1&rdquo;))
          (package-d-path (cask-test/link bundle &rsquo;package-d &ldquo;package-d-0.0.1&rdquo;)))
      (cl-letf (((symbol-function &rsquo;princ) #&rsquo;insert))
        (with-temp-buffer
          (cask-cli&#x2013;print-table (cask-links bundle))
          (should-not (zerop (length (buffer-string)))))))))
</p>

</div>
</div>
</div>
<div id="outline-container-orgfdde84f" class="outline-3">
<h3 id="orgfdde84f"><a href="#orgfdde84f">インデントマクロ</a></h3>
<div class="outline-text-3" id="text-orgfdde84f">
<p>
マクロ呼び出しをTABがどのようにインデントするべきか定義するために、declareフォームを使うことができる。
</p>

<ul class="org-ul">
<li><a href="https://ayatakesi.github.io/emacs/24.5/elisp_html/Indenting-Macros.html#Indenting-Macros">Indenting Macros (GNU Emacs Lisp Reference Manual)</a></li>
</ul>
</div>
</div>

<div id="outline-container-org11bc4e0" class="outline-3">
<h3 id="org11bc4e0"><a href="#org11bc4e0">バッファの開き方を分岐させるときの書き方</a></h3>
<div class="outline-text-3" id="text-org11bc4e0">
<p>
動作の異なる関数を分岐で代入して、funcallで評価する。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>display-buffer-fnには、動作の異なるバッファを切り替える関数が代入されている</label><pre class="src src-git-permalink">https://github.com/kd-collective/org-roam/blob/abe63b436035049923ae96639b9b856697047779/org-roam-node.el#L454-L458
</pre>
</div>

<div class="results" id="orgcb543be">
<p>
    (display-buffer-fn (if other-window
			   #'switch-to-buffer-other-window
			 #'pop-to-buffer-same-window)))
(funcall display-buffer-fn buf)
(when (org-invisible-p) (org-show-context))
</p>

</div>
</div>
</div>

<div id="outline-container-org5e14983" class="outline-3">
<h3 id="org5e14983"><a href="#org5e14983">modus-themeを切り替える</a></h3>
<div class="outline-text-3" id="text-org5e14983">
<p>
modus-themes-toggleでダークテーマ、ライトテーマを切り替えられる。便利。
</p>
</div>
</div>
<div id="outline-container-org95d1310" class="outline-3">
<h3 id="org95d1310"><a href="#org95d1310">現在のメジャーモードの調べ方</a></h3>
<div class="outline-text-3" id="text-org95d1310">
<p>
判定や使いかたを調べるのに使える。
</p>
<div class="org-src-container">
<pre class="src src-ruby">major-mode
</pre>
</div>

<pre class="example">
-&gt; "org-mode"
</pre>
</div>
</div>
<div id="outline-container-org8061435" class="outline-3">
<h3 id="org8061435"><a href="#org8061435"><code>format-spec</code> で設定の幅を広げる</a></h3>
<div class="outline-text-3" id="text-org8061435">
<p>
<code>(format-spec)</code> で文字と関数をマッピングして、ユーザが設定しやすくできる。
</p>

<ul class="org-ul">
<li><a href="https://github.com/magit/magit/blob/f805f6a7720aeb894e9a58f0b36769ebdb53dd7c/lisp/magit-mode.el#L921">https://github.com/magit/magit/blob/f805f6a7720aeb894e9a58f0b36769ebdb53dd7c/lisp/magit-mode.el#L921</a></li>
</ul>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(format-spec
     magit-buffer-name-format <span class="org-comment-delimiter">;; </span><span class="org-comment">"%x%M%v: %t%x"</span>
     `((?m . ,m)
       (?M . ,(<span class="org-keyword">if</span> (eq mode 'magit-status-mode) <span class="org-string">"magit"</span> m))
       (?v . ,(<span class="org-keyword">or</span> v <span class="org-string">""</span>))
       (?V . ,(<span class="org-keyword">if</span> v (concat <span class="org-string">" "</span> v) <span class="org-string">""</span>))
       (?t . ,n)
       (?x . ,(<span class="org-keyword">if</span> magit-uniquify-buffer-names <span class="org-string">""</span> <span class="org-string">"*"</span>))
       (?T . ,(<span class="org-keyword">if</span> magit-uniquify-buffer-names n (concat n <span class="org-string">"*"</span>)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org50d22ea" class="outline-3">
<h3 id="org50d22ea"><a href="#org50d22ea">必須ではない依存パッケージの書き方</a></h3>
<div class="outline-text-3" id="text-org50d22ea">
<p>
変数なら
(defvar w3m-current-url)
</p>

<p>
関数なら
(declare-function w3m-current-title &ldquo;ext:w3m-util&rdquo;)
</p>

<p>
と書くことで、読み込み先を指定されてることになるのでbyte-compileのエラーにならなくなる。
</p>
</div>
</div>
<div id="outline-container-orgbabb210" class="outline-3">
<h3 id="orgbabb210"><a href="#orgbabb210">依存インストール</a></h3>
<div class="outline-text-3" id="text-orgbabb210">
<p>
requireかと思いがちだが、一番上の <code>;; Package-Requires: ((emacs "25.1"))</code> で依存インストールに利用されてる。requireはあくまでパッケージを読み込むだけ。
</p>
</div>
</div>
<div id="outline-container-orga341284" class="outline-3">
<h3 id="orga341284"><a href="#orga341284">アクションと検索をわける</a></h3>
<div class="outline-text-3" id="text-orga341284">
<p>
ace-link.elを見ていて、アクションとリンク検索を分けていた。リンク検索する → 決定を押したときのアクションを、それぞれのメジャーモードで判断するというわけだ。
単純で強力。
あとから追加するときも、その例にならえばいくらでもメジャーモードごとの追加ができるというわけだ。
ここから学べることは多いように思える。
</p>

<ul class="org-ul">
<li>(ace-link-info) - エントリーポイント</li>
<li>(ace-link-info-action) - アクション</li>
<li>(ace-link&#x2013;info-current) - collectで使われるユーティリティ</li>
<li>(ace-link&#x2013;info-collect) - リンクに番号をふる</li>
</ul>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">ace-link-info</span> ()
  <span class="org-doc">"Open a visible link in an `</span><span class="org-doc"><span class="org-constant">Info-mode</span></span><span class="org-doc">' buffer."</span>
  (<span class="org-keyword">interactive</span>)
  (<span class="org-keyword">let</span> ((pt (avy-with ace-link-info
              (avy-process
               (mapcar #'cdr
                       (ace-link--info-collect))
               (avy--style-fn avy-style)))))
    (ace-link--info-action pt)))

(<span class="org-keyword">defun</span> <span class="org-function-name">ace-link--info-action</span> (pt)
  (<span class="org-keyword">when</span> (numberp pt)
    (push-mark)
    (goto-char pt)
    (<span class="org-keyword">let</span> ((we (window-end)))
      (<span class="org-keyword">while</span> (not (<span class="org-keyword">ignore-errors</span>
                    (Info-follow-nearest-node)))
        (forward-char 1)
        (<span class="org-keyword">when</span> (&gt; (point) we)
          (<span class="org-warning">error</span> <span class="org-string">"Could not follow link"</span>))))))

(<span class="org-keyword">declare-function</span> Info-follow-nearest-node <span class="org-string">"info"</span>)
(<span class="org-keyword">declare-function</span> Info-next-reference <span class="org-string">"info"</span>)
(<span class="org-keyword">declare-function</span> Info-try-follow-nearest-node <span class="org-string">"info"</span>)
(<span class="org-keyword">declare-function</span> Info-goto-node <span class="org-string">"info"</span>)

(<span class="org-keyword">defun</span> <span class="org-function-name">ace-link--info-current</span> ()
  <span class="org-doc">"Return the node at point."</span>
  (cons (<span class="org-keyword">cl-letf</span> (((symbol-function #'Info-goto-node)
                   (<span class="org-keyword">lambda</span> (node _) node))
                  (browse-url-browser-function
                   (<span class="org-keyword">lambda</span> (url <span class="org-type">&amp;rest</span> _) url)))
          (Info-try-follow-nearest-node))
        (point)))

(<span class="org-keyword">defun</span> <span class="org-function-name">ace-link--info-collect</span> ()
  <span class="org-doc">"Collect the positions of visible links in the current `</span><span class="org-doc"><span class="org-constant">Info-mode</span></span><span class="org-doc">' buffer."</span>
  (<span class="org-keyword">let</span> ((end (window-end))
        points)
    (<span class="org-keyword">save-excursion</span>
      (goto-char (window-start))
      (<span class="org-keyword">when</span> (<span class="org-keyword">ignore-errors</span> (Info-next-reference) t)
        (<span class="org-keyword">push</span> (ace-link--info-current) points)
        (Info-next-reference)
        (<span class="org-keyword">while</span> (<span class="org-keyword">and</span> (&lt; (point) end)
                    (&gt; (point) (cdar points)))
          (<span class="org-keyword">push</span> (ace-link--info-current) points)
          (Info-next-reference))
        (nreverse points)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org52d8f5a" class="outline-3">
<h3 id="org52d8f5a"><a href="#org52d8f5a">マッピング</a></h3>
<div class="outline-text-3" id="text-org52d8f5a">
<p>
(ace-link-setup-default)でマッピングしているところを見つけた。参考になる。
</p>
</div>
</div>
<div id="outline-container-org8fec857" class="outline-3">
<h3 id="org8fec857"><a href="#org8fec857">ディレクトリ探索</a></h3>
<div class="outline-text-3" id="text-org8fec857">
<p>
(add-node-modules-path)はディレクトリ探索の参考になる。1つづつ上がって、node_modules/binを探索する。
コードが短いのも良い。
</p>
</div>
</div>
<div id="outline-container-org12facaf" class="outline-3">
<h3 id="org12facaf"><a href="#org12facaf">名前変換</a></h3>
<div class="outline-text-3" id="text-org12facaf">
<p>
引数の、関数のsymbolを取得する関数。いいな。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">all-the-icons--data-name</span> (name)
  <span class="org-doc">"Get the symbol for an icon family function for icon set NAME."</span>
  (intern (concat <span class="org-string">"all-the-icons-"</span> (downcase (symbol-name name)) <span class="org-string">"-data"</span>)))
</pre>
</div>

<p>
↓みたいに使える。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(funcall (all-the-icons--data-name family))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgaf66f35" class="outline-3">
<h3 id="orgaf66f35"><a href="#orgaf66f35">mapcar</a></h3>
<div class="outline-text-3" id="text-orgaf66f35">
<p>
関数引数の関数はミソ。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">Function: mapcar function sequence

&#12371;&#12398;&#38306;&#25968;&#12399;&#12289;sequence &#12398;&#21508;&#35201;&#32032;&#12395; function &#12434;&#36969;&#29992;(&#35379;&#27880;&#65306;apply)&#12375;&#12289;&#12381;&#12398;&#32080;&#26524;&#12398;&#12522;&#12473;&#12488;&#12434;&#36820;&#12375;&#12414;&#12377;&#12290;sequence &#12364; nil &#12391;&#32066;&#12427;&#12522;&#12473;&#12488;&#12391;&#12394;&#12356;&#22580;&#21512;&#12289;&#12456;&#12521;&#12540;&#12395;&#12394;&#12426;&#12414;&#12377;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(mapcar (<span class="org-keyword">function</span> car) '((a b) (c d) (e f)))
=&gt; (a c e)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf466076" class="outline-3">
<h3 id="orgf466076"><a href="#orgf466076">debugger を起動しないようにする</a></h3>
<div class="outline-text-3" id="text-orgf466076">
<p>
何かの拍子に、debugger実行されるようになり、普通に実行できなくなった。
(debugger-list-functions)
で関数を確認。adviceされてるとわかった。
(advice-remove &rsquo;登録関数 &rsquo;debug&#x2013;implement-debug-on-entry) を削除して戻った。
</p>
</div>
</div>
<div id="outline-container-org70c3073" class="outline-3">
<h3 id="org70c3073"><a href="#org70c3073">すべてdebug対象に</a></h3>
<div class="outline-text-3" id="text-org70c3073">
<p>
(edebug-all-defs)
でevalしただけで対象にするように設定する。→ 結局 C-uつけないとできない気が。
regionを選択して、 C-u M-x eval-region
すると範囲内すべてが対象に。
</p>

<p>
オフにするときは(edebug-all-defs)をトグルしてオフにしてから、region指定して <code>M-x eval-region</code>
</p>
</div>
</div>
<div id="outline-container-org40e5e51" class="outline-3">
<h3 id="org40e5e51"><a href="#org40e5e51">外部コマンド系パッケージ</a></h3>
<div class="outline-text-3" id="text-org40e5e51">
<ol class="org-ol">
<li>ユーザ入力やフラグを通してひたすら引数を収集して、compilation に渡す。</li>
<li>コマンドを実行する。</li>
<li>バッファを作成して外部コマンドの結果をいい感じに出力する。</li>
</ol>
</div>
</div>
<div id="outline-container-orgf8e604d" class="outline-3">
<h3 id="orgf8e604d"><a href="#orgf8e604d">avyの流れ</a></h3>
<div class="outline-text-3" id="text-orgf8e604d">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">let</span> ((pt (avy-with ace-link-custom
            (avy-process
             (ace-link--custom-collect) <span class="org-comment-delimiter">; </span><span class="org-comment">&#20803;&#12496;&#12483;&#12501;&#12449;&#12363;&#12425;&#12522;&#12531;&#12463;&#12434;&#21454;&#38598;&#12375;&#12390;((&#21517;&#21069;1 . &#20301;&#32622;1) (&#21517;&#21069;2 . &#20301;&#32622;2)...)&#12522;&#12473;&#12488;&#12395;&#12377;&#12427;</span>
             (avy--style-fn avy-style))))) <span class="org-comment-delimiter">; </span><span class="org-comment">&#12522;&#12531;&#12463;&#25991;&#23383;&#12434;&#34920;&#31034;&#12375;&#12390;&#25805;&#20316;&#12434;&#24453;&#12388;&#12290;</span>
  (ace-link--custom-action pt)) <span class="org-comment-delimiter">; </span><span class="org-comment">&#12450;&#12463;&#12471;&#12519;&#12531;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc6ca036" class="outline-3">
<h3 id="orgc6ca036"><a href="#orgc6ca036">リストのcustomの例</a></h3>
<div class="outline-text-3" id="text-orgc6ca036">
<p>
あとから追加、削除、編集が自由にできる。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defcustom</span> <span class="org-variable-name">devdocs-alist</span>
  '((c-mode           . <span class="org-string">"c"</span>)
    (c++-mode         . <span class="org-string">"c++"</span>)
    (clojure-mode     . <span class="org-string">"clojure"</span>)
    (coffee-mode      . <span class="org-string">"CoffeeScript"</span>)
    (common-lisp-mode . <span class="org-string">"lisp"</span>)
    (cperl-mode       . <span class="org-string">"perl"</span>)
    (css-mode         . <span class="org-string">"css"</span>)
    (elixir-mode      . <span class="org-string">"elixir"</span>)
    (enh-ruby-mode    . <span class="org-string">"ruby"</span>)
    (erlang-mode      . <span class="org-string">"erlang"</span>)
    (gfm-mode         . <span class="org-string">"markdown"</span>)
    (go-mode          . <span class="org-string">"go"</span>)
    (groovy-mode      . <span class="org-string">"groovy"</span>)
    (haskell-mode     . <span class="org-string">"haskell"</span>)
    (html-mode        . <span class="org-string">"html"</span>)
    (java-mode        . <span class="org-string">"java"</span>)
    (js2-mode         . <span class="org-string">"javascript"</span>)
    (js3-mode         . <span class="org-string">"javascript"</span>)
    (less-css-mode    . <span class="org-string">"less"</span>)
    (lua-mode         . <span class="org-string">"lua"</span>)
    (markdown-mode    . <span class="org-string">"markdown"</span>)
    (perl-mode        . <span class="org-string">"perl"</span>)
    (php-mode         . <span class="org-string">"php"</span>)
    (processing-mode  . <span class="org-string">"processing"</span>)
    (puppet-mode      . <span class="org-string">"puppet"</span>)
    (python-mode      . <span class="org-string">"python"</span>)
    (ruby-mode        . <span class="org-string">"ruby"</span>)
    (sass-mode        . <span class="org-string">"sass"</span>)
    (scala-mode       . <span class="org-string">"scala"</span>)
    (tcl-mode         . <span class="org-string">"tcl"</span>))
  <span class="org-doc">"Alist which maps major modes to names of DevDocs documentations."</span>
  <span class="org-builtin">:type</span> '(repeat (cons (symbol <span class="org-builtin">:tag</span> <span class="org-string">"Major mode"</span>)
                       (string <span class="org-builtin">:tag</span> <span class="org-string">"DevDocs documentation"</span>)))
  <span class="org-builtin">:group</span> 'devdocs)
</pre>
</div>

<p>
使う関数すらcustomにできる。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defcustom</span> <span class="org-variable-name">devdocs-build-search-pattern-function</span>
  'devdocs-build-search-pattern-function
  <span class="org-doc">"A function to be called by `</span><span class="org-doc"><span class="org-constant">devdocs-search</span></span><span class="org-doc">'.</span>
<span class="org-doc">It builds search pattern base on some context."</span>
  <span class="org-builtin">:type</span> 'function
  <span class="org-builtin">:group</span> 'devdocs)
</pre>
</div>
</div>
</div>
<div id="outline-container-org3994405" class="outline-3">
<h3 id="org3994405"><a href="#org3994405">Gitリポジトリを調べる</a></h3>
<div class="outline-text-3" id="text-org3994405">
<p>
(locate-dominating-file directory file)
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">cl-defun</span> <span class="org-function-name">eshell-git-prompt--git-root-dir</span>
    (<span class="org-type">&amp;optional</span> (directory default-directory))
  <span class="org-doc">"Return Git root directory name if exist, otherwise, return nil."</span>
  (<span class="org-keyword">let</span> ((root (locate-dominating-file directory <span class="org-string">".git"</span>)))
    (<span class="org-keyword">and</span> root (file-name-as-directory root))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b60b0b" class="outline-3">
<h3 id="org8b60b0b"><a href="#org8b60b0b">変数が束縛されていれば、という表現</a></h3>
<div class="outline-text-3" id="text-org8b60b0b">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">eshell-git-prompt-last-command-status</span> ()
  <span class="org-doc">"Return Eshell last command execution status.</span>
<span class="org-doc">When Eshell just launches, `</span><span class="org-doc"><span class="org-constant">eshell-last-command-status</span></span><span class="org-doc">' is not defined yet,</span>
<span class="org-doc">return 0 (i.e., success)."</span>
  (<span class="org-keyword">if</span> (not (boundp 'eshell-last-command-status))
      0
    eshell-last-command-status))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge1e139c" class="outline-2">
<h2 id="orge1e139c"><a href="#orge1e139c">arielコードメモ</a></h2>
<div class="outline-text-2" id="text-orge1e139c">
<p>
<a href="http://dev.ariel-networks.com/articles/workshop/emacs-lisp-basic/">http://dev.ariel-networks.com/articles/workshop/emacs-lisp-basic/</a>
の元の内容に、たまにコメントをつけて読んだ。
</p>
<ul class="org-ul">
<li>実装を見ている</li>
<li>わかりやすい例</li>
</ul>
</div>
<div id="outline-container-orged2fb68" class="outline-3">
<h3 id="orged2fb68"><a href="#orged2fb68">ring</a></h3>
<div class="outline-text-3" id="text-orged2fb68">
<p>
データ型定義のやり方。型述語の実装。
</p>
<div class="org-src-container">
<pre class="src src-git-permalink">https://github.com/kijimaD/emacs/blob/master/lisp/emacs-lisp/ring.el#L48-L52
</pre>
</div>

<div class="results" id="orgcd51f20">
<p>
(defun ring-p (x)
  &ldquo;Return t if X is a ring; nil otherwise.&rdquo;
  (and (consp x) (integerp (car x))
       (consp (cdr x)) (integerp (cadr x))
       (vectorp (cddr x))))
</p>

</div>
</div>
</div>

<div id="outline-container-orgd0ff202" class="outline-3">
<h3 id="orgd0ff202"><a href="#orgd0ff202">eww</a></h3>
<div class="outline-text-3" id="text-orgd0ff202">
<p>
<a href="https://github.com/kijimaD/emacs/blob/master/lisp/net/eww.el#L1">https://github.com/kijimaD/emacs/blob/master/lisp/net/eww.el#L1</a>
</p>
</div>
</div>
<div id="outline-container-org26f649e" class="outline-3">
<h3 id="org26f649e"><a href="#org26f649e">lisp.h</a></h3>
<div class="outline-text-3" id="text-org26f649e">
<p>
lispシンボルの実装。
<a href="https://github.com/kijimaD/emacs/blob/master/src/lisp.h#L798">https://github.com/kijimaD/emacs/blob/master/src/lisp.h#L798</a>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(type-of 42)
=&gt;integer
(type-of 3.14)
=&gt; float
(type-of <span class="org-string">"foo"</span>)
=&gt; string
(type-of '(1 2))
=&gt; cons
(type-of '[1 2])
=&gt; vector
(type-of 'foo)
=&gt; symbol
(type-of ?a)  <span class="org-comment-delimiter">; </span><span class="org-comment">C&#12398;'a'&#30456;&#24403;&#12290;&#20869;&#37096;&#30340;&#12395;&#12399;&#25968;&#20516;</span>
=&gt; integer
</pre>
</div>
</div>
</div>
<div id="outline-container-org7dd4f43" class="outline-3">
<h3 id="org7dd4f43"><a href="#org7dd4f43">中で起こってること</a></h3>
<div class="outline-text-3" id="text-org7dd4f43">
<p>
<code>(setq foo "FOO")</code> したとき、symbolオブジェクトは以下のようにセットされます。
</p>
<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">// </span><span class="org-comment">lisp.h</span>
<span class="org-keyword">struct</span> <span class="org-type">Lisp_Symbol</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">Lisp_String</span> *<span class="org-variable-name">name</span>;  =&gt; <span class="org-string">"foo"</span>
    Lisp_Object value;  =&gt; <span class="org-string">"FOO"</span>&#12398;&#20516;&#12434;&#25345;&#12388;&#25991;&#23383;&#21015;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12434;&#25351;&#12377;
    Lisp_Object function;  =&gt; &#31354;
    &#30053;
    };
</pre>
</div>

<p>
↑のように作られているオブジェクトを関数で調べてみます。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(symbolp 'foo)    <span class="org-comment-delimiter">; </span><span class="org-comment">&#12471;&#12531;&#12508;&#12523;&#12363;&#21542;&#12363;&#12398;&#21028;&#23450;&#12290;t&#12364;&#30495;&#12290;nil&#12364;&#20605;&#12290;(&#24460;&#36848;)</span>
=&gt; t
(symbol-name 'foo)
=&gt; <span class="org-string">"foo"</span>
(symbol-value 'foo)
=&gt; <span class="org-string">"FOO"</span>
(boundp 'foo)   <span class="org-comment-delimiter">; </span><span class="org-comment">&#20516;&#12475;&#12523;&#12395;&#20516;&#12364;&#12354;&#12428;&#12400;t&#12289;&#12394;&#12369;&#12428;&#12400;nil</span>
=&gt; t
(fboundp 'foo)  <span class="org-comment-delimiter">; </span><span class="org-comment">&#38306;&#25968;&#12475;&#12523;&#12395;&#38306;&#25968;&#12364;&#12354;&#12428;&#12400;t&#12289;&#12394;&#12369;&#12428;&#12400;nil</span>
=&gt; nil
(symbol-function 'foo)
                                        <span class="org-comment-delimiter">; </span><span class="org-comment">&#12414;&#12384;&#35373;&#23450;&#12375;&#12390;&#12356;&#12394;&#12356;&#12398;&#12391;&#12289;&#20170;&#12399;&#12456;&#12521;&#12540;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org61d6d48" class="outline-3">
<h3 id="org61d6d48"><a href="#org61d6d48">クォートの意味</a></h3>
<div class="outline-text-3" id="text-org61d6d48">
<blockquote>
<p>
クォートは「評価しない」ことを指示します。クォートしないと、基本的に評価されてしまいます。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(type-of 'foo)
=&gt; symbol
(type-of foo)
=&gt; string   <span class="org-comment-delimiter">; </span><span class="org-comment">&#35413;&#20385;&#24460;&#12289;&#12388;&#12414;&#12426;&#20516;&#12475;&#12523;&#12398;&#25351;&#12377;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12398;&#22411;&#12364;&#20986;&#21147;&#12373;&#12428;&#12414;&#12377;</span>
</pre>
</div>

<p>
<code>'</code> は <code>quote</code> 関数の略記です。
</p>
</div>
</div>
<div id="outline-container-org96208d1" class="outline-3">
<h3 id="org96208d1"><a href="#org96208d1">シンボルのまとめ</a></h3>
<div class="outline-text-3" id="text-org96208d1">
<blockquote>
<p>
ここまでで分かったこと
</p>

<p>
シンボルは名前を持つ (symbol-name関数で確認可能)
シンボルの値セルは任意のオブジェクトを指す (symbol-value関数で確認可能)
シンボルの指すオブジェクトの型はtype-ofで確認可能
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org5c583bc" class="outline-3">
<h3 id="org5c583bc"><a href="#org5c583bc">コンスセルの表記</a></h3>
<div class="outline-text-3" id="text-org5c583bc">
<blockquote>
<p>
コンスセルとはふたつのポインタ(*)を持ったオブジェクトです。
</p>
</blockquote>
<p>
実装
<a href="https://github.com/kijimaD/emacs/blob/master/src/lisp.h#L1350">https://github.com/kijimaD/emacs/blob/master/src/lisp.h#L1350</a>
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">Lisp_Cons</span>
{
  <span class="org-keyword">union</span>
  {
    <span class="org-keyword">struct</span>
    {
      <span class="org-comment-delimiter">/* </span><span class="org-comment">Car of this cons cell.</span><span class="org-comment-delimiter">  */</span>
      <span class="org-type">Lisp_Object</span> <span class="org-variable-name">car</span>;

      <span class="org-keyword">union</span>
      {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Cdr of this cons cell.</span><span class="org-comment-delimiter">  */</span>
        <span class="org-type">Lisp_Object</span> <span class="org-variable-name">cdr</span>;

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Used to chain conses on a free list.</span><span class="org-comment-delimiter">  */</span>
        <span class="org-keyword">struct</span> <span class="org-type">Lisp_Cons</span> *<span class="org-variable-name">chain</span>;
      } <span class="org-variable-name">u</span>;
    } <span class="org-variable-name">s</span>;
    GCALIGNED_UNION_MEMBER
  } <span class="org-variable-name">u</span>;
};
</pre>
</div>
<p>
最新のコードは若干変わっている。
</p>
<ul class="org-ul">
<li><code>union</code> って何だろう。</li>
<li>2つのポインタ…elispではcarとcdr</li>
</ul>

<blockquote>
<p>
後述するように、コンスセルのcdrが別のコンスセルを指すことで、リスト構造を作ります。コンスセルで作るリスト処理こそがLisp(LISt Processing)の名前の由来でもあります。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org02eca75" class="outline-3">
<h3 id="org02eca75"><a href="#org02eca75">コンスセルの表記</a></h3>
<div class="outline-text-3" id="text-org02eca75">
<p>
<code>("foo" . "bar")</code>
これは内部的に。
</p>
<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">Lisp_Cons</span>
{
  <span class="org-type">Lisp_Object</span> <span class="org-variable-name">car</span>;  =&gt; <span class="org-string">"foo"</span>&#25991;&#23383;&#21015;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12434;&#25351;&#12377;
    Lisp_Object cdr;  =&gt; <span class="org-string">"bar"</span>&#25991;&#23383;&#21015;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12434;&#25351;&#12377;
    };
</pre>
</div>

<p>
オブジェクトが2つ組み合わされたもの。
</p>
</div>
</div>
<div id="outline-container-org3121293" class="outline-3">
<h3 id="org3121293"><a href="#org3121293">コンスセルの生成</a></h3>
<div class="outline-text-3" id="text-org3121293">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(cons <span class="org-string">"foo"</span> <span class="org-string">"bar"</span>)
=&gt; (<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>)
</pre>
</div>

<ul class="org-ul">
<li>consはconstructの略。</li>
</ul>
</div>
</div>
<div id="outline-container-org28e2351" class="outline-3">
<h3 id="org28e2351"><a href="#org28e2351">コンスセルの値</a></h3>
<div class="outline-text-3" id="text-org28e2351">
<p>
コンスセルの値にアクセスするには <code>car</code> と <code>cdr</code> だけ使える。getterメソッドみたいなもの。
</p>

<blockquote>
<p>
car、cdr以外にコンスセルの中を参照する手段はありません。
</p>
</blockquote>

<p>
なるほど。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(car '(<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>))
=&gt; <span class="org-string">"foo"</span>
(cdr '(<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>))
=&gt; <span class="org-string">"bar"</span>
</pre>
</div>

<blockquote>
<p>
Java風に言えば、コンスセルはふたつのprivateフィールドとふたつのアクセサを持つだけの軽いオブジェクトです。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orga63fad6" class="outline-3">
<h3 id="orga63fad6"><a href="#orga63fad6">プログラム自体がオブジェクト</a></h3>
<div class="outline-text-3" id="text-orga63fad6">
<blockquote>
<p>
厳密に言えば、(&ldquo;foo&rdquo; . &ldquo;bar&rdquo;) という文字列は、コンスセルの(Java風に言えば)シリアライズ化した表現です。
後述するように、elispのプログラム自体はリスト表現で書きます。
これの意味することは、プログラム自体がオブジェクトであり、ソースコードはオブジェクトをシリアライズ化しただけの文字列と言えます。
</p>
</blockquote>

<ul class="org-ul">
<li>シリアライズ化。</li>
<li>データとプログラムの区別がない…真髄的なところだということはわかる。</li>
</ul>
</div>
</div>
<div id="outline-container-org68a1fc4" class="outline-3">
<h3 id="org68a1fc4"><a href="#org68a1fc4">なんでもオブジェクト</a></h3>
<div class="outline-text-3" id="text-org68a1fc4">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> foo '(<span class="org-string">"foo"</span> . 42))  <span class="org-comment-delimiter">; </span><span class="org-comment">car&#12395;&#25991;&#23383;&#21015;&#12289;cdr&#12395;&#25968;&#20516;&#12398;&#12467;&#12531;&#12473;&#12475;&#12523;&#12434;&#25351;&#12377;&#12471;&#12531;&#12508;&#12523;foo</span>
=&gt; (<span class="org-string">"foo"</span> . 42)
(<span class="org-keyword">setq</span> bar '(foo . foo))   <span class="org-comment-delimiter">; </span><span class="org-comment">quote&#12399;&#20840;&#20307;&#12395;&#21177;&#12356;&#12390;&#12356;&#12427;&#12398;&#12391;&#12289;car&#12392;cdr&#12398;&#20001;&#26041;&#12364;&#12471;&#12531;&#12508;&#12523;foo</span>
=&gt; (foo . foo)
(symbol-value (car bar))
=&gt; (<span class="org-string">"foo"</span> . 42)
(symbol-value (cdr bar))
=&gt; (<span class="org-string">"foo"</span> . 42)
(<span class="org-keyword">setq</span> bar `(,foo . foo))  <span class="org-comment-delimiter">; </span><span class="org-comment">backquote&#12398;&#20363;</span>
=&gt; ((<span class="org-string">"foo"</span> . 42) . foo)   <span class="org-comment-delimiter">; </span><span class="org-comment">,&#12398;&#12388;&#12356;&#12383;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12399;&#35413;&#20385;&#12290;&#12381;&#12358;&#12391;&#12394;&#12356;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12399;&#26410;&#35413;&#20385;</span>
</pre>
</div>

<p>
bar -&gt; foo -&gt; &ldquo;foo&rdquo; -&gt; 42
</p>

<p>
シンボルを評価すると、値セルを返します。
</p>
</div>
</div>
<div id="outline-container-org0c9aed8" class="outline-3">
<h3 id="org0c9aed8"><a href="#org0c9aed8">cdrが別のコンスセル</a></h3>
<div class="outline-text-3" id="text-org0c9aed8">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(cons <span class="org-string">"foo"</span> '(<span class="org-string">"bar"</span> . <span class="org-string">"baz"</span>))
=&gt; (<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> . <span class="org-string">"baz"</span>)
</pre>
</div>

<p>
<code>("foo" . "bar" "baz")</code> とはならない。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">'(<span class="org-string">"foo"</span> . (<span class="org-string">"bar"</span> . <span class="org-string">"baz"</span>))
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; ("foo" "bar" . "baz")</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org18f54f5" class="outline-3">
<h3 id="org18f54f5"><a href="#org18f54f5">リスト化</a></h3>
<div class="outline-text-3" id="text-org18f54f5">
<p>
最期のcdrをnilにするとリストに。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(cons <span class="org-string">"foo"</span> '(<span class="org-string">"bar"</span> . nil))
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; ("foo" "bar")</span>
</pre>
</div>

<p>
nilじゃないとコンスセルになる(前の節の通り)。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(cons <span class="org-string">"foo"</span> '(<span class="org-string">"bar"</span> . <span class="org-string">"aaa"</span>))
(<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> . <span class="org-string">"aaa"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcbda797" class="outline-3">
<h3 id="orgcbda797"><a href="#orgcbda797">リスト操作</a></h3>
<div class="outline-text-3" id="text-orgcbda797">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(car '(<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>))
=&gt; <span class="org-string">"foo"</span>
(cdr '(<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>))
=&gt; (<span class="org-string">"bar"</span> <span class="org-string">"baz"</span>)
(cdr (cdr '(<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>)))
=&gt; (<span class="org-string">"baz"</span>)    <span class="org-comment-delimiter">; </span><span class="org-comment">dotted pair notation&#12391;&#26360;&#12369;&#12400; ("baz" . nil)</span>
(cdr (cdr (cdr '(<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>))))
=&gt; nil
</pre>
</div>

<p>
面倒だけど、リストの操作が行えます。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> foo <span class="org-string">"a"</span>)
(<span class="org-keyword">setq</span> foo (cons <span class="org-string">"value"</span> foo))   <span class="org-comment-delimiter">; </span><span class="org-comment">&#12522;&#12473;&#12488;foo&#12395;&#35201;&#32032;&#12434;prepend</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; ("value" . "a")</span>
(<span class="org-keyword">setq</span> foo (cons <span class="org-string">"value"</span> foo))   <span class="org-comment-delimiter">; </span><span class="org-comment">&#12373;&#12425;&#12395;prepend</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; ("value" "value" . "a")</span>
(<span class="org-keyword">setq</span> load-path (cons (expand-file-name <span class="org-string">"~/elisp"</span>) load-path))

(list <span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>)  <span class="org-comment-delimiter">; </span><span class="org-comment">&#24341;&#25968;&#12434;&#35201;&#32032;&#12395;&#25345;&#12388;&#12522;&#12473;&#12488;&#12434;&#29983;&#25104;</span>
=&gt; (<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>)

(append '(<span class="org-string">"foo"</span> <span class="org-string">"bar"</span>) '(<span class="org-string">"baz"</span>))  <span class="org-comment-delimiter">; </span><span class="org-comment">&#36899;&#25509;&#12375;&#12383;&#12522;&#12473;&#12488;&#12434;&#29983;&#25104;</span>
=&gt; (<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>)
(<span class="org-keyword">setq</span> load-path (append load-path (list (expand-file-name <span class="org-string">"~/elisp"</span>))))

(car (nthcdr 1 '(<span class="org-string">"foo"</span> <span class="org-string">"bar"</span> <span class="org-string">"baz"</span>)))   <span class="org-comment-delimiter">; </span><span class="org-comment">N&#30058;&#30446;&#12398;&#35201;&#32032;&#12398;&#21462;&#24471;</span>
=&gt; <span class="org-string">"bar"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org1bc4ae0" class="outline-3">
<h3 id="org1bc4ae0"><a href="#org1bc4ae0">評価</a></h3>
<div class="outline-text-3" id="text-org1bc4ae0">
<blockquote>
<p>
コンスセルの評価は次のように行います。
</p>

<p>
リストの先頭要素(先頭のコンスセルのcar)のシンボルの関数セルの指す関数呼び出し
リストの後続要素(先頭以外のコンスセルのcar)を関数の引数として渡す。引数はquoteがなければ、評価してから引数に渡ります
リストの後続要素は、リストであるかもしれません。この場合、内側のリストを評価、つまり関数呼び出しをしてから、外側のリストの関数呼び出しをします(前ページですでにやっていますが)。
</p>
</blockquote>

<ul class="org-ul">
<li>コンスセルとリストの違い。コンスセルは <code>( . )</code> で、最後のcdrがnilでないもの。</li>
<li>リストは最後のcdrがnilのもの。</li>
<li><code>(append '("foo" "bar") '("baz"))</code> の例.
<ol class="org-ol">
<li>リストの先頭要素 <code>append</code> の関数セルの指す関数を呼び出す。</li>
<li>リストの後続要素 <code>'("foo" "bar") '("baz")</code> が引数として呼び出される。quoteがあるので評価されない。リストのときは評価=関数呼び出しを1.と同様に内側→外側の順に行う。</li>
</ol></li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">plus1</span> (n)
  (+ n 1))
=&gt; plus1
(plus1 10)
=&gt; 11
(<span class="org-keyword">defun</span> <span class="org-function-name">my-plus</span> (m n)
  (+ m n))
=&gt; my-plus
(my-plus 2 5)
=&gt; 7
</pre>
</div>

<blockquote>
<p>
関数の戻り値(=関数の評価結果)は、関数本体の最後の評価結果です
</p>
</blockquote>

<p>
なるほど。
</p>
</div>
</div>
<div id="outline-container-org5d164ad" class="outline-3">
<h3 id="org5d164ad"><a href="#org5d164ad">関数に名前はない</a></h3>
<div class="outline-text-3" id="text-org5d164ad">
<blockquote>
<p>
defunを見て、関数に名前があると思うのは間違いです。
</p>

<p>
defunは、シンボルを作って、その関数セルが関数定義を指すようにしています。
</p>
</blockquote>

<p>
シンボルの定義を思い返してみます。
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">// </span><span class="org-comment">lisp.h</span>
<span class="org-keyword">struct</span> <span class="org-type">Lisp_Symbol</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">Lisp_String</span> *<span class="org-variable-name">name</span>;  =&gt; <span class="org-string">"foo"</span>
    Lisp_Object value;  =&gt; <span class="org-string">"FOO"</span>&#12398;&#20516;&#12434;&#25345;&#12388;&#25991;&#23383;&#21015;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12434;&#25351;&#12377;
    Lisp_Object function;  =&gt; &#31354;
    &#30053;
    };
</pre>
</div>

<p>
確かに関数定義を指しています。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">foo</span> () (message <span class="org-string">"a"</span>))
(symbolp 'foo)
=&gt; t
(symbol-name 'foo)
=&gt; <span class="org-string">"foo"</span>
(symbol-value 'foo)
=&gt; error: (void-variable foo)
(symbol-function 'foo)
=&gt; (<span class="org-keyword">lambda</span> nil (message <span class="org-string">"a"</span>))
(boundp 'foo)
=&gt; nil
(fboundp 'foo) <span class="org-comment-delimiter">; </span><span class="org-comment">&#38306;&#25968;&#23450;&#32681;</span>
=&gt; t
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf36b99a" class="outline-3">
<h3 id="orgf36b99a"><a href="#orgf36b99a">既存関数も同じ</a></h3>
<div class="outline-text-3" id="text-orgf36b99a">
<p>
どれもシンボルで、関数定義を指しています。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(symbol-function 'car)
=&gt; #&lt;subr car&gt;
(symbol-function 'defun)
=&gt; #&lt;subr defun&gt;
(symbol-function '+)
=&gt; #&lt;subr +&gt;
</pre>
</div>

<blockquote>
<p>
subr(subroutineの略)は、Cで書かれた関数を意味しています。
</p>

<p>
構造(シンボルcarやシンボルdefunがあり、それらの関数セルが関数定義を指す)は同じです。
</p>
</blockquote>

<p>
subrそうだったのか。 <code>#&lt;&gt;</code> はどういう意味なのだろう。
</p>
</div>
</div>
<div id="outline-container-orge1d36b7" class="outline-3">
<h3 id="orge1d36b7"><a href="#orge1d36b7">fset</a></h3>
<div class="outline-text-3" id="text-orge1d36b7">
<blockquote>
<p>
値セルにsetqやsetがあったように、関数セルにはfsetがあります(fsetqはありません)。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(fset 'my-plus2
      '(lambda (n) (+ n 2)))   <span class="org-comment-delimiter">; </span><span class="org-comment">defun&#12392;&#21516;&#12376;</span>
=&gt; (<span class="org-keyword">lambda</span> (n) (+ n 2))
(my-plus2 10)
=&gt; 12
</pre>
</div>

<p>
関数セルと値セルを確認します。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> foo <span class="org-string">"foo"</span>)
=&gt; <span class="org-string">"foo"</span>
(fset 'foo '(lambda (s) (concat s <span class="org-string">"bar"</span>))) <span class="org-comment-delimiter">; </span><span class="org-comment">&#21517;&#21069;&#12392;&#12522;&#12473;&#12488;&#12398;&#32068;&#12415;&#21512;&#12431;&#12379;&#12290;&#12393;&#12385;&#12425;&#12418;&#26410;&#35413;&#20385;&#12391;&#28193;&#12377;&#12290;</span>
=&gt; (<span class="org-keyword">lambda</span> (s) (concat s <span class="org-string">"bar"</span>))
(foo foo)
=&gt; <span class="org-string">"foobar"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org1728045" class="outline-3">
<h3 id="org1728045"><a href="#org1728045">lambda</a></h3>
<div class="outline-text-3" id="text-org1728045">
<p>
<a href="https://github.com/kijimaD/emacs/blob/master/lisp/subr.el#L106">https://github.com/kijimaD/emacs/blob/master/lisp/subr.el#L106</a>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">lambda</span> (&#24341;&#25968; ...) (&#38306;&#25968;&#26412;&#20307;))
</pre>
</div>

<p>
処理の中身。名前と組み合わせると関数になります。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((<span class="org-keyword">lambda</span> (m n) (+ m n)) 2 5)
=&gt; 7
</pre>
</div>

<p>
関数定義。declare(&#x2026;関数やマクロに関する情報、infoで出てくる文章)の箇所を除くとこれだけです。
引数cdr(処理したい内容)でコンスセルを作って、関数セルと組み合わせてリストを作ります。なので名前はありません。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">lambda</span> (<span class="org-type">&amp;rest</span> cdr)
  (list 'function (cons 'lambda cdr)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org4f24826" class="outline-3">
<h3 id="org4f24826"><a href="#org4f24826">関数とは何か</a></h3>
<div class="outline-text-3" id="text-org4f24826">
<p>
述語関数から見てます。この方法いいですね。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">                                        <span class="org-comment-delimiter">; </span><span class="org-comment">subr.el</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">functionp</span> (object)
  <span class="org-doc">"Non-nil if OBJECT is a type of object that can be called as a function."</span>
  (<span class="org-keyword">or</span> (subrp object) (byte-code-function-p object)
      (eq (car-safe object) 'lambda)
      (<span class="org-keyword">and</span> (symbolp object) (fboundp object))))
</pre>
</div>

<blockquote>
<p>
elispにとって、「関数」とは次の4つのいずれかであることが分かります。
</p>

<ul class="org-ul">
<li>subroutine (Cで書かれた関数)</li>
<li>バイトコンパイルされた関数 (今はあまり気にしないように)</li>
<li>シンボルlambdaで始まるリスト</li>
<li>関数セルが空ではないシンボル</li>
</ul>
</blockquote>
</div>
</div>
<div id="outline-container-orgfdd81d1" class="outline-3">
<h3 id="orgfdd81d1"><a href="#orgfdd81d1">関数呼び出し</a></h3>
<div class="outline-text-3" id="text-orgfdd81d1">
<blockquote>
<p>
リストの先頭要素に「関数」があれば、関数呼び出しになります。
</p>
</blockquote>

<p>
リストがすべてに優先して存在します。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(my-plus 1 3)   <span class="org-comment-delimiter">; </span><span class="org-comment">&#12471;&#12531;&#12508;&#12523;&#12391;&#12354;&#12428;&#12400;&#38306;&#25968;&#12475;&#12523;&#12398;&#25351;&#12377;&#38306;&#25968;&#12434;&#21628;&#12403;&#20986;&#12377;</span>
=&gt; 4
((<span class="org-keyword">lambda</span> (m n) (+ m n)) 1 3)   <span class="org-comment-delimiter">; </span><span class="org-comment">&#12471;&#12531;&#12508;&#12523;lambda&#12391;&#22987;&#12414;&#12427;&#12522;&#12473;&#12488;&#12418;&#12300;&#38306;&#25968;&#12301;</span>
=&gt; 4
</pre>
</div>
</div>
</div>
<div id="outline-container-org2a2c674" class="outline-3">
<h3 id="org2a2c674"><a href="#org2a2c674">funcall</a></h3>
<div class="outline-text-3" id="text-org2a2c674">
<blockquote>
<p>
funcall関数は引数の1番目を関数として呼びます。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(funcall 'my-plus 1 3)
=&gt; 4
(funcall '(lambda (m n) (+ m n)) 1 3)
=&gt; 4
</pre>
</div>

<ul class="org-ul">
<li><code>'(lambda (m n) (+ m n))</code> は関数として呼ばれる。</li>
</ul>
<p>
<code>- (lambda (m n) (+ m n))</code> でもいいみたい。
</p>

<p>
違いは何だっけ。&#x2026; 評価して渡されるか。この場合は関数なので、評価されるのがいつでも結果は変わらない。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(funcall '(lambda () (+ 1 2)))
(<span class="org-keyword">if</span> (eq 1 (+ 1)) 1) <span class="org-comment-delimiter">; </span><span class="org-comment">1</span>
(<span class="org-keyword">if</span> (eq 1 '(+ 1)) 1) <span class="org-comment-delimiter">; </span><span class="org-comment">nil</span>

(+ (+ 1) 1) <span class="org-comment-delimiter">; </span><span class="org-comment">2</span>
(+ '(+ 1) 1) <span class="org-comment-delimiter">; </span><span class="org-comment">(wrong-type-argument number-or-marker-p (+ 1))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd159d02" class="outline-3">
<h3 id="orgd159d02"><a href="#orgd159d02">値セルにlambda</a></h3>
<div class="outline-text-3" id="text-orgd159d02">
<p>
つまり、値を関数でも呼び出せます。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> foo '(lambda (m n) (+ m n)))
=&gt; (<span class="org-keyword">lambda</span> (m n) (+ m n))
(funcall foo 2 5)
=&gt; 7
</pre>
</div>

<p>
なるほど…。
</p>
</div>
</div>
<div id="outline-container-orgaf01eec" class="outline-3">
<h3 id="orgaf01eec"><a href="#orgaf01eec">明示的に空にする</a></h3>
<div class="outline-text-3" id="text-orgaf01eec">
<blockquote>
<p>
(makunbound &rsquo;foo)   ;値セルを空にする
=&gt; foo
(fmakunbound &rsquo;foo)  ;関数セルを空にする
=&gt; foo
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org1a65d66" class="outline-3">
<h3 id="org1a65d66"><a href="#org1a65d66">連想リスト(association list)</a></h3>
<div class="outline-text-3" id="text-org1a65d66">
<div class="org-src-container">
<pre class="src src-emacs-lisp">'((<span class="org-string">"foo"</span> . <span class="org-string">"FOO"</span>) (<span class="org-string">"bar"</span> . <span class="org-string">"BAR"</span>) (<span class="org-string">"baz"</span> . <span class="org-string">"BAZ"</span>))
</pre>
</div>

<p>
リストの要素がコンスセル。
</p>
</div>
</div>
<div id="outline-container-org38e9faf" class="outline-3">
<h3 id="org38e9faf"><a href="#org38e9faf">配列</a></h3>
<div class="outline-text-3" id="text-org38e9faf">
<blockquote>
<p>
配列は次の4つに分類できます。
</p>

<ul class="org-ul">
<li>ベクタ</li>
<li>文字列</li>
<li>文字テーブル</li>
<li>ブールベクタ</li>
</ul>
</blockquote>

<blockquote>
<p>
言語仕様として「配列」があると言うより、次のarrayp述語で「配列」型(基本型では無い)が定義されているようなものです。
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">// </span><span class="org-comment">data.c</span>
DEFUN (<span class="org-string">"arrayp"</span>, Farrayp, Sarrayp, 1, 1, 0, <span class="org-string">"Return t if OBJECT is an array (string or vector)."</span>)
  (object)
  <span class="org-type">Lisp_Object</span> <span class="org-variable-name">object</span>;
{
  <span class="org-keyword">if</span> (VECTORP (object) || STRINGP (object)
      || CHAR_TABLE_P (object) || BOOL_VECTOR_P (object))
    <span class="org-keyword">return</span> Qt;
  <span class="org-keyword">return</span> Qnil;
}
</pre>
</div>

<p>
ベクタ/文字/文字テーブル/ブールベクタであればarray。なんだそりゃ。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(arrayp '(1 2)) <span class="org-comment-delimiter">; </span><span class="org-comment">nil</span>
(arrayp <span class="org-string">"aaa"</span>)  <span class="org-comment-delimiter">; </span><span class="org-comment">t</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org6ed9854" class="outline-3">
<h3 id="org6ed9854"><a href="#org6ed9854">ベクタ</a></h3>
<div class="outline-text-3" id="text-org6ed9854">
<div class="org-src-container">
<pre class="src src-emacs-lisp">[1 3 5]
=&gt; [1 3 5]
(vectorp [1 3 5])
=&gt; t
(<span class="org-keyword">setq</span> foo [1 3 5])    <span class="org-comment-delimiter">; </span><span class="org-comment">quote&#12375;&#12390;&#12418;&#12375;&#12394;&#12367;&#12390;&#12418;&#21516;&#12376;</span>
=&gt; [1 3 5]
(vectorp foo)
=&gt; t
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf928a63" class="outline-3">
<h3 id="orgf928a63"><a href="#orgf928a63">ベクタの操作</a></h3>
<div class="outline-text-3" id="text-orgf928a63">
<div class="org-src-container">
<pre class="src src-emacs-lisp">
</pre>
</div>
</div>
</div>
<div id="outline-container-org30f9988" class="outline-3">
<h3 id="org30f9988"><a href="#org30f9988">元ページ再掲</a></h3>
<div class="outline-text-3" id="text-org30f9988">
<p>
<a href="http://dev.ariel-networks.com/articles/workshop/emacs-lisp-basic/">http://dev.ariel-networks.com/articles/workshop/emacs-lisp-basic/</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org30b7326" class="outline-2">
<h2 id="org30b7326"><a href="#org30b7326">リスト遊び</a></h2>
<div class="outline-text-2" id="text-org30b7326">
</div>
<div id="outline-container-orgc0453b1" class="outline-3">
<h3 id="orgc0453b1"><a href="#orgc0453b1">リスト</a></h3>
<div class="outline-text-3" id="text-orgc0453b1">
<ul class="org-ul">
<li>リストを構成するセルのCDRは <code>m</code> ，セルかnilを指している。</li>
</ul>
<p>
しかしポイントはなんでも指せるので、CDRはアトム(整数とか)も参照できる。
CARが1。CDRが2のセルは、表記方法では表現できない。
これを表現するために、ドット対表記が用意されている。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(cons 1 (cons 2 nil))
=&gt; (1 2)

(cons 1 2)
=&gt; (1 . 2)
</pre>
</div>

<p>
nilで終端しないセルはドット対で表記する。
この方法で表現すると、
(1) =&gt; (1. nil)
(1 2 3) =&gt; (1 . (2 . (3. nil)))
みたいになる。ドット対は連想リストで用いられる。
</p>
</div>
</div>
<div id="outline-container-org63984b6" class="outline-3">
<h3 id="org63984b6"><a href="#org63984b6">Lispのデータ</a></h3>
<div class="outline-text-3" id="text-org63984b6">
<ul class="org-ul">
<li>セル(1対のポインタ。consで作られる。CARとCDRが指しているポインタが指すデータを見るには、carとcdrを用いる)</li>
<li>アトム(セル以外。整数とか)</li>
</ul>
</div>
</div>
<div id="outline-container-org92265de" class="outline-3">
<h3 id="org92265de"><a href="#org92265de">Lispの評価</a></h3>
<div class="outline-text-3" id="text-org92265de">
<ul class="org-ul">
<li>式がセルなら関数を呼び出す。第1要素のシンボルの指す関数を実行する。引数は評価する。</li>
<li>式がアトムならその値を返す。</li>
</ul>
</div>
</div>
<div id="outline-container-org1472fc0" class="outline-3">
<h3 id="org1472fc0"><a href="#org1472fc0">quote</a></h3>
<div class="outline-text-3" id="text-org1472fc0">
<p>
クオートをつけると評価せずそのまま返す。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">quote</span> (1 2))
=&gt; (1 2)

&#21516;&#12376;&#24847;&#21619;:
'(1 2)

(<span class="org-keyword">setq</span> dog 5)
dog
=&gt; 5   <span class="org-comment-delimiter">; </span><span class="org-comment">&#35413;&#20385;&#32080;&#26524;</span>
'dog
=&gt; dog <span class="org-comment-delimiter">; </span><span class="org-comment">&#12471;&#12531;&#12508;&#12523;&#33258;&#36523;&#12434;&#34920;&#29694;&#12377;&#12427;</span>
</pre>
</div>

<p>
(setq dog &ldquo;dog&rdquo;)
はシンボルdog(評価しない)に、&ldquo;dog&rdquo;を入れるということ。
</p>
</div>
</div>
<div id="outline-container-org0e00285" class="outline-3">
<h3 id="org0e00285"><a href="#org0e00285">ポインタ</a></h3>
<div class="outline-text-3" id="text-org0e00285">
<p>
変数から変数への代入は、ポインタを複製するということ。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> x 'dog)
(<span class="org-keyword">setq</span> y 'dog)
(eq x y)
=&gt; t
(<span class="org-keyword">setq</span> z y)
(eq y z)
=&gt; t
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> x <span class="org-string">"dog"</span>)
(<span class="org-keyword">setq</span> y <span class="org-string">"dog"</span>)
(eq x y)
=&gt; nil <span class="org-comment-delimiter">; </span><span class="org-comment">&#21516;&#12376;&#20013;&#36523;&#12398;&#25991;&#23383;&#21015;&#12384;&#12364;&#12289;&#25351;&#12375;&#12390;&#12356;&#12427;&#12509;&#12452;&#12531;&#12479;&#12364;&#30064;&#12394;&#12427;&#12383;&#12417;&#12290;</span>
(<span class="org-keyword">setq</span> z y)
(eq y z)
=&gt; t   <span class="org-comment-delimiter">; </span><span class="org-comment">&#25351;&#12375;&#12390;&#12356;&#12427;&#12509;&#12452;&#12531;&#12479;&#12364;&#21516;&#12376;&#12383;&#12417;</span>
</pre>
</div>

<p>
変数はポインタを格納する箱。
</p>
</div>
</div>
</div>
<div id="outline-container-orgf9e339a" class="outline-2">
<h2 id="orgf9e339a"><a href="#orgf9e339a">On Lisp</a></h2>
<div class="outline-text-2" id="text-orgf9e339a">
<p>
<a href="http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/preface.html">On Lisp &#x2014; 前書き</a>
</p>
</div>
<div id="outline-container-org90b14ce" class="outline-3">
<h3 id="org90b14ce"><a href="#org90b14ce">もう1つの関数定義</a></h3>
<div class="outline-text-3" id="text-org90b14ce">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">double</span> (x) (* x 2))
#'double <span class="org-comment-delimiter">; </span><span class="org-comment">&#38306;&#25968;&#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12434;&#24471;&#12427;</span>

#'(lambda (x) (* x 2))
</pre>
</div>

<blockquote>
<p>
名前が関数呼び出しの先頭かシャープクォートの次に来ると関数への参照と見
なされ， それ以外では変数名と見なされる．
</p>
</blockquote>
<p>
なので(double double)とかも可能。変数と関数の名前空間が異なっている。
</p>

<ul class="org-ul">
<li>関数は普通のデータオブジェクト。なので変数が値として関数を持てる。</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> x #'append)
</pre>
</div>

<p>
2つの式は大体同じことをしている。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">double</span> (x) (* x 2))

(<span class="org-keyword">setf</span> (symbol-function 'double)
      #'(lambda (x) (* x 2)))
</pre>
</div>

<p>
手続き定義…名前をコードと関連付ける。
</p>

<blockquote>
<p>
関数を作るのにdefunは必要ではなく， 関数は何かのシンボルの値と
して保存されなくてもいい．
defunの背後には， もっと一般的な仕組みが隠れている： 関数を作ることと，
それをある名前に関連づけることは別々の働きだ． Lispの関数の概念の一般性
全体までは必要ないとき， defunはもっと制限の強いプログラミング言語と同
じ位単純に関数定義を行う．
</p>
</blockquote>

<p>
applyは、オブジェクトを関数として実行する。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 1 2)
(apply #'+ '(1 2))
(apply (symbol-function '+) '(1 2))
(apply #'(lambda (x y) (+ x y)) '(1 2))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf846da8" class="outline-3">
<h3 id="orgf846da8"><a href="#orgf846da8">クロージャ</a></h3>
<div class="outline-text-3" id="text-orgf846da8">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">make-adder</span> (n)
  #'(lambda (x) (+ x n)))
</pre>
</div>

<p>
は数を取り，「呼ばれると引数にその数を加えるクロージャ」を返す． その足
し算関数のインスタンスは幾らでも作ることができる。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">&gt; (<span class="org-keyword">setq</span> add2 (make-adder 2)
        add10 (make-adder 10))
#&lt;Interpreted-Function BF162E&gt;
&gt; (funcall add2 5)
7
&gt; (funcall add10 3)
13
</pre>
</div>

<p>
変数に引数をとった関数を入れる。すごいな。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">make-dbms</span> (db)
  (list
   #'(lambda (key)
       (cdr (assoc key db)))
   #'(lambda (key val)
       (<span class="org-keyword">push</span> (cons key val) db)
       key)
   #'(lambda (key)
       (<span class="org-keyword">setf</span> db (delete key db <span class="org-builtin">:key</span> #'car))
       key)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org74787f6" class="outline-3">
<h3 id="org74787f6"><a href="#org74787f6">末尾再帰</a></h3>
<div class="outline-text-3" id="text-org74787f6">
<p>
再帰関数とは自分自身を呼び出す関数だ． そして関数呼び出しの後に行うべき
作業が残っていなければ， その呼び出しは\emph{末尾再帰}だ． 次の関数は末
尾再帰でない。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">our-length</span> (lst)
  (<span class="org-keyword">if</span> (null lst)
      0
    (1+ (our-length (cdr lst)))))

</pre>
</div>

<p>
再帰呼び出しから戻った後，結果を1+ に渡さなければいけないからだ． しか
し次の関数は末尾再帰だ。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">our-find-if</span> (fn lst)
  (<span class="org-keyword">if</span> (funcall fn (car lst))
      (car lst)
    (our-find-if fn (cdr lst))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org7647b70" class="outline-3">
<h3 id="org7647b70"><a href="#org7647b70">抽象化</a></h3>
<div class="outline-text-3" id="text-org7647b70">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">1st</span> (exp) (car exp))
(<span class="org-keyword">defun</span> <span class="org-function-name">2nd</span> (exp) (car (cdr exp)))
(<span class="org-keyword">defun</span> <span class="org-function-name">3rd</span> (exp) (car (cdr (cdr exp))))

(<span class="org-keyword">setq</span> order-func1 '((OP . 2nd) (ARG1 . 1st) (ARG2 . 3rd)))
(<span class="org-keyword">setq</span> order-func2 '((OP . 1st) (ARG1 . 2nd) (ARG2 . 3rd)))

(<span class="org-keyword">defun</span> <span class="org-function-name">order-func</span> (sym odr-db)
  (cdr (assq sym odr-db)))

(<span class="org-keyword">defun</span> <span class="org-function-name">op</span> (exp order-db)
  (funcall (order-func 'OP order-db) exp))
(<span class="org-keyword">defun</span> <span class="org-function-name">arg1</span> (exp order-db)
  (funcall (order-func 'ARG1 order-db) exp))
(<span class="org-keyword">defun</span> <span class="org-function-name">arg2</span> (exp order-db)
  (funcall (order-func 'ARG2 order-db) exp))

(<span class="org-keyword">setq</span> op-func1 '((+ . +) (- . -) (* . *)))
(<span class="org-keyword">setq</span> op-func2 '((add . +) (sub . -) (mul . *)))

(<span class="org-keyword">defun</span> <span class="org-function-name">op-func</span> (sym op-db)
  (cdr (assq sym op-db)))

(<span class="org-keyword">defun</span> <span class="org-function-name">calc</span> (exp op-db odr-db)
  (<span class="org-keyword">cond</span>
   ((atom exp) exp)
   (t (funcall
       (op-func (op exp odr-db) op-db)
       (calc (arg1 exp odr-db) op-db odr-db)
       (calc (arg2 exp odr-db) op-db odr-db)))))

(calc '(1 + (2 * 3)) op-func1 order-func1)
(calc '(add 1 (mul 2 3)) op-func2 order-func2)
</pre>
</div>
</div>
</div>
<div id="outline-container-orga8d805b" class="outline-3">
<h3 id="orga8d805b"><a href="#orga8d805b">関数</a></h3>
<div class="outline-text-3" id="text-orga8d805b">
<p>
<a href="http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/functions.html">On Lisp &#x2014; 関数</a>
</p>

<blockquote>
<p>
関数的プログラミングとは，副作用ではなく， 値を返すことで動作するプログ
ラムを書くことだ．
</p>

<p>
副作用とはオブジェクトの破壊的な変更（rplacaの使用等）
や変数への代入（setqの使用等）を含む．
</p>

<p>
reverse等のオペレータは，副作用でなく返
り値のために呼ばれるよう意図されている
</p>
</blockquote>

<p>
setqを使うときはたいてい副作用だ。
lispのほとんどの関数は副作用のために呼ばれることを意図されていない。
だから副作用がほしいときはsetqを使う。
</p>

<blockquote>
<p>
この習慣を育てるには時間がかかるかもしれない． 一つの方法は，以下のオペ
レータは税金がかかっているつもりで扱うことだ：
</p>

<p>
set setq setf psetf psetq incf decf push pop pushnew
rplaca rplacd rotatef shiftf remf remprop remhash
</p>

<p>
あとlet*もそうだ． この中に命令的プログラムが潜んでいることがしばしばあ
る． これらのオペレータに税金がかかっているつもりになるのは， よいLisp
のプログラミング・スタイルへ向かう手助けとして勧めただけで， それがよい
スタイルの基準なのではない． しかし，それだけでもずいぶん進歩できるだろ
う．
</p>
</blockquote>

<p>
上は危険。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">&gt; (multiple-value-bind (int frac) (truncate 26.21875)
    (list int frac))
(26 0.21875)
</pre>
</div>

<p>
多値。
</p>

<p>
関数的プログラムは，それが欲しがるものを求める。
命令的プログラムは，何をすべきかの指示を求める。
</p>

<p>
関数的プログラムの 「aと， <code>x</code> の第1要素の2乗から成るリスト
を返せ．」
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">fun</span> (x)
  (list 'a (expt (car x) 2)))
</pre>
</div>

<p>
命令的プログラミングではこうだ． 「xの第1要素を求め，それを2乗せよ． そ
してaと，先程2乗した値から成るリストを返せ．」
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">imp</span> (x)
  (<span class="org-keyword">let</span> (y sqr)
    (<span class="org-keyword">setq</span> y (car x))
    (<span class="org-keyword">setq</span> sqr (expt y 2))
    (list 'a sqr)))
</pre>
</div>

<blockquote>
<p>
その方法は，命令的プログラムは関数的プログラムを裏返しにしたものと思う
ことだ． 関数的プログラムが命令的プログラムの中に隠れているのを見つける
には， ただ裏返しにすればいい． この方法をimpで試してみよう．
</p>

<p>
だからルールはこうあるべきだ： 任意の関数呼び出しが， 自分だけが支配す
るオブジェクトを安全に書き換えられるようにする．
</p>

<p>
何が引数と返り値を支配するのだろう？関数呼び出しは返り値として受け取る
オブジェクトを支配するが， 引数として渡されるオブジェクトは支配しない，
というのがLispの慣習のようだ． 引数に変更を加える関数は「破壊的」との呼
び名で区別されるが， 返ってくるオブジェクトに変更を加える関数には特に呼
び名がない．
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org32e18b2" class="outline-3">
<h3 id="org32e18b2"><a href="#org32e18b2">ユーティリティ関数</a></h3>
<div class="outline-text-3" id="text-org32e18b2">
<p>
<a href="http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/utilityFunctions.html">On Lisp &#x2014; ユーティリティ関数</a>
</p>

<blockquote>
<p>
Common Lispのオペレータは3種類に分かれる： 関数にマクロ（ユーザが作れる
もの）と，特殊オペレータ（ユーザには作れない）だ． この章では，Lispを新
しい関数で拡張するテクニックを説明する． しかしここで言う「テクニック」
は普通の意味のものではない． そういった関数について知るべき重要な点は，
それらをどうやって書くかということではなく，それらがどこから来たのかと
いうことだ． Lispの拡張には，他の関数を書くときと大体同じテクニックが使
われることになる． そういった拡張を書くとき難しいのは， どうやって書く
かを決めることではなく，何を書くかを決めることだ．
</p>
</blockquote>

<p>
ユーティリティ関数について。
最初は本屋を検索する関数をこう書いた。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">find-books</span> (towns)
  (<span class="org-keyword">if</span> (null towns)
      nil
    (<span class="org-keyword">let</span> ((shops (bookshops (car towns))))
      (<span class="org-keyword">if</span> shops
          (values (car towns) shops)
        (find-books (cdr towns))))))
</pre>
</div>

<p>
本当に欲しいのは(val ues (car towns) shops)だ。
これは一般化できる。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">find2</span> (fn lst)
  (<span class="org-keyword">if</span> (null lst)
      nil
    (<span class="org-keyword">let</span> ((val (funcall fn (car lst))))
      (<span class="org-keyword">if</span> val
          (values (car lst) val)
        (find2 fn (cdr lst))))))
</pre>
</div>

<p>
(find2 #&rsquo;bookshops towns)
だけで達成できるようになった。引数で関数を渡すようになった。
</p>

<blockquote>
<p>
Lispプログラミング独特の特徴の一つは，引数としての関数の重要性だ． これ
はLispがボトムアップ・プログラミングに適している理由の一部だ． 関数の骨
格を抽象化するのは，引数に関数を使うことで肉付けができるときには比較的
簡単だ．
</p>
</blockquote>

<p>
なるほど。
</p>

<blockquote>
<p>
Lispでは関数全体を引数として渡せるので，この考えをさらに深めることがで
きる． 前述の例の両方で，特定の関数から始めて，関数を引数に取る一般的な
関数に進んだ． 1番目の例ではすでに定義されていたmapcanを使い， 2番目の例
では新しいユーティリティfind2を書いたが， 全体的な原則は同じだ： 一般部
分と個別部分を混ぜ合わせるのでなく， 一般部分を定義して個別部分を引数と
して渡すこと．
</p>
</blockquote>

<p>
filterは関数と1個のリストを取り， その関数がリスト適用されたときに非
nil値が返されるような要素全てをリストにして返す。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">&gt; (filter #'(lambda (x) (<span class="org-keyword">if</span> (numberp x) (1+ x)))
          '(a 1 2 b 3 c d 4))
(2 3 4 5)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">longer</span> (x y)
  (labels ((compare (x y)
                    (<span class="org-keyword">and</span> (consp x)
                         (<span class="org-keyword">or</span> (null y)
                             (compare (cdr x) (cdr y))))))
    (<span class="org-keyword">if</span> (<span class="org-keyword">and</span> (listp x) (listp y))
        (compare x y)
      (&gt; (length x) (length y)))))

(<span class="org-keyword">defun</span> <span class="org-function-name">filter</span> (fn lst)
  (<span class="org-keyword">let</span> ((acc nil))
    (<span class="org-keyword">dolist</span> (x lst)
      (<span class="org-keyword">let</span> ((val (funcall fn x)))
        (<span class="org-keyword">if</span> val (<span class="org-keyword">push</span> val acc))))
    (nreverse acc)))

(<span class="org-keyword">defun</span> <span class="org-function-name">group</span> (source n)
  (<span class="org-keyword">if</span> (zerop n) (<span class="org-warning">error</span> <span class="org-string">"zero length"</span>))
  (labels ((rec (source acc)
                (<span class="org-keyword">let</span> ((rest (nthcdr n source)))
                  (<span class="org-keyword">if</span> (consp rest)
                      (rec rest (cons (subseq source 0 n) acc))
                    (nreverse (cons source acc))))))
    (<span class="org-keyword">if</span> source (rec source nil) nil)))
</pre>
</div>

<p>
さまざまな検索ユーティリティ。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">&gt; (split-if #'(lambda (x) (&gt; x 4))
            '(1 2 3 4 5 6 7 8 9 10))
(1 2 3 4)
(5 6 7 8 9 10)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">mapa-b</span> (fn a b <span class="org-type">&amp;optional</span> (step 1)
                  (map-&gt; fn
                         a
                         #'(lambda (x) (&gt; x b))
                         #'(lambda (x) (+ x step)))
</pre>
</div>

<p>
うーむ。急にむずかしくなってよくわからないぞ。
対応付け関数というのは役立ちそうだが。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">map-&gt;</span> (fn start test-fn succ-fn)
  (do ((i start (funcall succ-fn i))
       (result nil))
      ((funcall test-fn i) (nreverse result))
    (<span class="org-keyword">push</span> (funcall fn i) result)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org1076803" class="outline-3">
<h3 id="org1076803"><a href="#org1076803">シンボルとストリング</a></h3>
<div class="outline-text-3" id="text-org1076803">
<p>
新しく作るユーティリティについて。
</p>
<blockquote>
<p>
それらの新オペレータは，どれも（議論の余地はあるが）プログラムを読み辛
くしてしまう． プログラムを読み取れるようになる前に，それらのユーティリ
ティを全て理解しなければいけない． こういった言明がなぜ誤解されるのかに
ついては， popページで説明した例（一番近い書店を探した例）のことを考え
てみて欲しい． そのプログラムをfind2を使って書けば， 「プログラムを読み
取れるようになる前に， この新ユーティリティの定義を理解しなければいけな
いじゃないか．」 と不満を言う人が出てくる． それでは，find2を使わなかっ
たとしてみよう． するとfind2の定義は理解しなくてもいいが， find-booksの
定義を理解しなければいけない． その中ではfind2の仕事が「書店を見つける」
という個別の課題と混ざっている． find2を理解するのはせいぜいfind-books
と同じくらい難しいだけだ． また，ここでは新ユーティリティは1回しか使っ
ていない． ユーティリティは繰り返し使うよう意図されたものだ． 実際のプ
ログラムでは，find2を理解しなければいけないか， または3, 4個の特定目的
の検索ルーチンを理解しなければいけないかの，どちらかの選択だろう． 前者
の方が確実に簡単だ．
</p>
</blockquote>

<p>
なるほど。十分に抽象的であればほかでも使えるし、理解として蓄積してほかのプログラムを読み書きするときに利用できる。
</p>
</div>
</div>
<div id="outline-container-org67e67c0" class="outline-3">
<h3 id="org67e67c0"><a href="#org67e67c0">返り値としての関数</a></h3>
<div class="outline-text-3" id="text-org67e67c0">
<p>
<a href="http://www.asahi-net.or.jp/~kc7k-nd/onlispjhtml/returningFunctions.html">On Lisp &#x2014; 返り値としての関数</a>
</p>

<blockquote>
<p>
前章では，関数を引数として渡せることが抽象化への可能性をどれ程大きくす
るかを見た． 関数に対して行える操作が豊かな程，その可能性を深く利用でき
る． 新しい関数を生成して返す関数を定義することで， 関数を引数に取るユー
ティリティの効果を増幅できる．
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">joiner</span> (obj)
  (typecase obj
    (cons #'append)
    (number #'+)))
</pre>
</div>

<blockquote>
<p>
これはオブジェクトを引数に取り， その型に応じてそれらのオブジェクトを加
え合わせる関数を返す． これは数やリストに対して働く多態的な
(polymorphic)連結関数の定義に使える：
</p>
</blockquote>
<p>
なるほど。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">complement</span> (fn)
  #'(lambda (<span class="org-type">&amp;rest</span> args) (not (apply fn args))))
&gt; (remove-if (complement #'oddp) '(1 2 3 4 5 6))
(1 3 5)
</pre>
</div>

<blockquote>
<p>
関数を引数として渡せることは抽象化のための強力な道具だ． 関数を返す関数
が書けることで，それを最大限に利用できるようになる． 残りの節では関数を
返すユーティリティの例を幾つか挙げる．
</p>
</blockquote>

<p>
文言のところどころを読んだ覚えがあるのだが、コードは全然覚えてない…。
</p>
</div>
</div>
</div>
<div id="outline-container-org6b6b976" class="outline-2">
<h2 id="org6b6b976"><a href="#org6b6b976">関数メモ</a></h2>
<div class="outline-text-2" id="text-org6b6b976">
</div>
<div id="outline-container-orgaa05eb7" class="outline-3">
<h3 id="orgaa05eb7"><a href="#orgaa05eb7">&#x2013;map</a></h3>
<div class="outline-text-3" id="text-orgaa05eb7">
<p>
<code>map(FORM LIST)</code> はフォームとリストを引数にとり、リストにフォームを適用していく関数。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">--map</span> (* 10 it) '(1 2 3 4 5))
</pre>
</div>

<div class="results" id="orgea8a80d">
<p>
(10 20 30 40 50)
</p>

</div>
</div>
</div>

<div id="outline-container-orge4b23bf" class="outline-3">
<h3 id="orge4b23bf"><a href="#orge4b23bf">seq-some</a></h3>
<div class="outline-text-3" id="text-orge4b23bf">
<p>
<code>seq-some (pred sequence)</code> は述語関数とリストを引数にとり、述語をリストに適用して1つでも条件を満たせば <code>t</code> を返す関数。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(seq-some 'oddp '(1 2 3 4))
</pre>
</div>

<div class="results" id="org064a40d">
<p>
t
</p>

</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(seq-some 'oddp '(2 4))
</pre>
</div>

<div class="results" id="orgcf8f923">
<p>
nil
</p>

</div>
</div>
</div>

<div id="outline-container-org5944483" class="outline-3">
<h3 id="org5944483"><a href="#org5944483">macroexp-progn</a></h3>
<div class="outline-text-3" id="text-org5944483">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(macroexp-progn '(1
                  2
                  3
                  (* 2 2)))
</pre>
</div>

<div class="results" id="org660b0d6">
<p>
(progn 1 2 3 (* 2 2))
</p>

</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(eval (macroexp-progn '(1
                        2
                        3
                        (* 2 2))))
</pre>
</div>

<div class="results" id="org9cb9239">
<p>
4
</p>

</div>
</div>
</div>

<div id="outline-container-org6b65d94" class="outline-3">
<h3 id="org6b65d94"><a href="#org6b65d94">&#x2013;some(form list)</a></h3>
<div class="outline-text-3" id="text-org6b65d94">
<p>
dashライブラリに含まれる関数。
</p>

<p>
LIST内に条件を1つでも満たすものがあればFORMを返す。
LIST要素はitにバインドされる。マクロすごいな。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>リスト1つ1つがitにバインドされる</label><pre class="src src-emacs-lisp">(<span class="org-keyword">--some</span> (evenp it) '(2 4))  <span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; t</span>
(<span class="org-keyword">--some</span> (evenp it) '(1 3)) <span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; nil</span>
(<span class="org-keyword">--some</span> (evenp it) '(1 3 2)) <span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; t</span>
</pre>
</div>

<div class="results" id="org4d5d191">
<p>
t
</p>

</div>

<p>
定義を見ても、どうやってitにバインドしてるのかわからない。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>itは出てない</label><pre class="src src-emacs-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">--some</span> (form list)
  <span class="org-doc">"Return non-nil if FORM evals to non-nil for at least one item in LIST.</span>
<span class="org-doc">If so, return the first such result of FORM.</span>
<span class="org-doc">Each element of LIST in turn is bound to `</span><span class="org-doc"><span class="org-constant">it</span></span><span class="org-doc">' and its index</span>
<span class="org-doc">within LIST to `</span><span class="org-doc"><span class="org-constant">it-index</span></span><span class="org-doc">' before evaluating FORM.</span>
<span class="org-doc">This is the anaphoric counterpart to `</span><span class="org-doc"><span class="org-constant">-some</span></span><span class="org-doc">'."</span>
  (<span class="org-keyword">declare</span> (debug (form form)))
  (<span class="org-keyword">let</span> ((n (make-symbol <span class="org-string">"needle"</span>)))
    `(<span class="org-keyword">let</span> (,n)
       (<span class="org-keyword">--each-while</span> ,list (not (<span class="org-keyword">setq</span> ,n ,form)))
       ,n)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org261800f" class="outline-3">
<h3 id="org261800f"><a href="#org261800f">apply-partially</a></h3>
<div class="outline-text-3" id="text-org261800f">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos <span class="org-string">"apply-partially"</span>)
</pre>
</div>

<p>
どうやって使うのかわからない。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">my-apply-partially</span> (fun <span class="org-type">&amp;rest</span> args)
  (<span class="org-keyword">lambda</span> (<span class="org-type">&amp;rest</span> args2)
    (apply fun (append args args2))))
</pre>
</div>

<div class="results" id="org12cfbb8">
<p>
my-apply-partially
</p>

</div>

<p>
/lisp/subr.el にはいろいろ見慣れた関数があるな。
</p>
</div>
</div>
<div id="outline-container-org05804f0" class="outline-3">
<h3 id="org05804f0"><a href="#org05804f0">buffer-read-only</a></h3>
<div class="outline-text-3" id="text-org05804f0">
<p>
バッファが読み込み専用なら <code>t</code> を返す。
</p>
</div>
</div>
<div id="outline-container-org9703022" class="outline-3">
<h3 id="org9703022"><a href="#org9703022">called-interactively-p</a></h3>
<div class="outline-text-3" id="text-org9703022">
<p>
直に実行してほしくないことがある。privateメソッドのように。
<a href="20210922005248-magit.html#ID-5ba43a42-93cb-48fa-8578-0558c757493f">magit</a>のコードから取ってきた。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>called-interactively-pを使う</label><pre class="src src-emacs-lisp">(magit-blame-mode
 (<span class="org-keyword">when</span> (called-interactively-p 'any)
   (<span class="org-keyword">setq</span> magit-blame-mode nil)
   (<span class="org-warning">user-error</span>
    (concat <span class="org-string">"Don't call `</span><span class="org-string"><span class="org-constant">magit-blame-mode</span></span><span class="org-string">' directly; "</span>
            <span class="org-string">"instead use `</span><span class="org-string"><span class="org-constant">magit-blame</span></span><span class="org-string">'"</span>))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org5440dde" class="outline-3">
<h3 id="org5440dde"><a href="#org5440dde">cl-block</a></h3>
</div>
<div id="outline-container-org2d13f33" class="outline-3">
<h3 id="org2d13f33"><a href="#org2d13f33">declare</a></h3>
<div class="outline-text-3" id="text-org2d13f33">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos <span class="org-string">"declare"</span>)
</pre>
</div>

<p>
謎。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>よく見かける書き方</label><pre class="src src-emacs-lisp">(<span class="org-keyword">declare</span> (indent 2))
</pre>
</div>

<div class="results" id="orgd54cdda">
<p>
nil
</p>

</div>
</div>
</div>

<div id="outline-container-org89e8a8a" class="outline-3">
<h3 id="org89e8a8a"><a href="#org89e8a8a">dolist</a></h3>
<div class="outline-text-3" id="text-org89e8a8a">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>numはリストを構成する要素の名前。(dolist (var list) body)</label><pre class="src src-emacs-lisp">(<span class="org-keyword">let</span> ((nums '(1 2 3 4 5))
      (sum 0))
      (<span class="org-keyword">dolist</span> (num nums)
            (<span class="org-keyword">setq</span> sum (+ sum num)))
      sum)
</pre>
</div>

<div class="results" id="orge2ccff3">
<p>
15
</p>

</div>
</div>
</div>

<div id="outline-container-org79de671" class="outline-3">
<h3 id="org79de671"><a href="#org79de671">format-spec</a></h3>
<div class="outline-text-3" id="text-org79de671">
<p>
フォーマット文字列を入れ込みたいときに使う。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>定数としてフォーマット文字列を決めておいて、あとから埋め込む</label><pre class="src src-emacs-lisp">(<span class="org-keyword">setq</span> my-format <span class="org-string">"%h:%m"</span>)
(<span class="org-keyword">defun</span> <span class="org-function-name">my-format-time</span> (hour minute)
  (format-spec my-format
               `((?h . ,hour)
                 (?m . ,minute))))

(my-format-time 12 59)
</pre>
</div>

<div class="results" id="org2eff8d8">
<p>
12:59
</p>

</div>
</div>
</div>

<div id="outline-container-org1a6286d" class="outline-3">
<h3 id="org1a6286d"><a href="#org1a6286d">line-number-at-pos</a></h3>
<div class="outline-text-3" id="text-org1a6286d">
<p>
行数を求める関数。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>何も引数を渡さないと現在のカーソル位置の行数</label><pre class="src src-emacs-lisp">(line-number-at-pos)
</pre>
</div>

<div class="results" id="org22ac8ce">
<p>
1204
</p>

</div>
</div>
</div>

<div id="outline-container-org59dec6c" class="outline-3">
<h3 id="org59dec6c"><a href="#org59dec6c">looking-at</a></h3>
<div class="outline-text-3" id="text-org59dec6c">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>現在のカーソル位置からあとにマッチするものがあればt</label><pre class="src src-emacs-lisp">(looking-at <span class="org-string">"."</span>)
</pre>
</div>

<div class="results" id="orgd0106ea">
<p>
t
</p>

</div>
</div>
</div>

<div id="outline-container-orgb985058" class="outline-3">
<h3 id="orgb985058"><a href="#orgb985058">open-line</a></h3>
<div class="outline-text-3" id="text-orgb985058">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos <span class="org-string">"open-line"</span>)
</pre>
</div>

<p>
open-lineは改行するコマンド。カーソルは移動しない。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>一行改行する</label><pre class="src src-emacs-lisp">(open-line 1)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7618553" class="outline-3">
<h3 id="org7618553"><a href="#org7618553">push</a></h3>
<div class="outline-text-3" id="text-org7618553">
<p>
(push NEWELT PLACE)
リストを先頭にくっつける関数。
だが、PLACEはsymbolである必要がある。直にリストを入れることはできない。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>リストを作成する</label><pre class="src src-emacs-lisp">(<span class="org-keyword">let</span> ((l '(a b c)))
  (<span class="org-keyword">push</span> 'new l))
</pre>
</div>

<div class="results" id="org7d09650">
<p>
(new a b c)
</p>

</div>
</div>
</div>

<div id="outline-container-org8613876" class="outline-3">
<h3 id="org8613876"><a href="#org8613876">repeat</a></h3>
<div class="outline-text-3" id="text-org8613876">
<p>
最後に実行したコマンドを繰り返す。
</p>
</div>
</div>
<div id="outline-container-orge62f6f3" class="outline-3">
<h3 id="orge62f6f3"><a href="#orge62f6f3">user-error</a></h3>
<div class="outline-text-3" id="text-orge62f6f3">
<p>
エラーを出力する。
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>処理を止め、メッセージを出す</label><pre class="src src-emacs-lisp">(<span class="org-warning">user-error</span> <span class="org-string">"this is error!"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org9418b92" class="outline-3">
<h3 id="org9418b92"><a href="#org9418b92">with-demoted-errors</a></h3>
<div class="outline-text-3" id="text-org9418b92">
<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos <span class="org-string">"with-demoted-errors"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span class="org-keyword">with-demoted-errors</span> <span class="org-string">"&#12371;&#12428;&#12399;&#12456;&#12521;&#12540; %S"</span> (/ 1 0))
</pre>
</div>
<div class="results" id="org3fec8d5">
<p>
nil
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-orgfaf88ae" class="outline-2">
<h2 id="orgfaf88ae"><a href="#orgfaf88ae">Tasks</a></h2>
<div class="outline-text-2" id="text-orgfaf88ae">
</div>
<div id="outline-container-org51011af" class="outline-3">
<h3 id="org51011af"><a href="#org51011af"><span class="todo TODO">TODO</span> <a href="https://qiita.com/kawabata@github/items/9a1a1e211c57a56578d8">Emacs Lispの汎変数 - Qiita</a></a></h3>
<div class="outline-text-3" id="text-org51011af">
<p>
汎変数の解説。
</p>
</div>
</div>

<div id="outline-container-org8b259d7" class="outline-3">
<h3 id="org8b259d7"><a href="#org8b259d7"><span class="todo TODO">TODO</span> 末尾再帰を調べる</a></h3>
<div class="outline-text-3" id="text-org8b259d7">
<p>
Schemeでは実装仕様で末尾再帰を要求してくるとのこと。
</p>
<ul class="org-ul">
<li><a href="http://emacs.rubikitch.com/tco/">tco.el : 【関数型歓喜】えっ、Emacs Lispで末尾再帰の最適化ができる…だと!？</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer class="footer py-3"><div class="container"><div class="row "><div class="col-md-4"></div><div class="col-sm col-md"><nav class="navbar"><a class="nav-link text-secondary small px-0" href="./index.html">Insomnia</a><a class="nav-link text-secondary small px-0" href="./sitemap.html">Sitemap</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD/roam">Repository</a><a class="nav-link text-secondary small px-0" href="https://github.com/kijimaD">@kijimaD</a></nav></div><div class="col-md-4"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"/>
</div>
</body>
</html>
