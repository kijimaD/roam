:PROPERTIES:
:ID:       1658782a-d331-464b-9fd7-1f8233b8b7f8
:END:
#+title: Docker

* 概要
Dockerはパフォーマンスに優れた仮想環境を作るプログラム。
* Memo
** pushスクリプト
[[https://www.amazon.co.jp/dp/B01N0SS6NF/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1][Amazon.co.jp: Deploying Rails with Docker, Kubernetes and ECS (English Edition) eBook : Acuña, Pablo: Foreign Language Books]] に載ってたスクリプト。書いてリポジトリに入れておくとスムーズにビルドやプッシュができる。
レジストリ・ユーザ名・リポジトリを適宜変える。
#+begin_src shell
  #!/bin/sh

  LC=$(git rev-parse --short HEAD)
  docker build -t ghcr.io/kijimad/webapp:${LC} .
  docker push ghcr.io/kijimad/webapp:${LC}
#+end_src
** 実行後にコンテナ削除
docker run するとコンテナ内に入れるが、作ったコンテナはそのままになる。
実行後に削除して欲しい場合は、 ~docker --rm webapp /bin/sh~ などrmオプションを使う。
** コンテナ間の接続はサービス名を用いる
コンテナ間の接続をしようとして、このようなエラーが出た。
#+caption: sidekiq -> redisへ接続したい
#+begin_quote
Error connecting to Redis on 127.0.0.1:6379 (Errno::ECONNREFUSED)
#+end_quote

127.0...とあることから、コンテナ内のアドレスを見に行ってる。
コンテナ間での通信には、サービス名のアドレスを追加する必要がある。

#+caption: redis://redis:6379/15
#+begin_export yaml
  worker:
    build: .
    command: bundle exec sidekiq
    environment:
      REDIS_URL: redis://redis:6379/15 ＃<---別のredisコンテナへの接続
    volumes:
      - .:/app
    links:
      - mysql
      - redis
#+end_export
** rootユーザでファイル作成しないようにする
Dockerコンテナ内でファイルを作成すると、ownerがrootになり編集や削除ができず面倒。
Dockerの内部ではユーザid(uid)やグループid(gid)がホストと異なる。idがホストマシンと合わないためrootとして実行されたことになる、よう。

安易な解決策としては、権限をホストユーザに変更すれば問題ない。
とはいえ、コンテナ内のサービスが新しくファイルを作るたび(たとえばマイグレーションファイル生成)に実行するのは面倒。
[[https://docs.docker.com/samples/rails/][If you are running Docker on Linux, the files rails new created are owned by root.]]
#+caption: 権限変更
#+begin_src shell
  sudo chown -R $USER:$USER .
#+end_src

解決策としてはいくつか種類があるようなのだが、とりあえずできた。
サービスのvolumesにユーザ情報をマウントする。:roは読み取り専用(read onlyか)。
これでidの照合元がホストと同じになる。

#+caption: docker-compose.yml
#+begin_src yaml
  volumes:
    - .:/rails
#+end_src

あとはidを環境変数経由で渡せば、コンテナ内でもホストのユーザが実行したことになる。
#+begin_src shell
  sudo docker run -u "$(id -u $USER):$(id -g $USER)" rails /bin/sh
  sudo docker-compose run -u "$(id -u $USER):$(id -g $USER)" rails /bin/sh
#+end_src

overrideがある場合、このようになる(長すぎ)。
#+begin_src shell
sudo docker-compose -f docker-compose.yml -f docker-compose-app.override.yml run -u "$(id -u $USER):$(id -g $USER)" rails /bin/sh
#+end_src

[[https://blog.amedama.jp/entry/docker-container-host-same-user][Docker コンテナ内で Docker ホストと同じユーザを使う - CUBE SUGAR CONTAINER]]
** Docker Hub
Dockerイメージをインターネット上にアップロードできるスペース。
個別にビルドしなくてよくなるためDocker関連の全工程が高速化する。テスト、ローカル、デプロイ…。
** マルチステージビルドとは
サイトをDockerデプロイにしたり、CIをDockerで行うとき。
複数の環境が関係する場合、マルチステージビルドを行うとキャッシュが効くため高速化できる。

- Linux関連のイメージ
- [[id:cfd092c4-1bb2-43d3-88b1-9f647809e546][Ruby]]関連のイメージ
- node関連のイメージ
- [[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]アプリのイメージ

のように。
Linux → [[id:cfd092c4-1bb2-43d3-88b1-9f647809e546][Ruby]] + node → [[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]] という依存関係になる。
** Dockerfileは何か
Dockrfileはイメージを作る。(image build)
docker-compose upは↑で作られたイメージを元にコンテナを作り起動までする。そのなかアプリケーションを走らせて開発する。

image構築 → コンテナ構築 → コンテナ起動 という流れ。

コンテナの作り方には2種類ある。
- 自作する必要があるものは↑Dockerfileで作る
- 既存コンテナ([[id:7dab097c-60ba-43b9-949f-c58bf3151aa8][MySQL]]とか)はイメージをダウンロードする
** コンテナ内でコマンド実行する
コンテナ内部で実行したいコマンドがあるときにやりたいこと、たとえば[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]だと、gemfileが新しくなったときにbundle installしたい。

runは新しくコンテナを作成し、内部でコマンドを実行する。サービス名はdocker-compose.ymlから取っている。つまり立ち上がっているコンテナ名は関係ないのに注意。何も指定してない場合、docker-compose.ymlからサービス名を決定する。ほかのファイルの場合には-fオプションが必要。外部で永続化される…volumeが指定されてるような処理(bundle install)とか、データベース関係はいいのだが、その他は永続化されないので注意。

#+caption: run
#+begin_src shell
  docker-compose run {サービス名} {shellコマンド}
#+end_src

execはコンテナを再利用してコマンドを実行する。高速。
#+caption: exec
#+begin_src shell
  docker-compose exec {サービス名} {shellコマンド}
#+end_src
** キャッシュを使わずにbuildする
#+begin_src shell
  docker-compose build --no-cache
#+end_src
** 立ち上げと停止
#+begin_src shell
docker-compose up --build -d # コンテナ作成する
docker-compose down
#+end_src
** docker外に公開する
[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]
Dockerfileで。
#+begin_src shell
  CMD bundle exec rails server -b 0.0.0.0
#+end_src

などと書いておくと、外部(Docker外)からアクセスできるようになる。-b 0.0.0.0 がないと別のネットワークからアクセスが不可。コンテナを超えると別のネットワーク扱いになるのでこの記述が必要。
** ポート指定する
どっちだったか忘れる。
左が公開、右がコンテナ内。だからブラウザでポート8000アクセスできるようになる。
#+begin_src shell
  docker run -p 8000:3000 -it bdd92ace66ec
#+end_src
** ログを確認する
#+begin_src shell
docker ps -a # id確認
docker logs 1111... # idを入れる
#+end_src
** イメージを削除する
使ってないイメージを削除する。
#+begin_src shell
  docker images prone
#+end_src

一気に全部削除する。
#+begin_src shell
  docker stop $(docker ps -q)
  docker rm $(docker ps -aq)
  docker rmi $(docker images -q)
#+end_src
* Tasks
** タスクを簡単に実行する方法を調べる
[[id:1ad8c3d5-97ba-4905-be11-e6f2626127ad][Emacs]]拡張あるいは、Makefile的なのにまとめる。
** TODO [[https://www.forcia.com/blog/002273.html][社内のDockerfileのベストプラクティスを公開します│FORCIA CUBE│フォルシア株式会社]]
非常に詳しい情報。
** TODO ゴミファイルができないようにする
キャッシュや履歴関係がroot権限でできるので、削除が面倒＋コンテナを作るのが邪魔される。

- できないようにする
- 自動削除するようにする
** Rails Docker環境化[6/9]
:LOGBOOK:
CLOCK: [2021-12-14 Tue 22:49]--[2021-12-15 Wed 00:40] =>  1:51
:END:
仕事をLinuxで行えるようにする。
*** TODO rails c内で日本語が含まれると失敗する
*** TODO system specが失敗する
:LOGBOOK:
CLOCK: [2022-01-14 Fri 21:59]--[2022-01-14 Fri 22:24] =>  0:25
CLOCK: [2022-01-13 Thu 22:24]--[2022-01-13 Thu 22:49] =>  0:25
CLOCK: [2022-01-13 Thu 10:40]--[2022-01-13 Thu 11:05] =>  0:25
:END:
seleniumが接続に失敗している。

#+begin_quote
Selenium::WebDriver::Error::UnknownError:
  unknown error: net::ERR_CONNECTION_REFUSED
#+end_quote

例によってコンテナ内にアクセスしようとして弾かれているのか。
*** TODO migration時にschemaに変な差分が出る
DB設定がおかしいようだ。
*** DONE 非同期処理の動作確認
CLOSED: [2022-01-12 Wed 23:08]
:LOGBOOK:
CLOCK: [2022-01-12 Wed 23:02]--[2022-01-12 Wed 23:08] =>  0:06
CLOCK: [2022-01-12 Wed 22:32]--[2022-01-12 Wed 22:57] =>  0:25
:END:
redis, sidekiqが本当に動いてるかわからない。
letter openerを見る限り、できてない。

追加した。
*** DONE [#A] dockerがrootユーザでファイルを生成する問題
CLOSED: [2021-12-25 Sat 23:51]
生成したファイルがroot権限になってしまう。
だからbundle installを実行すると、その後は通常ユーザでは編集できなくなる。
面倒だし、migrationとか明らかにダメな気がする。

簡単な解決策と環境変数によって解決する方法を調べた。
*** DONE 基本コマンド
CLOSED: [2021-12-20 Mon 22:57]
[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]部分をDocker化する。表示はまったく問題なさそう。
リロードするとちゃんとローカルの変更が反映される。

最初にルートファイルのdockerfileでベースイメージをビルドして、名前を付ける。
#+begin_src shell
  docker build . -t app
#+end_src

各コンテナでは↑で作成したベースイメージappを用いる。
イメージを使う代わりに ~build .~ でも可能だが、各コンテナがイメージをビルドする(中身は同じ)ので遅くごちゃつく。

#+caption: docker-compose.yml
#+begin_src yaml
  rails:
    image: app
    environment:
      RAILS_ENV: development
      REDIS_URL: redis://redis:6379
      MEMCACHED_URL: memcached://memcached:11211
      SKIP_RECAPTCHA: "true"
      MEMCACHED_HOST: memcached
      MEMCACHED: memcached:11211
      WEBPACKER_DEV_SERVER_HOST: webpack
      CHROME_HOST_NAME: http://selenium_chrome:4444/wd/hub
    ports:
      - 3000:3000
    stdin_open: true
    tty: true
    command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -b '0.0.0.0'"
    volumes:
      - .:/rails
      - /etc/passwd:/etc/passwd:ro # Linux用
      - /etc/group:/etc/group:ro # Linux用
    depends_on:
      - mysql

  worker:
    image: app
    command: bundle exec sidekiq
    links:
      - mysql
      - redis

  webpack:
    image: app
    build: .
    tty: true
    environment:
      NODE_ENV: development
      RAILS_ENV: development
      WEBPACKER_DEV_SERVER_HOST: 0.0.0.0
    command: yarn watch
    volumes:
      - .:/rails
      - /etc/passwd:/etc/passwd:ro # Linux用
      - /etc/group:/etc/group:ro # Linux用
    ports:
      - 8080:8080
#+end_src

#+caption: コンテナ作成 + 立ち上げ
#+begin_src shell
  sudo docker-compose up --build
#+end_src

#+caption: 再起動
#+begin_src shell
  docker-compose {service} restart
#+end_src

#+caption: railsはサービス名。以下を好きなコマンドに変える
#+begin_src shell
  docker-compose run rails bundle exec rails c
#+end_src

#+caption: bundle install
#+begin_src shell
  docker-compose run rails bundle install
#+end_src

#+caption: テストを実行する
#+begin_src shell
  docker-compose run rails bundle exec bin/rspec spec/requests/top/top_spec.rb
#+end_src

#+caption: コンテナ内のshellに入ってみる
#+begin_src shell
  docker-compose run rails /bin/bash
#+end_src
*** DONE docker-compose.ymlのオーバーライド
CLOSED: [2021-12-20 Mon 22:57]
個人で微妙に設定が異なることもある。
Dockerでやるのはミドルウェアだけとか、[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]もすべてやる、といったような。
そのときはgitignoreを指定したymlを指定して起動する。

#+caption: 後から読み込まれた設定ファイルで上書きされる
#+begin_src shell
  docker-compose -f docker-compose.yml -f docker-compose-app.override.yml up
#+end_src

もちろん一般性があるならgit管理にするのがベストだが、人によって構成が異なるので仕方ない。とくにMacだと速度に問題あるため、[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]は[[id:1658782a-d331-464b-9fd7-1f8233b8b7f8][Docker]]で立ち上げないのが多数派。

[[id:e04aa1a3-509c-45b2-ac64-53d69c961214][Rails]]サービスをoverride.ymlに、それ以外のミドルウェアサービスをdocker-compose.ymlに書いてる場合は、明示する必要がある。
#+caption: overrideしたときのbundle install。-f指定が必要。
#+begin_src shell
  docker-compose -f docker-compose.yml -f docker-compose-app.override.yml run rails bundle install
#+end_src

docker-compose runする場合も-fオプションが必要。
runはコンテナを新しく作る…つまりymlを見てるので、指定が必要なのである。

#+caption: model specを実行する
#+begin_src shell
  docker-compose -f docker-compose.yml -f docker-compose-app.override.yml exec rails bundle exec rspec --options ./.rspec ./spec/models/user_spec.rb
#+end_src

↑いちいちクソ長いコマンドを打つのは苦痛なので、shellに入って作業すると楽。
#+caption: shellに入る
#+begin_src shell
  sudo docker-compose -f docker-compose.yml -f docker-compose-app.override.yml run rails /bin/sh
#+end_src
*** DONE DBのGUIツールとの接続
CLOSED: [2021-12-17 Fri 20:58]
Linux用のsqlectronがよさそう。が、上手く[[id:7dab097c-60ba-43b9-949f-c58bf3151aa8][MySQL]]と接続できない
docker-compose.ymlで ~MYSQL_ALLOW_EMPTY_PASSWORD: 'yes'~ を追加すると入れるように。
パスワードを指定してるとログインできない。

だがこのsqlectron、表示テーブルでの編集ができないので値を書き換えるのに非常に不便。
別のを使ったほうがいいだろう。
*** DONE yarnができてない
CLOSED: [2021-12-17 Fri 20:58]
- ポートを合わせる
- webpack.config.jsにhostを加える

が必要。

#+caption: docker-compose.yml
#+begin_src yaml
  webpack:
    build: .
    environment:
      NODE_ENV: development
      RAILS_ENV: development
      WEBPACKER_DEV_SERVER_HOST: 0.0.0.0
    command: yarn watch
    volumes:
      - .:/rails
    ports:
      - 8080:8080
    depends_on:
      - rails
#+end_src

ホットリロードできるのを確認。
hostを加える必要があった。
#+caption: webpack.config.js
#+begin_src json
  devServer: {
    contentBase: path.join(__dirname, 'app/assets/javascripts'),
    allowedHosts: ['.lvh.me'],
    host: '0.0.0.0',
  },
#+end_src
* Archives
* References
** [[https://github.com/phusion/passenger-docker][phusion/passenger-docker: Docker base images for Ruby, Python, Node.js and Meteor web apps]]
Web開発用の扱いやすいDockerイメージ。
** [[https://12factor.net/][The Twelve-Factor App]]
SaaS開発の方法論。
日本語訳もあった。[[https://12factor.net/ja/][The Twelve-Factor App （日本語訳）]]
** [[https://docs.docker.jp/pdf-download.html][Docker ドキュメント日本語版 PDF ダウンロード — Docker-docs-ja 19.03 ドキュメント]]
Dockerのドキュメント。
